<!DOCTYPE html>
<head><meta charset="utf-8">
<link rel=icon href="../kelas16.png">
<title>jtye</title>
<style>
*{font-family:monospace}
.h{cursor:pointer;color:#0000ee}
</style>


<script src="k.js"></script>
<script src="parse.js"></script>

</head>

<article id="main">
<h2 style="border-bottom:2px solid darkred;padding-bottom:0.2em">jtye: k in fifty functions <a href="repl.html">repl</a> <a href="test.html">tests</a></h2>
<details><summary>k core (k.js) <span id=coreb></span> bytes</summary><pre id="core">
let  /*k*/

atom  =x=>typeof x==="number",
rec   =f=>x=>atom(x)?f(x):x.map(rec(f)),
atomic=f=>(x,y)=>atom(x)?(atom(y)?f(x,y):y.map(y=>atomic(f)(x,y))):atom(y)?x.map(x=>atomic(f)(x,y)):x.map((x,i)=>atomic(f)(x,y[i])),

each  =f=>(...x)=>1==x.length?(atom(x[0])?f(x[0]):x[0].map(x=>f(x))):flip(x).map(x=>f(...x)),
over  =f=>(...x)=>1<x.length?fold(f,...x):x[0].reduce((a,x,i)=>i?f(a,x):a),
fold  =f=>(...x)=>flip(x.slice(1)).reduce((a,x,i)=>i?f(a,...x[i]):a,x[0]),
scan  =(f,y)=>x=>{y=y?[f(x[0],y)]:[first(x)];  x.slice(1).forEach((x,i)=>y.push(f(x,y[i]))) ;return y},
left  =f=>(y,x)=>atom(x)?f(x,y):x.map((x,i)=>f(y,x)),
right =f=>(y,x)=>atom(y)?f(x,y):y.map((y,i)=>f(y,x)),
both  =f=>(y,x)=>atom(x)?right(f)(x,y):atom(y)?left(f)(y,x):x.map((x,i)=>f(y[i],x)),
prior =(f,y)=>x=>x.map((x,i,a)=>f(i?a[i-1]:y?y:a[0],x)),

type  =x=>x.constructor.name,
neg   =rec(x=>-x),
sqr   =rec(x=>x*x),
sqrt  =rec(Math.sqrt),
flip  =x=>atom(x)?x:Array(over(max)(each(count)(x))).fill(0).map((_,i)=>x.map(x=>atom(x)?x:x[i])),
rev   =x=>atom(x)?x:x.reverse(),
up    =x=>{x=til(count(x));return x.sort((a,b)=>a<b?-1:a>b?1:0)},
down  =x=>{x=til(count(x));return x.sort((a,b)=>a>b?-1:a<b?1:0)},
freq  =x=>x.reduce((r,x)=>{r[x]=r[x]?r[x]+1:1;r},{}),
not   =rec(x=>+!x),
value =x=>(typeof x==="string")?eval(parse(x)):x.constructor===Object?Object.values(x):x,
til   =x=>(typeof x==="string")?token(x):atom(x)?Array(x<0?0:x).fill(0).map((_,i)=>i):where(x),
where =x=>(atom(x)?list(x):x).flatMap((x,i)=>Array(x).fill(i)),
first =x=>atom(x)?x:x.length?x[0]:0,
uniq  =x=>atom(x)?rand(x):x.filter((y,i)=>i===x.indexOf(y)),
rand  =x=>atom(x)?Array(x).fill(0).map(Math.random):x.toSorted((a,b)=>0.5-Math.random()),
sort  =x=>x.toSorted(),
count =x=>atom(x)?1:x.length,
floor =rec(Math.floor),
list  =x=>[x],
string=x=>(atom(x)||typeof x==="function")?String(x):(typeof x==="string")?JSON.stringify(x):x.every(atom)?x.map(String).join(" "):"("+x.map(string).join(";")+")",

dex   =(y,x)=>y,
add   =atomic((y,x)=>x+y),
sub   =atomic((y,x)=>x-y),
mul   =atomic((y,x)=>x*y),
div   =atomic((y,x)=>x/y),
mod   =atomic((y,x)=>x?(y%=x,y+x*+(y<0)):y),
idiv  =atomic((y,x)=>x?~~((y-(x-1)*+(y<0))/x):y),
min   =atomic(Math.min),
max   =atomic(Math.max),
less  =atomic((y,x)=>+(x<y)),
more  =atomic((y,x)=>+(x>y)),
eql   =atomic((y,x)=>+(x==y)),

match =(y,x)=>(type(x)!=type(y))?0:(atom(x)?+(x==y):(x.length!=y.length)?0:+x.every((x,i)=>match(x,y[i]))),
dict  =(y,x)=>x.reduce((r,x,i)=>(r[x]=y[i],r),{}),
at    =(y,x)=>(typeof x==="function")?x(y):atom(x)?x:atom(y)?x[y]:right(at)(y,x),
amend =(y,f,i,x)=>{x.slice();i.forEach((i,j)=>x[i]=f?f(x[i],y=atom(y)?y:y[j]):y);return x},
find  =(y,x)=>atom(y)?(-1<(y=x.indexOf(y))?y:x.length):right(find)(y,x),
cut   =(y,x)=>atom(x)?(x<0?cut(Math.floor(y.length/-x),y):cut(mul(Math.ceil(y.length/x),til(x)),y)):[...x].map((x,i,a)=>y.slice(x,a[i<a.length-1?1+i:a.length])),
take  =(y,x)=>atom(x)?at(y,x<0?add(y.length+x,til(-x)):til(x)):x.filter(x=>y.includes(x)),
drop  =(y,x)=>atom(x)?(x<0?y.slice(0,x):y.slice(x)):x.filter(x=>!y.includes(x)),
cat   =(y,x)=>atom(x)?cat(list(x),y):x.concat(y),
split =(y,x)=>y.split(x),
join  =(y,x)=>y.join(x),
dec   =(y,x)=>y.slice(1).reduce((r,y,i)=>y+mul(at(x,i),r),first(y)),
enc   =(y,x)=>rev(rev(x).map(x=>{let t=mod(x,y);y=idiv(x,y);return t}))
</pre></details>
<details><summary>parser (parse.js) <span id=pareb></span> bytes</summary><pre id="pare"></pre></details>
<h3>about</h3>
jtye/k is k for javascript.</p>

i write more js these days, mainly for ui and cross platform.</br>
my style evolves to more functional. that's mostly fine but sometimes annoying.
</p>

<pre>
compare: let sum=(f,x)=>x.reduce((a,x)=>f(a,x),0)
why not:                                over(add)
</pre>

<h3>core</h3>
the core adds 50 primitive functions and 3 helpers which work on numbers arrays and strings.
the functions can be used directly in javascript.<p/>

the helper functions rec and atomic can be used to extend the language with more vector functions, e.g.
<pre>
sin=rec(Math.sin),cos=rec(Math.cos),pow=atomic(Math.pow)
</pre>

<h3>parse</h3>
let's add a parser, that transforms k source to js which uses our primitives.</p>

bytecode, virtual machine? we don't need this, we can just use javascript's eval.</br>

see the <a href="test.html">test's output</a> (in green) what the parser compiles k code to.

<h3>ref</h3>
<pre id="ref" style="border:2px solid darkred;width:fit-content;padding:0.5em">
+ type   add   ' each prior bin `js`
- neg    sub   / over right join dec
* sqr    mul   \ scan left split enc
% sqrt   div   inv idiv mod         
& flip   min                  atom  
| rev    max                  atomic 
< up     less                    rec
> down   more                       
= freq   eql                        
~ not    match           
. value        parse                
! til    dict  token key where      
@ first  at    amend                
? uniq   find  rand                 
^ sort   cut             while()[;;]
# count  take            if()[;;;;;]
_ floor  drop            do[]while()
, list   cat             for(;;)[;;]
$ string             try[]catch(e)[]
</pre>
<b><span id="code"></span></b>

<h3>adverbs</h3>
there are only 3 adverb symbols ' / \
' is each or prior(for :+-*%&|<>=~), / \ are over and scan.

derived verbs from each over and scan are available in variadic form
and may also take more than 1 argument.
the verb's arity should match the number of arguments:
e.g. f'[a;b;c] is triadic each.

x/y x\y is is encode/decode for numbers and join/split for strings.
x'y is binary search.

<h3>ambivalence</h3>

primitives are fixed at compile time if possible, e.g. 1-2 is sub, while -x is neg.
by themselves, e.g. (-;+) or f:- they default to dyadic, e.g. sub but not neg.
this is also true when used in derived +/ which is over(add).
the exception is each: -' compiles to ambivalent each((x,y)=>y===undefined?neg(x):sub(x,y))

derived verbs themselves, are monadic by default +/ is sum not add-each-right.
the dyadic form is chosen at compile time for x+/y.
this is resolved at runtime using variadic forms.

compositions however are always dyadic: 1+- is {1+x-y}
to simulate a monadic train, append dex(:) e.g. 1+-:

</pre>

<h3>js escape</h3>
everything between backticks is compiled verbatim to js and parsed as a noun:

<pre>
f`x.slice(-3)` compiles to  at(x.slice(3),f)
</pre>

<h3>structural todo</h3>
<pre>
while(1>x)[]
do[]while(1>x) (maybe not)
[]=>{b;l;o;c;k}
for(a;b;c)[]
for(`let i in a`)
if()[]         (no else)
try[]catch(e)[]
$[a;b;c]
</pre>

<h3>web use</h3>
<pre>
&lt;script src="k.js">&lt;/script>
&lt;script src="parse.js">&lt;/script>
</pre>

example.. e.g. interactive page in k

<h3>standalone</h3>
see:mk, todo click to download. or compile to native: qjsc(6mb)

</article>

<pre id="b" class="repl" contenteditable="true" spellcheck="false">jtye/k (in //parse out \doc)
 
</pre>
<script>
fetch("k.js"    ).then(r=>r.text()).then(r=>{core.textContent=r;coreb.textContent=r.length})
fetch("parse.js").then(r=>r.text()).then(r=>{pare.textContent=r;pareb.textContent=r.length})

let showref=(s)=>{
 let c=core.textContent
 c=c.slice(1+(c.match(RegExp("\n"+s.textContent+" *=")).index))
 c=c.slice(0,c.indexOf("\n")-1)
 code.textContent=c
}

let s=ref.textContent,c=core.textContent,r="",m;while(m=s.match(/[a-z]+/)){
 if(c.match(RegExp("\n"+m[0]+" *="))){
  r+=s.slice(0,m.index)+`<span onclick="showref(this)" class="h">${m[0]}</span>`
 } else {
  r+=s.slice(0,m.index)+m[0]
 }
 s=s.slice(m.index+m[0].length)
};r+=s
ref.innerHTML=r
</script>
</body></html>
