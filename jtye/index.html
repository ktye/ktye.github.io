<!DOCTYPE html>
<head><meta charset="utf-8">
<link rel=icon href="../kelas16.png">
<title></title>
<style>
*{font-family:monospace}
.full{margin:0}
.repl{height:100vh;width:100vw;margin:0;outline:none;display:none}
</style>


<script src="k.js" onload='console.log(this.content)'></script>
<script src="parse.js"></script>

<script>

let
o=x=>b.textContent+=x,
krep=s=>{
 if(s.trim().startsWith("\\")){b.textContent+="\n ";b.style.display="none";main.style.display="block";return}
 let p=parse(s);o(" //"+p+"\n")
 try{
  r=string(eval(p))
  o(r+"\n ")
 }catch(e){
  o(" ^"+e+"\n ")
 }
 end()},
end=()=>{
 let s=window.getSelection()
 s.removeAllRanges()
 let r=document.createRange()
 r.selectNodeContents(b)
 r.collapse(false)
 s.addRange(r)
 window.scrollTo(0,b.scrollHeight)
 b.focus()},
pos=()=>getSelection().getRangeAt(0).endOffset


window.onkeydown=e=>{if(e.key=="Enter"){
 e.preventDefault() 
 let o=pos(),j=b.textContent.indexOf("\n",o)
 if(j>=0)o=j
 let t=b.textContent.slice(0,o)
 b.textContent=t
 let i=t.lastIndexOf("\n")
 t=t.slice(i>0?1+i:0)
 //b.textContent+="\n"
 if(t.trim()!=""){krep(t)}}}

</script>
</head>

<article id="main">
<h2 style="border-bottom:2px solid darkred;padding-bottom:0.2em">jtye: a direct k for javascript <button onclick="main.style.display='none';b.style.display='block';body.classList.add('full');end()">repl</button> <a href="test.html">tests</a></h2>
<details><summary>k core (k.js) <span id=coreb></span> bytes</summary><pre id="core"></pre></details>
<details><summary>parser (parse.js) <span id=pareb></span> bytes</summary><pre id="pare"></pre></details>
<h3>about</h3>
jtye/k is k for javascript.</p>

i write more js these days, mainly for ui and cross platform.</br>
my style evolves to more functional. that's mostly fine but sometimes annoying.
</p>

<pre>
compare: let sum=(f,x)=>x.reduce((a,x)=>f(a,x),0)
why not:                                over(add)
</pre>

<h3>core</h3>
the core adds 50 primitive functions and 3 helpers which work on numbers arrays and strings.
the functions can be used directly in javascript.<p/>

the helper functions rec and atomic can be used to extend the language with more vector functions, e.g.
<pre>
sin=rec(Math.sin),cos=rec(Math.cos),pow=atomic(Math.pow)
</pre>

<h3>parse</h3>
let's add a parser, that transforms k source to js which uses our primitives.</p>

bytecode, virtual machine? we don't need this, we can just use javascript's eval.</br>

see the <a href="test.html">test's output</a> (in green) what the parser compiles k code to.

<h3>ref</h3>
<pre style="border:2px solid darkred;width:fit-content;margin:0.5em">
+ type   add   ' each prior bin `js`
- neg    sub   / over right join dec
* sqr    mul   \ scan left split enc
% sqrt   div   inv idiv mod
& flip   min              
| rev    max                 atom 
< up     less                atomic
> down   more                   rec
= freq   eql        
~ not    match           
. value        parse
! til    dict  token key where
@ first  at    amend
? uniq   find  rand
^ sort   cut             while()[;;]
# count  take            if()[;;;;;]
_ floor  drop            do[]while()
, list   cat             for(;;)[;;]
$ string             try[]catch(e)[]
</pre>

<h3>adverbs</h3>
there are only 3 adverb symbols ' / \
' is each or prior(for :+-*%&|<>=~), / \ are over and scan.

derived verbs from each over and scan are available in variadic form
and may also take more than 1 argument.
the verb's arity should match the number of arguments:
e.g. f'[a;b;c] is triadic each.

x/y x\y is is encode/decode for numbers and join/split for strings.
x'y is binary search.

<h3>ambivalence</h3>

primitives are fixed at compile time if possible, e.g. 1-2 is sub, while -x is neg.
by themselves, e.g. (-;+) or f:- they default to dyadic, e.g. sub but not neg.
this is also true when used in derived +/ which is over(add).
the exception is each: -' compiles to ambivalent each((x,y)=>y===undefined?neg(x):sub(x,y))

derived verbs themselves, are monadic by default +/ is sum not add-each-right.
the dyadic form is chosen at compile time for x+/y.
this is resolved at runtime using variadic forms.

compositions however are always dyadic: 1+- is {1+x-y}
to simulate a monadic train, append dex(:) e.g. 1+-:

</pre>

<h3>js escape</h3>
everything between backticks is compiled verbatim to js and parsed as a noun:

<pre>
f`x.slice(-3)` compiles to  at(x.slice(3),f)
</pre>

<h3>structural todo</h3>
<pre>
while(1>x)[]
do[]while(1>x) (maybe not)
[]=>{b;l;o;c;k}
for(a;b;c)[]
for(`let i in a`)
if()[]         (no else)
try[]catch(e)[]
$[a;b;c]
</pre>

<h3>web use</h3>
<pre>
&lt;script src="k.js">&lt;/script>
&lt;script src="parse.js">&lt;/script>
</pre>

example.. e.g. interactive page in k

<h3>standalone</h3>
see:mk, todo click to download. or compile to native: qjsc(6mb)

</article>

<pre id="b" class="repl" contenteditable="true" spellcheck="false">jtye/k (in //parse out \doc)
 
</pre>


<script>
fetch("k.js"    ).then(r=>r.text()).then(r=>{core.textContent=r;coreb.textContent=r.length})
fetch("parse.js").then(r=>r.text()).then(r=>{pare.textContent=r;pareb.textContent=r.length})
</script>
</body></html>
