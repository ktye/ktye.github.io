//assembly interpreter
/*
 do    0
  ..   1
 end   2

 while 0
  ..   1
 do    2
  ..   3
 end   4

 switch 3  0    // "switch" currentindex [..offset-addr-endcase-i] [..offset endcase-i-to-end]
  ..       1
 endcase   2
  ..       3
 endcase   4
  ..       5
 end       6

*/

let ai=(_=>{

let parse=(x,M,aim)=>{ //source,import-object,ai.a(compiled module)
 let A=new WebAssembly.Instance(aim,M).exports
 let G={} //globals {name:v}
 let F={} //functions
 let T=[] //indirect call table
 let U=new Uint8Array(A.memory.buffer),dd=(o,s)=>{for(let i=0;i<s.length;i+=2)U[o++]=parseInt(s.substr(i,2),16)} //data/heap
 let isvar=x=>!"-0123456789".includes(x[0])
 let args =x=>{let r={};x.split("").forEach((t,i)=>r[i]="j"==t?0n:0);return r}
 let nest=[],addr=[],la=""
 let n=0,s="",c=[],l=0,im="",lo={}
 let p=_=>{if(!n)return;s=s.split(":");F[n]={r:s[0],a:s[1],c:c,lo:{...args(s[1]),...lo},l:l};[n,s,c,l,im,lo]=[0,"",[],0,"",{}]}
 x.trimEnd().split("\n").forEach((x,line)=>{let i,j,a=x.trim().split(" "),a0=a[0].trim(),a1=(a[1]?a[1].trim():"");
  (1<a.length&&a[1].includes(":"))?(p(),n=a0,s=a[1],l=line,c.push((a[2]=="import")?[M[a[3]][a[4]]]:["nop"]))
  :    "tab"==a0?(p(),T.push(a[2]))
  :    "dat"==a0?(p(),dd(Number(parseFloat(a[1]),a[2])))
  :     "if"==a0?(nest.push("if"),addr.push(c.length),c.push(["if",0]))
  :   "else"==a0?(nest.pop(),i=addr.pop(),c[i][1]=c.length-i,nest.push("else"),addr.push(c.length),c.push(["jmp",0]))
  :  "while"==a0?(nest.push("while"),addr.push([c.length,c.length]),c.push(["nop"]))
  :     "do"==a0?((nest[nest.length-1]=="while")?(la=addr.pop(),la[0]=c.length-la[0],la[1]=c.length,addr.push(la),c.push(["if",0]))//  (while)do
                                               :(nest.push("do"),c.push(["nop",c.length])))                                       //    do(end)
  : "switch"==a0?(nest.push("switch"),addr.push(c.length),c.push(["switch",Number(a1),2,Array(Number(a1)-1).fill(c.length)]))
  :"endcase"==a0?(i=addr[addr.length-1],j=c[i][2]++,c[i][j]=c.length-c[i][j],c[i].push(c.length),c.push(["jmp",c.length]))
  :    "end"==a0?(la=nest.pop(),i=addr.pop(),(la==  "if"?(c[i][1]=c.length-i,c.push(["nop"]))                                          //    (if)end
                                             :la=="else"?(c[i][1]=c.length-i,c.push(["nop"]))                                          //  (else)end
                                             :la==  "do"?c.push(["ifnot",c[i][1]-c.length])                                            //    (do)end
                                             :(j=c[i][2],c[i].slice(j).forEach((x,k)=>c[i][j+k]=c.length-c[i][j+k]),c.push(["nop"])))) //(switch)end 
  :(1==a0.length&&"ijef".includes(a0))?(n?("i"==a0?(isvar(a1)?(c.push(["nop"]),lo[a[1]]=0 ):c.push(["const",Number(a1)]))
                                          :"j"==a0?(isvar(a1)?(c.push(["nop"]),lo[a[1]]=0n):c.push(["const",BigInt(a1)]))
                                          :"e"==a0?(isvar(a1)?(c.push(["nop"]),lo[a[1]]=0 ):c.push(["const",Number(a1)]))
                                          :        (isvar(a1)?(c.push(["nop"]),lo[a[1]]=0 ):c.push(["const",Number(a1)])))
                                         :(G[a[1]]=(a0=="j"?0n:0)))
  :c.push(a)
 });p();return{A:A,G:G,F:F,T:T,M:M,S:[],C:[],f:"",l:0}}  //S(value stack) C(call stack) f(current function name) l(line of function)

/*o-p-s*/

let op=(m,s,a)=>{if(!s in ops)throw new Error("unknown op:",s);a=ops[s];a=m.A[s](...m.S.splice(-a,a));if(a!==undefined)m.S.push(a)}
let exit=m=>{throw new Error("exit")}
let ret=m=>{m.C.length?[m.f,m.l]=m.C.pop():exit()}
let ncal=(F,m)=>{let r=F.c[0][0](...Object.values(F.lo));if(F.r.length)m.S.push(r)} //native
let scal=(f,m)=>{m.C.push([m.f,m.l]);m.f=f;m.l=0;let F=m.F[f];for(let i=0;i<F.a.length;i++)F.lo[F.a.length-1-i]=m.S.pop();if(1==F.c.length)ncal(F,m)}
let dcal=(f,m)=>{let n=m.C.length;scal(f,m);while(m.C.length>n)step(m,1)}

let step=(m,over)=>{let F=m.F[m.f],cal=over?dcal:scal;if(F.c.length<=++m.l)return ret(m)
 let a=F.c[m.l],a0=a[0],a1=a[1],x
 let icl=(x,s,f)=>{f=m.T[x];if(m.F[f].s!=s){throw new Error("line "+(F.l+m.l)+": signature mismatch for indirect function "+x)};cal(f,m)}
   "const"==a0?m.S.push(a1)                    //ief(Number) j(BigNum)
 :   "get"==a0?m.S.push(F.lo[a1])
 :   "set"==a0?F.lo[a1]=m.S.pop()
 :   "tee"==a0?F.lo[a1]=m.S[m.S.length-1]
 :   "glo"==a0?m.S.push(m.G[a1])
 :   "gst"==a0?m.G[a1]=m.S.pop()
 :   "cal"==a0?cal(a1,m)   //(m.F.includes(a1)?cal(a1,m):m.M.)
 :    "if"==a0?m.l+=m.S.pop()?0:a1
 : "ifnot"==a0?m.l+=m.S.pop()?0:a1              //do after while, end after do
 :"switch"==a0?(x=1+m.S.pop(),m.l+=(x<a.length?a[x]:a[x.length-1]))
 :   "jmp"==a0?m.l+=a1                          //else break continue endcase end
 :   "nop"==a0?0                                //do while
 :  "ical"==a0?icl(m.S.pop(),a1)
 :  "ret"==a0?ret(m)
 :op(m,a0)}

let run=(f,a,m)=>{m.f=f,m.l=0,a.forEach((v,i)=>m.F[f].lo[i]=v);try{ while(1)step(m,0) }catch(e){ if(e.message=="exit"){if(m.S.length)return m.S[0]}else{throw(e)} }}
let line=x=>x.l+x.F[x.f].l
return{parse:parse,step:step,run:run,line:line}})()
