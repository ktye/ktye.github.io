<!DOCTYPE html>
<head><meta charset="utf-8">
<link rel=icon href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABBSURBVDhPY/wPBAxIgJGREcrCBGhKwYAJSqMAdIXYNMIAVgNIAaMGDG8DYIkHXyICgdFABOZeYCChhBJp2ZmBAQC+JhoLeAkPhAAAAABJRU5ErkJggg=='>
<title>k.5</title>
<style>
body{margin:0;overflow:hidden}
*{box-sizing:border-box;font-family:monospace}
#ain{position:absolute;top:2em;left:0;background:#efe;width:50vw;height:calc(50vh - 1em);overflow:auto;border:none;outline:none;resize:none}
#kin{position:absolute;top:calc(50vh + 1em);left:0;background:#ffe;width:50vw;height:calc(50vh - 1em);overflow:auto;border:none;outline:none;resize:none}
#bar{position:absolute;top:0;left:50vw;height:2em}
#out{position:absolute;top:2em;margin:0;right:0;width:50vw;height:calc(100vh - 2em);overflow:auto}
.ln{color:darkblue;cursor:pointer}
.ln:hover{text-decoration:underline}
</style>
</head>

<body onload="init()">
<select   id="exa" onchange='example(this)'></select>
<textarea id="ain" spellcheck="false" title="extension source">a</textarea>
<textarea id="kin" spellcheck="false" title="k source for stage2">k</textarea>
<div      id="bar">
 <button  id="ccc" onclick="run(2)"  title="compile to c">c</button>
 <button  id="ast" onclick="run(1)"  title="show IR table">ast</button>
 <button  id="run" onclick="run(0)"  title="compile to wasm and run">run</button>
 <span class="ln" onclick="showhk()" title="show compiler source">halfkey.k</span> <span class="ln" onclick="run(3)" title="download generated k+.c">k+.c</span> <span class="ln" onclick="run(4)" title="download generated wasm">k+.wasm</span>
 <a href="about.html">about</a>
</div>
<pre id="out">out</pre>
<a id="dl" style="display:none"></a>

<script>
let K,kk,hk,cc,wb,dt
function ge(x){return document.getElementById(x)}
function ce(x){return document.createElement(x)}
function su(u){return(u.length)?new TextDecoder("utf-8").decode(u):""}
function us(s){return new TextEncoder("utf-8").encode(s)}
function O(x){let o=ge("out");o.textContent+=("string"==typeof x)?x:su(x)}
function init(){let fe=(u,f)=>{fetch(u).then(r=>r.text()).then(f)}
 fe("halfkey.k",   r=>hk=r) //halfkey compiler
 fe("drawtree.k",  r=>dt=r) //tree view
 fe("../kweb/k.k", r=>kk=r) //k-source as table
 fe("../kweb/cc.k",r=>cc=r) //c transpiler
 fe("../kweb/wb.k",r=>wb=r) //wasm(binary) compiler
}
window.onerror=function(m,s,l,c,e){O(m+" "+e+"\n")}
window.addEventListener("unhandledrejection",function(e){ 
   O(e.reason+"\n") 
});

let env={env:{ //wasm import object
 Exit:x=>{        },
 Args:()=>{return 0},
 Arg:(x,y)=>{return 0},
 Read:(x,y,z)=>{return 0},
 Write:(f,m,s,n)=>{O(new Uint8Array(K.memory.buffer,s,n));return 0},
 ReadIn:(x,y)=>{return 0},
 Native:(x,y)=>{return 0},
}}

//k-memory access
function lo(x){return Number(BigInt.asUintN(32,x))} //pointer
function C(){return new Int8Array(K.memory.buffer)} //heap
function KC(u){u=("string"==typeof u)?us(u):u;let r=K.mk(18,u.length);C().set(u,lo(r));return r}
function CK(x){return C().slice(lo(x),lo(x)+K.nn(x))}
function sc(x){return K.sc(KC(x))}

function run(c){ //stage 1
 ge("out").textContent=""
 fetch("../k.wasm").then(r=>r.arrayBuffer()).then(r=>WebAssembly.instantiate(r,env)).then(r=>{
  K=r.instance.exports
  K.kinit()
  O("k1\n")  
  //if(c!=2&&c!=3)
  K.dx(K.Val(KC(kk)))   //load k.k interpreter source (vars: C D T P I S)
  K.dx(K.Asn(sc("A"),K.Atx(K.Val(KC("`p@")),KC(ain.value)))) //parse src.a, store in A 
  K.dx(K.Val(KC(hk)))        //run halfkey.k compiler
  setTimeout(()=>{            //to flush O
   if(c==1){
    K.dx(K.Val(KC(dt)))
    K.dx(K.Val(KC("draw simple[]")))
    ge("out").textContent=ge("out").textContent.replaceAll("|","│").replaceAll("+","├").replaceAll("L","└").replaceAll("-","─").replaceAll("T","┬")
    return
   }
   K.dx(K.Val(KC((c%4)?cc:wb)))   //load wb.k or cc.k
   K.dx(K.Val(KC(((2==c)?"simple[];C:_&8;ccren:{x}":"full[]"))))
   let b=CK(K.Val(KC(["wb``","","cc`nort`lib","cc``","wb``"][c])))
   switch(c){
   case 0:stage2(b);break
   case 2:ge("out").textContent=su(b);break
   default:downld((c==4)?"k+.wasm":"k+.c",b)
   }
  },10)
 })
}
function downld(s,u){
 O("download "+s+"\n")
 let x=new Blob([u],{type:"application/octet-stream"}) //u:uint8array
 let dl=ge("dl")
 dl.href=URL.createObjectURL(x)
 dl.download=s
 dl.click()
}
function stage2(w){
 //return
 K=null                           //reboot
 WebAssembly.instantiate(w.buffer,env).then(r=>{
  K=r.instance.exports
  K.kinit()
  O("k2\n")
  let x=ge("kin").value
  console.log("kin",x)
  x = KC(x)
  console.log("KC",x)
  K.dx(K.Val(x))
 })
}

function showhk(){ge("out").textContent=hk}



let examples={
 add:{a:`/add two integers
f:{[xi;yi]x+y}

/x and y are declared as integer atoms
/they are automatically unpacked and a k value is returned.

/click on [ast] to see the compiled function representation.
/click on [c]   to see generated c code.
/[k+.c] downloads a modified interpreter that has 'f' defined as a native function.
/compile with: gcc k+.c -lm   or clang -fwrapv k+.c -lm

/the text in this editor can be changed.
`, k:`/test f with two ints
 \\f[2;3]
 
/this code runs in the stage2 interpreter, if you click the [run] button
`},

 ktypes:{
  a:`/variables of k type call k functions instead of integer opcodes.
/k vars are declared by xk or x alone
take:{[x;y]x#y}

/mixed i+k or f+k convert the scalar to k types. mixed i+f converts to float.
mixed:{[xf;yi]x+y}

/vector types also call k functions
vectors:{[xI;yF]x+y}
`,
  k:` \\take[2#;!5]
 \\mixed[3.5;2]
 \\vectors[1 2 3;0.5 0.6 0.7]
`
 },
 
 float:{
  a:`/some scalar floating point functions are predefined:
/ hypot atan2 pow fmin fmax copysign
/ exp log atan abs sqrt ceil floor nearest
f:{[xf;yf]exp hypot[xf;yf]}
`,
  k:`/scalar integers are automatically uptyped when floats are expected
 \\f[3;4]
`,
 },
 
 index:{
  a:`/first and last expect integer vectors.
/typecheck is done on entry, indexing is type-dependent.
first:{[xI]x[0]}
last:{[xI]x[-1+xn]}`,
  k:" \\first 1 2 3\n \\last 1 2 3\n",
 },

 macro:{
    a:`/for each k variable some symbols are replaced by primitives:
/ xt     short for tp[x]  int value of the type
/ xn     short for nn[x]  length of the array
/ x0..x2      x[0]..x[2]  indexing
/ xi          x[i]        e.g. within loops
first:{[xI]x0}
`,
  k:" \\first 1 2 3\n \\last 1 2 3\n",
 },
 
 amend:{
  a:`/indexed assignment for vector types
amend:{[xI]x[1]:3;x}

/modified assign
m:{[xI]x[1]+:2}
`,
  k:"",
 },
 
 cond:{
    a:`/if is a keyword. 2 args is a simple if statement:
absolute:{[xi]if[0>x;x:-x];x}

/3 args is if-else-then:
ifelse:{[xi;yf]if[x<3;x:2*x;y:4*y];x}

/if both branches return the same type, it's an expression:
tern:{[xi]2*if[x<3;4;5]}

`,
  k:" \\absolute -3\n \\ifelse[3;4.5]\n \\tern 3",
 },
 
 switch:{
    a:`/switch is a jump table
/the first expression evaluates to an integer, the cases are consecutive 0,1,2..default

jump:{[xi]switch[x;x:2*x;x:5*x;x:3];x}
`,
  k:" \\jump 1\n",
 },
 
 loop:{
    a:`/while is W

/one statement
loop:{[xi]W[x>3;x:x-1];x}

/multiple
loop2:{[xi]W[x>3;x:x-1;x:3*x];x}

/ndo is N. it uses the loop variable i:0..
ndo:{[xi;yi]N[x;y+:i];y}
`,
  k:" \\loop 5\n \\ndo[3;4]\n",
 },

 lu:{
    a:`/?`,
  k:`/lu decomposition
lu:{[A]i:0;k:!#A;P:!#A
 while[1<#k
  j:i+*&a=m:|/a:abs A[k;i]  /or optimized (*>) 
  P[(i;j)]:P[(j;i)]
  A[(i;j)]:A[(j;i)]
  A[k:1_k;i]%:A[i;i]
  A[k;k]-:A[k;i]*\:A[i;k]
  i+:1]
 (A;P)}
`

 },
 
 
}
for(let x in examples){let o=ce("option");o.value=x;o.textContent=x;ge("exa").appendChild(o)}
function example(s){if(ge("exa").value!=s.value)ge("exa").value=s.value;let x=examples[s.value];ge("ain").value=x.a;ge("kin").value=x.k}
let h=window.location.hash.slice(1);example({value:(h.length)?h:"amend"})

</script></body></html>

