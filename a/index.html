<!DOCTYPE html>
<head><meta charset="utf-8">
<link rel="icon" type="image/png" sizes="16x16" href="../kelas16.png">
<title>a</title>
<style>
body{font-family:georgia,serif;font-size:large}
pre{background:#eee}
#t{background:black;color:white;height:20em;line-height:1;padding:3px;outline:none;font-size:xlarge}
//textarea{color:white;background:black;resize:none}
</style>
</head><body onload="kinit()">

<h1>the k incunabulum (2024)</h1>

<pre id="t" contenteditable="true" spellcheck="false" onkeyup="key(event,this)"></pre>

<h2>a.c</h2>
<pre>
#include"a.h"//cc -Os -oa a.c -w
F(w_,write(1,y,x))f(w,127>x?w_(1,(u)&x):w_(strlen(x),x))F(err,w(x);w(58);w(y);w(10);96)f(qz,Qz(1)0)
G(m,(u)memcpy((void*)x,(void*)y,f))
f(a,char*s=malloc(x+1);*s++=x;(u)s)
f(ind,Qr(!ax)x=a(x);i(nx,xi=i)x)
f(cat,Qr(!ax)u r=a(1);*sr=x;r)
F(Cat,x=ax?cat(x):x;y=ay?cat(y):y;u r=a(nx+ny);m(ny,r+nx,y);m(nx,r,x))
f(at,Qr(ax)*sx)
F(At,Qr(ax||!ay)sx[y])
f(cnt,Qr(ax)nx)
F(Cnt,Qr(!ax||ay)x=a(x);m(nx,x,y))
F(Add,ax?ay?x+y:Add(y,x):r(a(ny),i(nr,ri=(ax?x:xi)+yi)))
u(*f[])()={0,qz,ind,cnt,cat,at},(*F[])()={0,Add,qz,Cnt,Cat,At};
u U[26];f(n,10>x-48?x-48:U[x-97])
char*V=" +!#,@";f(v,(strchr(V,x)?:V)-V)
us(e,u i=*s++;v(i)?x(e(s),Q(x)f[v(i)](x)):x(n(i),*s?y(e(s+1),Q(y)F[v(*s)](x,y)):x))
us(ws,u x=*s?e(s):0;Q(x)ax?w(48+x):_(i(nx,w(48+xi);w(32))0);w(10))
int main(){char s[99];while(1)w(32),s[read(0,s,99)-1]=0,ws(s);}
</pre>

<h2>a.h</h2>
<pre>
typedef unsigned long u;
#define _u(f,e,x...) u f(x){return _(e);}
#define ax (10>x)
#define nx sx[-1]
#define sx ((char*)x)
#define xi sx[i]
#define _(e) ({e;})
#define r(a,e) _(u r=a;e;r)
#define x(a,e) _(u x=a;e)
#define y(a,e) _(u y=a;e)
#define i(n,e) {int $n=n;int i=0;for(;i<$n;++i){e;}}
#define f(f,e) _u(f,e,u x)
#define F(f,e) _u(f,e,u x,u y)
#define G(g,e) _u(g,e,u f,u x,u y)
#define us(f,e) _u(f,e,char*s)
#define Q(e) if(96==(e))return 96;
#define Qr(e) if(e){return err((u)__func__,(u)"rank");}
#define Qz(e) if(e){return err((u)__func__,(u)"todo");}
#define ri sr[i]
#define yi x(y,xi)
#define nr x(r,nx)
#define ny x(y,nx)
#define sr x(r,sx)
#define sy x(y,sx)
#define ay x(y,ax)
</pre>


<h2>it comes with instructions</h2>
<pre>
special k - just for you
e is apl(noun verb)

a few prims. no checks. no refcount.
</pre>
<pre>
i put the abbreviations in a.h
[ans][rxy]  atom? num string
[rxy]i   integer at i
</pre>
<pre>
@x is 'at' x is first x

in this implementation

@2 is rank error


i put in Qr(rank) Qz(todo) in the prims
</pre>

<h2>compile to wasm</h2>
let's use this code as an example how to compile low level c to webassembly.</br>
by low level, i mean programs that use no or very little libraries calls, which includes libc.<p/>

webassembly separates code and data. code is static. data lives in a single block of memory, called <i>linear memory</i>.</br>
in wasm32 memory is indexed by an int32. what was a pointer in c is an index (int32) in wasm.</p>

wasm can be written without using stack memory, only heap for application data.
that is what i usually do when writing webassembly directly or with a custom compiler.</br>
the reason that can be done, is that functions can use an unlimited number of local variables and may include deep expression trees.<br/>
mapping these to registers or when to spill is not of wasm's concern, but propagated to the virtual machine implementation, often a jit compiler.<p/>
c however, often uses stack memory, e.g. to pass a reference of a local variable or to allocate a local array.
that's why c compilers, such as clang targetting wasm, use some space within the linear memory section for the c stack.</p>

clang compiled programs use the following memory layout and define some internal variables that can be accessed (or exported):
<pre>
     |   data   |  <--- stack  |  heap --->  |
     0    __data_end     __heap_base       max(can be grown at runtime)
</pre>
for details see <a href="https://surma.dev/things/c-to-webassembly/">surma's article</a>.</br>
this is often not necessary to know, but we use it to implement <tt>malloc</tt><p/>


in <tt>a.c</tt> the <tt>main</tt> function allocates a local input buffer and continues with a <i>read-eval-print-loop</i>.
for wasm on a webpage <tt>read</tt> would block the ui leaving the page unresponsive. we need somthing else.<br>
instead of entering with <tt>main</tt>, we allocate the input buffer in js and call <tt>ws(s)</tt> directly with the input string when the terminal receives a return key.</p>


let's compile <tt>a.c</tt> from arthur unmodified using clang:
<pre>
PATH="$PATH:/usr/lib/llvm-13/bin" # i need this for clang to find the linker

clang-13 -Os --target=wasm32 -mbulk-memory \
 -Wl,--export=ws,--export=__heap_base,-allow-undefined \
 --no-standard-libraries -Wl,--no-entry -oa.wasm a.c       #a.wasm is 1433 bytes
</pre>

we export the functions explicitly, that we need to have available within js and allow undefined function references.<br/>
what the compiler cannot resolve will be an import to the wasm module. it needs to be provided by js, otherwise the module cannot be instantiated.</p>

let's check what clang came up with, converting the wasm binary to text format: <tt>wasm2wat</tt> is part of <a href="https://github.com/WebAssembly/wabt/releases">wabt</a>.
there are binaries to download, or it may be available as a package for your system.

<pre>
$wasm2wat a.wasm -o a.wat
$head -15 a.wat
(module
  (type (;0;) (func (param i32) (result i32)))
  (type (;1;) (func (param i32 i32) (result i32)))
  (type (;2;) (func (param i32)))
  (type (;3;) (func (param i32 i32)))
  (type (;4;) (func (param i32 i32 i32) (result i32)))
  (import "env" "write" (func (;0;) (type 4)))
  (import "env" "strlen" (func (;1;) (type 0)))
  (import "env" "malloc" (func (;2;) (type 0)))
  (import "env" "strchr" (func (;3;) (type 1)))
  (func (;4;) (type 2) (param i32)
    (local i32)
    global.get 0
    i32.const 16
    i32.sub
$grep export a.wat
  (export "memory" (memory 0))
  (export "ws" (func 16))
  (export "__heap_base" (global 1))
</pre>

we see that the module expects <i>write strlen malloc strchr</i> as imports and exports <i>memory ws __heap_base</i>.</p>
from the function type index you can conclude which parameters each function needs and returns.
int32 can be a js number, int64 needs to be a BigInt (e.g. 0n).<br/>

<!--
when a function returns an int64 clang used to compile it much more complicated, because initially the mapping int64 to js/bigint did not exist.
-->

<h2>malloc</h2>
<tt>a.c</tt> uses <tt>malloc</tt> but never frees. that means we can implement it using a simple bump allocator.</br>
initially the heap starts at <tt>__heap_base</tt> upto max memory which we can query in the browser console (press F12):
<pre>
K.memory.buffer.byteLength //131072 two block of wasm memory (a block is 64kb)
K.__heap_base              //66784 (global variable exported from wasm)
</pre>
to access memory, e.g. read from or write into we need a array view:
<pre>
c=new Uint8Array(K.memory.buffer)
</pre>
this way we can also slice the data part of vector, if we know where it starts and how long it is, to convert data between js and wasm.
for other types just use <tt>Float64Array</tt> or <tt>Int32Array</tt> using the same underlying buffer.</p>
however if we grow the linear memory section
<pre>
K.memory.grow(4) //grow by 4*64kb, it returns the old number of blocks
</pre>
the underlying memory is copied (similar to <tt>realloc</tt>) and the array view must be recreated (otherwise it is <i>detached</i>).

<h2>js source</h2>
<pre id="j"></pre>

<script>
let g=x=>document.getElementById(x)
let t=g("t"),j=g("j") //t:console(content-editable pre element
let O=s=>{t.textContent=(t.textContent+s).split("\n").slice(-20).join("\n");E()}
let E=_=>{let s=window.getSelection();s.removeAllRanges();let r=document.createRange();r.selectNodeContents(t);r.collapse(false);s.addRange(r);t.focus()}
let lo=x=>Number(BigInt.asUintN(32,x))
let su=x=>t_.decode(x),t_=new TextDecoder("utf-8")
let us=x=>_t.encode(x),_t=new TextEncoder("utf-8")

 
let /*there be*/ K
let B                                                //input buffer
let C=_=>new Uint8Array(K.memory.buffer)
let M,ma=x=>{M+=x;return M-x}                        //todo check for max memory and grow
let S=(x,n)=>su(new Uint8Array(K.memory.buffer,x,n)) //js string from wasm pointer,length
let kenv={env:{                                      //this is a.wasm's import module                
 malloc:ma,                                          //which provides js functions called by wasm
 write:(x,y,z)=>{O(S(y,z));return z},
 strlen:x=>C().slice(x).indexOf(0),
 strchr:(x,y)=>{let c=C();while(c[x++])if(y==c[x])return x;return 0}}}

let key=(e,t)=>{if("Enter"==e.key){
 let s="\n"+t.textContent;s=s.slice(1+s.lastIndexOf("\n")).trim();t.textContent+="\n"
 try{ws(us(s));t.textContent+=" "}catch(e){
  O("segmentation fault\n");kinit()}                 //for authentic look and feel
  E()}}
 
let ws=u=>{let c=C();u.forEach((x,i)=>c[B+i]=x);c[B+u.length]=0;K.ws(B)}  //fill buffer than call ws


let kinit=()=>{
 let s=document.documentElement.outerHTML;j.textContent=s.slice(9+s.indexOf("<"+"script>"),-25) //show src
 fetch("a.wasm").then(r=>r.arrayBuffer()).then(r=>WebAssembly.instantiate(r,kenv)).then(r=>{
  K=r.instance.exports,M=K.__heap_base               //store all exports in K
  B=ma(128);                                         //allocate input buffer
  O(" ")})}

</script></body></html>
