<!DOCTYPE html>
<head><meta charset="utf-8">
<link rel="icon" type="image/png" sizes="16x16" href="../kelas16.png">
<title>a</title>
<style>
body{font-family:georgia,serif;font-size:large}
pre{margin:0}
td{vertical-align:top}
th{border-bottom:1px solid}
.s:hover{cursor:pointer}
.e{display:none;background:#ffe;padding-left:1em}
.l{color:blue;text-decoration:underline}
#tog:hover{cursor:pointer}
</style>
</head><body onload="init()">

<h1>introduction to atw/c</h1>

<span style="cursor:pointer;color:blue" onclick="expand(this)">expand</span>
<span style="float:right">(click on a line to show explanations)</span>

<table>
<tr><th><tt>a.c</tt></th><th><tt>a.h</tt></th></tr>
<tr><td><pre>
<span class="s">#include"a.h"//fF[+-!#,@] atom/vector 1byteint 1bytetoken  no(memmanage parser tokens ..)<span class="e">
+-!#,@ are are the list of primitives that are implemented in simple/k
fF means for both monadic and dyadic cases
the implementation contains atoms and vectors
but only for one data size: all values are one integers, e.g. -128..127
tokens are limited to single digit numbers as well
a true implementation needs memory management (allocate/free/reuse..)
this is not included here. vectors are allocated but never freed.
k/simple includes a parser and tokenizer in a basic form.
</span></span>
<span class="s">#define r(n,e) _(u r=a(n);i(n,ri=e)r)<span class="e" id="r">
r is defined as a macro.
it returns a vector of length n and assigns the expression e to each element.
<span class="l">a</span> creates the result array and <span class="l">ri</span>=e assigned the e to the element r[i]</span></span>
<span class="s">f(w,write(1,ax?(u)&x:x,ax?1:strlen(x)))<span class="e">
f(w,..) defines the monadic function w(x).
w uses the unix system call (see "man 2 write") and writes to stdout.
strlen is a libc function that clang recognizes as a builtin.
it returns the length of the string by counting until a 0 byte occurs in the data.
strings in c are terminated by the sential value 0. they do not contain a length.
but this is just a convention. we later define arrays, storing length and data.

w uses <span class="l">ax</span> to check if the argument is an atom.
for atoms it calls write passing a pointer to the argument &x and the length 1.
for vectors it passes x which in this case is interpreted as a pointer as it is.</span></span>
<span class="s">c b[12];<span class="e">
b is an array of type c with length 12. c definitions are type name.
the length comes last and is not part of the type.
b is only used locally as a buffer by the next function
but is defined as a global variable.</span></span>
<span class="s">f(si,sprintf(b,"%d ",128>x?x:x-256);b)<span class="e">
si(x) prints/formats the number x into the buffer b including a space
used for printing vectors (or atoms where we don't see it).
the argument x is an unsigned integer but is used to format signed integers.
the max value for the domain is 127 and we get negative number with x-256.
si returns the buffer because the next function calls it as w(si(x)) and w expects
the buffer as an argument.
</span></span>
<span class="s">f(wi,w(si(x)))<span class="e">
wi writes an integer, by calling w(si(x))</span></span>
<span class="s">f(w_,$(ax,wi(x))i(nx,wi(xi))w(10))<span class="e">
w_ writes a k value (atom or vector).
ax tests if x is an atom calling wi directly, otherwise it calls
wi in a loop for each element <span class="l">xi</span>.
the conditonal form $(a,b)c is defined as a macro <span class="l">$</span>
it is very similar to the ternary operator that c already has: a?b:c
the difference is that in a ternary operator a b and c must be expressions.
the operator itself is also an expression, it has a value.
but the loop <span class="l">i</span>(nx,..) is a block and cannot be used
in a ternary expression.</span></span>

<span class="s">F(err,w(f);w(58);w(x);w(10);96)<span class="e">
err(f,x) writes an error message. it is called by <span class="l">Qr</span> <span class="l">Qz</span>.
the arguments are the current function and the error string "rank" or "nyi".
the error message has the form (function):(error-type)(newline)</span></span>
<span class="s">G(m,(u)memcpy((void*)x,(void*)y,f))<span class="e">
m(f,x,y) moves/copies data by calling the builtin memcopy.
it reorders the argument: the first arg is the number of elements to copy,
followed by destination and source pointer.</span></span>
<span class="s" id="a">f(a,c*s=malloc(x+1);*s++=x;(u)s)<span class="e">
a(x) creates a vector. it allocates memory using the builtin malloc,
which expects a length (number of bytes).
it passes 1 element more than needed, stores the array length in the first
element and increases the pointer to the result c before returning it.
in this form c points to the data part of the vector and c[-1] is the length
usually accessed by <span class="l">nx</span></span></span>
<span class="s">f(foo,Qz(1)0)<span class="e">
foo is a function that print the nyi error.
it is a placeholder within the function <span class="l">table</span> for monadic primitives.</span></span>
<span class="s">f(sub,ax?(c)-x:r(nx,-xi))<span class="e">
sub is arithmetic negate, a monadic function.
it negates atoms and uses <span class="l">r</span> to negate all elements of a vector.
in (c)-x, (c) is a type cast. this casts the type from a longer integer to char.
both are unsigned, but the effect is that all but the lower byte remain 0 instead
of 1 because of sign extension.</span></span>
<span class="s">f(ind,Qr(!ax)r(x,i))<span class="e">
ind is !x known as til x, iota, or index generation.
it uses <span class="l">Qr</span> to check the rank of x and allows only atoms.
<span class="l">r</span> creates a return array and assigns the loop variable i to each element.</span></span>
<span class="s">f(cnt,Qr(ax)nx)<span class="e">
cnt is #x, also known as ‚ç¥ or tally. is fails for atoms and returns the length of vectors using <span class="l">nx</span></span></span>
<span class="s">f(cat,Qr(!ax)r(1,x))<span class="e">
cat is ,x the monadic form known as enlist.
it allows only atoms, creates a length-1 vector putting x inside.</span></span>
<span class="s">F(Add,ax?af?f+x:Add(x,f):r(nx,(af?f:fi)+xi))<span class="e">
Add is the example for a scalar function that extends atoms to vectors for
all 4 combinations of atom/vector arguments.
it uses a nested ternary test for the arguments.
note that f is the first arg and x the second.
if x is an atom but f is a vector is switches the arguments and calls itself again.
the final expression r(nx,..) handles the part where x is a vector and iterates
over x. f is checked within the loop each time and either added directly or indexed
with the loop variable.</span></span>
<span class="s">F(Sub,Add(f,sub(x)))<span class="e">
Sub is like Add but instead of implementing it again it negates the second argument
and calls Add.</span></span>
<span class="s">F(Ind,Qr(!f)r(nx,xi%f))<span class="e">
Ind is f!x and takes the modulo.
f is checked to be nonzero. it can only be an atom,
since we have neither vector literals nor parens.
the right argument x is not checked and assumed to be a vector.
x is rank checked to be a vector (try 3!4 and see it crash).</span></span>
<span class="s">F(Cnt,Qr(!af)r(f,ax?x:xi))<span class="e">
Cnt is take: f#x.
f is alywas atomic, x may be both.
the return array is filled in a loop using <span class="l">r</span>.</span></span>
<span class="s">F(Cat,f=af?cat(f):f;x=ax?cat(x):x;u r=a(nf+nx);m(nx,r+nf,x);m(nf,r,f))<span class="e">
Cat is catenation: f,x.
it rank checks both arguments and enlists each if it is an atom.
it returns a vector explicitly with u r=a(..) giving it the catenated length 
of both arguments.</span></span>
<span class="s">F(At,Qr(af)ax?sf[x]:r(nx,sf[xi]))f(at,At(x,0))<span class="e">
?</span></span>
<span class="s">char*V=" +-!#,@";<span class="e">
?</span></span>
<span class="s">u(*f[])()={0,foo,sub,ind,cnt,cat,at},(*F[])()={0,Add,Sub,Ind,Cnt,Cat,At},U[26];<span class="e" id="table">
?</span></span>
<span class="s">f(v,(strchr(V,x)?:V)-V)<span class="e">
?</span></span>
<span class="s">f(n,10>x-48?x-48:U[x-97])<span class="e">
?</span></span>
<span class="s">us(e,u i=*s++;v(i)?x(e(s),Q(x)f[v(i)](x)):x(n(i),*s?y(e(s+1),Q(y)F[v(*s)](x,y)):x))<span class="e">
?</span></span>
<span class="s">int main(){char s[99];while(1)if(w(32),s[read(0,s,99)-1]=0,*s)w_(e(s));}<span class="e">
?</span></span>
</pre></td><td><pre>
typedef unsigned char c;typedef unsigned long u;u Q=96;
<span class="s">#define $(a,b) if(a)b;else<span class="e" id="$">
?</span></span>
<span class="s">#define ax (256>x)<span class="e" id="ax">
?</span></span>
<span class="s">#define xi (nx>i?sx[i]:0)<span class="e" id="xi">
?</span></span>
<span class="s">#define i(n,e) {int $n=n;int i=0;for(;i<$n;++i){e;}}<span class="e" id="i">
?</span></span>
<span class="s">#define _(e) ({e;})<span class="e">
?</span></span>
<span class="s">#define _u(f,e,x...) u f(x){return({e;});}<span class="e">
?</span></span>
<span class="s">#define nx sx[-1]<span class="e" id="nx">
?</span></span>
<span class="s">#define sx ((c*)x)<span class="e">
?</span></span>
<span class="s">#define x(a,e) _(u x=a;e)<span class="e">
?</span></span>
<span class="s">#define y(a,e) _(u y=a;e)<span class="e">
?</span></span>
<span class="s">#define f(g,e) _u(g,e,u x)<span class="e">
?</span></span>
<span class="s">#define F(g,e) _u(g,e,u f,u x)<span class="e">
?</span></span>
<span class="s">#define G(g,e) _u(g,e,u f,u x,u y)<span class="e">
?</span></span>
<span class="s">#define us(f,e) _u(f,e,c*s)<span class="e">
?</span></span>
<span class="s">#define Q(e) if(Q==(e))return Q;<span class="e">
?</span></span>
<span class="s">#define Qr(e) if(e){return err((u)__func__,(u)"rank");}<span class="e" id="Qr">
?</span></span>
<span class="s">#define Qz(e) if(e){return err((u)__func__,(u)"nyi");}<span class="e" id="Qz">
?</span></span>
<span class="s">#define sr x(r,sx)<span class="e">
?</span></span>
<span class="s">#define ri sr[i]<span class="e" id="ri">
ri accesses element i of r. it may be used for both:
to get the value and to assign to but is only used in <span class="l">r</span></span></span>

<span class="s">#define af x(f,ax)<span class="e">
?</span></span>
<span class="s">#define nf x(f,nx)<span class="e">
?</span></span>
<span class="s">#define sf x(f,sx)<span class="e">
?</span></span>
<span class="s">#define fi x(f,xi)<span class="e">
?</span></span>
</pre></td></tr></table>

<hr/>
puzzle: find out why 1-2 works and returns -1 but 2-1 fails to produce the correct result.
</p>



<script>
let ge=x=>document.getElementById(x)
let aq=x=>Array.from(document.querySelectorAll(x))
let init=_=>{
	aq(".s").forEach(x=>x.onclick=toggle) 
	aq(".l").forEach(x=>x.onclick=link) 
}
let expand=t=>{aq(".e").forEach(x=>x.style.display=(t.textContent=="expand")?"block":"none");t.textContent=(t.textContent=="expand")?"collapse":"expand"}
let toggle=e=>{let c=e.target.firstElementChild;if(!e.target.classList.contains("s")){e.target.style.display="none";return};c.style.display=(c.style.display=="block")?"none":"block"}
let link=e=>{ let d=ge(e.target.textContent);d.style.display="block"; e.stopPropagation();}

</script>

<p/>

<pre>

integrate notes from kelas:..

//!\file a.h \brief less is more
//!headers for syscalls and stdlib functions
#include<unistd.h> //write(2)
#include<string.h> //strlen memcpy strchr
#include<stdlib.h> //malloc
#include<stdio.h>  //sprintf

//! type system
typedef unsigned char c;typedef unsigned long long u;    //!< type c is just a shorthand for byte, type u requires more words:
                                                         //!< although u is formally defined as ull (an unsigned 64bit integer),
                                                         //!< it is in fact an *opaque type*, i.e. k/simple uses it for everything,
                                                         //!< e.g. u can be: an atom (0..255), a vector pointer or a function pointer.
                                                         //!< since k/simple only supports a single atom type (8bit integer),
                                                         //!< atoms are expensive, since 7 out of 8 bytes of u are wasted. however,
                                                         //!< vectors of atoms do not incur this tax, because they are allocated with
                                                         //!< one extra leading byte which holds its length in bytes:

                                                         //!< k/simple memory layout:
                                                         //!<  vector x: |n|aaaaaaaaaaa....
                                                         //!<             ^ ^
                                                         //!<             | pointer to x points to its 0'th item, a's are 8bit wide
                                                         //!<             byte prior to 0'th item of x is the length of x (max 255 items)

//!minimal atwc
#define R return
#define $(a,b) if(a)b;else                               //!< handy shorthand for if-then-else. beware of dangling else!
#define i(n,e) {int $n=n;int i=0;for(;i<$n;++i){e;}}     //!< execute expression e n times, loop counter i is accessible from e

//!accessors for x
#define ax (256>x)                                       //!< is x an atom? (atoms are 0..255, x presumed to be of type u)
#define sx ((c*)x)                                       //!< reinterpret x as char pointer (ie as string or byte vector)
#define xi (nx>i?sx[i]:0)                                //!< return i'th element of vector x or 0 if i is out of bounds
#define nx sx[-1]                                        //!< length of vector x (stored in the byte preceding the actual data \see typedef u)

//!functions
#define _(e) ({e;})                                      //!< isolate expression e in its own lexical scope and clamp it with ;
#define _u(f,e,x...) u f(x){R _(e);}                     //!< generic function definition: all functions return some u, f function name, x args, e body
#define x(a,e) _(u x=a;e)                                //!< whatever a is, call it x and then execute some expression e in a separate lexical scope
#define y(a,e) _(u y=a;e)                                //!< (ditto for y) idea of x()/y() is to make use of standard accessors eg ax xi etc
#define f(g,e) _u(g,e,u x)                               //!< define a monadic function g: takes arg x of type u and returns some u, e is body
#define F(g,e) _u(g,e,u f,u x)                           //!< define a dyadic function g: takes args f and x of type u, returns some u, or:
                                                         //!< define an adverb g: takes function pointer f to some verb and its only arg x (nyi)
#define G(g,e) _u(g,e,u f,u x,u y)                       //!< define an adverb g: takes function pointer f, x and y are the args, returns some u (nyi)
#define us(f,e) _u(f,e,c*s)                              //!< define a function f which takes a string s as its only argument, e is body

//!error handling
u Q=96;                                                  //!< Q is magic number for error
#define Q(e)  if(Q==(e))R Q;                             //!< if some e evaluates to Q, return error
#define Qr(e) if(e){R err((u)__func__,(u)"rank");}       //!< if some e evaluates to true, throw rank error
#define Qz(e) if(e){R err((u)__func__,(u)"nyi");}        //!< ditto for not yet implemented

//!accessors for r
#define sr x(r,sx)                                       //!< reinterpret r as char pointer (ie as string or byte vector) \see sx
#define ri sr[i]                                         //!< get i'th element of vector r \todo consider using xi for bound check

//!accessors for f
</pre>
<pre>
#include"a.h"//fF[+-!#,@] atom/vector 1byteint 1bytetoken  no(memmanage parser tokens ..) cc -Os -oa a.c -w
             //! a typical example how atw comments his code:
             //! he says:       he means:
             //! fF[+-!#,@]     we have 6 verbs [+ - ! # , @] in both monadic and dyadic contexts, total of 12
             //!                (since monadic plus is nyi, we actually have 11, so roll your own f[+])
             //! atom/vector    k/simple sports atoms and vectors!
             //! 1byteint       only supported atom/vector type is 8bit integer
             //! 1bytetoken     input tokenizer is spartan: a token can't be longer than one char
             //! no(...)        no memory management, no parser and no tokenizer are implemented
             //! cc -w ..       build it like so
</pre>
<pre>
/! minimalistic type system
typedef unsigned char c;typedef unsigned long long u;    //!< type c is just a shorthand for byte, but type u requires more words:
                                                         //!< although u is formally defined as ull (an unsigned 64bit integer),
                                                         //!< it is in fact an *opaque type*, i.e. k/simple uses it for everything,
                                                         //!< e.g. u can be: an atom (0..255), a vector pointer or a function pointer.
                                                         //!< since k/simple only supports a single atom type (8bit integer),
                                                         //!< atoms are expensive, since 7 out of 8 bytes of u are wasted. however,
                                                         //!< vectors of atoms do not incur this tax, because they are allocated with
                                                         //!< one extra leading byte which holds its length in bytes:

                                                         //!< k/simple memory layout for vectors:
                                                         //!<  vector x: |n|aaaaaaaaaaa....
                                                         //!<             ^ ^
                                                         //!<             | pointer to x points to its 0'th item, all a's are 8bit wide
                                                         //!<             byte prior to 0'th item of x holds the length of x (max 255 items)

------------->                                           //!< \note it would make sense to redefine u as an alias for uintptr_t to reduce
                                                         //!< pressure on 32bit targets, e.g. for wasm32 there seems no reason for u to
                                                         //!< be 8 bytes wide. uintptr_t is basically sizeof(void*) and requires <stdint.h>.
                                                         //!< for simplicity, we keep u as ull for now.

it is not trivial to microbenchmark wasm32, especially on such a toy system, but my intuition is that uintptr_t would make quite a bit of a difference on something closer to a real dea
</pre>
</body></html>

