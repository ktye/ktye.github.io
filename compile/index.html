<!DOCTYPE html>
<head><meta charset="utf-8">
<link rel=icon href="../kelas16.png">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1">
<meta name="format-detection" content="telephone=no">
<title>compile</title>
<style>
body{font-family:georgia,serif;/*overflow-x:clip*/}
textarea{font-family:monospace;width:100%;background:#ffe;border:none;outline:none;white-space:pre;overflow-wrap:normal;overflow:hidden}
.o{background:#efe;overflow:clip}
@media(orientation:portrait){*{font-size:x-large}}
</style></head><body>

the following text includes an interactive repl. all yellow fields are k inputs, green is k output.<p/>
<pre class="o" id="banner"></pre>

let's start with an intermediate representation of a program
<textarea class="k" data-src="asn.k"></textarea>
<pre class="o"></pre>

for now we only care about <i>P</i>, the parent vector:
<textarea class="k">P</textarea>
<pre class="o"></pre>

let's draw the tree:
<textarea class="k" data-src="tree.k"></textarea>
<pre class="o"></pre>

<textarea class="k">`&lt;t:tree[]; `0</textarea>
<pre class="o"></pre>

we can see that the tree is in depth first order, showing the parent before the children.<br/>
How can we reorder the tree, such that the children come first, but their order is kept?</p>

Let's calculate an address for each node, e.g. node 13 should have the address 0-1-7-12-13, by tracing back the parent vector:
<textarea class="k">(P@)\P   /fix-point scan</textarea>
<pre class="o"></pre>

add index vector and a large value (e.g. the size of the tree):
<textarea class="k">(,(#P)##P) , (,!#P) , (P@)\P </textarea>
<pre class="o"></pre>

reverse, transpose and remove the uniq zeros:
<textarea class="k">a:?'+|(,(#P)##P),(,!#P),(P@)\P
a</textarea>
<pre class="o"></pre>

<textarea class="k">a 13</textarea>
<pre class="o"></pre>
this is the address for the node, except for the large terminating number.</p>

now we can sort by this address, the large number is chosen, such that the parents sort after the children.
<textarea class="k">i:&lt;a; i</textarea>
<pre class="o"></pre>

to reorder the tree, we index all vectors with i, except for P which needs to be adjusted to the new order:
<textarea class="k">P:(i?P)i;T:T i;I:I i;S:S i</textarea>
<pre class="o"></pre>

printing the tree needs some adjustments as well.
<textarea class="k" data-src="ptree.k"></textarea>
<pre class="o"></pre>

we show both trees side by side:
<textarea class="k">`<"\n"/("\n"\t),'"    ",/"\n"\ptree[]; `0</textarea>
<pre class="o"></pre>

parallel move: (todo)
<textarea class="k">
pmov:{[x;y]n:#x;s:n#0;M:!0
 m:{M,:(x,y)}
 f:{[i]i; $[~(x i)=y i;:0;0]
  s[i]:1
  {[j]$[y[j]=x[j];$[~sj:s j; f j; 1=sj; [m[t;y j];y[j]:t];0]  ;0]}'!n
  m[x i;y i]
  s[i]:2
 }
 {$[s x;0;f x]}'!n
 M}
</textarea>
<pre class="o"></pre>


assembling the tree uses a reduction of function "as" over the nodes.<br/>
"as" calls a function depending on the node type with the node index as first argument and return values from the evaluation of it's children as 2nd argument.<br/>
each node function may produce output calling "O" and returns an integer for the current register.
<textarea class="k" data-src="as.k"></textarea>
<pre class="o"></pre>

<script src="pmov.js"></script>
<script>
let K,o,lo=x=>Number(BigInt.asUintN(32,x)),af=Array.from
let C=()=>new Int8Array(K.memory.buffer)
let KC=x=>{x=("string"===typeof x)?us(x):x;let r=K.mk(18,x.length);C().set(x,lo(r));return r}
let su=x=>t_.decode(x),t_=new TextDecoder("utf-8"),us=x=>_t.encode(x),_t=new TextEncoder("utf-8")
let kenv={env:{ 
 Exit:  function(x      ){},
 Args:  function(       ){return 0},
 Arg:   function(x,y    ){return 0},
 Read:  function(a,b,c  ){return -1},
 Write: function(a,b,c,d){let u=new Uint8Array(K.memory.buffer),v=u.slice(c,c+d),f=u.slice(a,a+b);o.textContent+=su(v);return 0},
 ReadIn:function(x,y    ){return 0},
 Native:function(x,y  ,i){return 0}}}

let kinit=_=>{
 let n,nk=x=>{n=x.byteLength;return x}
 fetch("../k.wasm").then(r=>r.arrayBuffer()).then(r=>WebAssembly.instantiate(nk(r),kenv)).then(r=>{
 K=r.instance.exports;K.kinit();
 banner.textContent="ktye/k "+n
 K.repl(KC('`l:(.`"lxy.")100 30'))
 let k=af(document.querySelectorAll(".k"))
 k.forEach(x=>{x.style.height="0px";x.style.height=x.scrollHeight+3+"px"})
 k.forEach(x=>x.nextElementSibling.textContent="") //clear output
 k.forEach(x=>{o=x.nextElementSibling;K.repl(KC(x.value))})})}



let k=af(document.querySelectorAll(".k"));
{ let x=[],F={};k.forEach((k,i)=>{let s=k.dataset.src;if(s)x.push(fetch(s).then(r=>r.text()).then(r=>F[s]=r))});Promise.all(x).then(_=>{k.forEach(k=>k.value=k.dataset.src?F[k.dataset.src]:k.value);kinit()}) }

//kinit()
af(document.querySelectorAll("textarea")).forEach(x=>{x.onchange=kinit;x.spellcheck=false;x.autocorrect=false;x.oninput=_=>{x.style.height="";x.style.height=x.scrollHeight+3+"px"}})
</script></body></html>
