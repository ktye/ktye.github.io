<!DOCTYPE html>
<head><meta charset="utf-8">
<link rel=icon href="../kelas16.png">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1">
<meta name="format-detection" content="telephone=no">
<title>compile</title>
<style>
body{font-family:georgia,serif;/*overflow-x:clip*/}
textarea{font-family:monospace;width:100%;background:#ffe;border:none;outline:none;white-space:pre;overflow-wrap:normal;overflow:hidden}
.o{background:#efe;overflow:clip}
@media(orientation:portrait){*{font-size:x-large}}
</style></head><body>

the following text includes an interactive repl. all yellow fields are k inputs, green is k output.<p/>
<pre class="o" id="banner"></pre>

let's start with an intermediate representation of a program
<textarea class="k" data-src="asn.k"></textarea>
<pre class="o"></pre>

for now we only care about <i>P</i>, the parent vector:
<textarea class="k">P</textarea>
<pre class="o"></pre>

let's draw the tree:
<textarea class="k" data-src="tree.k"></textarea>
<pre class="o"></pre>

<textarea class="k">`&lt;t:tree[]; `0</textarea>
<pre class="o"></pre>

we can see that the tree is in depth first order, showing the parent before the children.<br/>
How can we reorder the tree, such that the children come first, but their order is kept?</p>

Let's calculate an address for each node, e.g. node 13 should have the address 0-1-7-12-13, by tracing back the parent vector:
<textarea class="k">(P@)\P   /fix-point scan</textarea>
<pre class="o"></pre>

add index vector and a large value (e.g. the size of the tree):
<textarea class="k">(,(#P)##P) , (,!#P) , (P@)\P </textarea>
<pre class="o"></pre>

reverse, transpose and remove the uniq zeros:
<textarea class="k">a:?'+|(,(#P)##P),(,!#P),(P@)\P
a</textarea>
<pre class="o"></pre>

<textarea class="k">a 13</textarea>
<pre class="o"></pre>
this is the address for the node, except for the large terminating number.</p>

now we can sort by this address, the large number is chosen, such that the parents sort after the children.
<textarea class="k">i:&lt;a; i</textarea>
<pre class="o"></pre>

to reorder the tree, we index all vectors with i, except for P which needs to be adjusted to the new order:
<textarea class="k">P:(i?P)i;T:T i;I:I i;S:S i</textarea>
<pre class="o"></pre>

printing the tree needs some adjustments as well.
<textarea class="k" data-src="ptree.k"></textarea>
<pre class="o"></pre>

we show both trees side by side:
<textarea class="k">`<"\n"/("\n"\t),'"    ",/"\n"\ptree[]; `0</textarea>
<pre class="o"></pre>

parallel move:
<textarea class="k">
/sequentialize parallel register moves
pmov:{[x;y;t]q:(n:#y)#0;m:!0
 q0:{[i]q[i]:1;r:2,i,,/{0,j x}'&x[i]=y j:|!n ;r}
 q1:{[i]m,:t,y i;y[i]:t;!0}
 g0:{[i]((q0;q1;:)[q i])[i]}
 g1:{[i]m,:x[i],y[i];q[i]:2;!0}
 f:{[i]s:0,i;while[0<l:-1+#s;g:s l-1;i:s l;s:-2_s;$[x[i]~y i;0;s,:$[g;g1 i;g0 i]]]}
 {[i]$[~q i;f i;0]}'!n;m}

 /pmov[dst;src;tmp]
 \pmov[1 2 3;1 2 3;-1] /!0            => do nothing
 \pmov[1 2 3;3 2 3;-1] /1 3           => mov r1,r3
 \pmov[1 2 3;3 2 1;-1] /-1 3 3 1 1 -1 => mov t,r3;mov r3,r1;mov r1,t
</textarea>
<pre class="o"></pre>


assembling the tree uses a reduction of function "as" over the nodes.<br/>
"as" calls a function depending on the node type with the node index as first argument and return values from the evaluation of it's children as 2nd argument.<br/>
each node function may produce output calling "O" and returns an integer for the current register.
<textarea class="k" data-src="as.k"></textarea>
<pre class="o"></pre>

<script src="pmov.js"></script>
<script>
let K,o,lo=x=>Number(BigInt.asUintN(32,x)),af=Array.from
let C=()=>new Int8Array(K.memory.buffer)
let KC=x=>{x=("string"===typeof x)?us(x):x;let r=K.mk(18,x.length);C().set(x,lo(r));return r}
let su=x=>t_.decode(x),t_=new TextDecoder("utf-8"),us=x=>_t.encode(x),_t=new TextEncoder("utf-8")
let kenv={env:{ 
 Exit:  function(x      ){},
 Args:  function(       ){return 0},
 Arg:   function(x,y    ){return 0},
 Read:  function(a,b,c  ){return -1},
 Write: function(a,b,c,d){let u=new Uint8Array(K.memory.buffer),v=u.slice(c,c+d),f=u.slice(a,a+b);o.textContent+=su(v);return 0},
 ReadIn:function(x,y    ){return 0},
 Native:function(x,y  ,i){return 0}}}

let kinit=_=>{
 let n,nk=x=>{n=x.byteLength;return x}
 fetch("../k.wasm").then(r=>r.arrayBuffer()).then(r=>WebAssembly.instantiate(nk(r),kenv)).then(r=>{
 K=r.instance.exports;K.kinit();
 banner.textContent="ktye/k "+n
 K.repl(KC('`l:(.`"lxy.")100 30'))
 let k=af(document.querySelectorAll(".k"))
 k.forEach(x=>{x.style.height="0px";x.style.height=x.scrollHeight+3+"px"})
 k.forEach(x=>x.nextElementSibling.textContent="") //clear output
 k.forEach(x=>{o=x.nextElementSibling;K.repl(KC(x.value))})})}



let k=af(document.querySelectorAll(".k"));
{ let x=[],F={};k.forEach((k,i)=>{let s=k.dataset.src;if(s)x.push(fetch(s).then(r=>r.text()).then(r=>F[s]=r))});Promise.all(x).then(_=>{k.forEach(k=>k.value=k.dataset.src?F[k.dataset.src]:k.value);kinit()}) }

//kinit()
af(document.querySelectorAll("textarea")).forEach(x=>{x.onchange=kinit;x.spellcheck=false;x.autocorrect=false;x.oninput=_=>{x.style.height="";x.style.height=x.scrollHeight+3+"px"}})
</script></body></html>
