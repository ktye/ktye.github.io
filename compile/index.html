<!DOCTYPE html>
<head><meta charset="utf-8">
<link rel=icon href="../kelas16.png">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1">
<meta name="format-detection" content="telephone=no">
<title>compile</title>
<style>
body{font-family:georgia,serif;/*overflow-x:clip*/}
summary{font-size:large;font-weight:bold}
details:open>summary{margin-bottom:1em}
textarea{font-family:monospace;width:100%;background:#ffe;border:none;outline:none;white-space:pre;overflow-wrap:normal;overflow:hidden}
.c{margin-left:1em;margin-top:0.5em;display:block}
.o{background:#efe;overflow:clip}
.d{border:1px solid blue}
@media(orientation:portrait){*{font-size:x-large}}
</style></head><body>

the following text includes an interactive repl. all yellow fields are k inputs, green is k output.<p>
<pre class="o" id="banner"></pre><a id="dl" hidden></a>

<details id="postfix"><summary>intermediate representation and transform to postfix</summary>

let's start with an intermediate representation of a program
<textarea class="k" data-src="asn.k"></textarea>
<pre class="o"></pre>

for now we only care about <i>P</i>, the parent vector:
<textarea class="k">P</textarea>
<pre class="o"></pre>

let's draw the tree:
<textarea class="k" data-src="tree.k"></textarea>
<pre class="o"></pre>

<textarea class="k">`&lt;t:tree[]; `0</textarea>
<pre class="o"></pre>

we can see that the tree is in depth first order, showing the parent before the children.<br/>
How can we reorder the tree, such that the children come first, but their order is kept?</p>

Let's calculate an address for each node, e.g. node 13 should have the address 0-1-7-12-13, by tracing back the parent vector:
<textarea class="k">(P@)\P   /fix-point scan</textarea>
<pre class="o"></pre>

add index vector and a large value (e.g. the size of the tree):
<textarea class="k">(,(#P)##P) , (,!#P) , (P@)\P </textarea>
<pre class="o"></pre>

reverse, transpose and remove the uniq zeros:
<textarea class="k">a:?'+|(,(#P)##P),(,!#P),(P@)\P
a</textarea>
<pre class="o"></pre>

<textarea class="k">a 13</textarea>
<pre class="o"></pre>
this is the address for the node, except for the large terminating number.</p>

now we can sort by this address, the large number is chosen, such that the parents sort after the children.
<textarea class="k">i:&lt;a; i</textarea>
<pre class="o"></pre>

to reorder the tree, we index all vectors with i, except for P which needs to be adjusted to the new order:
<textarea class="k">P:(i?P)i;T:T i;I:I i;S:S i</textarea>
<pre class="o"></pre>

printing the tree needs some adjustments as well.
<textarea class="k" data-src="ptree.k"></textarea>
<pre class="o"></pre>

we show both trees side by side:
<textarea class="k">`<"\n"/("\n"\t),'"    ",/"\n"\ptree[]; `0</textarea>
<pre class="o"></pre>

</details>

<details id="pmov"><summary>parallel register moves</summary>
<p>
before calling a function, the child nodes are evaluated to a list of registers for the function arguments.<br/>
all active registers are pushed to the stack and the arguments must be reordered from the current argument list to expected calling order.<br/>
in general this cannot be done sequentially because some registers may be overwritten.
</p>
<p>
<a href="https://compiler.club/parallel-moves">here</a> is a description of an algorithm that finds a sequence of moves which is equivalent to a parallel assignment of all src to dst registers.
</p>
<code>pmov[dst;src;tmp]</code> tmp is a temporary register, which is needed if there is a cycle.
<textarea class="k" data-src="pmov.k"></textarea><pre class="o"></pre>
<textarea class="k">
 \pmov[1 2 3;1 2 3;-1] /!0            => do nothing
 \pmov[1 2 3;3 2 3;-1] /1 3           => mov r1,r3
 \pmov[1 2 3;3 2 1;-1] /-1 3 3 1 1 -1 => mov t,r3;mov r3,r1;mov r1,t
</textarea><pre class="o"></pre></details>


<details id="assemble"><summary>assemble</summary>

<p>
assembling the tree uses a reduction with function <code>as</code> over the nodes:<br/>
<code class="c">as/[();!#P;nc P]</code>
</p>
<p>
<code>as</code> calls a function depending on the node type <code>(.T y)</code> with the node index as first argument and return values from the evaluation of it's children as 2nd argument:<br/>
<code class="c">as:{c:(0,(#x)-z)^x;(c 0),,,/(.T y)[y;c 1]}</code>
</p>
each node function may produce output calling "O" and returns an integer for the current register.

<textarea hidden class="k" data-src="pmov.k"></textarea><pre class="o"></pre>
<textarea hidden class="k" data-src="postfix.k"></textarea><pre class="o"></pre>
<textarea hidden class="k" data-src="asn.k"></textarea><pre class="o"></pre>
<textarea hidden class="k" >postfix[];`0</textarea><pre class="o"></pre>

<textarea class="k" data-src="as0.k"></textarea>
<pre class="o"></pre>

</details>

<details id="insert" open><summary>insert nodes</summary>
  <textarea hidden class="k" data-src="tests/a.k"></textarea><pre class="o"></pre>
  <textarea hidden class="k" data-src="postfix.k"></textarea><pre class="o"></pre>
  <textarea hidden class="k">postfix[];`0</textarea><pre class="o"></pre>
  <textarea hidden class="k" data-src="ptree.k"></textarea>
  
to insert nodes, we cut the vectors <code>T P I S</code> at the insertion points, append the new items and join:<br/>
<p> <code class="c">ins:{[i;x;y];-1_,/((0,i)^x),'y,*y}</code><p/>
the parent vector needs to be adjusted
<p> <code class="c">P:(0,i)'P+ins[i;P;p]</code></p>
<p> e.g. we want to insert a marker before the else clause in a conditional.
a <code>cnd</code> has 2 or 3 children, if there are 3 insert a node with type <code>els</code> before the last child:<p/>

<textarea class="k">
insert:{[j;t;p;i;s]T::ins[j;T;t];P::(0,j)'P+ins[j;P;p];I::ins[j;I;i]P::ins[j;S;s]}
else:(lc P)i@&3=(nc P)@i:&`cnd=T
else
</textarea><pre class="o"></pre>

<textarea hidden class="k">`&lt;ptree[]; `0</textarea><pre class="o"></pre>
  
  
</details>

<details id="as" ><summary>as</summary>

<textarea hidden class="k" data-src="pmov.k"></textarea><pre class="o"></pre>
<textarea hidden class="k" data-src="postfix.k"></textarea><pre class="o"></pre>
  <textarea hidden class="k" data-src="tests/a.k"></textarea><pre class="o"></pre>
  <textarea hidden class="k">postfix[];`0</textarea><pre class="o"></pre>
  <textarea hidden class="k" data-src="ptree.k"></textarea>
  <textarea class="k">`&lt;ptree[]; `0</textarea><pre class="o"></pre>
<textarea hidden class="k" data-src="tests/a.k"></textarea><pre class="o"></pre>
<textarea class="k" data-src="as.k"></textarea>
<pre class="o d"></pre>

</details>


<script>
let K,o,lo=x=>Number(BigInt.asUintN(32,x)),af=Array.from,qa=x=>af(document.querySelectorAll(x))
let C=()=>new Int8Array(K.memory.buffer)
let KC=x=>{x=("string"===typeof x)?us(x):x;let r=K.mk(18,x.length);C().set(x,lo(r));return r}
let su=x=>t_.decode(x),t_=new TextDecoder("utf-8"),us=x=>_t.encode(x),_t=new TextEncoder("utf-8")
let kenv={env:{ 
 Exit:  function(x      ){},
 Args:  function(       ){return 0},
 Arg:   function(x,y    ){return 0},
 Read:  function(a,b,c  ){return -1},
 Write: function(a,b,c,d){let u=new Uint8Array(K.memory.buffer),v=u.slice(c,c+d),f=u.slice(a,a+b);o.textContent+=su(v);return 0},
 ReadIn:function(x,y    ){return 0},
 Native:function(x,y  ,i){return 0}}}

let kinit=_=>{
 let n,nk=x=>{n=x.byteLength;return x}
 fetch("../k.wasm").then(r=>r.arrayBuffer()).then(r=>WebAssembly.instantiate(nk(r),kenv)).then(r=>{
 K=r.instance.exports;K.kinit();
 banner.textContent="ktye/k "+n
 K.repl(KC('`l:(.`"lxy.")100 30'))
 let k=qa(".k").filter(x=>x.parentElement.open)
 k.forEach(x=>{x.style.height="0px";x.style.height=x.scrollHeight+3+"px"})
 k.forEach(x=>x.nextElementSibling.textContent="") //clear output
 k.forEach(x=>{o=x.nextElementSibling;K.repl(KC(x.value))})})}

let download=(f,u)=>{let x=new Blob([u],{type:"application/octet-stream"});dl.href=URL.createObjectURL(x);dl.download=f;dl.click()}

qa("details").forEach(d=>d.ontoggle=e=>{if(!e.target.open)return; qa("details").forEach(x=>{x.open=x===e.target}); kinit()})

let k=qa(".k");
{ let x=[],F={};k.forEach((k,i)=>{let s=k.dataset.src;if(s)x.push(fetch(s).then(r=>r.text()).then(r=>F[s]=r))});Promise.all(x).then(_=>{k.forEach(k=>k.value=k.dataset.src?F[k.dataset.src]:k.value); kinit() }) }

qa(".d").forEach(x=>x.ondblclick=_=>download("x.as",us(x.textContent)))
qa("textarea").forEach(x=>{x.onchange=kinit;x.spellcheck=false;x.autocorrect=false;x.oninput=_=>{x.style.height="";x.style.height=x.scrollHeight+3+"px"}})
</script></body></html>
