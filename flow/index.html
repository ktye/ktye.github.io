<!DOCTYPE html>
<head><meta charset="utf-8">
<link rel=icon href="../kelas16.png"><title>NAVIER STOKES</title>
<style>*{font-family:monospace;font-size:large}
canvas{background:#ccc;}
#err{color:darkred}
</style>
</head>

<body onload="">
<div style="display:flex;gap:2em">
 <canvas id="cnv" width="512" height="512"></canvas><div><button onclick="step()">step</button></div>
</div>
<hr/>
<pre id="err"></pre>
<hr/><div style="display:flex;gap:2em"><pre id="src"></pre><div style="border-left:1px solid">

<h1>NAVIER STOKES</h1>
‚àÇw/‚àÇt + w grad w + grad p/œÅ = ùúà div grad w + f<br/>
div v = 0

<h2>excitation</h2>
‚àÇw/‚àÇt = f<br/>
this is the simple part: multiply the force field f with the time step and add it to the velocity field.

<h2>convection</h2>
w grad w
is the nonlinear term of fluid flow, which makes it interesting.
the change of velocity is the local time derivative ‚àÇw/‚àÇt and what flows in if there is a gradient: w grad w.
it's also called self-convection because it's the velocity which is transported by itself.

forward integration can be unstable if the step size is too large.
to keep it stable we integrate backwards: update the velocity with the value of the cells where it comes from.
we use bilinear interpolation with the 4 neighbor cells as the source value.

<h2>diffusion</h2>
‚àÇw/‚àÇt = ùúà div grad v</br>
with the laplace operator on the right side. it's the same form as the heat equation.
differences equal out with time.
this part is not present in the euler equations of inviscous flow.<br/>

we solve it under the fft together with the projection step.

<h2>projection</h2>
handle grad p and div v = 0</br>
we can ignore grad p if we keep the velocity field solenoidal.
there are no sources and the conservation of mass demands div v = 0.<br/>
in 2d this is 0=du/dx+dv/dy. in fourier space this is 0=X*U+Y*V,
e.g. the scalar product with the wave vector (X;Y) is 0.
this means, the velocity field in fouier space is perpendicular to the wave vector.
we have to project it, to keep it that way.</br>

for 2d-fft we can apply a normal fft to the rows than the columns,
e.g. do twice: flip fft each.<br/>

U:fft2 u; V:fft2 v. with two-for-one we have W:fft2 u+iv 
and we can recover U:0.5*(W+conj W I) and V:-i*0.5*(W-conj W I) with I: n/n!n-!n,n
The projection keeps U,V orthogonal to the vector of wave numbers X,Y
e.g. it substracts the part in direction of X,Y:
<pre>
P(U) = (1-XX/RR) U -   (XY/RR) V
P(V) = (- XY/RR) U + (1-YY/RR) U,  with RR:XX+YY
</pre>
X and Y are the wavenumbers X:0.+(n*n)#(!m),m,1_(-m)+!m:n%2 in the order after the transform.
before transfoming back, we combine the parts: P(W) = P(U) + i*P(V).

we can formulate the projection without decomposing W into U and V, working on W directly:
<pre>
P(W) = 0.5*W - 0.5*(conj W I) * (X+i*Y)^2 / (abs(X+i*Y))^2
</pre>
</div></div>
<script>



fetch("flow.k").then(r=>r.text()).then(r=>{src.textContent=r;kinit()})

let K,f,lo=x=>Number(BigInt.asUintN(32,x)),C=()=>new Int8Array(K.memory.buffer),U=()=>new Uint32Array(K.memory.buffer),F=()=>new Float64Array(K.memory.buffer),
KC=x=>{x=("string"===typeof x)?us(x):x;let r=K.mk(18,x.length);C().set(x,lo(r));return r},Ks=s=>K.sc(KC(s)),
FK=x=>{let r=F().slice(lo(x)>>>3,(lo(x)>>>3)+K.nn(x));K.dx(x);return r},
su=x=>t_.decode(x),t_=new TextDecoder("utf-8"),us=x=>_t.encode(x),_t=new TextEncoder("utf-8"),
kenv={env:{ 
 Exit:  function(x      ){},
 Args:  function(       ){return 0},
 Arg:   function(x,y    ){return 0},
 Read:  function(a,b,c  ){return -1},
 Write: function(a,b,c,d){let u=new Uint8Array(K.memory.buffer),v=u.slice(c,c+d);err.textContent+=su(v);return 0},
 ReadIn:function(x,y    ){return 0},
 Native:function(x,y    ){return 0}}},
kinit=()=>{fetch("../k.wasm").then(r=>r.arrayBuffer()).then(r=>WebAssembly.instantiate(r,kenv)).then(r=>{K=r.instance.exports;K.kinit();aprio();err.textContent="k"})},
aprio=()=>{
 f=K.Val(KC(src.textContent))
 draw()
 console.log("f",K.tp(f))
},step=()=>{K.dx(K.Cal(K.rx(f),K.mk(23,0)));  draw()},ctx=cnv.getContext("2d"),
draw=()=>{ctx.clearRect(0,0,512,512)
 let u=FK(K.Val(KC("w 0"))),v=FK(K.Val(KC("w 1"))),n=Math.sqrt(u.length),scale=512/n,x=y=scale/2
 let k=0;for(let i=0;i<n;i++){for(let j=0;j<n;j++){
  ctx.fillRect(x-3,y-3,6,6)
  ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x+20*u[k],y+20*v[k]);ctx.stroke()
  x+=scale;k++
 };y+=scale;x=scale/2}
}

</script>

</body></html>
