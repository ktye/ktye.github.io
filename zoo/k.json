{"adverbs.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func ech(x K) K { return l2t(x, 0, df) } // '","func ecp(x K) K { return l2t(x, 1, df) } // ':","func rdc(x K) K { return l2t(x, 2, df) } // /","func ecr(x K) K { return l2t(x, 3, df) } // /:","func scn(x K) K { return l2t(x, 4, df) } // \\","func ecl(x K) K { return l2t(x, 5, df) } // \\:","","func Ech(f, x K) (r K) {","\tt := tp(f)","\tif isfunc(t) == 0 {","\t\tif nn(x) == 2 {","\t\t\tx, r = spl2(x)","\t\t\treturn lin(x, f, r)","\t\t}","\t\treturn Bin(f, Fst(x))","\t}","\tif nn(x) == 1 {","\t\tx = Fst(x)","\t} else {","\t\treturn ecn(f, x)","\t}","\tif tp(x) \u003c 16 {","\t\ttrap(Type)","\t}","\txt := tp(x)","\tif xt == Dt {","\t\tx, r = spl2(x)","\t\treturn Key(x, Ech(f, l1(r)))","\t}","\tif xt == Tt {","\t\tx = explode(x)","\t}","\txn := nn(x)","\tr = mk(Lt, xn)","\trp := int32(r)","\tfor i := int32(0); i \u003c xn; i++ {","\t\tSetI64(rp, int64(Atx(rx(f), ati(rx(x), i))))","\t\trp += 8","\t}","\tdx(f)","\tdx(x)","\treturn uf(r)","}","func ecn(f, x K) (r K) {","\tif nn(x) == 2 {","\t\tr, x = spl2(x)","\t\tif r == 0 {","\t\t\treturn Ech(f, l1(x))","\t\t}","\t\tif tp(f) == 0 \u0026\u0026 int32(f) == 13 {","\t\t\tif tp(r) == Tt \u0026\u0026 tp(x) == Tt { // T,'T (horcat)","\t\t\t\tif nn(r) != nn(x) {","\t\t\t\t\ttrap(Length)","\t\t\t\t}","\t\t\t\tp, q := spl2(r)","\t\t\t\tr, x = spl2(x)","\t\t\t\treturn key(Cat(p, r), Cat(q, x), Tt)","\t\t\t}","\t\t}","\t\treturn ec2(f, r, x)","\t}","\treturn Ech(20, l2(f, Flp(x)))","}","func ec2(f, x, y K) (r K) {","\tvar t T","\tr, t, x, y = dctypes(x, y)","\tif r != 0 {","\t\treturn key(r, ec2(f, x, y), t)","\t}","\tn, _ := conform(x, y)","\tswitch n {","\tcase 0: // a-a","\t\treturn Cal(f, l2(x, y))","\tcase 1: // a-v","\t\tn = nn(y)","\tcase 2: // v-v","\t\tn = nn(x)","\tdefault: // v-a","\t\tn = nn(x)","\t}","\tr = mk(Lt, n)","\trp := int32(r)","\tfor i := int32(0); i \u003c n; i++ {","\t\tSetI64(rp, int64(Cal(rx(f), l2(ati(rx(x), i), ati(rx(y), i)))))","\t\trp += 8","\t}","\tdx(f)","\tdx(x)","\tdx(y)","\treturn uf(r)","}","func Ecp(f, x K) (r K) {","\tt := tp(f)","\tif isfunc(t) == 0 {","\t\tif nn(x) != 1 {","\t\t\ttrap(Rank)","\t\t}","\t\treturn In(f, Fst(x))","\t}","\txn := nn(x)","\tvar y K","\tvar m int32","\tif xn == 1 {","\t\tx = Fst(x)","\t\ty = Fst(rx(x)) // could be missing(xt)","\t\tm = 1","\t} else if xn == 2 {","\t\ty, x = spl2(x)","\t} else {","\t\ttrap(Rank)","\t}","\txt := tp(x)","\tif xt \u003c 16 {","\t\ttrap(Type)","\t}","\tif xt \u003e Lt {","\t\ttrap(Nyi)","\t}","\txn = nn(x)","\tif 1 \u003e xn-m {","\t\tdx(f)","\t\treturn x","\t}","","\tyt := tp(y)","\tif tp(f) == 0 \u0026\u0026 xt \u003c Zt \u0026\u0026 yt == xt-16 {","\t\tfp := int32(f)","\t\tif fp \u003e 2 \u0026\u0026 xt != St \u0026\u0026 fp \u003c 6 || fp == 7 || fp == 8 {","\t\t\treturn epx(fp, x, y, xn) // +-*% \u0026|","\t\t}","\t\tif fp == 12 {","\t\t\tfp = 11 // ~ =","\t\t}","\t\tif fp \u003e 8 \u0026\u0026 fp \u003c 12 {","\t\t\treturn epc(fp, x, y, xn) // \u003c\u003e= (~)","\t\t}","\t}","\tr = mk(Lt, xn)","\trp := int32(r)","\tSetI64(rp, int64(cal(rx(f), l2(ati(rx(x), 0), y))))","\tfor i := int32(1); i \u003c xn; i++ {","\t\trp += 8","\t\tSetI64(rp, int64(cal(rx(f), l2(ati(rx(x), i), ati(rx(x), i-1)))))","\t}","\tdx(f)","\tdx(x)","\treturn uf(r)","}","func epx(f int32, x, y K, n int32) (r K) { // ( +-*% \u0026| )':","\txt := tp(x)","\tif xt \u003c It {","\t\tx, xt = uptype(x, it), It","\t}","\txp := int32(x)","\tr = mk(xt, n)","\trp := int32(r)","\tif f \u003e 6 {","\t\tf--","\t}","\tf = 212 + 11*f","\typ := int32(y)","\tif xt == It {","\t\tSetI32(rp, Func[f].(f2i)(I32(xp), yp))","\t\tfor i := int32(1); i \u003c n; i++ {","\t\t\txp += 4","\t\t\trp += 4","\t\t\tSetI32(rp, Func[f].(f2i)(I32(xp), I32(xp-4)))","\t\t}","\t} else {","\t\tf++","\t\tSetF64(rp, Func[f].(f2f)(F64(xp), F64(yp)))","\t\tfor i := int32(1); i \u003c n; i++ {","\t\t\txp += 8","\t\t\trp += 8","\t\t\tSetF64(rp, Func[f].(f2f)(F64(xp), F64(xp-8)))","\t\t}","\t}","\tdx(x)","\tdx(y)","\treturn r","}","func epc(f int32, x, y K, n int32) (r K) { // ( \u003c\u003e= )':","\txt := tp(x)","\txp := int32(x)","\ts := sz(xt)","\tr = mk(Bt, n)","\trp := int32(r)","\tf = 173 + 15*f","\tswitch s \u003e\u003e 2 {","\tcase 0:","\t\tSetI8(rp, Func[f].(f2i)(I8(xp), int32(y)))","\t\tfor i := int32(1); i \u003c n; i++ {","\t\t\txp++","\t\t\trp++","\t\t\tSetI8(rp, Func[f].(f2i)(I8(xp), I8(xp-1)))","\t\t}","\tcase 1:","\t\tSetI8(rp, Func[f].(f2i)(I32(xp), int32(y)))","\t\tfor i := int32(1); i \u003c n; i++ {","\t\t\txp += 4","\t\t\trp++","\t\t\tSetI8(rp, Func[f].(f2i)(I32(xp), I32(xp-4)))","\t\t}","\tdefault:","\t\tf++","\t\tSetI8(rp, Func[f].(f2c)(F64(xp), F64(int32(y))))","\t\tfor i := int32(1); i \u003c n; i++ {","\t\t\txp += 8","\t\t\trp++","\t\t\tSetI8(rp, Func[f].(f2c)(F64(xp), F64(xp-8)))","\t\t}","\t}","\tdx(x)","\tdx(y)","\treturn r","}","func Rdc(f, x K) (r K) { // x f/y   (x=0):f/y","\tt := tp(f)","\tif isfunc(t) == 0 {","\t\tif nn(x) == 2 {","\t\t\tr, x = spl2(x)","\t\t\tif t == it \u0026\u0026 isfunc(tp(r)) != 0 {","\t\t\t\treturn ndo(int32(f), r, x)","\t\t\t} else {","\t\t\t\ttrap(Type)","\t\t\t}","\t\t}","\t\treturn Mod(Fst(x), f)","\t}","\tif arity(f) \u003e 2 {","\t\treturn rdn(f, x, 0)","\t}","\tif t == df { // x//y","\t\tr = x0(int32(f))","\t\tdx(f)","\t\treturn Dec(r, Fst(x))","\t}","\tvar y K","\tif xn := nn(x); xn == 1 {","\t\ty = Fst(x)","\t\tx = 0","\t} else if xn == 2 {","\t\tx, y = spl2(x)","\t} else {","\t\ttrap(Rank)","\t}","\tyt := tp(y)","\tif yt == Dt {","\t\ty = Val(y)","\t\tyt = tp(y)","\t}","\tif yt \u003c 16 {","\t\tif x == 0 {","\t\t\tdx(f)","\t\t\treturn y","\t\t} else {","\t\t\treturn cal(f, l2(x, y))","\t\t}","\t}","","\txt := tp(x)","\tyn := nn(y)","\tif tp(f) == 0 {","\t\tfp := int32(f)","\t\tif fp \u003e 1 \u0026\u0026 fp \u003c 9 \u0026\u0026 (xt == 0 || yt == xt+16) { // sum,prd,min,max (reduce.go)","\t\t\tif yt == Tt {","\t\t\t\treturn Ech(rdc(f), l2(x, Flp(y)))","\t\t\t}","\t\t\tr = Func[365+fp].(rdf)(x, int32(y), yt, yn)","\t\t\tif r != 0 {","\t\t\t\tdx(x)","\t\t\t\tdx(y)","\t\t\t\treturn r","\t\t\t}","\t\t}","\t\tif x == 0 \u0026\u0026 fp == 13 { // ,/","\t\t\tif yt \u003c Lt {","\t\t\t\treturn y","\t\t\t}","\t\t\tr = ucats(y)","\t\t\tif r != 0 {","\t\t\t\treturn r","\t\t\t}","\t\t}","\t}","","\tif yn == 0 {","\t\tif x == 0 {","\t\t\tdx(y)","\t\t\treturn missing(yt - 16) // or identity element, e.g. +/() -\u003e 0 not \"\"","\t\t} else {","\t\t\tdx(f)","\t\t\tdx(y)","\t\t\treturn x","\t\t}","\t}","","\ti := int32(0)","\tif x == 0 {","\t\tx, i = ati(rx(y), 0), 1","\t}","\tfor i \u003c yn {","\t\tx = cal(rx(f), l2(x, ati(rx(y), i)))","\t\ti++","\t}","\tdx(y)","\tdx(f)","\treturn x","}","func rdn(f, x, l K) (r K) { // {x+y*z}/x  {x+y*z}\\x","\tn := nn(f)","\tif n \u003e nn(x) {","\t\treturn prj(rdc(f), x)","\t}","","\tr = Fst(rx(x))","\tx = Flp(ndrop(1, x))","\tn = nn(x)","\tfor i := int32(0); i \u003c n; i++ {","\t\tr = Cal(rx(f), Cat(Enl(r), ati(rx(x), i)))","\t\tif l != 0 {","\t\t\tl = cat1(l, rx(r))","\t\t}","\t}","\tdx(f)","\tdx(x)","\tif l != 0 {","\t\tdx(r)","\t\treturn uf(l)","\t}","\treturn r","}","","func Ecr(f, x K) (r K) { // f/:x   x f/:y   x/:y(join)","\tt := tp(f)","\tif isfunc(t) == 0 {","\t\tif nn(x) != 1 {","\t\t\ttrap(Rank)","\t\t}","\t\treturn join(f, Fst(x))","\t}","\txn := nn(x)","\tswitch xn - 1 {","\tcase 0: // fixed-point","\t\treturn fix(f, Fst(x))","\tcase 1:","\t\tvar y K","\t\tx, y = spl2(x)","\t\tyt := tp(y)","\t\tif yt \u003c 16 {","\t\t\treturn cal(f, l2(x, y))","\t\t}","\t\tif yt \u003e Lt {","\t\t\tvar t T","\t\t\tr, t, x, y = dctypes(x, y)","\t\t\treturn key(r, Ecr(f, l2(x, y)), t)","\t\t}","\t\tyn := nn(y)","\t\tr = mk(Lt, yn)","\t\trp := int32(r)","\t\tfor i := int32(0); i \u003c yn; i++ {","\t\t\tSetI64(rp, int64(cal(rx(f), l2(rx(x), ati(rx(y), i)))))","\t\t\trp += 8","\t\t}","\t\tdx(f)","\t\tdx(x)","\t\tdx(y)","\t\treturn uf(r)","\tdefault:","\t\treturn trap(Rank)","\t}","}","func fix(f, x K) (r K) {","\ty := rx(x)","\tfor {","\t\tr = Atx(rx(f), rx(x))","\t\tif match(r, x) != 0 {","\t\t\tbreak","\t\t}","\t\tif match(r, y) != 0 {","\t\t\tbreak","\t\t}","\t\tdx(x)","\t\tx = r","\t}","\tdx(r)","\tdx(y)","\tdx(f)","\treturn x","}","func fixs(f, x K) (r K) {","\tl := Enl(rx(x))","\ty := rx(x)","\tfor {","\t\tr = Atx(rx(f), rx(x))","\t\tif match(r, x) != 0 {","\t\t\tbreak","\t\t}","\t\tif match(r, y) != 0 {","\t\t\tbreak","\t\t}","\t\tdx(x)","\t\tx = r","\t\tl = cat1(l, rx(x))","\t}","\tdx(x)","\tdx(y)","\tdx(f)","\tdx(r)","\treturn l","}","func ndo(n int32, f, x K) K {","\tfor n \u003e 0 {","\t\tx = cal(rx(f), l1(x))","\t\tn--","\t}","\tdx(f)","\treturn x","}","","func Scn(f, x K) (r K) {","\tt := tp(f)","\tif isfunc(t) == 0 {","\t\tif nn(x) != 1 {","\t\t\ttrap(Rank)","\t\t}","\t\treturn Div(Fst(x), f)","\t}","\tif arity(f) \u003e 2 {","\t\treturn rdn(f, x, mk(Lt, 0))","\t}","\tif t == df { // x\\\\y","\t\tr = x0(int32(f))","\t\tdx(f)","\t\treturn Enc(r, Fst(x))","\t}","\tvar y K","\tif xn := nn(x); xn == 1 {","\t\ty = Fst(x)","\t\tx = 0","\t} else if xn == 2 {","\t\tx, y = spl2(x)","\t} else {","\t\ttrap(Rank)","\t}","\tyt := tp(y)","\tif yt \u003c 16 {","\t\tif x == 0 {","\t\t\tdx(f)","\t\t\treturn y","\t\t} else {","\t\t\treturn cal(f, l2(x, y))","\t\t}","\t}","\tyn := nn(y)","\tif yn == 0 {","\t\tdx(f)","\t\tdx(x)","\t\treturn y","\t}","\tif yt == Dt {","\t\tr, y = spl2(y)","\t\treturn Key(r, Scn(f, l2(x, y)))","\t}","","\txt := tp(x)","\tif tp(f) == 0 {","\t\tfp := int32(f)","\t\tif fp \u003e 1 \u0026\u0026 fp \u003c 9 \u0026\u0026 (xt == 0 || yt == xt+16) { // sums,prds,mins,maxs (reduce.go)","\t\t\tif yt == Tt {","\t\t\t\treturn Flp(Ech(scn(f), l2(x, Flp(y)))) // +f\\'[x;+y]","\t\t\t}","\t\t\tr = Func[372+fp].(rdf)(x, int32(y), yt, yn)","\t\t\tif r != 0 {","\t\t\t\tdx(x)","\t\t\t\tdx(y)","\t\t\t\treturn r","\t\t\t}","\t\t}","\t}","","\tr = mk(Lt, yn)","\trp := int32(r)","\ti := int32(0)","\tif x == 0 {","\t\tx, i = ati(rx(y), 0), 1","\t\tSetI64(rp, int64(rx(x)))","\t\trp += 8","\t}","\tfor i \u003c yn {","\t\tx = cal(rx(f), l2(x, ati(rx(y), i)))","\t\tSetI64(rp, int64(rx(x)))","\t\trp += 8","\t\ti++","\t}","\tdx(y)","\tdx(x)","\tdx(f)","\treturn uf(r)","}","func Ecl(f, x K) (r K) { // f\\:x   x f\\:y   x\\:y(split)","\tt := tp(f)","\tif isfunc(t) == 0 {","\t\tif nn(x) != 1 {","\t\t\ttrap(Rank)","\t\t}","\t\treturn split(f, Fst(x))","\t}","\txn := nn(x)","\tswitch xn - 1 {","\tcase 0: // fixed-point-scan","\t\treturn fixs(f, Fst(x))","\tcase 1:","\t\tvar y K","\t\tx, y = spl2(x)","\t\tif tp(x) \u003c 16 {","\t\t\treturn cal(f, l2(x, y))","\t\t}","\t\txn := nn(x)","\t\tr = mk(Lt, xn)","\t\trp := int32(r)","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tSetI64(rp, int64(cal(rx(f), l2(ati(rx(x), i), rx(y)))))","\t\t\trp += 8","\t\t}","\t\tdx(f)","\t\tdx(x)","\t\tdx(y)","\t\treturn uf(r)","\tdefault:","\t\treturn trap(Rank)","\t}","}","","func uf(x K) (r K) {","\txn := nn(x)","\txp := int32(x)","\tvar rt T","\tfor i := int32(0); i \u003c xn; i++ {","\t\tt := tp(K(I64(xp)))","\t\tif i == 0 {","\t\t\trt = t","\t\t} else if t != rt {","\t\t\treturn x","\t\t}","\t\txp += 8","\t}","\tif rt == Dt {","\t\treturn ufd(x)","\t}","\tif rt == 0 || rt \u003e zt {","\t\treturn x","\t}","\trt += 16","\tr = mk(rt, xn)","\ts := sz(rt)","\trp := int32(r)","\txp = int32(x)","\tswitch s \u003e\u003e 2 {","\tcase 0:","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tSetI8(rp, I32(xp))","\t\t\txp += 8","\t\t\trp++","\t\t}","\tcase 1:","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tSetI32(rp, I32(xp))","\t\t\txp += 8","\t\t\trp += 4","\t\t}","\tcase 2:","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tSetI64(rp, I64(I32(xp)))","\t\t\txp += 8","\t\t\trp += 8","\t\t}","\tdefault:","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\ts := I32(xp)","\t\t\tSetI64(rp, I64(s))","\t\t\tSetI64(rp+8, I64(s+8))","\t\t\txp += 8","\t\t\trp += 16","\t\t}","\t}","\tdx(x)","\treturn r","}","func ufd(x K) (r K) {","\txp := int32(x)","\tr = Til(x0(xp))","\tif tp(r) != St {","\t\tdx(r)","\t\treturn x","\t}","\tn := nn(x)","\tfor i := int32(0); i \u003c n; i++ {","\t\tif match(r, K(I64(int32(I64(xp))))) == 0 {","\t\t\tdx(r)","\t\t\treturn x","\t\t}","\t\txp += 8","\t}","\treturn key(r, Flp(Ech(20, l1(x))), Tt)","}",""],"alloc.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func minit(a, b int32) {","\tp := int32(1 \u003c\u003c a)","\tfor i := a; i \u003c b; i++ {","\t\tSetI32(4*i, p)","\t\tSetI32(p, 0)","\t\tp *= 2","\t}","\tSetI32(128, b)","}","func alloc(n, s int32) int32 {","\tsize := n * s","\tt := bucket(size)","\tif int64(n)*int64(s) \u003e 2147483647 /*|| t \u003e 31*/ {","\t\ttrap(Grow)","\t}","\ti := 4 * t","\tm := 4 * I32(128)","\tfor I32(i) == 0 {","\t\tif i \u003e= m {","\t\t\tm = 4 * grow(i)","\t\t} else {","\t\t\ti += 4","\t\t}","\t}","\ta := I32(i)","\tSetI32(i, I32(a))","\tfor j := i - 4; j \u003e= 4*t; j -= 4 {","\t\tu := a + 1\u003c\u003c(j\u003e\u003e2)","\t\tSetI32(u, I32(j))","\t\tSetI32(j, u)","\t}","\tif a\u002631 != 0 { // memory corruption","\t\ttrap(Unref)","\t}","\treturn a","}","func grow(p int32) int32 {","\t//j := Memorysize()","\t//Printf(\"grow%12d%12d\\n\", p, j)","\tm := I32(128)                       // old total memory (log2)","\tn := 1 + (p \u003e\u003e 2)                   // required total mem (log2)","\tg := (1 \u003c\u003c (n - 16)) - Memorysize() // grow by 64k blocks","","\t//Printf(\"mng%12d%12d%12d\\n\", m, n, g)","","\tif g \u003e 0 {","\t\tif Memorygrow(g) \u003c 0 {","\t\t\ttrap(Grow)","\t\t}","\t}","","\t//p = Memorysize()","\t//Printf(\"size%12d\\n\", p)","","\tminit(m, n)","\treturn n","}","","func mcount() (r uint32) {","\tr = 0","\tfor i := int32(5); i \u003c 31; i++ {","\t\tn := fcount(4 * i)","\t\t//fmt.Println(\"m\", i, n)","\t\tr += uint32(n) * (1 \u003c\u003c uint32(i))","\t}","\treturn r","}","func fcount(x int32) (r int32) {","\tr = 0","\tfor {","\t\tif I32(x) == 0 {","\t\t\tbreak","\t\t}","\t\tr++","\t\tx = I32(x)","\t}","\treturn r","}","","func mfree(x, bs int32) {","\t//if x == 8080-16 {","\t//\tfmt.Println(\"free \", x+16)","\t//}","\tif x\u002631 != 0 {","\t\ttrap(Unref)","\t}","\tt := 4 * bs","\tSetI32(x, I32(t))","\tSetI32(t, x)","}","func bucket(size int32) (r int32) {","\tr = 32 - I32clz(uint32(15+size))","\tif r \u003c 5 {","\t\tr = 5","\t}","\treturn r","}","func mk(t T, n int32) (r K) {","\t//defer func(t T, n int32) {","\t//\tif int32(r) == 8080 {","\t//\t\tfmt.Println(\"mk\", t, n, int32(r))","\t//\t}","\t//}(t, n)","\t//Printf(\"mk%12d%12d\\n\", t, n)","\tif t \u003c 17 {","\t\ttrap(Value)","\t}","\tr = K(uint64(t) \u003c\u003c uint64(59))","\tx := alloc(n, sz(t))","\tSetI32(x+12, 1) //rc","\tSetI32(x+4, n)","\treturn r | K(x+16)","}","func tp(x K) T     { return T(uint64(x) \u003e\u003e 59) }","func nn(x K) int32 { return I32(int32(x) - 12) }","func ep(x K) int32 { return int32(x) + sz(tp(x))*nn(x) }","func sz(t T) int32 {","\tif t \u003c 16 {","\t\treturn 8","\t} else if t \u003c 19 {","\t\treturn 1","\t} else if t \u003c 21 {","\t\treturn 4","\t} else if t == Zt {","\t\treturn 16","\t}","\treturn 8","}","func rx(x K) K {","\tif tp(x) \u003c 5 {","\t\treturn x","\t}","\tp := int32(x) - 4","\tSetI32(p, 1+I32(p))","\treturn x","}","func dx(x K) {","\tt := tp(x)","\tif t \u003c 5 {","\t\treturn","\t}","\tp := int32(x) - 16","\trc := I32(p + 12)","\tSetI32(p+12, rc-1)","\tif rc == 0 {","\t\ttrap(Unref)","\t}","\tif rc == 1 {","\t\tn := nn(x)","\t\tif t\u002615 \u003e 6 {","\t\t\tif t == 14 || t == 24 || t == 25 {","\t\t\t\tn = 2 // nat | D | T","\t\t\t} else if t == 12 || t == 13 {","\t\t\t\tn = 3 // prj | lam","\t\t\t}","\t\t\tp := int32(x)","\t\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\t\tdx(K(I64(p)))","\t\t\t\tp += 8","\t\t\t}","\t\t}","\t\tmfree(p, bucket(sz(t)*n))","\t}","}","func rl(x K) { // ref list elements","\txp := int32(x)","\txn := nn(x)","\tfor i := int32(0); i \u003c xn; i++ {","\t\tx0(xp)","\t\txp += 8","\t}","}","func lfree(x K) { // free list non-recursive","\tmfree(int32(x)-16, bucket(8*nn(x)))","}",""],"call.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func Cal(x, y K) K {","\txt := tp(x)","\tyt := tp(y)","\tif tp(x) == lf \u0026\u0026 yt \u003e Lt {","\t\treturn callenv(x, y)","\t}","\ty = explode(y)","\tif isfunc(xt) != 0 {","\t\treturn cal(x, y)","\t}","\treturn atdepth(x, y)","}","func isfunc(t T) int32 { return I32B(t == 0 || (t \u003c 16 \u0026\u0026 t \u003e tt)) }","","func cal(f, x K) (r K) {","\tt := tp(f)","\tfp := int32(f)","\txn := nn(x)","\txp := int32(x)","\tvar z K","\tif t \u003c df {","\t\tswitch xn - 1 {","\t\tcase 0:","\t\t\tx = Fst(x)","\t\tcase 1:","\t\t\tx, r = spl2(x)","\t\tcase 2:","\t\t\tx, r, z = spl3(x)","\t\t}","\t}","\tif t != 0 {","\t\tt -= 9","\t}","\tswitch t {","\tcase 0: // basic","\t\tswitch xn - 1 {","\t\tcase 0:","\t\t\tr = Func[int32(f)].(f1)(x)","\t\tcase 1:","\t\t\tr = Func[fp+64].(f2)(x, r)","\t\tcase 2:","\t\t\tr = Func[fp+192].(f4)(x, r, 1, z)","\t\tcase 3:","\t\t\tz := x3(xp)","\t\t\tx, r, f = spl3(x)","\t\t\tr = Func[fp+192].(f4)(x, r, f, z)","\t\tdefault:","\t\t\tr = trap(Rank)","\t\t}","\t\tr = r","\tcase 1: // cf","\t\tswitch xn - 1 {","\t\tcase 0:","\t\t\tr = calltrain(f, x, 0)","\t\tcase 1:","\t\t\tr = calltrain(f, x, r)","\t\tdefault:","\t\t\tr = trap(Rank)","\t\t}","\t\tr = r","\tcase 2: // df","\t\t//d := K(I64(fp))","\t\td := x0(fp)","\t\ta := 85 + int32(I64(fp+8))","\t\tr = Func[a].(f2)(d, x)","\tcase 3: // pf","\t\tr = callprj(f, x)","\tcase 4: // lf","\t\tr = lambda(f, x)","\tcase 5: // xf","\t\tr = native(f, x)","\tdefault:","\t\tr = trap(Type)","\t}","\tdx(f)","\treturn r","}","func calltrain(f, x, y K) (r K) {","\tn := nn(f)","\tfp := int32(f)","\tif y == 0 {","\t\tr = cal(x0(fp), l1(x))","\t} else {","\t\tr = cal(x0(fp), l2(x, y))","\t}","\tfor i := int32(1); i \u003c n; i++ {","\t\tfp += 8","\t\tr = cal(x0(fp), l1(r))","\t}","\treturn r","}","func callprj(f, x K) K {","\tn := nn(x)","\tfn := nn(f)","\tif fn != n {","\t\tif n \u003c fn {","\t\t\trx(f)","\t\t\treturn prj(f, x)","\t\t}","\t\ttrap(Rank)","\t}","\tp, l, i := spl3(rx(f))","\tx = stv(l, i, x)","\tx = Cal(p, x)","\treturn x","}","func callenv(f, x K) (r K) { // {..}.d  {..}.t","\tr, x = spl2(x)","\tif tp(r) != St {","\t\ttrap(Type)","\t}","\tn := nn(r)","\tfp := int32(f)","\tr = slam(l3(x0(fp), Unq(ucat(r, x1(fp))), x2(fp)), n)","\tdx(f)","\treturn cal(r, explode(x))","}","func native(f K, x K) K {","\tfn := nn(f)","\txn := nn(x)","\tif xn \u003c fn {","\t\trx(f)","\t\treturn prj(f, x)","\t}","\tif xn != fn {","\t\ttrap(Rank)","\t}","\t//return Func[int32(98)].(f2)(x0(int32(f)), x) // +/api: KR","\treturn K(Native(int64(x0(int32(f))), int64(x))) // +/api: KR","}","func lambda(f K, x K) (r K) {","\tfn := nn(f)","\txn := nn(x)","\tif xn \u003c fn {","\t\trx(f)","\t\treturn prj(f, x)","\t}","\tif xn != fn {","\t\ttrap(Rank)","\t}","\tfp := int32(f)","\tc := K(I64(fp))","\tlo := K(I64(fp + 8))","\tnl := nn(lo)","\tsa := mk(It, 2*nl) //K(I64(fp + 16))","\tsp := int32(sa)","\tvp := I32(8)","\tlp := int32(lo)","\txp := int32(x)","\trl(x)","\tdx(x)","\tfor i := int32(0); i \u003c nl; i++ {","\t\tp := vp + I32(lp)","\t\tSetI64(sp, I64(p))","\t\tif i \u003c fn {","\t\t\tSetI64(p, I64(xp))","\t\t\txp += 8","\t\t} else {","\t\t\tSetI64(p, 0)","\t\t}","\t\tsp += 8","\t\tlp += 4","\t}","\tspp, spe := pp, pe","\tr = exec(rx(c))","\tvp = I32(8)","\tsp = int32(sa)","\tlp = int32(lo)","\tfor i := int32(0); i \u003c nl; i++ {","\t\tp := vp + I32(lp)","\t\tdx(K(I64(p)))","\t\tSetI64(p, I64(sp))","\t\tSetI64(sp, 0)","\t\tlp += 4","\t\tsp += 8","\t}","\tdx(sa)","\tpp, pe = spp, spe","\treturn r","}","func com(x, y K) K { return K(int32(l2(y, x))) | K(cf)\u003c\u003c59 } // compose","func prj(f, x K) (r K) { // project","\tif isfunc(tp(f)) == 0 {","\t\treturn atdepth(f, x)","\t}","\txn := nn(x)","\txp := int32(x)","\ta := mk(It, 0)","\tfor i := int32(0); i \u003c xn; i++ {","\t\tif I64(xp) == 0 {","\t\t\ta = cat1(a, Ki(i))","\t\t}","\t\txp += 8","\t}","\tar := arity(f)","\tfor i := xn; i \u003c ar; i++ {","\t\ta = cat1(a, Ki(i))","\t\tx = cat1(x, 0)","\t}","\tan := nn(a)","\tif tp(f) == pf { // collapse","\t\tvar y K","\t\tf, r, y = spl3(f)","\t\tx = stv(r, rx(y), x)","\t\ta = Drp(a, y)","\t}","\tr = l3(f, x, a)","\tSetI32(int32(r)-12, an)","\treturn K(int32(r)) | K(pf)\u003c\u003c59","}","func arity(f K) int32 {","\tt := tp(f)","\tif t \u003e df {","\t\treturn nn(f)","\t}","\treturn 2","}",""],"cat.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func Cat(x, y K) K {","\txt, yt := tp(x), tp(y)","\tif xt == Tt \u0026\u0026 yt == Dt {","\t\ty, yt = Enl(y), Tt","\t}","\tif xt\u002615 == yt\u002615 {","\t\tif xt \u003c 16 {","\t\t\tx = Enl(x)","\t\t}","\t\tif yt \u003c 16 {","\t\t\treturn cat1(x, y)","\t\t} else {","\t\t\treturn ucat(x, y)","\t\t}","\t} else if xt == Lt \u0026\u0026 yt \u003c 16 \u0026\u0026 nn(x) \u003e 0 {","\t\treturn cat1(x, y)","\t}","\treturn uf(Cat(explode(x), explode(y)))","}","func Enl(x K) (r K) {","\tt := tp(x)","\tif t \u003c 16 {","\t\tt += 16","\t\tr = mk(t, 1)","\t\trp := int32(r)","\t\txp := int32(x)","\t\ts := sz(t)","\t\tswitch s \u003e\u003e 2 {","\t\tcase 0:","\t\t\tSetI8(rp, xp)","\t\tcase 1:","\t\t\tSetI32(rp, xp)","\t\tcase 2:","\t\t\tSetI64(rp, I64(xp))","\t\tcase 3:","\t\tcase 4:","\t\t\tSetI64(rp, I64(xp))","\t\t\tSetI64(rp+8, I64(xp+8))","\t\t}","\t\tdx(x)","\t\treturn r","\t}","\tif t == Dt {","\t\tif tp(K(I64(int32(x)))) == St {","\t\t\treturn Flp(Ech(13, l1(x))) // +,'x","\t\t}","\t}","\treturn l1(x)","}","func explode(x K) (r K) {","\txt := tp(x)","\tif xt \u003c 16 {","\t\tr = l1(x)","\t} else if xt \u003c Lt {","\t\txn := nn(x)","\t\tr = mk(Lt, xn)","\t\tif xn == 0 {","\t\t\tdx(x)","\t\t\treturn r","\t\t}","\t\txp, rp := int32(x), int32(r)","\t\te := ep(x)","\t\tswitch xt - 17 {","\t\tcase 0: //Bt","\t\t\tfor xp \u003c e {","\t\t\t\tSetI64(rp, int64(Kb(I8(xp))))","\t\t\t\trp += 8","\t\t\t\txp++","\t\t\t\tcontinue","\t\t\t}","\t\tcase 1: //Ct","\t\t\tfor xp \u003c e {","\t\t\t\tSetI64(rp, int64(Kc(I8(xp))))","\t\t\t\trp += 8","\t\t\t\txp++","\t\t\t\tcontinue","\t\t\t}","\t\tcase 2: //It","\t\t\tfor xp \u003c e {","\t\t\t\tSetI64(rp, int64(Ki(I32(xp))))","\t\t\t\trp += 8","\t\t\t\txp += 4","\t\t\t\tcontinue","\t\t\t}","\t\tcase 3: //St","\t\t\tfor xp \u003c e {","\t\t\t\tSetI64(rp, int64(Ks(I32(xp))))","\t\t\t\trp += 8","\t\t\t\txp += 4","\t\t\t\tcontinue","\t\t\t}","\t\tcase 4: //Ft","\t\t\tfor xp \u003c e {","\t\t\t\tSetI64(rp, int64(Kf(F64(xp))))","\t\t\t\trp += 8","\t\t\t\txp += 8","\t\t\t\tcontinue","\t\t\t}","\t\tdefault: //Zt","\t\t\tfor xp \u003c e {","\t\t\t\tSetI64(rp, int64(Kz(F64(xp), F64(xp+8))))","\t\t\t\trp += 8","\t\t\t\txp += 16","\t\t\t\tcontinue","\t\t\t}","\t\t}","\t\tdx(x)","\t} else if xt == Lt {","\t\tr = x","\t} else if xt == Tt {","\t\tvar k K","\t\txn := nn(x)","\t\tk, x = spl2(x)","\t\tr = mk(Lt, xn)","\t\trp := int32(r)","\t\tx = Flp(x)","\t\txp := int32(x)","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tSetI64(rp, int64(Key(rx(k), x0(xp))))","\t\t\txp += 8","\t\t\trp += 8","\t\t}","\t\tdx(x)","\t\tdx(k)","\t\treturn r","\t}","\treturn r","}","func flat(x K) (r K) { // ((..);(..)) -\u003e (...)","\tr = mk(Lt, 0)","\txn := nn(x)","\txp := int32(x)","\tfor i := int32(0); i \u003c xn; i++ {","\t\tr = Cat(r, x0(xp))","\t\txp += 8","\t}","\tdx(x)","\treturn r","}","func ucat(x, y K) K { // Bt,Bt .. Lt,Lt","\txt := tp(x)","\t//if xt != tp(y) {","\t//\tpanic(\"ucat\")","\t//}","","\tif xt \u003e Lt {","\t\treturn dcat(x, y)","\t}","\tny := nn(y)","\tr, rp, s := uspc(x, xt, ny)","\tif xt == Lt {","\t\trl(y)","\t}","\tMemorycopy(rp, int32(y), s*ny)","\tdx(y)","\treturn r","}","func dcat(x, y K) (r K) { // d,d  t,t","\tvar q K","\tt := tp(x)","\tr, x = spl2(x)","\tq, y = spl2(y)","\tif t == Dt {","\t\treturn Key(Cat(r, q), Cat(x, y))","\t} else {","\t\tif match(r, q) == 0 {","\t\t\ttrap(Value)","\t\t}","\t\tdx(q)","\t\tx = Ech(13, l2(x, y))","\t\treturn key(r, x, t)","\t}","}","func ucats(x K) (r K) { // ,/ unitype-lists","\txn := nn(x)","\tif xn == 0 {","\t\treturn x","\t}","\txp := int32(x)","\tvar rt T","\tvar rn int32","\tfor i := int32(0); i \u003c xn; i++ {","\t\txi := K(I64(xp))","\t\tt := tp(xi)","\t\tif i == 0 {","\t\t\trt = t","\t\t}","\t\tif rt != t || rt \u003c 16 || t \u003e Zt {","\t\t\treturn 0","\t\t}","\t\trn += nn(xi)","\t\txp += 8","\t}","\tr = mk(rt, rn)","\ts := sz(rt)","\trp := int32(r)","\txp = int32(x)","\tfor i := int32(0); i \u003c xn; i++ {","\t\txi := K(I64(xp))","\t\trn = s * nn(xi)","\t\tMemorycopy(rp, int32(xi), rn)","\t\trp += rn","\t\txp += 8","\t}","\tdx(x)","\treturn r","}","func cat1(x, y K) K {","\txt := tp(x)","\tr, rp, s := uspc(x, xt, 1)","\typ := int32(y)","\tif s == 1 {","\t\tSetI8(rp, yp)","\t} else if s == 4 {","\t\tSetI32(rp, yp)","\t} else if s == 8 {","\t\tif xt == Ft {","\t\t\tSetI64(rp, I64(yp))","\t\t\tdx(y)","\t\t} else {","\t\t\tSetI64(rp, int64(y))","\t\t}","\t} else if s == 16 {","\t\t//F64x2store(rp, F64x2load(yp))","\t\tMemorycopy(rp, yp, 16)","\t\tdx(y)","\t}","\treturn r","}","func uspc(x K, xt T, ny int32) (K, int32, int32) {","\tvar r K","\tnx := nn(x)","\ts := sz(xt)","\tif I32(int32(x)-4) == 1 \u0026\u0026 bucket(s*nx) == bucket(s*(nx+ny)) {","\t\tr = x","\t} else {","\t\tr = mk(xt, nx+ny)","\t\tMemorycopy(int32(r), int32(x), s*nx)","\t\tif xt == Lt {","\t\t\trl(x)","\t\t}","\t\tdx(x)","\t}","\tSetI32(int32(r)-12, nx+ny)","\treturn r, int32(r) + s*nx, s","}","func ncat(x, y K) K {","\txt := tp(x)","\tif xt \u003c 16 {","\t\tx = Enl(x)","\t}","\treturn cat1(uptypes(x, y, 0))","}","func spl2(l K) (x, y K) {","\tlp := int32(l)","\tx, y = x0(lp), x1(lp)","\tdx(l)","\treturn x, y","}","func spl3(l K) (x, y, z K) {","\tlp := int32(l)","\tx, y, z = x0(lp), x1(lp), x2(lp)","\tdx(l)","\treturn x, y, z","}",""],"cmp.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func Mtc(x, y K) (r K) {","\tr = Kb(match(x, y))","\tdx(x)","\tdx(y)","\treturn r","}","func match(x, y K) int32 {","\tif x == y {","\t\treturn 1","\t}","\txt, yt := tp(x), tp(y)","\tif xt != yt {","\t\treturn 0","\t}","\tvar xn, yn int32","\tif xt \u003e 16 {","\t\txn, yn = nn(x), nn(y)","\t\tif xn != yn {","\t\t\treturn 0","\t\t}","\t\tif xn == 0 {","\t\t\treturn 1","\t\t}","\t\txp, yp := int32(x), int32(y)","\t\te := ep(y)","\t\tve := e \u0026^ 15","\t\tswitch xt - 17 {","\t\tcase 0: // Bt","\t\t\treturn mtC(xp, yp, ve, e)","\t\tcase 1: // Ct","\t\t\treturn mtC(xp, yp, ve, e)","\t\tcase 2: // It","\t\t\treturn mtC(xp, yp, ve, e) //mtI","\t\tcase 3: // St","\t\t\treturn mtC(xp, yp, ve, e) //mtI","\t\tcase 4: // Ft","\t\t\treturn mtF(xp, yp, e)","\t\tcase 5: // Zt","\t\t\treturn mtF(xp, yp, e)","\t\tcase 6: // Lt","\t\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\t\tif match(K(I64(xp)), K(I64(yp))) == 0 {","\t\t\t\t\treturn 0","\t\t\t\t}","\t\t\t\txp += 8","\t\t\t\typ += 8","\t\t\t}","\t\t\treturn 1","\t\tdefault: // Dt, Tt","\t\t\tif match(K(I64(xp)), K(I64(yp))) != 0 {","\t\t\t\treturn match(K(I64(xp+8)), K(I64(yp+8)))","\t\t\t}","\t\t\treturn 0","\t\t}","\t}","\txp, yp := int32(x), int32(y)","\tif xt \u003c ft {","\t\treturn I32B(xp == yp)","\t}","\tswitch int32(xt-ft) - 3*I32B(xt \u003e 9) {","\tcase 0: // ft","\t\treturn eqf(F64(xp), F64(yp))","\tcase 1: // zt","\t\treturn eqz(F64(xp), F64(xp+8), F64(yp), F64(yp+8))","\tcase 2: // composition","\t\tyn = 8 * nn(y)","\tcase 3: // derived","\t\tyn = 16","\tcase 4: // projection","\t\tyn = 24","\tcase 5: // lambda","\t\treturn match(K(I64(xp+16)), K(I64(yp+16))) // compare strings","\tdefault: // xf, kf","\t\treturn match(K(I64(xp)), K(I64(yp)))","\t}","\tfor yn \u003e 0 { // composition, derived, projection","\t\tyn -= 8","\t\tif match(K(I64(xp+yn)), K(I64(yp+yn))) == 0 {","\t\t\treturn 0","\t\t}","\t}","\treturn 1","}","func mtC(xp, yp, ve, e int32) int32 { // f77 replace","\tfor yp \u003c ve {","\t\tif I8x16load(xp).Eq(I8x16load(yp)).All_true() == 0 {","\t\t\treturn 0","\t\t}","\t\txp += 16","\t\typ += 16","\t}","\tfor yp \u003c e {","\t\tif I8(xp) != I8(yp) {","\t\t\treturn 0","\t\t}","\t\txp++","\t\typ++","\t}","\treturn 1","}","","/*","func mtI(xp, yp, ve, e int32) (r int32) {","\tfor yp \u003c ve {","\t\tif I8x16load(xp).Eq(I8x16load(yp)).All_true() == 0 {","\t\t\treturn 0","\t\t}","\t\txp += 16","\t\typ += 16","\t}","\tfor yp \u003c e {","\t\tif I32(xp) != I32(yp) {","\t\t\treturn 0","\t\t}","\t\txp += 4","\t\typ += 4","\t}","\treturn 1","}","*/","func mtF(xp, yp, e int32) int32 {","\tfor yp \u003c e {","\t\tif eqf(F64(xp), F64(yp)) == 0 {","\t\t\treturn 0","\t\t}","\t\txp += 8","\t\typ += 8","\t\tcontinue","\t}","\treturn 1","}","func all(x, n int32) int32 { // f77 replace","\tt := I8x16splat(1)","\te := x + n","\tve := e \u0026^ 15","\tfor x \u003c ve {","\t\tif I8x16load(x).Eq(t).All_true() != 1 {","\t\t\treturn 0","\t\t}","\t\tx += 16","\t}","\tfor x \u003c e {","\t\tif I8(x) == 0 {","\t\t\treturn 0","\t\t}","\t\tx++","\t}","\treturn 1","}","func any(x, n int32) int32 { // f77 replace","\te := x + n","\tve := e \u0026^ 15","\tfor x \u003c ve {","\t\tif I8x16load(x).Any_true() != 0 {","\t\t\treturn 1","\t\t}","\t\tx += 16","\t}","\tfor x \u003c e {","\t\tif I8(x) != 0 {","\t\t\treturn 1","\t\t}","\t\tx++","\t}","\treturn 0","}","func Any(x K) K {","\tif tp(x) != Bt {","\t\ttrap(Type)","\t}","\txn := nn(x)","\tdx(x)","\treturn Kb(any(int32(x), xn))","}","func In(x, y K) K {","\txt, yt := tp(x), tp(y)","\tif xt == yt \u0026\u0026 xt \u003e 16 {","\t\treturn Ecl(30, l2(x, y))","\t} else if xt+16 != yt {","\t\ttrap(Type)","\t}","\tdx(y)","\treturn in(x, y, xt)","}","func in(x, y K, xt T) K {","\txp, yp := int32(x), int32(y)","\te := ep(y)","\tve := e \u0026^ 15","\tswitch xt - 1 {","\tcase 0: //bt","\t\te = inC(xp, yp, ve, e)","\tcase 1: //ct","\t\te = inC(xp, yp, ve, e)","\tcase 2: //it","\t\te = inI(xp, yp, ve, e)","\tcase 3: //st","\t\te = inI(xp, yp, ve, e)","\tcase 4: //ft","\t\tdx(x)","\t\te = inF(F64(xp), yp, e)","\tdefault: //zt","\t\tdx(x)","\t\te = inZ(F64(xp), F64(xp+8), yp, e)","\t}","\treturn Kb(I32B(e != 0))","}","func inC(x, yp, ve, e int32) int32 { // f77 replace","\tv := I8x16splat(x)","\tfor yp \u003c ve {","\t\tif v.Eq(I8x16load(yp)).Any_true() != 0 {","\t\t\treturn yp","\t\t}","\t\typ += 16","\t}","\tfor yp \u003c e {","\t\tif x == I8(yp) {","\t\t\treturn yp","\t\t}","\t\typ++","\t}","\treturn 0","}","func inI(x, yp, ve, e int32) int32 {","\tv := I32x4splat(x)","\tfor yp \u003c ve {","\t\tif v.Eq(I32x4load(yp)).Any_true() != 0 {","\t\t\treturn yp","\t\t}","\t\typ += 16","\t}","\tfor yp \u003c e {","\t\tif x == I32(yp) {","\t\t\treturn yp","\t\t}","\t\typ += 4","\t}","\treturn 0","}","func inF(x float64, yp int32, e int32) int32 {","\tfor yp \u003c e {","\t\tif eqf(x, F64(yp)) != 0 {","\t\t\treturn yp","\t\t}","\t\typ += 8","\t}","\treturn 0","}","func inZ(re, im float64, yp int32, e int32) int32 {","\tfor yp \u003c e {","\t\tif eqz(re, im, F64(yp), F64(yp+8)) != 0 {","\t\t\treturn yp","\t\t}","\t\typ += 16","\t}","\treturn 0","}","","func Not(x K) (r K) { // ~x","\txt := tp(x)","\txp := int32(x)","\tif xt == bt {","\t\tr = Kb(1 - xp)","\t} else if xt == Bt {","\t\tr = use1(x)","\t\trp := int32(r)","\t\te := ep(r)","\t\tnot(xp, rp, e)","\t\tdx(x)","\t} else if xt\u002615 == st {","\t\tr = Eql(Ks(0), x)","\t} else {","\t\tr = Eql(Ki(0), x)","\t}","\treturn r","}","func not(xp, rp, e int32) { //f77 replace","\tw := I8x16splat(1)","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Not().And(w))","\t\txp += 16","\t\trp += 16","\t\tcontinue","\t}","}",""],"err.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","const ( // iota is not supported by wg","\tErr    = int32(0)","\tType   = int32(1)","\tValue  = int32(2)","\tIndex  = int32(3)","\tLength = int32(4)","\tRank   = int32(5)","\tParse  = int32(6)","\tStack  = int32(7)","\tGrow   = int32(8)","\tUnref  = int32(9)","\tIo     = int32(10)","\tNyi    = int32(11)",")","","func trap(x int32) K {","\ts := src()","\t//Printf(\"src %d %d, nn=%d srcp:%d\\n\", int32(src), int32(src\u003e\u003e32), nn(src), srcp)","\t//if srcp \u003c nn(src) {","\tif srcp == 0 {","\t\twrite(Ku(2608)) // 0\\n","\t} else {","\t\ta := maxi(srcp-30, 0)","\t\tfor i := a; i \u003c srcp; i++ {","\t\t\tif I8(int32(s)+i) == 10 {","\t\t\t\ta = 1 + i","\t\t\t}","\t\t}","\t\tb := mini(int32(s)+nn(s), srcp+30)","\t\tfor i := srcp; i \u003c b; i++ {","\t\t\tif I8(int32(s)+i) == 10 {","\t\t\t\tb = i","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tWrite(0, 0, int32(s)+a, b-a)","\t\tif srcp \u003e a {","\t\t\twrite(Cat(Kc(10), ntake(srcp-a-1, Kc(32))))","\t\t}","\t}","\twrite(Ku(2654)) // ^\\n","\tpanic(x)","\treturn 0","}","func Srcp() int32 { return srcp }",""],"exec.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","type f1 = func(K) K","type f2 = func(K, K) K","type f3 = func(K, K, K) K","type f4 = func(K, K, K, K) K","","func quoted(x K) int32 { return I32B(int32(x) \u003e= 448 \u0026\u0026 tp(x) == 0) }","func quote(x K) K      { return x + 448 }","func unquote(x K) K    { return x - 448 }","","func exec(x K) K {","\tsrcp = 0","\txn := nn(x)","\tif xn == 0 {","\t\tdx(x)","\t\treturn 0","\t}","\tvar a K // accumulator","\tp := int32(x)","\te := p + 8*xn","\tfor p \u003c e {","\t\tu := K(I64(p))","\t\t//kprint(u)","\t\t//fmt.Printf(\"exec p=%d sp=%d tp=%d int32=%d case(%d) %s\\n\", p, sp-256, tp(u), int32(u), int32(u)\u003e\u003e6, sK(u))","\t\t//fmt.Printf(\"exec p=%d tp=%d int32=%d case(%d)\\n\", p, tp(u), int32(u), int32(u)\u003e\u003e6)","\t\tif tp(u) != 0 {","\t\t\tpush(a)","\t\t\ta = rx(u)","\t\t} else {","\t\t\tswitch int32(u) \u003e\u003e 6 {","\t\t\tcase 0: //   0..63   monadic","\t\t\t\ta = Func[marksrc(u)].(f1)(a)","\t\t\tcase 1: //  64..127  dyadic","\t\t\t\ta = Func[marksrc(u)].(f2)(a, pop())","\t\t\tcase 2: // 128       dyadic indirect","\t\t\t\tmarksrc(a)","\t\t\t\ta = Cal(a, l2(pop(), pop()))","\t\t\tcase 3: // 192..255  tetradic","\t\t\t\ta = Func[marksrc(u)].(f4)(a, pop(), pop(), pop())","\t\t\tcase 4: // 256       drop","\t\t\t\tdx(a)","\t\t\t\ta = pop()","\t\t\tcase 5: // 320       jump","\t\t\t\tp += int32(a)","\t\t\t\ta = pop()","\t\t\tcase 6: // 384       jump if not","\t\t\t\tu = pop()","\t\t\t\tp += int32(a) * I32B(int32(u) == 0)","\t\t\t\tdx(u)","\t\t\t\ta = pop()","\t\t\tdefault: //448..     quoted verb","\t\t\t\tpush(a)","\t\t\t\ta = rx(u - 448)","\t\t\t}","\t\t}","\t\t//vcount: vcount(a)","\t\tp += 8","\t\tcontinue","\t}","\tdx(pop())","\tdx(x)","\treturn a","}","","func marksrc(x K) int32 {","\tif p := 0xffffff \u0026 int32(x\u003e\u003e32); p != 0 {","\t\tsrcp = p","\t}","\treturn int32(x)","}","func push(x K) {","\tSetI64(sp, int64(x))","\tsp += 8","\tif sp == 512 {","\t\ttrap(Stack)","\t}","}","func pop() K {","\tsp -= 8","\tif sp \u003c 256 {","\t\ttrap(Stack)","\t}","\treturn K(I64(sp))","}","func lst(n K) (r K) {","\trn := int32(n)","\tr = mk(Lt, rn)","\trp := int32(r)","\tfor i := int32(0); i \u003c rn; i++ {","\t\tSetI64(rp, int64(pop()))","\t\trp += 8","\t}","\treturn uf(r)","}","func nul(x K) K { push(x); return 0 }","func lup(x K) K {","\tvp := I32(8) + int32(x)","\tr := x0(vp)","\treturn r","}","func Asn(x, y K) K {","\tif tp(x) != st {","\t\ttrap(Type)","\t}","\tvp := I32(8) + int32(x)","\tdx(K(I64(vp)))","\tSetI64(vp, int64(rx(y)))","\treturn y","}","func Amd(x, i, v, y K) (r K) {","\t//fmt.Printf(\"amend[%s;%s;%s;%s]\\n\", sK(x), sK(i), sK(v), sK(y))","\txt := tp(x)","\tif xt == st {","\t\treturn Asn(x, Amd(Val(x), i, v, y))","\t}","\tif xt \u003c 16 {","\t\ttrap(Type)","\t}","\tif tp(i) == Lt {","\t\ti = Rdc(13, l1(i))","\t\ty = Rdc(13, l1(y))","\t}","","\tif xt \u003e Lt {","\t\tr, x = spl2(x)","\t\tif xt == Tt \u0026\u0026 tp(i)\u002615 == it { // table-assign-rows","\t\t\tif tp(y) \u003e Lt {","\t\t\t\ty = Val(y)","\t\t\t}","\t\t\treturn key(r, Dmd(x, l2(0, i), v, y), xt)","\t\t}","\t\tr = Unq(Cat(r, rx(i)))","\t\treturn key(r, Amd(ntake(nn(r), x), Fnd(rx(r), i), v, y), xt)","\t}","\tif i == 0 {","\t\tif v == 1 {","\t\t\tif tp(y) \u003c 16 {","\t\t\t\ty = ntake(nn(x), y)","\t\t\t}","\t\t\tdx(x)","\t\t\treturn y","\t\t}","\t\treturn Cal(v, l2(x, y))","\t}","\tif tp(v) != 0 || v != 1 {","\t\ty = cal(v, l2(Atx(rx(x), rx(i)), y))","\t}","\tti, yt := tp(i), tp(y)","\tif xt\u002615 != yt\u002615 {","\t\tx, xt = explode(x), Lt","\t}","\tif ti == it {","\t\tif xt != yt+16 {","\t\t\tx = explode(x)","\t\t}","\t\treturn sti(x, int32(i), y)","\t}","\tif yt \u003c 16 {","\t\ty = ntake(nn(i), y)","\t\tyt = tp(y)","\t}","\tif xt == Lt {","\t\ty = explode(y)","\t}","\treturn stv(x, i, y)","}","func Dmd(x, i, v, y K) (r K) {","\t// fmt.Printf(\"dmend[%s;%s;%s;%s]\\n\", sK(x), sK(i), sK(v), sK(y))","\tif tp(x) == st {","\t\treturn Asn(x, Dmd(Val(x), i, v, y))","\t}","\ti = explode(i)","\tf := Fst(rx(i))","\tif nn(i) == 1 {","\t\tdx(i)","\t\treturn Amd(x, f, v, y)","\t}","","\tif f == 0 {","\t\tf = seq(nn(x))","\t}","\ti = ndrop(1, i)","","\tif tp(f) \u003e 16 { // matrix-assign","\t\tn := nn(f)","\t\tif nn(i) != 1 {","\t\t\ttrap(Rank)","\t\t}","\t\ti = Fst(i)","\t\tif tp(f) == It \u0026\u0026 tp(x) == Tt {","\t\t\tr, x = spl2(x)","\t\t\treturn key(rx(r), Dmd(x, l2(Fnd(r, i), f), v, y), Tt)","\t\t}","\t\tif tp(f) != It || tp(x) != Lt {","\t\t\ttrap(Nyi) // Dt","\t\t}","\t\tr = use(x)","\t\tfor j := int32(0); j \u003c n; j++ {","\t\t\trj := int32(r) + 8*I32(int32(f)+4*j)","\t\t\tSetI64(rj, int64(Amd(K(I64(rj)), rx(i), rx(v), ati(rx(y), j))))","\t\t}","\t\tdx(f)","\t\tdx(i)","\t\tdx(v)","\t\tdx(y)","\t\treturn r","\t}","","\treturn Amd(x, f, 1, Dmd(Atx(rx(x), f), i, v, y))","}","","//vcount: func vcount(x K) {","//vcount: \ti := Cnt(rx(x))","//vcount: \tPrintf(\"vcount %d\\n\", int32(i))","//vcount: }",""],"find.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func Fnd(x, y K) (r K) { // x?y","\txt, yt := tp(x), tp(y)","\tif xt \u003c 16 {","\t\tif yt == Tt {","\t\t\treturn grp(x, y)","\t\t} else {","\t\t\treturn deal(x, y)","\t\t}","\t}","\tif xt \u003e Lt {","\t\tif xt == Tt {","\t\t\ttrap(Nyi) // t?..","\t\t}","\t\tr, x = spl2(x)","\t\treturn Atx(r, Fnd(x, y))","\t} else if xt == yt {","\t\tyn := nn(y)","\t\tif xt \u003c Ft \u0026\u0026 yn \u003e 2 {","\t\t\tif xt == Bt {","\t\t\t\treturn fndBs(x, y)","\t\t\t}","\t\t\tif yn \u003e 4 \u0026\u0026 xt == Ct || yn \u003e 8 {","\t\t\t\tr = fndXs(x, y, xt, yn)","\t\t\t\tif r != 0 {","\t\t\t\t\treturn r","\t\t\t\t}","\t\t\t}","\t\t}","\t\tr = mk(It, yn)","\t\trp := int32(r)","\t\tif xt == Lt {","\t\t\typ := int32(y)","\t\t\tfor i := int32(0); i \u003c yn; i++ {","\t\t\t\tSetI32(rp, fndl(x, x0(int32(yp))))","\t\t\t\trp += 4","\t\t\t\typ += 8","\t\t\t}","\t\t} else {","\t\t\tfor i := int32(0); i \u003c yn; i++ {","\t\t\t\tyi := ati(rx(y), i)","\t\t\t\tSetI32(rp, fnd(x, yi, xt-16))","\t\t\t\tdx(yi)","\t\t\t\trp += 4","\t\t\t}","\t\t}","\t} else if xt == yt+16 {","\t\tr = Ki(fnd(x, y, yt))","\t} else if xt == Lt {","\t\tr = Ki(fndl(x, rx(y)))","\t} else if yt == Lt {","\t\treturn Ecr(18, l2(x, y))","\t} else {","\t\ttrap(Type)","\t}","\tdx(x)","\tdx(y)","\treturn r","}","func fnd(x, y K, t T) (r int32) {","\txn := nn(x)","\tif xn == 0 {","\t\treturn nai","\t}","\txp, yp := int32(x), int32(y)","\txe := ep(x)","\tve := xe \u0026^ 15","\tswitch t - 1 {","\tcase 0: // bt","\t\tr = idxc(yp, xp, ve, xe)","\tcase 1: // ct","\t\tr = idxc(yp, xp, ve, xe)","\tcase 2: // it","\t\tr = idxi(yp, xp, ve, xe)","\tcase 3: // st","\t\tr = idxi(yp, xp, ve, xe)","\tcase 4: // ft","\t\tr = idxf(F64(yp), xp, xe)","\tdefault: // zt","\t\tr = idxz(F64(yp), F64(yp+8), xp, xe)","\t}","\tif r \u003c 0 {","\t\treturn nai","\t}","\treturn r","}","func fndBs(x, y K) K {","\ta := fnd(x, Kb(0), 1)","\tb := fnd(x, Kb(1), 1) - a","\tdx(x)","\treturn Add(Ki(a), Mul(Ki(b), y))","}","func fndXs(x, y K, t T, yn int32) (r K) {","\txn := nn(x)","\ta := int32(min(0, int32(x), t, xn))","\tb := 1 + (int32(max(0, int32(x), t, xn))-a)\u003e\u003e(3*I32B(t == St))","\tif b \u003e 256 \u0026\u0026 b \u003e yn {","\t\treturn 0","\t}","\tif t == St {","\t\tx, y = Div(Flr(x), Ki(8)), Div(Flr(y), Ki(8))","\t\ta \u003e\u003e= 3","\t}","\tr = ntake(b, Ki(nai))","\trp := int32(r) - 4*a","\tx0 := int32(x)","\txp := ep(x)","\tif t == Ct {","\t\tfor xp \u003e x0 {","\t\t\txp--","\t\t\tSetI32(rp+4*I8(xp), xp-x0)","\t\t}","\t} else {","\t\tfor xp \u003e x0 {","\t\t\txp -= 4","\t\t\tSetI32(rp+4*I32(xp), (xp-x0)\u003e\u003e2)","\t\t}","\t}","\tdx(x)","\treturn Atx(r, Add(Ki(-a), y))","}","func idxc(x, p, ve, e int32) (r int32) {","\tr = inC(x, p, ve, e)","\tif r == 0 {","\t\treturn -1","\t}","\te = r + 16","\tfor i := r; i \u003c e; i++ {","\t\tif I8(i) == x {","\t\t\treturn i - p","\t\t}","\t\tcontinue","\t}","\treturn 0 //not reached","}","func idxi(x, p, ve, e int32) (r int32) {","\tr = inI(x, p, ve, e)","\tif r == 0 {","\t\treturn -1","\t}","\te = r + 16","\tfor i := r; i \u003c e; i += 4 {","\t\tif I32(i) == x {","\t\t\treturn (i - p) \u003e\u003e 2","\t\t}","\t\tcontinue","\t}","\treturn 0 //not reached","}","func idxf(x float64, p, e int32) (r int32) {","\tr = inF(x, p, e)","\tif r == 0 {","\t\treturn -1","\t}","\treturn (r - p) \u003e\u003e 3","}","func idxz(re, im float64, p, e int32) (r int32) {","\tr = inZ(re, im, p, e)","\tif r == 0 {","\t\treturn -1","\t}","\treturn (r - p) \u003e\u003e 4","}","func fndl(x, y K) (r int32) {","\txn := nn(x)","\txp := int32(x)","\tdx(y)","\tfor r \u003c xn {","\t\tif match(K(I64(xp)), y) != 0 {","\t\t\treturn r","\t\t}","\t\tr++","\t\txp += 8","\t}","\treturn nai","}","func idx(x, a, b int32) int32 {","\tfor i := a; i \u003c b; i++ {","\t\tif x == I8(i) {","\t\t\treturn i - a","\t\t}","\t}","\treturn -1","}","","func Find(x, y K) (r K) { // find[pattern;string] returns all matches (It)","\txt, yt := tp(x), tp(y)","\tif xt != yt || xt != Ct {","\t\ttrap(Type)","\t}","\txn, yn := nn(x), nn(y)","\tif xn == 0 || yn == 0 {","\t\tdx(x)","\t\tdx(y)","\t\treturn mk(It, 0)","\t}","\tr = mk(It, 0)","\txp, yp := int32(x), int32(y)","\ty0 := yp","\te := yp + yn","\tfor yp \u003c e { // todo rabin-karp / knuth-morris / boyes-moore..","\t\tif findat(xp, yp, xn) != 0 {","\t\t\tr = cat1(r, Ki(yp-y0))","\t\t\typ += xn","\t\t} else {","\t\t\typ++","\t\t}","\t\tcontinue","\t}","\tdx(x)","\tdx(y)","\treturn r","}","func findat(xp, yp, n int32) int32 {","\tfor i := int32(0); i \u003c n; i++ {","\t\tif I8(xp+i) != I8(yp+i) {","\t\t\treturn 0","\t\t}","\t\tcontinue","\t}","\treturn 1","}",""],"index.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func Atx(x, y K) (r K) { // x@y","\txt, yt := tp(x), tp(y)","\txp := int32(x)","\tif xt \u003c 16 {","\t\tif xt == 0 || xt \u003e tt {","\t\t\treturn cal(x, l1(y))","\t\t}","\t\tif xt == st {","\t\t\tif xp == 0 {","\t\t\t\tif yt == it { // `123 (quoted verb)","\t\t\t\t\treturn K(int32(y))","\t\t\t\t}","\t\t\t}","\t\t\treturn cal(Val(sc(cat1(cs(x), Kc('.')))), l1(y))","\t\t}","\t}","\tif xt \u003e Lt \u0026\u0026 yt \u003c Lt {","\t\tif yt == lf {","\t\t\treturn Atx(x, Wer(callenv(y, rx(x))))","\t\t}","\t\tr, x = spl2(x)","\t\tif xt == Tt {","\t\t\tif yt\u002615 == it {","\t\t\t\treturn key(r, Ecl(19, l2(x, y)), Dt+T(I32B(yt == It)))","\t\t\t}","\t\t}","\t\treturn Atx(x, Fnd(r, y))","\t}","\tif yt\u002615 == ft {","\t\treturn Rot(x, y)","\t}","\tif yt \u003c It {","\t\ty = uptype(y, it)","\t\tyt = tp(y)","\t}","\tif yt == It || yt == Bt {","\t\treturn atv(x, y)","\t}","\tif yt == it \u0026\u0026 xt \u003e 16 {","\t\treturn ati(x, int32(y))","\t}","\tif yt == Lt {","\t\treturn Ecr(19, l2(x, y))","\t}","\tif yt == Dt {","\t\tr, y = spl2(y)","\t\treturn Key(r, Atx(x, y))","\t}","\treturn trap(Type) // f@","}","func ati(x K, i int32) (r K) { // x BT..LT","\tt := tp(x)","\tif t \u003c 16 {","\t\treturn x","\t}","\tif t \u003e Lt {","\t\treturn Atx(x, Ki(i))","\t}","\tif i \u003c 0 || i \u003e= nn(x) {","\t\tdx(x)","\t\treturn missing(t - 16)","\t}","\ts := sz(t)","\tp := int32(x) + i*s","\tswitch s \u003e\u003e 2 {","\tcase 0:","\t\ti := I8(p)","\t\tif i \u003c 0 {","\t\t\ti += 256","\t\t}","\t\tr = K(i)","\tcase 1:","\t\t//r = K(U32(p))","\t\tr = K(uint32(I32(p)))","\tcase 2:","\t\t//r = K(U64(p))","\t\tr = K(uint64(I64(p)))","\tdefault:","\t\tdx(x)","\t\treturn Kz(F64(p), F64(p+8))","\t}","\tif t == Ft {","\t\tr = Kf(F64reinterpret_i64(uint64(r)))","\t} else if t == Lt {","\t\tr = rx(r)","\t\tdx(x)","\t\treturn r","\t}","\tdx(x)","\treturn r | K(t-16)\u003c\u003c59","}","func atv(x, y K) (r K) { // x BT..LT","\tt := tp(x)","\tif t == Tt {","\t\treturn Atx(x, y)","\t}","\tyn := nn(y)","\tif t \u003c 16 {","\t\tdx(y)","\t\treturn ntake(yn, x)","\t}","\txn := nn(x)","\tr = mk(t, yn)","\ts := sz(t)","\trp := int32(r)","\txp := int32(x)","\typ := int32(y)","","\tna := missing(t - 16)","\tswitch s \u003e\u003e 2 {","\tcase 0:","\t\tfor i := int32(0); i \u003c yn; i++ {","\t\t\txi := I32(yp)","\t\t\tif uint32(xi) \u003e= uint32(xn) {","\t\t\t\tSetI8(rp, int32(na))","\t\t\t} else {","\t\t\t\tSetI8(rp, I8(xp+xi))","\t\t\t}","\t\t\trp++","\t\t\typ += 4","\t\t}","\tcase 1:","\t\tfor i := int32(0); i \u003c yn; i++ {","\t\t\txi := I32(yp)","\t\t\tif uint32(xi) \u003e= uint32(xn) {","\t\t\t\tSetI32(rp, int32(na))","\t\t\t} else {","\t\t\t\tSetI32(rp, I32(xp+4*xi))","\t\t\t}","\t\t\trp += 4","\t\t\typ += 4","\t\t}","\tcase 2:","\t\tfor i := int32(0); i \u003c yn; i++ {","\t\t\txi := I32(yp)","\t\t\tif uint32(xi) \u003e= uint32(xn) {","\t\t\t\tif t == Lt {","\t\t\t\t\tSetI64(rp, int64(na))","\t\t\t\t} else {","\t\t\t\t\tSetI64(rp, I64(int32(na)))","\t\t\t\t}","\t\t\t} else {","\t\t\t\tSetI64(rp, I64(xp+8*xi))","\t\t\t}","\t\t\trp += 8","\t\t\typ += 4","\t\t}","\tdefault:","\t\tfor i := int32(0); i \u003c yn; i++ {","\t\t\txi := I32(yp)","\t\t\tif uint32(xi) \u003e= uint32(xn) {","\t\t\t\tSetI64(rp, I64(int32(na)))","\t\t\t\tSetI64(rp+8, I64(int32(na)))","\t\t\t} else {","\t\t\t\txi *= 16","\t\t\t\tSetI64(rp, I64(xp+xi))","\t\t\t\tSetI64(rp+8, I64(8+xp+xi))","\t\t\t}","\t\t\trp += 16","\t\t\typ += 4","\t\t}","\t}","\tif t == Lt {","\t\trl(r)","\t\tr = uf(r)","\t}","\tdx(na)","\tdx(x)","\tdx(y)","\treturn r","}","func stv(x, i, y K) K {","\tx = use(x)","\txt := tp(x)","\tif It != tp(i) {","\t\ttrap(Type)","\t}","\t//if xt != tp(y) {","\t//\ttrap(Type)","\t//}","\txn := nn(x)","\tn := nn(i)","\tif n != nn(y) {","\t\ttrap(Length)","\t}","\ts := sz(xt)","\txp := int32(x)","\typ := int32(y)","\tip := int32(i)","\tfor j := int32(0); j \u003c n; j++ {","\t\txi := uint32(I32(ip + 4*j))","\t\tif xi \u003e= uint32(xn) {","\t\t\ttrap(Index)","\t\t}","\t}","\tswitch s \u003e\u003e 2 {","\tcase 0:","\t\tfor j := int32(0); j \u003c n; j++ {","\t\t\tSetI8(xp+I32(ip), I8(yp))","\t\t\tip += 4","\t\t\typ++","\t\t}","\tcase 1:","\t\tfor j := int32(0); j \u003c n; j++ {","\t\t\tSetI32(xp+4*I32(ip), I32(yp))","\t\t\tip += 4","\t\t\typ += 4","\t\t}","\tcase 2:","\t\tif xt == Lt {","\t\t\trl(y)","\t\t\tfor j := int32(0); j \u003c n; j++ {","\t\t\t\tdx(K(I64(xp + 8*I32(ip))))","\t\t\t\tip += 4","\t\t\t}","\t\t\tip = int32(i)","\t\t}","\t\tfor j := int32(0); j \u003c n; j++ {","\t\t\tSetI64(xp+8*I32(ip), I64(yp))","\t\t\tip += 4","\t\t\typ += 8","\t\t}","\t\tif xt == Lt {","\t\t\tx = uf(x)","\t\t}","\tdefault:","\t\tfor j := int32(0); j \u003c n; j++ {","\t\t\txp = int32(x) + 16*I32(ip)","\t\t\tSetI64(xp, I64(yp))","\t\t\tSetI64(xp+8, I64(yp+8))","\t\t\tip += 4","\t\t\typ += 16","\t\t}","\t}","\tdx(i)","\tdx(y)","\treturn x","}","func sti(x K, i int32, y K) K {","\tx = use(x)","\txt := tp(x)","\t//if xt \u003c Lt \u0026\u0026 yt != xt-16 {","\t//\ttrap(Type)","\t//}","\txn := nn(x)","\tif i \u003c 0 || i \u003e= xn {","\t\ttrap(Index)","\t}","\ts := sz(xt)","\txp := int32(x)","\typ := int32(y)","\tswitch s \u003e\u003e 2 {","\tcase 0:","\t\tSetI8(xp+i, yp)","\tcase 1:","\t\tSetI32(xp+4*i, yp)","\tcase 2:","\t\txp += 8 * i","\t\tif xt == Lt {","\t\t\tdx(K(I64(xp)))","\t\t\tSetI64(xp, int64(rx(y)))","\t\t\tx = uf(x)","\t\t} else {","\t\t\tSetI64(xp, I64(yp))","\t\t}","\tdefault:","\t\txp += 16 * i","\t\tSetI64(xp, I64(yp))","\t\tSetI64(xp+8, I64(yp+8))","\t}","\tdx(y)","\treturn x","}","","func atdepth(x, y K) K {","\txt := tp(x)","\tif xt \u003c 16 {","\t\ttrap(Type)","\t}","\tf := Fst(rx(y))","\tif f == 0 {","\t\tf = seq(nn(x))","\t}","\tx = Atx(x, f)","\tif nn(y) == 1 {","\t\tdx(y)","\t\treturn x","\t}","\ty = ndrop(1, y)","\tif tp(f) \u003e 16 {","\t\tif nn(y) == 1 \u0026\u0026 xt == Tt {","\t\t\treturn Atx(x, Fst(y))","\t\t}","\t\treturn Ecl(20, l2(x, y))","\t}","\treturn atdepth(x, y)","}",""],"k.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","const nai int32 = -2147483648 // 0N","var loc, xyz K","var na, inf float64","var pp, pe, sp, srcp, rand_ int32 //parse or execution position/end, stack position, src pointer","","/* debug c/f77","func dump(a, b int32) {","\tvar ii, jj int32","\tfor i := a; i \u003c b; i++ {","\t\tii = i","\t\tjj = I8(ii)","\t\tPrintf(\"mem%12d%12d\\n\", ii, jj)","\t}","}","func kprint(x K) { //rm","\tt := int32(tp(x))","\tn := int32(-1)","\tif t \u003e 16 {","\t\tn = nn(x)","\t}","\th := int32(x)","\tl := int32(uint32(x) \u003e\u003e 32)","\tPrintf(\"t/n%12d%12d%12d%12d\\n\", t, n, h, l)","}","func printlist(x K) { //rm","\tn := nn(x)","\tvar h, l int32","\tPrintf(\"list:#%d \", n)","\tfor i := int32(0); i \u003c n; i++ {","\t\txi := I64(int32(x) + 8*i)","\t\th = int32(xi)","\t\tl = int32(xi \u003e\u003e 32)","\t\tPrintf(\" (%d,%d)\\n\", h, l)","\t}","\tPrintf(\"\\n\")","}","func printints(x K) { //rm","\tn := nn(x)","\tPrintf(\"ints[%d]\", n)","\tvar xi int32","\tfor i := int32(0); i \u003c n; i++ {","\t\txi = I32(int32(x) + 4*i)","\t\tPrintf(\" %d\", xi)","\t}","\tPrintf(\"\\n\")","}","func printfloats(x K) { //rm","\tn := nn(x)","\tPrintf(\"floats[%d]\", n)","\tvar xi float64","\tfor i := int32(0); i \u003c n; i++ {","\t\txi = F64(int32(x) + 8*i)","\t\tPrintf(\" %f\", xi)","\t}","\tPrintf(\"\\n\")","}","func printchars(x K) { //rm","\tn := nn(x)","\tPrintf(\"bools/chars[%d]: \", n)","\tvar xi int32","\tfor i := int32(0); i \u003c n; i++ {","\t\txi = I8(int32(x) + i)","\t\tPrintf(\" %d\", xi)","\t}","\tPrintf(\"\\n\")","}","*/","","func init() {","\tMemory(1)","\tMemory2(1)","\tData(132, \"\\x00\\x01@\\x01\\x01\\x01\\x01\\t\\x10`\\x01\\x01\\x01\\x01\\x01\\t\\xc4\\xc4\\xc4\\xc4\\xc4\\xc4\\xc4\\xc4\\xc4\\xc4\\x01 \\x01\\x01\\x01\\x01\\x01BBBBBBBBBBBBBBBBBBBBBBBBBB\\x10\\t`\\x01\\x01\\x00\\xc2\\xc2\\xc2\\xc2\\xc2\\xc2BBBBBBBBBBBBBBBBBBBB\\x10\\x01`\\x01\") // k_test.go: TestClass","\tData(228, \":+-*%!\u0026|\u003c\u003e=~,^#_$?@.':/:\\\\:\")","\tData(520, \"vbcisfzldtmdplx00BCISFZLDT\") //546","\tExport(kinit, mk, nn, Val, Kst)","\tExportAll()","\t//            0    :    +    -    *    %    !    \u0026    |    \u003c    \u003e10  =    ~    ,    ^    #    _    $    ?    @    .20  '    ':   /    /:   \\    \\:                  30                       35                       40                       45","\tFunctions(00, nul, Idy, Flp, Neg, Fst, Sqr, Til, Wer, Rev, Asc, Dsc, Grp, Not, Enl, Srt, Cnt, Flr, Str, Unq, Typ, Val, ech, ecp, rdc, ecr, scn, ecl, lst, Kst, Out, Any, Fin, Abs, Img, Cnj, Ang, nyi, Uqs, Xpt, Cos, Fwh, Las, Exp, Log, Sin, Tok, Prs)","\tFunctions(64, Asn, Dex, Add, Sub, Mul, Div, Key, Min, Max, Les, Mor, Eql, Mtc, Cat, Cut, Tak, Drp, Cst, Fnd, Atx, Cal, Ech, Ecp, Rdc, Ecr, Scn, Ecl, com, prj, Otu, In, Find, Hyp, Cpx, nyi, Rot, Enc, Dec, Fil, nyi, Bin, Mod, Pow, Lgn, nyi, nyi, Rtp)","\tFunctions(192, tbln, tchr, tnms, tvrb, tpct, tvar, tsym)","\tFunctions(211, Amd, Dmd)","","\tFunctions(220, negi, negf, negz, negC, negI, negF, negZ)","\tFunctions(227, absi, absf, nyi, absC, absI, absF, absZ)","\tFunctions(234, addi, addf, addz, addcC, addiI, addfF, addzZ, addC, addI, addF, addZ)","\tFunctions(245, subi, subf, nyi, subcC, subiI, subfF, subzZ, subC, subI, subF, subZ)","\tFunctions(256, muli, mulf, mulz, mulcC, muliI, mulfF, mulzZ, mulC, mulI, mulF, mulZ)","\tFunctions(267, divi, divf, divz, nyi, nyi, divfF, divzZ, nyi, nyi, divF, divZ)","\tFunctions(278, mini, minf, minz, mincC, miniI, minfF, minzZ, minC, minI, minF, minZ)","\tFunctions(289, maxi, maxf, maxz, maxcC, maxiI, maxfF, maxzZ, maxC, maxI, maxF, maxZ)","\tFunctions(300, nyi, sqrf, nyi, nyi, nyi, sqrF, nyi)","","\tFunctions(308, lti, ltf, ltz, ltcC, ltiI, ltfF, ltzZ, ltCc, ltIi, ltFf, ltZz, ltC, ltI, ltF, ltZ)","\tFunctions(323, gti, gtf, gtz, gtcC, gtiI, gtfF, gtzZ, gtCc, gtIi, gtFf, gtZz, gtC, gtI, gtF, gtZ)","\tFunctions(338, eqi, eqf, eqz, eqcC, eqiI, eqfF, eqzZ, eqCc, eqIi, eqFf, eqZz, eqC, eqI, eqF, eqZ)","","\tFunctions(353, guC, guC, guI, guI, guF, guZ, guL, gdC, gdC, gdI, gdI, gdF, gdZ, gdL)","","\tFunctions(367, sum, rd0, prd, rd0, rd0, min, max)","\tFunctions(374, sums, rd0, prds, rd0, rd0, mins, maxs)","\t// don't delete: kom:FTAB 381)","}","","//   0....7  key","//   8...15  val","//  16...19","//  20..127  free list","// 128..131  memsize log2","// 132..227  char map (starts at 100)","// 228..253  verbs :+-*%!\u0026|\u003c\u003e=~,^#_$?@.':/:\\:","// 256..511  stack","// 512..519  wasi iovec","// 520..545  \"vbcisfzldtcdpl000BCISFZLDT\"","// 552..559  src (aligned)","","func kinit() {","\t//Printf(\"kinit\u003e\\n\")","\tminit(13, 16) //8k..64k","\tsp = 256","\tSetI64(552, int64(mk(Ct, 0))) //src","\tloc = 0","\tna = F64reinterpret_i64(uint64(0x7FF8000000000001))","\tinf = F64reinterpret_i64(uint64(0x7FF0000000000000))","\trand_ = 1592653589","\tSetI64(0, int64(mk(Lt, 0)))","\tSetI64(8, int64(mk(Lt, 0)))","\tsc(Ku(0))        // `   0","\tx := sc(Ku(120)) // `x  8","\ty := sc(Ku(121)) // `y 16","\tz := sc(Ku(122)) // `z 24","\txyz = cat1(Cat(x, y), z)","\tzk()","}","func reset() {","\tif sp != 256 {","\t\tpanic(Stack)","\t}","\tdx(src())","\tdx(xyz)","\tdx(K(I64(0)))","\tdx(K(I64(8)))","\t//check() // k_test.go","\tif (uint32(1)\u003c\u003cuint32(I32(128)))-(8192+mcount()) != 0 {","\t\ttrap(Err)","\t}","\tfor i := int32(5); i \u003c 31; i++ {","\t\tSetI32(4*i, 0)","\t}","\tkinit()","}","","type K uint64","type T int32","","// typeof(x K): t=x\u003e\u003e59","// isatom:      t\u003c16","// isvector:    t\u003e16","// isflat:      t\u003c22","// basetype:    t\u002615  0..9","// istagged:    t\u003c5","// haspointers: t\u003e5   (recursive unref)","// elementsize: $[t\u003c19;1;t\u003c21;4;8]","const ( //base t\u002615          bytes  atom  vector","\tbt T = 1  // bool    1      1     17","\tct T = 2  // char    1      2     18","\tit T = 3  // int     4      3     19","\tst T = 4  // symbol  4      4     20","\tft T = 5  // float   8      5     21","\tzt T = 6  // complex(8)     6     22","\tlt T = 7  // list    8            23","\tdt T = 8  // dict   (8)           24","\ttt T = 9  // table  (8)           25","\tcf T = 10 // comp   (8)    10","\tdf T = 11 // derived(8)    11","\tpf T = 12 // proj   (8)    12","\tlf T = 13 // lambda (8)    13","\txf T = 14 // native (8)    14","\tBt T = bt + 16","\tCt T = ct + 16","\tIt T = it + 16","\tSt T = st + 16","\tFt T = ft + 16","\tZt T = zt + 16","\tLt T = lt + 16","\tDt T = dt + 16","\tTt T = tt + 16",")","","// func t=0","// basic x \u003c 64 (triadic/tetradic)","// composition .. f2 f1 f0","// derived     func    symb","// projection  func    arglist  emptylist","// lambda      code    locals   string","// native      ptr(Ct) string","","// ptr: int32(x)","//  p-12    p-4 p","// [length][rc][data]","","func Kb(x int32) K { return K(uint32(x)) | K(bt)\u003c\u003c59 }","func Kc(x int32) K { return K(uint32(x)) | K(ct)\u003c\u003c59 }","func Ki(x int32) K { return K(uint32(x)) | K(it)\u003c\u003c59 }","func Ks(x int32) K { return K(uint32(x)) | K(st)\u003c\u003c59 }","func Kf(x float64) (r K) {","\tr = mk(Ft, 1)","\tSetF64(int32(r), x)","\treturn K(int32(r)) | K(ft)\u003c\u003c59","}","func Kz(x, y float64) (r K) {","\tr = mk(Zt, 1)","\trp := int32(r)","\tSetF64(rp, x)","\tSetF64(rp+8, y)","\treturn K(rp) | K(zt)\u003c\u003c59","}","func l1(x K) (r K) {","\tr = mk(Lt, 1)","\tSetI64(int32(r), int64(x))","\treturn r","}","func l2t(x, y K, t T) (r K) {","\tr = mk(Lt, 2)","\tSetI64(int32(r), int64(x))","\tSetI64(8+int32(r), int64(y))","\treturn K(uint32(r)) | K(t)\u003c\u003c59","}","func l2(x, y K) K    { return l2t(x, y, Lt) }","func l3(x, y, z K) K { return cat1(l2(x, y), z) }","func x0(x int32) K   { return rx(K(I64(x))) }","func x1(x int32) K   { return x0(x + 8) }","func x2(x int32) K   { return x0(x + 16) }","func x3(x int32) K   { return x0(x + 24) }","func Ku(x uint64) (r K) { // Ct","\tr = mk(Ct, 0)","\tp := int32(r)","\tfor x != 0 {","\t\tSetI8(p, int32(x))","\t\tx \u003e\u003e= uint64(8)","\t\tp++","\t}","\tSetI32(int32(r)-12, p-int32(r))","\treturn r","}","func kx(u int32, x K) K     { return cal(Val(Ks(u)), l1(x)) }","func kxy(u int32, x, y K) K { return cal(Val(Ks(u)), l2(x, y)) }","","/* encode bytes with: https://play.golang.org/p/4ethx6OEVCR","func enc(x []byte) (r uint64) {","\tvar o uint64 = 1","\tfor _, b := range x {","\t\tr += o * uint64(b)","\t\to \u003c\u003c= 8","\t}","\treturn r","}","*/","","func sc(c K) K {","\ts := K(I64(0))","\tsp := int32(s)","\tsn := nn(s)","\tfor i := int32(0); i \u003c sn; i++ {","\t\tif match(c, K(I64(sp))) != 0 {","\t\t\tdx(c)","\t\t\treturn K(sp-int32(s)) | K(st)\u003c\u003c59","\t\t}","\t\tsp += 8","\t}","\tSetI64(0, int64(cat1(s, c)))","\tSetI64(8, int64(cat1(K(I64(8)), 0)))","\treturn K(8*sn) | K(st)\u003c\u003c59","}","func cs(x K) K { return x0(I32(0) + int32(x)) }","func td(x K) (r K) { // table from dict","\tr, x = spl2(x)","\tif tp(r) != St || tp(x) != Lt {","\t\ttrap(Type)","\t}","\tm := maxcount(int32(x), nn(x))","\tx = Ech(15, l2(Ki(m), x)) // (|/#'x)#'x","\tr = l2(r, x)","\tSetI32(int32(r)-12, m)","\treturn K(int32(r)) | K(Tt)\u003c\u003c59","}","func missing(t T) K {","\tswitch t - 2 {","\tcase 0: // ct","\t\treturn Kc(32)","\tcase 1: // it","\t\treturn Ki(nai)","\tcase 2: // st","\t\treturn Ks(0)","\tcase 3: // ft","\t\treturn Kf(na)","\tcase 4: // zt","\t\treturn Kz(na, na)","\tcase 5: // lt","\t\treturn mk(Ct, 0) //Kb(0)","\tdefault:","\t\treturn K(t) \u003c\u003c 59","\t}","}",""],"k_test.go":["package main","","import (","\t\"bytes\"","\t\"fmt\"","\t\"io\"","\t\"io/ioutil\"","\t\"math\"","\t\"os\"","\t\"strconv\"","\t\"strings\"","\t\"testing\"","\t\"unicode/utf8\"","","\t. \"github.com/ktye/wg/module\"",")","","var save []byte","","func newtest() {","\tStdout = os.Stdout","\trand_ = 1592653589","\tif save == nil {","\t\tkinit()","\t\tsave = make([]byte, len(Bytes))","\t\tcopy(save, Bytes)","\t} else {","\t\tBytes = make([]byte, len(save))","\t\tcopy(Bytes, save)","\t\tpp, pe, sp = 0, 0, 256","\t}","}","func mkchars(b []byte) (r K) {","\tr = mk(Ct, int32(len(b)))","\tcopy(Bytes[int32(r):], b)","\treturn r","}","func intvalue(x K) int32     { return int32(x) }","func floatvalue(x K) float64 { return F64(int32(x)) }","func TestTypes(t *testing.T) {","\t//t.Skip()","\tnewtest()","\txi := Ki(-5)","\tif v := intvalue(xi); v != -5 {","\t\tt.Fatalf(\"got v=%d expected %d\\n\", v, -5)","\t}","\tif r := tp(xi); r != it {","\t\tt.Fatalf(\"got t=%d expected %d\\n\", r, it)","\t}","\tif n := intvalue(Cnt(xi)); n != 1 {","\t\tt.Fatalf(\"got n=%d expected %d\\n\", n, 1)","\t}","\txf := Kf(math.Pi)","\tif f := floatvalue(xf); f != math.Pi {","\t\tt.Fatalf(\"got f=%v expected %v\\n\", f, math.Pi)","\t}","\tif r := tp(xf); r != ft {","\t\tt.Fatalf(\"got t=%d expected %d\\n\", r, ft)","\t}","\tdx(xf)","\treset()","}","func TestBucket(t *testing.T) {","\ttc := []struct{ in, exp int32 }{","\t\t{0, 5},","\t\t{4, 5},","\t\t{8, 5},","\t\t{16, 5},","\t\t{17, 6},","\t\t{25, 6},","\t}","\tfor _, tc := range tc {","\t\tif got := bucket(tc.in); got != tc.exp {","\t\t\tt.Fatalf(\"bucket %d =\u003e %d (exp %d)\\n\", tc.in, got, tc.exp)","\t\t}","\t}","}","func TestMk(t *testing.T) {","\t//t.Skip()","\tnewtest()","\tr := mk(It, 2)","\tif rc := I32(int32(r) - 4); rc != 1 {","\t\tt.Fatalf(\"rc is %d not 1\\n\", rc)","\t}","\tif n := I32(int32(r) - 12); n != 2 {","\t\tt.Fatalf(\"n is %d not 2\\n\", n)","\t}","\tif tx := tp(r); tx != It {","\t\tt.Fatalf(\"t is %d not %d\\n\", tx, It)","\t}","\tif n := nn(r); n != 2 {","\t\tt.Fatalf(\"nn(x) is %d not 2\\n\", n)","\t}","}","func TestFloat(t *testing.T) {","\t//t.Skip()","\tnewtest()","\tdx(val(Ku(35382781554225)))","\treset()","}","func TestVerbs(t *testing.T) {","\t//t.Skip()","\tnewtest()","\tx := Til(Ki(3))","\tif r := int32(Cnt(x)); r != 3 {","\t\tt.Fatalf(\"got %d expected %d\", r, 3)","\t}","}","func TestTok(t *testing.T) {","\t//t.Skip()","\ttc := []struct {","\t\tin, exp string","\t}{","\t\t{\"1234567\", \",1234567\"},","\t\t{\"-1234567\", \",-1234567\"},","\t\t{\"*\", \",*\"},","\t}","\tfor _, tc := range tc {","\t\tnewtest()","\t\t//fmt.Println(tc.in)","\t\tgot := sK(tok(mkchars([]byte(tc.in))))","\t\tif got != tc.exp {","\t\t\tt.Fatalf(\"got %s expected %s\", got, tc.exp)","\t\t}","\t}","}","func TestMultiline(t *testing.T) {","\t//t.Skip()","\ttc := []struct {","\t\tin, exp string","\t}{","\t\t{\"1+2\\n3*4\", \"12\"},","\t}","\tfor _, tc := range tc {","\t\tnewtest()","\t\t//fmt.Println(tc.in)","\t\tgot := sK(Val(mkchars([]byte(tc.in))))","\t\tif got != tc.exp {","\t\t\tt.Fatalf(\"got %s expected %s\", got, tc.exp)","\t\t}","\t}","}","func TestShuffle(t *testing.T) {","\t//t.Skip()","\tnewtest()","\tdx(shuffle(seq(8), 5))","\treset()","}","func TestKT(t *testing.T) {","\t//t.Skip()","\tnewtest()","\tb, err := ioutil.ReadFile(\"k.t\")","\tif err != nil {","\t\tt.Fatal(err)","\t}","\tv := bytes.Split(b, []byte{10})","\tfor i := range v {","\t\tif len(v[i]) \u003e 1 {","\t\t\ttest(mkchars(append(v[i], 10)))","\t\t\treset()","\t\t}","\t}","\tdofile(mkchars([]byte(\"k.t\")), mkchars(b))","\treset()","\treset()","}","func TestKE(t *testing.T) {","\t//t.Skip()","\tb, err := ioutil.ReadFile(\"k.e\")","\tif err != nil {","\t\tt.Fatal(err)","\t}","\tv := bytes.Split(b, []byte{10})","\tfor i := range v {","\t\tnewtest()","\t\tvar buf bytes.Buffer","\t\tStdout = \u0026buf","\t\te := tryf(func() { test(mkchars(append(v[i], 10))) })","\t\texp := parseError(strings.Split(strings.Split(string(v[i]), \" /\")[1], \" \")[0])","\t\tfmt.Println(string(v[i]))","\t\tif e != exp {","\t\t\tt.Fatalf(\"expected error %d got %d\", exp, e)","\t\t}","\t}","}","func TestTraps(t *testing.T) {","\t//t.Skip()","\ttestCases := []struct {","\t\tf func()","\t\te int32","\t}{","\t\t{func() { x := mk(It, 0); dx(x); dx(x) }, Unref},","\t\t{func() { mk(2, 3) }, Value},","\t\t{func() { cal(mk(It, 0), seq(3)) }, Type},","\t\t{func() { test(seq(3)) }, Type},","\t\t{func() { test(mkchars([]byte(\"1 2 /1 /2\\n\"))) }, Length},","\t\t{func() { test(mkchars([]byte(\"1 /2\\n\"))) }, Err},","\t\t{func() { sp = 0; reset() }, Stack},","\t\t{func() { mk(It, 0); reset() }, Err},","\t\t{func() { use(Key(seq(2), seq(2))) }, Type},","\t\t{func() { nyi(Ki(0)) }, Nyi},","\t\t{func() { ndrop(5, Key(seq(2), seq(2))) }, Type},","\t\t{func() { mfree(int32(seq(1)), 5) }, Unref},","\t}","\tfor i, tc := range testCases {","\t\tnewtest()","\t\tStdout = io.Discard","\t\te := tryf(tc.f)","\t\tif e != tc.e {","\t\t\tt.Fatalf(\"tc %d: expected %d got %d\", i, tc.e, e)","\t\t}","\t}","}","func tryf(f func()) (err int32) {","\tdefer func() {","\t\tif r := recover(); r != nil {","\t\t\terr = r.(int32)","\t\t}","\t}()","\tf()","\treturn -1","}","func parseError(s string) int32 {","\terrs := []string{\"Err\", \"Type\", \"Value\", \"Index\", \"Length\", \"Rank\", \"Parse\", \"Stack\", \"Grow\", \"Unref\", \"Io\", \"Nyi\"} // err.go","\tfor i, x := range errs {","\t\tif s == x {","\t\t\treturn int32(i)","\t\t}","\t}","\tpanic(\"unknown error: \" + s)","}","func TestSymbols(t *testing.T) { // list symbols","\tnewtest()","\ts := K(I32(8)) | K(St)\u003c\u003c59","\tn := nn(s)","\tfor i := int32(0); i \u003c n; i++ {","\t\ty := 8 * i","\t\t_ = y","\t\t//fmt.Printf(\"%d %s\\n\", y, sK(Ks(y)))","\t}","\treset()","}","func TestRepl(t *testing.T) {","\ttestCases := [][2]string{","\t\t[2]string{\"1+1\", \"2\\n\"},","\t\t[2]string{\"x:!10\", \"\"},","\t\t[2]string{\"\\\\c\", \"\"},","\t\t[2]string{\"\\\\m\", \"18\\n\"},","\t}","\tfor _, tc := range testCases {","\t\tnewtest()","\t\tvar buf bytes.Buffer","\t\tStdout = \u0026buf","\t\trepl(mkchars([]byte(tc[0])))","\t\tif r := string(buf.Bytes()); r != tc[1] {","\t\t\tt.Fatalf(\"expected %q got %q\\n\", tc[1], r)","\t\t}","\t\treset()","\t}","}","func TestIndex(t *testing.T) {","\tnewtest()","\tx := Flr(seq(5))","\tdx(x)","\tif idx(2, int32(x), int32(x)+5) != 2 {","\t\tt.Fatal()","\t}","\tif idx(6, int32(x), int32(x)+5) != -1 {","\t\tt.Fatal()","\t}","\treset()","}","func TestClass(t *testing.T) {","\tc := make([]byte, 127)","\tcl := func(s string, n byte) {","\t\tfor _, b := range []byte(s) {","\t\t\tc[b] |= n","\t\t}","\t}","\tcl(`:+-*%!\u0026|\u003c\u003e=~,^#_$?@.'/\\`, 1)","\tcl(`abcdefghijklmnopqrstuvxwyzABCDEFGHIJKLMNOPQRSTUVWXYZ`, 2)","\tcl(`0123456789`, 4)","\tcl(`'/\\\\`, 8)","\tcl(`([{`, 16)","\tcl(\"\\n;)]}\", 32)","\tcl(`abcdefghijklmnopqrstuvxwyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789)]}\"`, 64)","\tcl(`0123456789abcdef`, 128)","\t//fmt.Printf(\"%q\\n\", string(c[32:]))","}","func Test360(t *testing.T) {","\t//t.Skip()","\tTx := []struct {","\t\ts     string","\t\tshape []int","\t\tr     interface{}","\t}{","\t\t{\"-7\", []int{}, []float64{-7}},","\t\t{\"'ALPHA⍴⍳'\", []int{7}, \"ALPHA⍴⍳\"},","\t\t{\"1+2\", []int{}, []float64{3}},","\t\t{\"3≤7\", []int{}, []bool{true}},","\t\t{\"7≤3\", []int{}, []bool{false}},","\t\t{\"1 2 3 4×4 3 2 1\", []int{4}, []float64{4, 6, 6, 4}},","\t\t{\"2+1 2 3 4\", []int{4}, []float64{3, 4, 5, 6}},","\t\t{\"1 2 3 4⌈2\", []int{4}, []float64{2, 2, 3, 4}},","\t\t{\"1 2 3\", []int{3}, []float64{1, 2, 3}},","\t\t{\"⍳3\", []int{3}, []int{1, 2, 3}},","\t\t{\"0)⍳3\", []int{3}, []int{0, 1, 2}},","\t\t{\"⍳0\", []int{}, []int{}},","\t\t{\"6-⍳6\", []int{6}, []float64{5, 4, 3, 2, 1, 0}},","\t\t{\"2×⍳0\", []int{}, []float64{}},","\t\t{\"2×⍳6\", []int{6}, []float64{2, 4, 6, 8, 10, 12}},","\t\t{\"X,X←2 3 5 7 11\", []int{10}, []float64{2, 3, 5, 7, 11, 2, 3, 5, 7, 11}},","\t\t{\"1,2 3\", []int{3}, []float64{1, 2, 3}},","\t\t{\"1 2,3\", []int{3}, []float64{1, 2, 3}},","\t\t{\"1 2,⍴⍳5\", []int{3}, []float64{1, 2, 5}},","\t\t{\",2 3⍴⍳6\", []int{6}, []int{1, 2, 3, 4, 5, 6}},","\t\t{\"⍴1\", []int{0}, []int{}},","\t\t{\"⍴⍴1\", []int{1}, []int{0}},","\t\t{\"⍴⍴⍴1\", []int{1}, []int{1}},","\t\t{\"⍴1 2 3\", []int{1}, []int{3}},","\t\t{\"⍴⍴1 2 3\", []int{1}, []int{1}},","\t\t{\"⍴⍴⍴1 2 3\", []int{1}, []int{1}},","\t\t{\"⍴2 3⍴⍳6\", []int{2}, []int{2, 3}},","\t\t{\"⍴⍴2 3⍴⍳6\", []int{1}, []int{2}},","\t\t{\"⍴⍴⍴2 3⍴⍳6\", []int{1}, []int{1}},","\t\t{\"⍴4 2 3⍴⍳6\", []int{3}, []int{4, 2, 3}},","\t\t{\"⍴⍴4 2 3⍴⍳6\", []int{1}, []int{3}},","\t\t{\"⍴⍴⍴4 2 3⍴⍳6\", []int{1}, []int{1}},","\t\t{\"2 3⍴1 2\", []int{2, 3}, []float64{1, 2, 1, 2, 1, 2}},","\t\t{\"⍴''\", []int{1}, []int{0}},","\t\t{\"''\", []int{0}, \"\"},","\t\t{\"'X'\", []int{1}, \"X\"},","\t\t{\"'CAN''T'\", []int{5}, \"CAN'T\"},","\t\t{\"A←'ABCDEFG'\", []int{7}, \"ABCDEFG\"},","\t\t{\"M←4 3⍴3 1 4 2 1 4 4 1 2 4 1 4\", []int{4, 3}, []float64{3, 1, 4, 2, 1, 4, 4, 1, 2, 4, 1, 4}},","\t\t{\"A[M]\", []int{4, 3}, \"CADBADDABDAD\"},","\t\t{\"(3 4⍴⍳12)[2;3]\", []int{}, []int{7}},","\t\t{\"(M←3 4⍴⍳12)[1 3;2 3 4]\", []int{2, 3}, []int{2, 3, 4, 10, 11, 12}},","\t\t{\"M[2;]\", []int{4}, []int{5, 6, 7, 8}},","\t\t{\"M[;2 1]\", []int{3, 2}, []int{2, 1, 6, 5, 10, 9}},","\t\t{\"M[M←4 3⍴3 1 4 2 1 4 4 1 2 4 1 4;]\", []int{4, 3, 3}, []float64{4, 1, 2, 3, 1, 4, 4, 1, 4, 2, 1, 4, 3, 1, 4, 4, 1, 4, 4, 1, 4, 3, 1, 4, 2, 1, 4, 4, 1, 4, 3, 1, 4, 4, 1, 4}},","\t\t{\"(3 3⍴⍳9)[;-3-4]\", []int{3}, []int{1, 4, 7}},","\t\t{\"3 3⍴1 0 0 0\", []int{3, 3}, []float64{1, 0, 0, 0, 1, 0, 0, 0, 1}},","\t\t{\"3⍴1\", []int{3}, []float64{1, 1, 1}},","\t\t{\"2 3⍴⍳6\", []int{2, 3}, []int{1, 2, 3, 4, 5, 6}},","\t\t{\"2 3 4⍴⍳6\", []int{2, 3, 4}, []int{1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6}},","\t\t{\"(1-2)\", []int{}, []float64{-1}},","\t\t{\"(⍳3)+4\", []int{3}, []float64{5, 6, 7}},","\t\t{\"X←⍳6\", []int{6}, []int{1, 2, 3, 4, 5, 6}},","\t\t{\"X[2 1]←8 9\", []int{6}, []float64{9, 8, 3, 4, 5, 6}},","\t\t{\"X[2 1 3]←7\", []int{6}, []float64{7, 7, 7, 4, 5, 6}},","\t\t{\"3 4⍳4\", []int{}, []int{2}},","\t\t{\"1 2 3 4⍳2 3⍴⍳6\", []int{2, 3}, []int{1, 2, 3, 4, 5, 5}},","\t\t{\"'ABCDEFGH'⍳'GAFFE'\", []int{5}, []int{7, 1, 6, 6, 5}},","\t\t{\"3 4 7∊⍳5\", []int{3}, []bool{true, true, false}},","\t\t{\"4∊⍳5\", []int{}, []bool{true}},","\t\t{\"2 3 5 7∊⍳4\", []int{4}, []bool{true, true, false, false}},","\t\t{\"(3 4⍴⍳12)∊2 3 5 7\", []int{3, 4}, []bool{false, true, true, false, true, false, true, false, false, false, false, false}},","\t\t{\"0↑3 4 5 6\", []int{0}, []float64{}},","\t\t{\"2↑3 4 5 6\", []int{2}, []float64{3, 4}},","\t\t{\"2 3↑3 4⍴⍳12\", []int{2, 3}, []int{1, 2, 3, 5, 6, 7}},","\t\t{\"2 ¯3↑3 4⍴⍳12\", []int{2, 3}, []int{2, 3, 4, 6, 7, 8}},","\t\t{\"2↓3 4 5 6\", []int{2}, []float64{5, 6}},","\t\t{\"1 2↓3 4⍴⍳12\", []int{2, 2}, []int{7, 8, 11, 12}},","\t\t{\"¯1 1↓3 4⍴⍳12\", []int{2, 3}, []int{2, 3, 4, 6, 7, 8}},","\t\t{\"⍋3 5 3 2\", []int{4}, []int{4, 1, 3, 2}},","\t\t{\"0)⍋3 5 3 2\", []int{4}, []int{3, 0, 2, 1}},","\t\t{\"⍒3 5 3 2\", []int{4}, []int{2, 1, 3, 4}},","\t\t{\"P←2 3 5 7\", []int{4}, []float64{2, 3, 5, 7}},","\t\t{\"E←3 4⍴⍳12\", []int{3, 4}, []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}},","\t\t{\"1 0 1 0/P\", []int{2}, []float64{2, 5}},","\t\t{\"1 0 1 0/E\", []int{3, 2}, []int{1, 3, 5, 7, 9, 11}},","\t\t{\"1 0 1/[1]E\", []int{2, 4}, []int{1, 2, 3, 4, 9, 10, 11, 12}},","\t\t{\"1 0 1⌿E\", []int{2, 4}, []int{1, 2, 3, 4, 9, 10, 11, 12}},","\t\t{\"0 1 0 1/⍳4\", []int{2}, []int{2, 4}},","\t\t{\"1 0 1\\\\⍳2\", []int{3}, []int{1, 0, 2}},","\t\t{\"1 0 1 1 1\\\\3 4⍴'ABCDEFGHIJKL'\", []int{3, 5}, \"A BCDE FGHI JKL\"},","\t\t{\"1 0 1⍀2 3⍴⍳6\", []int{3, 3}, []int{1, 2, 3, 0, 0, 0, 4, 5, 6}},","\t\t{\"⍉2 3⍴⍳6\", []int{3, 2}, []int{1, 4, 2, 5, 3, 6}},","\t\t{\"1 1⍉3 3⍴⍳9\", []int{3}, []int{1, 5, 9}},","\t\t{\"2 1 1⍉2 3 4⍴⍳24\", []int{3, 2}, []int{1, 13, 6, 18, 11, 23}},","\t\t{\"1 1 2⍉2 3 4⍴⍳24\", []int{2, 4}, []int{1, 2, 3, 4, 17, 18, 19, 20}},","\t\t{\"1 1 2⍉3 2 4⍴⍳24\", []int{2, 4}, []int{1, 2, 3, 4, 13, 14, 15, 16}},","\t\t{\"⍴2 4 1 3⍉2 3 4 5⍴1\", []int{4}, []int{4, 2, 5, 3}},","\t\t{\"⍴⍴(⍳0)⍉5\", []int{1}, []int{0}},","\t\t{\"⌽X←3 4⍴'ABCDEFGHIJKL'\", []int{3, 4}, \"DCBAHGFELKJI\"},","\t\t{\"⌽X\", []int{3, 4}, \"DCBAHGFELKJI\"},","\t\t{\"⌽[1]3 4⍴'ABCDEFGHIJKL'\", []int{3, 4}, \"IJKLEFGHABCD\"},","\t\t{\"⊖X\", []int{3, 4}, \"IJKLEFGHABCD\"},","\t\t{\"3⌽2 3 5 7\", []int{4}, []float64{7, 2, 3, 5}},","\t\t{\"¯1⌽2 3 5 7\", []int{4}, []float64{7, 2, 3, 5}},","\t\t{\"¯7⌽'ABCDEF'\", []int{6}, \"FABCDE\"},","\t\t{\"1⊖3 4⍴⍳12\", []int{3, 4}, []int{5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4}},","\t\t{\"1 0 ¯1⌽3 4⍴'ABCDEFGHIJKL'\", []int{3, 4}, \"BCDAEFGHLIJK\"},","\t\t{\"(2 2⍴0 ¯1 3 1)⌽[2]2 4 2⍴⍳16\", []int{2, 4, 2}, []int{1, 8, 3, 2, 5, 4, 7, 6, 15, 12, 9, 14, 11, 16, 13, 10}},","\t\t{\"(2 4⍴0 1 ¯1 0 0 3  2 1)⌽[1]2 2 4⍴⍳16\", []int{2, 2, 4}, []int{1, 10, 11, 4, 5, 14, 7, 16, 9, 2, 3, 12, 13, 6, 15, 8}},","\t\t{\"10⊥1 7 7 6\", []int{}, []float64{1776}},","\t\t{\"24 60 60⊥1 2 3\", []int{}, []float64{3723}},","\t\t{\"24 60 60⊤3723\", []int{3}, []int{1, 2, 3}},","\t\t{\"60 60⊤3723\", []int{2}, []int{2, 3}},","\t\t{\"1+-3\", []int{}, []float64{-2}},","\t\t{\"A←4\", []int{}, []float64{4}},","\t\t{\"A+2+A←4\", []int{}, []float64{10}},","\t\t{\"3 4[2]\", []int{}, []float64{4}},","\t\t{\"+/1 2 3\", []int{}, []float64{6}},","\t\t{\"+/⍳3\", []int{}, []int{6}},","\t\t{\"+/2 3⍴⍳6\", []int{2}, []int{6, 15}},","\t\t{\"+/[1]2 3⍴⍳6\", []int{3}, []int{5, 7, 9}},","\t\t{\"+⌿2 3⍴⍳6\", []int{3}, []int{5, 7, 9}},","\t\t{\"+/[2]2 4 3⍴⍳24\", []int{2, 3}, []int{22, 26, 30, 70, 74, 78}},","\t\t{\"2 3 4+.×5 6 7\", []int{}, []float64{56}},","\t\t{\"1 2 3∘.×1 2 3 4\", []int{3, 4}, []float64{1, 2, 3, 4, 2, 4, 6, 8, 3, 6, 9, 12}},","\t\t{\"(⍳3)∘.×⍳4\", []int{3, 4}, []int{1, 2, 3, 4, 2, 4, 6, 8, 3, 6, 9, 12}},","\t}","\tnt := func(x K, y int, xt T) {","\t\tif n := nn(x); int(n) != y {","\t\t\tt.Fatalf(\"length is %d should be %d\", n, y)","\t\t}","\t\tif tp(x) != xt {","\t\t\tt.Fatalf(\"type is %v not %v\", tp(x), xt)","\t\t}","\t}","\tchars := func(x K, y []byte) {","\t\t//fmt.Println(\"chars\", sK(x), \"|\", y)","\t\tnt(x, len(y), Ct)","\t\tfor i := 0; i \u003c len(y); i++ {","\t\t\tif xi := I8(int32(x) + int32(i)); xi != int32(int8(y[i])) {","\t\t\t\tt.Fatalf(\"x[%d] is %d not %d\", i, xi, y[i])","\t\t\t}","\t\t}","\t}","\trunes := func(x K, y string) {","\t\t//fmt.Println(\"runes\", sK(x), \"|\", y)","\t\tny := 0","\t\tfor range y {","\t\t\tny++","\t\t}","\t\tbuf := make([]byte, 4)","\t\tnt(x, ny, Lt)","\t\ti := 0","\t\tfor _, r := range y {","\t\t\tnr := utf8.EncodeRune(buf, r)","\t\t\tchars(K(I64(int32(x)+int32(8*i))), buf[:nr])","\t\t\ti++","\t\t}","\t}","\tbools := func(x K, y []bool) {","\t\t//fmt.Println(\"bools\", sK(x), \"|\", y)","\t\tnt(x, len(y), Bt)","\t\tfor i := 0; i \u003c len(y); i++ {","\t\t\tif xi := I8(int32(x) + int32(i)); xi != I32B(y[i]) {","\t\t\t\tt.Fatalf(\"x[%d] is %d not %v\", i, xi, y[i])","\t\t\t}","\t\t}","\t}","\tints := func(x K, y []int) {","\t\t//fmt.Println(\"ints\", sK(x), \"|\", y)","\t\tnt(x, len(y), It)","\t\tfor i := 0; i \u003c len(y); i++ {","\t\t\tif xi := I32(int32(x) + 4*int32(i)); xi != int32(y[i]) {","\t\t\t\tt.Fatalf(\"x[%d] is %d not %d\", i, xi, y[i])","\t\t\t}","\t\t}","\t}","\tfloats := func(x K, y []float64) {","\t\t//fmt.Println(\"floats\", sK(x), \"|\", y)","\t\tnt(x, len(y), Ft)","\t\tfor i := 0; i \u003c len(y); i++ {","\t\t\tif xi := F64(int32(x) + 8*int32(i)); xi != y[i] {","\t\t\t\tt.Fatalf(\"x[%d] is %v not %v\", i, xi, y[i])","\t\t\t}","\t\t}","\t}","\tnewtest()","\tx := mkchars([]byte(\"apl/apl.k\"))","\tdofile(x, readfile(rx(x)))","\tdef := val(mkchars([]byte(\"APL\")))","\tapl := val(mkchars([]byte(\"{RUN TOK x}\"))) //lup(sc(mkchars([]byte(\"APL\"))))","\to := sc(mkchars([]byte{'O'}))","\tfor _, tc := range Tx {","\t\tfmt.Println(tc.s)","\t\tAsn(o, Ki(1))","\t\tif strings.HasPrefix(tc.s, \"0)\") {","\t\t\ttc.s = tc.s[2:]","\t\t\tAsn(o, Ki(0))","\t\t}","\t\tif tc.shape == nil \u0026\u0026 tc.r == nil {","\t\t\tr := Atx(rx(def), mkchars([]byte(tc.s)))","\t\t\tif r != Ki(0) {","\t\t\t\tt.Fatalf(\"expected nil %s\", sK(r))","\t\t\t}","\t\t\tcontinue","\t\t}","\t\tr := Atx(rx(apl), mkchars([]byte(tc.s)))","\t\tnt(r, 3, Lt)","\t\tshape := x1(int32(r))","\t\travel := x2(int32(r))","\t\tints(shape, tc.shape)","\t\tswitch v := tc.r.(type) {","\t\tcase string:","\t\t\trunes(ravel, v)","\t\tcase []bool:","\t\t\tbools(ravel, v)","\t\tcase []int:","\t\t\tints(ravel, v)","\t\tcase []float64:","\t\t\tfloats(ravel, v)","\t\tdefault:","\t\t\tt.Fatal(\"wrong r type\")","\t\t}","\t\tdx(shape)","\t\tdx(ravel)","\t\tdx(r)","\t}","\tdx(apl)","\tdx(def)","\treset()","}","","/*","func memck() {","\ticheck := func(i int32) {","\t\tp := I32(4 * i)","\t\tfor p != 0 {","\t\t\tif p \u003c 4096 {","\t\t\t\tfmt.Println(\"memck \", i, p)","\t\t\t\tpanic(\"memck\")","\t\t\t}","\t\t\tp = I32(p)","\t\t}","\t}","\tfor i := int32(5); i \u003c 32; i++ {","\t\ticheck(i)","\t}","}","*/","","func check() { // debug in reset()","\tfor i := int32(5); i \u003c 31; i++ {","\t\t//fmt.Printf(\"[%d %d]: %d\\n\", i, 4*i, I32(4*i))","\t}","\tt := int32(0)","\tfor i := int32(5); i \u003c 31; i++ {","\t\tt += mark(i) * (int32(1) \u003c\u003c i)","\t}","\tif t != 1\u003c\u003cI32(128) {","\t\ttotal := (int32(1) \u003c\u003c I32(128)) - 8192","\t\tif total-t != 0 {","\t\t\tfmt.Printf(\"free %d of %d (+%d)\\n\", t, total, total-t)","\t\t}","\t}","\tscan()","}","func mark(i int32) (r int32) {","\tp := I32(4 * i)","\tfor p != 0 {","\t\tr++","\t\tSetI32(p+12, 0) // rc","\t\tif r := I32(p + 12); r != 0 {","\t\t\t//fmt.Printf(\"mark: p=%d rc=%d\\n\", p, r)","\t\t\t//panic(\"mark\")","\t\t}","\t\tSetI32(p+4, i) // bt","\t\tp = I32(p)","\t}","\treturn r","}","func scan() {","\ttotal := int32(1) \u003c\u003c I32(128)","\tp := int32(8192)","\tfor {","\t\tt := I32(p + 4)","\t\tif t \u003c 5 || t \u003e 31 {","\t\t\tfmt.Printf(\"illegal type at p+16=%d, bt=%d\\n\", p+16, t)","\t\t\tfmt.Printf(\"p=%d Ip=%d Ip+4=%d Ip+8=%d Ip+12=%d\\n\", p, I32(p), I32(p+4), I32(p+8), I32(p+12))","\t\t\tpanic(\"scan\")","\t\t}","\t\tif r := I32(p + 12); r != 0 {","\t\t\tfmt.Printf(\"non-free block at p=%d, bt=%d rc=%d\\n\", p, t, r)","\t\t\tpanic(\"scan\")","\t\t}","\t\tp += 1 \u003c\u003c t","\t\tif p == total {","\t\t\treturn","\t\t}","\t\tif p \u003e total {","\t\t\tpanic(\"scan/p\u003etotal\")","\t\t}","\t}","}","func rc(x K) int32 {","\txt := tp(x)","\tif xt \u003c ft {","\t\treturn -1","\t}","\treturn I32(int32(x) - 4)","}","func sK(x K) string {","\txp := int32(x)","\tswitch tp(x) {","\tcase 0:","\t\tif x == 0 {","\t\t\treturn \"\"","\t\t}","\t\ts := []byte(\"0:+-*%!\u0026|\u003c\u003e=~,^#_$?@.'/\\\\\")","\t\tvar r string","\t\titoa := func(x int32) string { return strconv.Itoa(int(x)) }","\t\tswitch {","\t\tcase xp \u003c 64:","\t\t\tif xp \u003c 23 {","\t\t\t\tr = string(s[xp])","\t\t\t} else {","\t\t\t\tr = \"`\" + itoa(xp)","\t\t\t}","\t\t\treturn r","\t\tcase xp \u003c 128:","\t\t\tif xp-64 \u003c 23 {","\t\t\t\tr = string(s[xp-64])","\t\t\t} else {","\t\t\t\tr = \"`\" + itoa(xp)","\t\t\t}","\t\t\treturn r","\t\tcase xp == 211:","\t\t\treturn \"@\"","\t\tcase xp == 212:","\t\t\treturn \".\"","\t\tcase xp \u003e= 448 \u0026\u0026 xp-448 \u003c 23:","\t\t\treturn string(s[xp-448])","\t\tdefault:","\t\t\treturn \"`\" + itoa(xp)","\t\t}","\tcase bt:","\t\tif int32(x) != 0 {","\t\t\treturn \"1b\"","\t\t} else {","\t\t\treturn \"0b\"","\t\t}","\tcase ct:","\t\treturn strconv.Quote(string([]byte{byte(xp)}))","\tcase it:","\t\treturn strconv.Itoa(int(xp))","\tcase st:","\t\tx = cs(x)","\t\tdx(x)","\t\txp = int32(x)","\t\tif nn(x) == 0 {","\t\t\treturn \"`\"","\t\t}","\t\treturn \"`\" + string(Bytes[xp:xp+nn(x)])","\tcase ft:","\t\treturn sflt(F64(xp))","\tcase zt:","\t\treturn sflz(F64(xp), F64(xp+8))","\tcase cf:","\t\txn := nn(x)","\t\txp = int32(x) + 8*xn","\t\ts := \"\"","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\txp -= 8","\t\t\ts += sK(K(I64(xp)))","\t\t}","\t\treturn s","\tcase df:","\t\ta := []string{\"'\", \"':\", \"/\", \"/:\", \"\\\\\", \"\\\\:\"}","\t\tr := sK(K(I64(xp)))","\t\tp := I64(xp + 8)","\t\treturn r + a[int(p)]","\tcase pf:","\t\tf := K(I64(xp))","\t\tl := K(I64(xp + 8))","\t\ti := K(I64(xp + 16))","\t\t// if tp(f) == 0 \u0026\u0026 nn(i) == 1 \u0026\u0026 I32(int32(i)) == 1 {","\t\tif nn(i) == 1 \u0026\u0026 I32(int32(i)) == 1 {","\t\t\treturn sK(K(I64(int32(l)))) + sK(f) // 1+","\t\t}","\t\treturn \"\u003cprj\u003e\"","\tcase lf:","\t\tx = K(I64(xp + 16))","\t\txp = int32(x)","\t\treturn string(Bytes[xp : xp+nn(x)])","\tcase Bt:","\t\tr := bytes.Repeat([]byte{'0'}, int(nn(x)))","\t\tfor i := range r {","\t\t\tif I8(xp+int32(i)) != 0 {","\t\t\t\tr[i] = '1'","\t\t\t}","\t\t}","\t\treturn comma(1 == nn(x)) + string(r) + \"b\"","\tcase Ct:","\t\treturn comma(1 == nn(x)) + strconv.Quote(string(Bytes[xp:xp+nn(x)]))","\tcase It:","\t\tif nn(x) == 0 {","\t\t\treturn \"!0\"","\t\t}","\t\tr := make([]string, nn(x))","\t\tfor i := range r {","\t\t\tr[i] = strconv.Itoa(int(I32(xp + 4*int32(i))))","\t\t}","\t\treturn comma(1 == nn(x)) + strings.Join(r, \" \")","\tcase St:","\t\tr := make([]string, nn(x))","\t\tfor i := range r {","\t\t\tr[i] = sK(K(I32(xp)) | K(st)\u003c\u003c59)","\t\t\txp += 4","\t\t}","\t\tif nn(x) == 0 {","\t\t\treturn \"0#`\"","\t\t}","\t\treturn comma(1 == nn(x)) + strings.Join(r, \"\")","\tcase Ft:","\t\tr := make([]string, nn(x))","\t\tfor i := range r {","\t\t\tr[i] = sflt(F64(xp + 8*int32(i)))","\t\t}","\t\treturn comma(1 == nn(x)) + strings.Join(r, \" \")","\tcase Zt:","\t\tr := make([]string, nn(x))","\t\tfor i := range r {","\t\t\tr[i] = sflz(F64(xp), F64(xp+8))","\t\t\txp += 16","\t\t}","\t\treturn comma(1 == nn(x)) + strings.Join(r, \" \")","\tcase Lt:","\t\tr := make([]string, nn(x))","\t\tfor i := range r {","\t\t\tr[i] = sK(K(I64(xp)))","\t\t\txp += 8","\t\t}","\t\tif len(r) == 1 {","\t\t\treturn \",\" + r[0]","\t\t} else {","\t\t\treturn \"(\" + strings.Join(r, \";\") + \")\"","\t\t}","\tcase Dt:","\t\treturn sK(K(I64(xp))) + \"!\" + sK(K(I64(xp+8)))","\tcase Tt:","\t\treturn \"+\" + sK(K(I64(xp))) + \"!\" + sK(K(I64(xp+8)))","\tdefault:","\t\tfmt.Println(\"type \", tp(x))","\t\tpanic(\"type\")","\t}","}","func sflt(x float64) string {","\ts := strconv.FormatFloat(x, 'g', -1, 64)","\tif strings.Index(s, \".\") \u003c 0 {","\t\ts += \".\"","\t}","\treturn s","}","func sflz(x, y float64) (s string) {","\tphi := 180.0 / math.Pi * math.Atan2(y, x)","\tr := math.Hypot(x, y)","\ts = strconv.FormatFloat(r, 'g', -1, 64) + \"a\"","\tif phi != 0 {","\t\ts += sflt(phi)","\t}","\treturn s","}","func comma(x bool) string {","\tif x {","\t\treturn \",\"","\t} else {","\t\treturn \"\"","\t}","}",""],"math.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","const pi float64 = 3.141592653589793","const maxfloat float64 = 1.797693134862315708145274237317043567981e+308","","func hypot(p, q float64) float64 {","\t//todo","\t//switch {","\t//case IsInf(p, 0) || IsInf(q, 0):","\t//\treturn Inf(1)","\t//case IsNaN(p) || IsNaN(q):","\t//\treturn NaN()","\t//}","\tp, q = F64abs(p), F64abs(q)","\tif p \u003c q {","\t\tt := p","\t\tp = q","\t\tq = t","\t}","\tif p == 0.0 {","\t\treturn 0.0","\t}","\tq = q / p","\treturn p * F64sqrt(1+q*q)","}","","func cosin(deg float64) (c, s float64) {","\tif deg == 0 {","\t\tc = 1.0","\t} else if deg == 90 {","\t\ts = 1.0","\t} else if deg == 180 {","\t\tc = -1.0","\t} else if deg == 270 {","\t\ts = -1.0","\t} else {","\t\tc, s = cosin_(deg * 0.017453292519943295)","\t}","\treturn c, s","}","func cosin_(x float64) (c, s float64) {","\tvar ss, cs int32","\tif x \u003c 0 {","\t\tx = -x","\t\tss = 1","\t}","\tvar j uint64","\tvar y, z float64","\tj = uint64(x * 1.2732395447351628) // *4/pi","\ty = float64(j)","\tif j\u00261 == 1 {","\t\tj++","\t\ty++","\t}","\tj \u0026= 7","\tz = ((x - y*7.85398125648498535156e-1) - y*3.77489470793079817668e-8) - y*2.69515142907905952645e-15","\tif j \u003e 3 {","\t\tj -= 4","\t\t//ss, cs = !ss, !cs","\t\tss, cs = 1-ss, 1-cs","\t}","\tif j \u003e 1 {","\t\tcs = 1 - cs","\t}","\tzz := z * z","\tc = 1.0 - 0.5*zz + zz*zz*((((((-1.13585365213876817300e-11*zz)+2.08757008419747316778e-9)*zz+-2.75573141792967388112e-7)*zz+2.48015872888517045348e-5)*zz+-1.38888888888730564116e-3)*zz+4.16666666666665929218e-2)","\ts = z + z*zz*((((((1.58962301576546568060e-10*zz)+-2.50507477628578072866e-8)*zz+2.75573136213857245213e-6)*zz+-1.98412698295895385996e-4)*zz+8.33333333332211858878e-3)*zz+-1.66666666666666307295e-1)","\tif j == 1 || j == 2 {","\t\tx = c","\t\tc = s","\t\ts = x","\t}","\tif cs != 0 {","\t\tc = -c","\t}","\tif ss != 0 {","\t\ts = -s","\t}","\treturn c, s","}","func ang2(y, x float64) (deg float64) {","\tif y == 0 {","\t\tif x \u003c 0 {","\t\t\treturn 180.0","\t\t}","\t\treturn 0.","\t}","\tif x == 0 {","\t\tif y \u003c 0 {","\t\t\treturn 270.0","\t\t}","\t\treturn 90.0","\t}","\tdeg = 57.29577951308232 * atan2(y, x)","\tif deg \u003c 0 {","\t\tdeg += 360.0","\t}","\treturn deg","}","func atan2(y, x float64) float64 {","\t// todo nan/inf","\tq := atan(y / x)","\tif x \u003c 0 {","\t\tif q \u003c= 0 {","\t\t\treturn q + pi","\t\t}","\t\treturn q - pi","\t}","\treturn q","}","func atan(x float64) float64 {","\t//if x == 0 {","\t//\treturn x","\t//}","\tif x \u003e 0 {","\t\treturn satan(x)","\t} else {","\t\treturn -satan(-x)","\t}","}","func satan(x float64) float64 {","\tif x \u003c= 0.66 {","\t\treturn xatan(x)","\t}","\tif x \u003e 2.41421356237309504880 {","\t\treturn 1.5707963267948966 - xatan(1.0/x) + 6.123233995736765886130e-17","\t}","\treturn 0.7853981633974483 + xatan((x-1)/(x+1)) + 0.5*6.123233995736765886130e-17","}","func xatan(x float64) float64 {","\tz := x * x","\tz = z * ((((-8.750608600031904122785e-01*z+-1.615753718733365076637e+01)*z+-7.500855792314704667340e+01)*z+-1.228866684490136173410e+02)*z + -6.485021904942025371773e+01) / (((((z+2.485846490142306297962e+01)*z+1.650270098316988542046e+02)*z+4.328810604912902668951e+02)*z+4.853903996359136964868e+02)*z + 1.945506571482613964425e+02)","\tz = x*z + x","\treturn z","}","func exp(x float64) float64 {","\tif x != x {","\t\treturn x","\t}","\tif x \u003e 7.09782712893383973096e+02 {","\t\treturn inf","\t}","\tif x \u003c -7.45133219101941108420e+02 {","\t\treturn 0.0","\t}","\tif -3.725290298461914e-09 \u003c x \u0026\u0026 x \u003c 3.725290298461914e-09 {","\t\treturn 1.0 + x","\t}","\tvar k int64","\tif x \u003c 0 {","\t\tk = int64(1.44269504088896338700*x - 0.5)","\t} else {","\t\tk = int64(1.44269504088896338700*x + 0.5)","\t}","\thi := x - float64(k)*6.93147180369123816490e-01","\tlo := float64(k) * 1.90821492927058770002e-10","\treturn expmulti(hi, lo, k)","}","func expmulti(hi, lo float64, k int64) float64 {","\tr := hi - lo","\tt := r * r","\tc := r - t*(1.66666666666666657415e-01+t*(-2.77777777770155933842e-03+t*(6.61375632143793436117e-05+t*(-1.65339022054652515390e-06+t*4.13813679705723846039e-08))))","\ty := 1 - ((lo - (r*c)/(2-c)) - hi)","\treturn ldexp(y, k)","}","","//func signbit(x float64) int32 { return int32(I64reinterpret_f64(x) \u003e\u003e 63) }","func ldexp(frac float64, exp int64) float64 {","\tif frac == 0 || frac \u003e maxfloat || frac \u003c -maxfloat || (frac != frac) {","\t\treturn frac","\t}","\tvar e int64","\tfrac, e = normalize(frac)","\texp += e","\tx := uint64(I64reinterpret_f64(frac))","\texp += int64(x\u003e\u003e52)\u00262047 - 1023","\tif exp \u003c int64(-1075) {","\t\treturn F64copysign(0, frac)","\t}","\tif exp \u003e int64(1023) {","\t\tif frac \u003c 0 {","\t\t\treturn -inf","\t\t}","\t\treturn inf","\t}","\tvar m float64 = 1.0","\tif exp \u003c int64(-1022) {","\t\texp += 53","\t\tm = 1.1102230246251565e-16","\t}","\tx \u0026^= 9218868437227405312","\tx |= uint64(exp+1023) \u003c\u003c 52","\treturn m * F64reinterpret_i64(uint64(x))","}","func frexp(f float64) (float64, int64) {","\tvar exp int64","\tif f == 0.0 {","\t\treturn f, 0","\t}","\tif f \u003c -maxfloat || f \u003e maxfloat || (f != f) {","\t\treturn f, 0","\t}","\tf, exp = normalize(f)","\tx := I64reinterpret_f64(f)","\texp += int64((x\u003e\u003e52)\u00262047) - 1022","\tx \u0026^= 9218868437227405312","\tx |= 4602678819172646912","\treturn F64reinterpret_i64(x), exp","}","","func normalize(x float64) (float64, int64) {","\tif F64abs(x) \u003c 2.2250738585072014e-308 {","\t\treturn x * 4.503599627370496e+15, int64(-52)","\t}","\treturn x, 0","}","func log(x float64) float64 {","\tif (x != x) || x \u003e maxfloat {","\t\treturn x","\t}","\tif x \u003c 0 {","\t\treturn na","\t}","\tif x == 0 {","\t\treturn -inf","\t}","\tf1, ki := frexp(x)","\tif f1 \u003c 0.7071067811865476 {","\t\tf1 *= 2","\t\tki--","\t}","\tf := f1 - 1","\tk := float64(ki)","\ts := f / (2 + f)","\ts2 := s * s","\ts4 := s2 * s2","\tt1 := s2 * (6.666666666666735130e-01 + s4*(2.857142874366239149e-01+s4*(1.818357216161805012e-01+s4*1.479819860511658591e-01)))","\tt2 := s4 * (3.999999999940941908e-01 + s4*(2.222219843214978396e-01+s4*1.531383769920937332e-01))","\tR := t1 + t2","\thfsq := 0.5 * f * f","\treturn k*6.93147180369123816490e-01 - ((hfsq - (s*(hfsq+R) + k*1.90821492927058770002e-10)) - f)","}","func modabsf(f float64) (i float64, frac float64) {","\tif f \u003c 1.0 {","\t\t// simplified for f \u003e 0","\t\treturn 0, f","\t}","\tx := I64reinterpret_f64(f)","\te := (x\u003e\u003e52)\u00262047 - 1023","\tif e \u003c 52 {","\t\tx \u0026^= 1\u003c\u003c(52-e) - 1","\t}","\ti = F64reinterpret_i64(x)","\tfrac = f - i","\treturn i, frac","}","func pow(x, y float64) float64 {","\tif y == 0.0 || x == 1.0 {","\t\treturn 1.0","\t}","\tif y == 1.0 {","\t\treturn x","\t}","\tif (x != x) || (y != y) || y \u003e maxfloat || y \u003c -maxfloat { // simplified","\t\treturn na","\t}","\tif x == 0 { // simplified","\t\tif y \u003c 0 {","\t\t\treturn inf","\t\t} else {","\t\t\treturn 0.0","\t\t}","\t}","\tif y == 0.5 {","\t\treturn F64sqrt(x)","\t}","\tif y == -0.5 {","\t\treturn 1.0 / F64sqrt(x)","\t}","","\tyi, yf := modabsf(F64abs(y))","\tif yf != 0.0 \u0026\u0026 x \u003c 0.0 {","\t\treturn na","\t}","\tif yi \u003e= 9.223372036854776e+18 {","\t\tif x == -1.0 {","\t\t\treturn 1.0","\t\t} else if (F64abs(x) \u003c 1.0) == (y \u003e 0.0) {","\t\t\treturn 0.0","\t\t} else {","\t\t\treturn inf","\t\t}","\t}","\ta1 := 1.0","\tae := int64(0)","\tif yf != 0 {","\t\tif yf \u003e 0.5 {","\t\t\tyf -= 1.0","\t\t\tyi += 1.0","\t\t}","\t\ta1 = exp(yf * log(x))","\t}","\tx1, xe := frexp(x)","\tfor i := int64(yi); i != 0; i \u003e\u003e= int64(1) {","\t\tif xe \u003c int64(-4096) || 4096 \u003c xe {","\t\t\tae += xe","\t\t\tbreak","\t\t}","\t\tif i\u00261 == 1 {","\t\t\ta1 *= x1","\t\t\tae += xe","\t\t}","\t\tx1 *= x1","\t\txe \u003c\u003c= int64(1)","\t\tif x1 \u003c 0.5 {","\t\t\tx1 += x1","\t\t\txe--","\t\t}","\t}","\tif y \u003c 0.0 {","\t\ta1 = 1.0 / a1","\t\tae = -ae","\t}","\treturn ldexp(a1, ae)","}","func ipow(x K, y int32) (r K) {","\tif tp(x) == It {","\t\tn := nn(x)","\t\tr = mk(It, n)","\t\trp := int32(r)","\t\txp := int32(x)","\t\te := rp + 4*n","\t\tfor rp \u003c e {","\t\t\tSetI32(rp, iipow(I32(xp), y))","\t\t\txp += 4","\t\t\trp += 4","\t\t}","\t\tdx(x)","\t\treturn r","\t} else {","\t\treturn Ki(iipow(int32(x), y))","\t}","}","func iipow(x, y int32) (r int32) {","\tr = 1","\tfor {","\t\tif y\u00261 == 1 {","\t\t\tr *= x","\t\t}","\t\ty \u003e\u003e= 1","\t\tif y == 0 {","\t\t\tbreak","\t\t}","\t\tx *= x","\t}","\treturn r","}",""],"numeric.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","type f1_ = func(int32, int32, int32)","type f1i = func(int32) int32","type f1f = func(float64) float64","type f1z = func(float64, float64) (float64, float64)","type f2b = func(uint64, uint64) uint64","type f2i = func(int32, int32) int32","","type c2cC = func(I8x16, I8x16, int32, int32, int32)","type f2cC = func(I8x16, int32, int32, int32)","type f2iI = func(I32x4, int32, int32, int32)","type f2vF = func(F64x2, int32, int32, int32)","type f2fF = func(float64, int32, int32, int32)","type f2zZ = func(float64, float64, int32, int32, int32)","","type c2Cc = func(int32, I8x16, I8x16, int32, int32)","type f2Cc = func(int32, I8x16, int32, int32)","type f2ii = func(int32, int32, int32, int32)","type f2Ff = func(int32, float64, int32, int32)","type f2Zz = func(int32, float64, float64, int32, int32)","","type f2v = func(int32, int32, int32, int32)","type f2vc = func(I8x16, int32, int32, int32, int32)","type f2f = func(float64, float64) float64","type f2z = func(float64, float64, float64, float64) (float64, float64)","type f2c = func(float64, float64) int32","type f2d = func(float64, float64, float64, float64) int32","","func use2(x, y K) K {","\tif I32(int32(y)-4) == 1 {","\t\treturn rx(y)","\t}","\treturn use1(x)","}","func use1(x K) K {","\tif I32(int32(x)-4) == 1 {","\t\treturn rx(x)","\t}","\treturn mk(tp(x), nn(x))","}","func use(x K) (r K) {","\txt := tp(x)","\tif xt \u003c 16 || xt \u003e Lt {","\t\ttrap(Type)","\t}","\tif I32(int32(x)-4) == 1 {","\t\treturn x","\t}","\tnx := nn(x)","\tr = mk(xt, nx)","\tMemorycopy(int32(r), int32(x), sz(xt)*nx)","\tif xt == Lt {","\t\trl(r)","\t}","\tdx(x)","\treturn r","}","","func nm(f int32, x K) (r K) {","\txt := tp(x)","\tif xt \u003e Lt {","\t\tr, x = spl2(x)","\t\treturn key(r, nm(f, x), xt)","\t}","\txp := int32(x)","\tif xt == Lt {","\t\tn := nn(x)","\t\tr = mk(Lt, n)","\t\trp := int32(r)","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\tSetI64(rp, int64(nm(f, x0(xp))))","\t\t\txp += 8","\t\t\trp += 8","\t\t}","\t\tdx(x)","\t\treturn uf(r)","\t}","\tif xt \u003c 16 {","\t\tswitch xt - 1 {","\t\tcase 0:","\t\t\treturn Ki(Func[f].(f1i)(xp))","\t\tcase 1:","\t\t\treturn Kc(Func[f].(f1i)(xp))","\t\tcase 2:","\t\t\treturn Ki(Func[f].(f1i)(xp))","\t\tcase 3:","\t\t\treturn trap(Type)","\t\tcase 4:","\t\t\tr = Kf(Func[1+f].(f1f)(F64(xp)))","\t\t\tdx(x)","\t\t\treturn r","\t\tcase 5:","\t\t\tr = Kz(Func[2+f].(f1z)(F64(xp), F64(xp+8)))","\t\t\tdx(x)","\t\t\treturn r","\t\tdefault:","\t\t\treturn trap(Type)","\t\t}","\t}","\tif xt == Bt {","\t\tx, xt = uptype(x, it), It","\t\txp = int32(x)","\t}","\tr = use1(x)","\trp := int32(r)","\te := ep(r)","\tif e == rp {","\t\tdx(x)","\t\treturn r","\t}","\tswitch xt - 18 {","\tcase 0:","\t\tFunc[3+f].(f1_)(xp, rp, e)","\tcase 1:","\t\tFunc[4+f].(f1_)(xp, rp, e)","\tcase 2:","\t\ttrap(Type)","\tcase 3:","\t\tFunc[5+f].(f1_)(xp, rp, e)","\tdefault:","\t\tFunc[6+f].(f1_)(xp, rp, e)","\t}","\tdx(x)","\treturn r","}","","func Neg(x K) K                            { return nm(220, x) }","func negi(x int32) int32                   { return -x }","func negf(x float64) float64               { return -x }","func negz(x, y float64) (float64, float64) { return -x, -y }","func negC(xp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Neg())","\t\txp += 16","\t\trp += 16","\t\tcontinue","\t}","}","func negI(xp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, I32x4load(xp).Neg())","\t\txp += 16","\t\trp += 16","\t\tcontinue","\t}","}","func negF(xp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, F64x2load(xp).Neg())","\t\txp += 16","\t\trp += 16","\t\tcontinue","\t}","}","func negZ(xp, rp, e int32) { negF(xp, rp, e) }","","func Abs(x K) K {","\txt := tp(x)","\tif xt \u003e Zt {","\t\treturn Ech(32, l1(x))","\t}","\tif xt == zt {","\t\txp := int32(x)","\t\tdx(x)","\t\treturn Kf(hypot(F64(xp), F64(xp+8)))","\t} else if xt == Zt {","\t\treturn absZ(x)","\t}","\treturn nm(227, x)","}","func absi(x int32) int32 {","\tif x \u003c 0 {","\t\treturn -x","\t}","\treturn x","}","func absf(x float64) float64 { return F64abs(x) }","func absC(xp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Abs())","\t\txp += 16","\t\trp += 16","\t\tcontinue","\t}","}","func absI(xp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, I32x4load(xp).Abs())","\t\txp += 16","\t\trp += 16","\t\tcontinue","\t}","}","func absF(xp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, F64x2load(xp).Abs())","\t\txp += 16","\t\trp += 16","\t\tcontinue","\t}","}","func absZ(x K) (r K) {","\tn := nn(x)","\tr = mk(Ft, n)","\trp := int32(r)","\txp := int32(x)","\tfor i := int32(0); i \u003c n; i++ {","\t\tSetF64(rp, hypot(F64(xp), F64(xp+8)))","\t\txp += 16","\t\trp += 8","\t\tcontinue","\t}","\tdx(x)","\treturn r","}","func Hyp(x, y K) K { // e.g.  norm:0. abs/x","\txt := tp(x)","\tyt := tp(y)","\tif xt \u003e Zt || yt \u003e Zt {","\t\treturn Ech(32, l2(x, y))","\t}","\tif xt == zt {","\t\tx, xt = Abs(x), ft","\t}","\tif xt == ft {","\t\txp := int32(x)","\t\typ := int32(y)","\t\tdx(x)","\t\tdx(y)","\t\tif yt == ft {","\t\t\treturn Kf(hypot(F64(xp), F64(yp)))","\t\t} else if yt == zt {","\t\t\treturn Kf(hypot(F64(xp), hypot(F64(yp), F64(yp+8))))","\t\t}","\t}","\treturn trap(Nyi)","}","","func Sqr(x K) K {","\tif tp(x)\u002615 != ft {","\t\tx = Add(Kf(0), x)","\t}","\treturn nm(300, x)","}","func sqrf(x float64) float64 { return F64sqrt(x) }","func sqrF(xp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, F64x2load(xp).Sqrt())","\t\txp += 16","\t\trp += 16","\t\tcontinue","\t}","}","","func Img(x K) (r K) { // imag x","\txt := tp(x)","\tif xt \u003e Zt {","\t\treturn Ech(33, l1(x))","\t}","\tif xt == Zt {","\t\txp := 8 + int32(x)","\t\tn := nn(x)","\t\tr = mk(Ft, n)","\t\trp := int32(r)","\t\te := rp + 8*n","\t\tfor rp \u003c e {","\t\t\tSetI64(rp, I64(xp))","\t\t\txp += 16","\t\t\trp += 8","\t\t}","\t\tdx(x)","\t\treturn r","\t}","\tdx(x)","\tif xt == zt {","\t\treturn Kf(F64(int32(x) + 8))","\t}","\tif xt \u003c zt {","\t\treturn Kf(0.0)","\t} else {","\t\treturn ntake(nn(x), Kf(0.0))","\t}","}","func Cpx(x, y K) K { return Add(x, Mul(Kz(0.0, 1.0), y)) } // x imag y","func Cnj(x K) K { // conj x","\txt := tp(x)","\tif xt \u003e Zt {","\t\treturn Ech(34, l1(x))","\t}","\tif xt\u002615 \u003c zt {","\t\treturn x","\t}","\txt = tp(x)","\txp := int32(x)","\tif xt == zt {","\t\tdx(x)","\t\treturn Kz(F64(xp), -F64(xp+8))","\t}","\tx = use(x)","\txp = 8 + int32(x)","\te := xp + 16*nn(x)","\tfor xp \u003c e {","\t\tSetF64(xp, -F64(xp))","\t\txp += 16","\t}","\treturn x","}","","func nd(f, ff int32, x, y K) (r K) {","\tvar av int32","\tvar t T","\tr, t, x, y = dctypes(x, y)","\tif r != 0 {","\t\treturn key(r, Func[64+ff].(f2)(x, y), t)","\t}","\tif t == Lt {","\t\treturn Ech(K(ff), l2(x, y))","\t}","\tx, y = uptypes(x, y, 1)","\txp, yp := int32(x), int32(y)","\tav, t = conform(x, y)","\tif av == 0 { // atom-atom","\t\tswitch t - 2 {","\t\tcase 0: // ct","\t\t\treturn Kc(Func[f].(f2i)(xp, yp))","\t\tcase 1: // it","\t\t\treturn Ki(Func[f].(f2i)(xp, yp))","\t\tcase 2: // st","\t\t\treturn trap(Type)","\t\tcase 3:","\t\t\tdx(x)","\t\t\tdx(y)","\t\t\treturn Kf(Func[1+f].(f2f)(F64(xp), F64(yp)))","\t\tdefault:","\t\t\tdx(x)","\t\t\tdx(y)","\t\t\treturn Kz(Func[2+f].(f2z)(F64(xp), F64(xp+8), F64(yp), F64(yp+8)))","\t\t}","\t}","\tif av == 1 { // atom-vector","\t\tr = use1(y)","\t\tif nn(r) == 0 {","\t\t\tdx(x)","\t\t\tdx(y)","\t\t\treturn r","\t\t}","\t\te := ep(r)","\t\typ, rp := int32(y), int32(r)","\t\tswitch t - 2 {","\t\tcase 0: // ct","\t\t\tv := I8x16splat(xp)","\t\t\tFunc[3+f].(f2cC)(v, yp, rp, e)","\t\tcase 1: // it","\t\t\tv := I32x4splat(xp)","\t\t\tFunc[4+f].(f2iI)(v, yp, rp, e)","\t\tcase 2: // st","\t\t\ttrap(Type)","\t\tcase 3: // ft","\t\t\tv := F64x2splat(F64(xp))","\t\t\tFunc[5+f].(f2vF)(v, yp, rp, e)","\t\tdefault: // zt","\t\t\tFunc[6+f].(f2zZ)(F64(xp), F64(xp+8), yp, rp, e)","\t\t}","\t\tdx(x)","\t\tdx(y)","\t\treturn r","\t} else { // vector-vector","\t\tr = use2(x, y)","\t\tif nn(r) == 0 {","\t\t\tdx(x)","\t\t\tdx(y)","\t\t\treturn r","\t\t}","\t\trp, xp, yp := int32(r), int32(x), int32(y)","\t\te := ep(r)","\t\tswitch t - 2 {","\t\tcase 0: // ct","\t\t\tFunc[7+f].(f2v)(xp, yp, rp, e)","\t\tcase 1: // it","\t\t\tFunc[8+f].(f2v)(xp, yp, rp, e)","\t\tcase 2: // st","\t\t\ttrap(Type)","\t\tcase 3: // ft","\t\t\tFunc[9+f].(f2v)(xp, yp, rp, e)","\t\tdefault: // zt","\t\t\tFunc[10+f].(f2v)(xp, yp, rp, e)","\t\t}","\t\tdx(x)","\t\tdx(y)","\t\treturn r","\t}","}","func nc(f, ff int32, x, y K) (r K) {","\tvar av int32","\tvar t T","\tr, t, x, y = dctypes(x, y)","\tif r != 0 {","\t\treturn key(r, nc(f, ff, x, y), t)","\t}","\tif t == Lt {","\t\treturn Ech(K(ff), l2(x, y))","\t}","\tx, y = uptypes(x, y, 0)","\txp, yp := int32(x), int32(y)","\tav, t = conform(x, y)","\tif av == 0 { // atom-atom","\t\tswitch t - 1 {","\t\tcase 0: // bt","\t\t\treturn Kb(Func[f].(f2i)(xp, yp))","\t\tcase 1: // ct","\t\t\treturn Kb(Func[f].(f2i)(xp, yp))","\t\tcase 2: // it","\t\t\treturn Kb(Func[f].(f2i)(xp, yp))","\t\tcase 3: // st","\t\t\treturn Kb(Func[f].(f2i)(xp, yp))","\t\tcase 4:","\t\t\tdx(x)","\t\t\tdx(y)","\t\t\treturn Kb(Func[1+f].(f2c)(F64(xp), F64(yp)))","\t\tdefault:","\t\t\tdx(x)","\t\t\tdx(y)","\t\t\treturn Kb(Func[2+f].(f2d)(F64(xp), F64(xp+8), F64(yp), F64(yp+8)))","\t\t}","\t} else if av == 1 { // atom-vector","\t\tyn := nn(y)","\t\tr = mk(Bt, yn)","\t\tif yn == 0 {","\t\t\tdx(x)","\t\t\tdx(y)","\t\t\treturn r","\t\t}","\t\trp := int32(r)","\t\te := ep(r)","\t\tswitch t - 1 {","\t\tcase 0: // bt","\t\t\tFunc[3+f].(c2cC)(I8x16splat(xp), I8x16splat(1), yp, rp, e)","\t\tcase 1: // ct","\t\t\tFunc[3+f].(c2cC)(I8x16splat(xp), I8x16splat(1), yp, rp, e)","\t\tcase 2: // it","\t\t\tFunc[4+f].(f2ii)(xp, yp, rp, e)","\t\tcase 3: // st","\t\t\tFunc[4+f].(f2ii)(xp, yp, rp, e)","\t\tcase 4: // ft","\t\t\tdx(x)","\t\t\tFunc[5+f].(f2fF)(F64(xp), yp, rp, e)","\t\tdefault: // zt","\t\t\tdx(x)","\t\t\tFunc[6+f].(f2zZ)(F64(xp), F64(xp+8), yp, rp, e)","\t\t}","\t\tdx(y)","\t\treturn r","\t}","\tif av == 3 {","\t\txn := nn(x)","\t\tr = mk(Bt, xn)","\t\tif xn == 0 {","\t\t\tdx(x)","\t\t\tdx(y)","\t\t\treturn r","\t\t}","\t\trp := int32(r)","\t\te := ep(r)","\t\tswitch t - 1 {","\t\tcase 0: // bt","\t\t\tFunc[7+f].(c2Cc)(xp, I8x16splat(yp), I8x16splat(1), rp, e)","\t\tcase 1: // ct","\t\t\tFunc[7+f].(c2Cc)(xp, I8x16splat(yp), I8x16splat(1), rp, e)","\t\tcase 2: // it","\t\t\tFunc[8+f].(f2ii)(xp, yp, rp, e)","\t\tcase 3: // st","\t\t\tFunc[8+f].(f2ii)(xp, yp, rp, e)","\t\tcase 4: // ft","\t\t\tdx(y)","\t\t\tFunc[9+f].(f2Ff)(xp, F64(yp), rp, e)","\t\tdefault: // zt","\t\t\tdx(y)","\t\t\tFunc[10+f].(f2Zz)(xp, F64(yp), F64(yp+8), rp, e)","\t\t}","\t\tdx(x)","\t\treturn r","\t} else { // vector-vector","\t\tn := nn(x)","\t\tif t == bt || t == ct {","\t\t\tr = use2(x, y)","\t\t\tr = K(Bt)\u003c\u003c59 | K(uint32(r))","\t\t} else {","\t\t\tr = mk(Bt, nn(x))","\t\t}","\t\tif n == 0 {","\t\t\tdx(x)","\t\t\tdx(y)","\t\t\treturn r","\t\t}","\t\trp := int32(r)","\t\te := ep(r)","\t\tswitch t - 1 {","\t\tcase 0: // bt","\t\t\tFunc[11+f].(f2vc)(I8x16splat(1), xp, yp, rp, e)","\t\tcase 1: // ct","\t\t\tFunc[11+f].(f2vc)(I8x16splat(1), xp, yp, rp, e)","\t\tcase 2: // it","\t\t\tFunc[12+f].(f2v)(xp, yp, rp, e)","\t\tcase 3: // st","\t\t\tFunc[12+f].(f2v)(xp, yp, rp, e)","\t\tcase 4: // ft","\t\t\tFunc[13+f].(f2v)(xp, yp, rp, e)","\t\tdefault: // zt","\t\t\tFunc[14+f].(f2v)(xp, yp, rp, e)","\t\t}","\t\tdx(x)","\t\tdx(y)","\t\treturn r","\t}","}","func conform(x, y K) (int32, T) { // 0:atom-atom 1:atom-vector, 2:vector-vector, 3:vector-atom","\txt, yt := tp(x), tp(y)","\tif xt \u003c 16 {","\t\tif yt \u003c 16 {","\t\t\treturn 0, xt","\t\t} else {","\t\t\treturn 1, xt","\t\t}","\t}","\txn := nn(x)","\tif yt \u003c 16 {","\t\treturn 3, yt","\t}","\tif nn(y) != xn {","\t\ttrap(Length)","\t}","\treturn 2, xt - 16","}","func Add(x, y K) K {","\tif tp(y) \u003c 16 {","\t\treturn nd(234, 2, y, x)","\t}","\treturn nd(234, 2, x, y)","}","func addi(x, y int32) int32                          { return x + y }","func addf(x, y float64) float64                      { return x + y }","func addz(xr, xi, yr, yi float64) (float64, float64) { return xr + yr, xi + yi }","func addcC(x I8x16, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, x.Add(I8x16load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func addiI(x I32x4, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, x.Add(I32x4load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func addfF(x F64x2, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, x.Add(F64x2load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func addzZ(re, im float64, yp, rp, e int32) {","\tx := F64x2splat(re).Replace_lane1(im)","\taddfF(x, yp, rp, e)","}","func addC(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Add(I8x16load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func addI(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, I32x4load(xp).Add(I32x4load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func addF(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, F64x2load(xp).Add(F64x2load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func addZ(xp, yp, rp, e int32) { addF(xp, yp, rp, e) }","","func Sub(x, y K) K {","\tif tp(y) \u003c 16 {","\t\treturn nd(234, 2, Neg(y), x)","\t}","\treturn nd(245, 3, x, y)","}","func subi(x, y int32) int32     { return x - y }","func subf(x, y float64) float64 { return x - y }","","//func subz(xr, xi, yr, yi float64) (float64, float64) { return xr - yr, xi - yi }","func subcC(x I8x16, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, x.Sub(I8x16load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func subiI(x I32x4, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, x.Sub(I32x4load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func subfF(x F64x2, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, x.Sub(F64x2load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func subzZ(re, im float64, yp, rp, e int32) {","\tx := F64x2splat(re).Replace_lane1(im)","\tsubfF(x, yp, rp, e)","}","func subC(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Sub(I8x16load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func subI(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, I32x4load(xp).Sub(I32x4load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func subF(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, F64x2load(xp).Sub(F64x2load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func subZ(xp, yp, rp, n int32) { subF(xp, yp, rp, n) }","","func Mul(x, y K) K {","\txt, yt := tp(x), tp(y)","\tif xt \u003c zt \u0026\u0026 yt == Zt {","\t\treturn scalez(x, y)","\t}","\tif yt \u003c zt \u0026\u0026 xt == Zt {","\t\treturn scalez(y, x)","\t}","\tif yt \u003c 16 {","\t\treturn nd(256, 4, y, x)","\t}","\treturn nd(256, 4, x, y)","}","func muli(x, y int32) int32                          { return x * y }","func mulf(x, y float64) float64                      { return x * y }","func mulz(xr, xi, yr, yi float64) (float64, float64) { return xr*yr - xi*yi, xr*yi + xi*yr }","func mulcC(x I8x16, yp, rp, e int32) {","\tc := x.Extract_lane_s0() // no I8x16.mul","\tfor rp \u003c e {","\t\tSetI8(rp, c*I8(yp))","\t\typ++","\t\trp++","\t\tcontinue","\t}","}","func muliI(x I32x4, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, x.Mul(I32x4load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func mulfF(x F64x2, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, x.Mul(F64x2load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func mulzZ(re, im float64, yp, rp, e int32) { // todo simd","\tfor rp \u003c e {","\t\txx, yy := mulz(re, im, F64(yp), F64(yp+8))","\t\tSetF64(rp, xx)","\t\tSetF64(rp+8, yy)","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func mulC(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, I8(xp)*I8(yp))","\t\txp++","\t\typ++","\t\trp++","\t\tcontinue","\t}","}","func mulI(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, I32x4load(xp).Mul(I32x4load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func mulF(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, F64x2load(xp).Mul(F64x2load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func mulZ(xp, yp, rp, e int32) { // todo simd","\tfor rp \u003c e {","\t\txx, yy := mulz(F64(xp), F64(xp+8), F64(yp), F64(yp+8))","\t\tSetF64(rp, xx)","\t\tSetF64(rp+8, yy)","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func scale(s float64, x K) (r K) {","\tif tp(x) \u003c Ft {","\t\tx = uptype(x, ft)","\t}","\tr = use1(x)","\tif nn(r) == 0 {","\t\tdx(x)","\t\treturn r","\t}","\te := ep(r)","\tv := F64x2splat(s)","\txp, rp := int32(x), int32(r)","\tmulfF(v, xp, rp, e)","\tdx(x)","\treturn r","}","func scalez(x, z K) K { // xt\u003c=ft, z:Zt","\tif tp(x) \u003c ft {","\t\tx = uptype(x, ft)","\t}","\ts := F64(int32(x))","\tdx(x)","\treturn scale(s, z)","}","","func Div(x, y K) K {","\txt, yt := tp(x), tp(y)","\tif xt\u002615 \u003c ft \u0026\u0026 yt\u002615 \u003c ft {","\t\treturn idiv(x, y, 0) // no simd for ints","\t}","\tif yt \u003c 16 \u0026\u0026 xt \u003e 16 \u0026\u0026 xt \u003c Lt {","\t\tif yt \u003c ft {","\t\t\ty = uptype(y, ft)","\t\t} else if yt == zt {","\t\t\treturn Mul(Div(Kz(1.0, 0.0), y), x)","\t\t}","\t\ts := 1.0 / F64(int32(y))","\t\tdx(y)","\t\treturn scale(s, x)","\t}","\treturn nd(267, 5, x, y)","}","func divi(x, y int32) int32     { return x / y }","func divf(x, y float64) float64 { return x / y }","func divz(xr, xi, yr, yi float64) (e float64, f float64) {","\tvar r, d float64","\tif F64abs(yr) \u003e= F64abs(yi) {","\t\tr = yi / yr","\t\td = yr + r*yi","\t\te = (xr + xi*r) / d","\t\tf = (xi - xr*r) / d","\t} else {","\t\tr = yr / yi","\t\td = yi + r*yr","\t\te = (xr*r + xi) / d","\t\tf = (xi*r - xr) / d","\t}","\treturn e, f","}","func divfF(x F64x2, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, x.Div(F64x2load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func divzZ(re, im float64, yp, rp, e int32) { // todo simd","\tfor rp \u003c e {","\t\txx, yy := divz(re, im, F64(yp), F64(yp+8))","\t\tSetF64(rp, xx)","\t\tSetF64(rp+8, yy)","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func divF(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, F64x2load(xp).Div(F64x2load(yp)))","\t\trp += 16","\t\txp += 16","\t\typ += 16","\t\tcontinue","\t}","}","func divZ(xp, yp, rp, e int32) { // todo simd","\tfor rp \u003c e {","\t\txx, yy := divz(F64(xp), F64(xp+8), F64(yp), F64(yp+8))","\t\tSetF64(rp, xx)","\t\tSetF64(rp+8, yy)","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func idiv(x, y K, mod int32) (r K) {","\tx, y = uptypes(x, y, 1)","\tav, t := conform(x, y)","\tif t != it {","\t\ttrap(Type)","\t}","\txp := int32(x)","\typ := int32(y)","\tswitch av {","\tcase 0: //a%a","\t\tif mod != 0 {","\t\t\tr = Ki(xp % yp)","\t\t} else {","\t\t\tr = Ki(xp / yp)","\t\t}","\t\treturn r","\tcase 1: //a%v","\t\tr = use(y)","\t\trp := int32(r)","\t\te := rp + 4*nn(r)","\t\tif mod != 0 {","\t\t\tfor rp \u003c e {","\t\t\t\tSetI32(rp, xp%I32(rp))","\t\t\t\trp += 4","\t\t\t}","\t\t} else {","\t\t\tfor rp \u003c e {","\t\t\t\tSetI32(rp, xp/I32(rp))","\t\t\t\trp += 4","\t\t\t}","\t\t}","\t\treturn r","\tcase 2: //v%v","\t\tr = use2(x, y)","\t\trp := int32(r)","\t\te := rp + 4*nn(r)","\t\tif mod != 0 {","\t\t\tfor rp \u003c e {","\t\t\t\tSetI32(rp, I32(xp)%I32(yp))","\t\t\t\txp += 4","\t\t\t\typ += 4","\t\t\t\trp += 4","\t\t\t}","\t\t} else {","\t\t\tfor rp \u003c e {","\t\t\t\tSetI32(rp, I32(xp)/I32(yp))","\t\t\t\txp += 4","\t\t\t\typ += 4","\t\t\t\trp += 4","\t\t\t}","\t\t}","\t\tdx(x)","\t\tdx(y)","\t\treturn r","\tdefault: // v%a","\t\tx = use(x)","\t\txp = int32(x)","\t\txn := nn(x)","\t\te := xp + 4*xn","\t\tif yp \u003e 0 \u0026\u0026 xn \u003e 0 \u0026\u0026 mod == 0 {","\t\t\tdivIi(xp, yp, e)","\t\t}","\t\tif mod != 0 {","\t\t\tfor xp \u003c e {","\t\t\t\tSetI32(xp, I32(xp)%yp)","\t\t\t\txp += 4","\t\t\t}","\t\t}","\t\treturn x","\t}","}","func divIi(xp, yp, e int32) { // x % powers of 2","\ts := int32(31) - I32clz(uint32(yp))","\tif yp == int32(1)\u003c\u003cs {","\t\tfor xp \u003c e {","\t\t\tI32x4store(xp, I32x4load(xp).Shr_s(s))","\t\t\txp += 16","\t\t\tcontinue","\t\t}","\t}","\tfor xp \u003c e {","\t\tSetI32(xp, I32(xp)/yp)","\t\txp += 4","\t}","}","func Mod(x, y K) K {","\txt, yt := tp(x), tp(y)","\tif xt\u002615 \u003c ft \u0026\u0026 yt\u002615 \u003c ft {","\t\treturn idiv(x, y, 1)","\t}","\tif xt \u003e= Lt || yt \u003e= Lt {","\t\treturn nd(0, 41, x, y)","\t} else {","\t\treturn trap(Type)","\t}","}","","func Min(x, y K) (r K) {","\txt, yt := tp(x), tp(y)","\tif xt\u002615 == bt \u0026\u0026 yt\u002615 == bt { // keep bool, no uptype to int","\t\tx = uptype(x, ct)","\t\ty = uptype(y, ct)","\t\tr = Min(x, y)","\t\treturn K(tp(r)-1)\u003c\u003c59 | K(uint32(r))","\t}","\tif tp(y) \u003c 16 {","\t\treturn nd(278, 7, y, x)","\t}","\treturn nd(278, 7, x, y)","}","func mini(x, y int32) int32 {","\tif x \u003c y {","\t\treturn x","\t}","\treturn y","}","func minf(x, y float64) float64 { return F64min(x, y) }","func minz(xr, xi, yr, yi float64) (float64, float64) {","\tif ltz(xr, xi, yr, yi) != 0 {","\t\treturn xr, xi","\t}","\treturn yr, yi","}","func mincC(x I8x16, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, x.Min_s(I8x16load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func miniI(x I32x4, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, x.Min_s(I32x4load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func minfF(x F64x2, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, x.Pmin(F64x2load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func minzZ(re, im float64, yp, rp, e int32) {","\tfor rp \u003c e {","\t\txx, yy := minz(re, im, F64(yp), F64(yp+8))","\t\tSetF64(rp, xx)","\t\tSetF64(rp+8, yy)","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func minC(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Min_s(I8x16load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func minI(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, I32x4load(xp).Min_s(I32x4load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func minF(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, F64x2load(xp).Pmin(F64x2load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func minZ(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\txx, yy := minz(F64(xp), F64(xp+8), F64(yp), F64(yp+8))","\t\tSetF64(rp, xx)","\t\tSetF64(rp+8, yy)","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","","func Max(x, y K) (r K) {","\txt, yt := tp(x), tp(y)","\tif xt\u002615 == bt \u0026\u0026 yt\u002615 == bt { // keep bool, no uptype to int","\t\tx = uptype(x, ct)","\t\ty = uptype(y, ct)","\t\tr = Max(x, y)","\t\treturn K(tp(r)-1)\u003c\u003c59 | K(uint32(r))","\t}","\tif tp(y) \u003c 16 {","\t\treturn nd(289, 8, y, x)","\t}","\treturn nd(289, 8, x, y)","}","func maxi(x, y int32) int32 {","\tif x \u003e y {","\t\treturn x","\t} else {","\t\treturn y","\t}","}","func maxf(x, y float64) float64 { return F64max(x, y) }","func maxz(xr, xi, yr, yi float64) (float64, float64) {","\tif gtz(xr, xi, yr, yi) != 0 {","\t\treturn xr, xi","\t}","\treturn yr, yi","}","func maxcC(x I8x16, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, x.Max_s(I8x16load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func maxiI(x I32x4, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, x.Max_s(I32x4load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func maxfF(x F64x2, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, x.Pmax(F64x2load(yp)))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func maxzZ(re, im float64, yp, rp, e int32) {","\tfor rp \u003c e {","\t\txx, yy := maxz(re, im, F64(yp), F64(yp+8))","\t\tSetF64(rp, xx)","\t\tSetF64(rp+8, yy)","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func maxC(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Max_s(I8x16load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func maxI(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI32x4store(rp, I32x4load(xp).Max_s(I32x4load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func maxF(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tF64x2store(rp, F64x2load(xp).Pmax(F64x2load(yp)))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func maxZ(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\txx, yy := maxz(F64(xp), F64(xp+8), F64(yp), F64(yp+8))","\t\tSetF64(rp, xx)","\t\tSetF64(rp+8, yy)","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","","func Eql(x, y K) K                     { return nc(338, 11, x, y) }","func eqi(x, y int32) int32             { return I32B(x == y) }","func eqf(x, y float64) int32           { return I32B((x != x) \u0026\u0026 (y != y) || x == y) }","func eqz(xr, xi, yr, yi float64) int32 { return eqf(xr, yr) \u0026 eqf(xi, yi) }","func eqcC(v, w I8x16, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, v.Eq(I8x16load(yp)).And(w))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func eqiI(x int32, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, eqi(x, I32(yp)))","\t\typ += 4","\t\trp++","\t\tcontinue","\t}","}","func eqfF(x float64, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, eqf(x, F64(yp)))","\t\typ += 8","\t\trp++","\t\tcontinue","\t}","}","func eqzZ(re, im float64, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, eqz(re, im, F64(yp), F64(yp+8)))","\t\typ += 16","\t\trp++","\t\tcontinue","\t}","}","func eqCc(xp int32, v, w I8x16, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Eq(v).And(w))","\t\txp += 16","\t\trp += 16","\t\tcontinue","\t}","}","func eqIi(xp, y int32, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, eqi(I32(xp), y))","\t\txp += 4","\t\trp++","\t\tcontinue","\t}","}","func eqFf(xp int32, y float64, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, eqf(F64(xp), y))","\t\txp += 8","\t\trp++","\t\tcontinue","\t}","}","func eqZz(xp int32, re, im float64, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, eqz(F64(xp), F64(xp+8), re, im))","\t\txp += 16","\t\trp++","\t\tcontinue","\t}","}","func eqC(w I8x16, xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Eq(I8x16load(yp)).And(w))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func eqI(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, eqi(I32(xp), I32(yp)))","\t\txp += 4","\t\typ += 4","\t\trp++","\t\tcontinue","\t}","}","func eqF(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, eqf(F64(xp), F64(yp)))","\t\txp += 8","\t\typ += 8","\t\trp++","\t\tcontinue","\t}","}","func eqZ(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, eqz(F64(xp), F64(xp+8), F64(yp), F64(yp+8)))","\t\txp += 16","\t\typ += 16","\t\trp++","\t\tcontinue","\t}","}","","func Les(x, y K) K { // x\u003cy   `file\u003cc","\tif tp(x) == st \u0026\u0026 tp(y) == Ct {","\t\tif int32(x) == 0 {","\t\t\twrite(rx(y))","\t\t\treturn y","\t\t}","\t\treturn writefile(cs(x), y)","\t}","\treturn nc(308, 9, x, y)","}","func lti(x, y int32) int32   { return I32B(x \u003c y) }","func ltf(x, y float64) int32 { return I32B(x \u003c y || x != x) }","func ltz(xr, xi, yr, yi float64) int32 {","\tif eqf(xr, yr) != 0 {","\t\treturn ltf(xi, yi)","\t}","\treturn ltf(xr, yr)","}","func ltcC(v, w I8x16, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, v.Lt_s(I8x16load(yp)).And(w))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func ltiI(x int32, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, lti(x, I32(yp)))","\t\typ += 4","\t\trp++","\t\tcontinue","\t}","}","func ltfF(x float64, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, ltf(x, F64(yp)))","\t\typ += 8","\t\trp++","\t\tcontinue","\t}","}","func ltzZ(re, im float64, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tif re == F64(yp) {","\t\t\tSetI8(rp, ltf(im, F64(yp+8)))","\t\t} else {","\t\t\tSetI8(rp, ltf(re, F64(yp)))","\t\t}","\t\typ += 16","\t\trp++","\t\tcontinue","\t}","}","func ltCc(xp int32, v, w I8x16, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Lt_s(v).And(w))","\t\txp += 16","\t\trp += 16","\t\tcontinue","\t}","}","func ltIi(xp, y int32, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, lti(I32(xp), y))","\t\txp += 4","\t\trp++","\t\tcontinue","\t}","}","func ltFf(xp int32, y float64, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, ltf(F64(xp), y))","\t\txp += 8","\t\trp++","\t\tcontinue","\t}","}","func ltZz(xp int32, re, im float64, rp, e int32) {","\tfor rp \u003c e {","\t\tif F64(xp) == re {","\t\t\tSetI8(rp, ltf(F64(xp+8), im))","\t\t} else {","\t\t\tSetI8(rp, ltf(F64(xp), re))","\t\t}","\t\txp += 16","\t\trp++","\t\tcontinue","\t}","}","func ltC(w I8x16, xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Lt_s(I8x16load(yp)).And(w))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func ltI(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, lti(I32(xp), I32(yp)))","\t\txp += 4","\t\typ += 4","\t\trp++","\t\tcontinue","\t}","}","func ltF(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, ltf(F64(xp), F64(yp)))","\t\txp += 8","\t\typ += 8","\t\trp++","\t\tcontinue","\t}","}","func ltZ(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, ltz(F64(xp), F64(xp+8), F64(yp), F64(yp+8)))","\t\txp += 16","\t\typ += 16","\t\trp++","\t\tcontinue","\t}","}","","func Mor(x, y K) K           { return nc(323, 10, x, y) }","func gti(x, y int32) int32   { return I32B(x \u003e y) }","func gtf(x, y float64) int32 { return I32B(x \u003e y || y != y) }","func gtz(xr, xi, yr, yi float64) int32 {","\tif eqf(xr, yr) != 0 {","\t\treturn gtf(xi, yi)","\t}","\treturn gtf(xr, yr)","}","func gtcC(v, w I8x16, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, v.Gt_s(I8x16load(yp)).And(w))","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func gtiI(x int32, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, gti(x, I32(yp)))","\t\typ += 4","\t\trp++","\t\tcontinue","\t}","}","func gtfF(x float64, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, gtf(x, F64(yp)))","\t\typ += 8","\t\trp++","\t\tcontinue","\t}","}","func gtzZ(re, im float64, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tif re == F64(yp) {","\t\t\tSetI8(rp, gtf(im, F64(yp+8)))","\t\t} else {","\t\t\tSetI8(rp, gtf(re, F64(yp)))","\t\t}","\t\typ += 16","\t\trp++","\t\tcontinue","\t}","}","func gtCc(xp int32, v, w I8x16, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Gt_s(v).And(w))","\t\txp += 16","\t\trp += 16","\t\tcontinue","\t}","}","func gtIi(xp, y int32, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, gti(I32(xp), y))","\t\txp += 4","\t\trp++","\t\tcontinue","\t}","}","func gtFf(xp int32, y float64, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, gtf(F64(xp), y))","\t\txp += 8","\t\trp++","\t\tcontinue","\t}","}","func gtZz(xp int32, re, im float64, rp, e int32) {","\tfor rp \u003c e {","\t\tif F64(xp) == re {","\t\t\tSetI8(rp, gtf(F64(xp+8), im))","\t\t} else {","\t\t\tSetI8(rp, gtf(F64(xp), re))","\t\t}","\t\txp += 16","\t\trp++","\t\tcontinue","\t}","}","func gtC(w I8x16, xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tI8x16store(rp, I8x16load(xp).Gt_s(I8x16load(yp)).And(w))","\t\txp += 16","\t\typ += 16","\t\trp += 16","\t\tcontinue","\t}","}","func gtI(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, gti(I32(xp), I32(yp)))","\t\txp += 4","\t\typ += 4","\t\trp++","\t\tcontinue","\t}","}","func gtF(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, gtf(F64(xp), F64(yp)))","\t\txp += 8","\t\typ += 8","\t\trp++","\t\tcontinue","\t}","}","func gtZ(xp, yp, rp, e int32) {","\tfor rp \u003c e {","\t\tSetI8(rp, gtz(F64(xp), F64(xp+8), F64(yp), F64(yp+8)))","\t\txp += 16","\t\typ += 16","\t\trp++","\t\tcontinue","\t}","}","","//func isnan(x float64) bool { return x != x }","","func Ang(x K) (r K) { // angle x","\txt := tp(x)","\tif xt \u003e Zt {","\t\treturn Ech(35, l1(x))","\t}","\tif xt \u003c zt {","\t\tdx(x)","\t\treturn Kf(0)","\t}","\txp := int32(x)","\tif xt == zt {","\t\tdx(x)","\t\treturn Kf(ang2(F64(xp+8), F64(xp)))","\t}","\tn := nn(x)","\tif xt == Zt {","\t\tr = mk(Ft, n)","\t\trp := int32(r)","\t\te := rp + 8*n","\t\tfor rp \u003c e {","\t\t\tSetF64(rp, ang2(F64(xp+8), F64(xp)))","\t\t\txp += 16","\t\t\trp += 8","\t\t}","\t} else {","\t\tr = ntake(n, Kf(0))","\t}","\tdx(x)","\treturn r","}","func Rot(x, y K) (r K) { // r@deg","\tif tp(x) \u003e Zt {","\t\treturn Ech(35, l2(x, y))","\t}","\tx = uptype(x, zt)","\tif y == 0 {","\t\treturn x","\t}","\tif tp(y)\u002615 \u003e ft {","\t\ttrap(Type)","\t}","\ty = uptype(y, ft)","\tyt := tp(y)","\typ := int32(y)","\tif yt == ft {","\t\tr = Kz(cosin(F64(yp)))","\t} else {","\t\tyn := nn(y)","\t\tr = mk(Zt, yn)","\t\trp := int32(r)","\t\tfor i := int32(0); i \u003c yn; i++ {","\t\t\tc, s := cosin(F64(yp))","\t\t\tSetF64(rp, c)","\t\t\tSetF64(rp+8, s)","\t\t\typ += 8","\t\t\trp += 16","\t\t}","\t}","\tdx(y)","\treturn Mul(r, x)","}","func Sin(x K) K { return nf(44, x, 0) } // sin x","func Cos(x K) K { return nf(39, x, 0) } // cos x","func Exp(x K) K { return nf(42, x, 0) } // exp x","func Log(x K) K { return nf(43, x, 0) } // log x","func Pow(y, x K) K { // x^y","\tif tp(x)\u002615 == it {","\t\tif tp(y) == it {","\t\t\tif int32(y) \u003e= 0 {","\t\t\t\treturn ipow(x, int32(y))","\t\t\t}","\t\t}","\t}","\treturn nf(106, x, y)","}","func Lgn(x, y K) K { // n log y","\txf := fk(x)","\tif xf == 10.0 {","\t\txf = 0.4342944819032518","\t} else if xf == 2.0 {","\t\txf = 1.4426950408889634","\t} else {","\t\txf = 1.0 / log(xf)","\t}","\treturn Mul(Kf(xf), Log(y))","}","func fk(x K) float64 {","\tt := tp(x)","\tif t == it {","\t\treturn float64(int32(x))","\t}","\tif t != ft {","\t\ttrap(Type)","\t}","\tdx(x)","\treturn F64(int32(x))","}","func nf(f int32, x, y K) (r K) {","\txt := tp(x)","\tif xt \u003e= Lt {","\t\tif y == 0 {","\t\t\treturn Ech(K(f), l1(x))","\t\t} else {","\t\t\treturn Ech(K(f-64), l2(y, x))","\t\t}","\t}","\tvar yf float64","\tif y != 0 {","\t\tyf = fk(y)","\t}","\tif xt\u002615 \u003c ft {","\t\tx = uptype(x, ft)","\t\txt = tp(x)","\t}","\txp := int32(x)","\tif xt == ft {","\t\tr = Kf(0)","\t\tff(f, int32(r), xp, 1, yf)","\t} else {","\t\txn := nn(x)","\t\tr = mk(Ft, xn)","\t\tif xn \u003e 0 {","\t\t\tff(f, int32(r), xp, xn, yf)","\t\t}","\t}","\tdx(x)","\treturn r","}","func ff(f, rp, xp, n int32, yf float64) {","\te := xp + 8*n","\tswitch f - 42 {","\tcase 0:","\t\tfor xp \u003c e {","\t\t\tSetF64(rp, exp(F64(xp)))","\t\t\trp += 8","\t\t\txp += 8","\t\t\tcontinue","\t\t}","\tcase 1:","\t\tfor xp \u003c e {","\t\t\tSetF64(rp, log(F64(xp)))","\t\t\trp += 8","\t\t\txp += 8","\t\t\tcontinue","\t\t}","\tdefault:","\t\tif f == 106 { // pow 42+64","\t\t\tfor xp \u003c e {","\t\t\t\tSetF64(rp, pow(F64(xp), yf))","\t\t\t\trp += 8","\t\t\t\txp += 8","\t\t\t\tcontinue","\t\t\t}","\t\t} else { // sin cos","\t\t\tfor xp \u003c e {","\t\t\t\tc, s := cosin_(F64(xp))","\t\t\t\tSetF64(rp, s)","\t\t\t\tif f == 39 {","\t\t\t\t\tSetF64(rp, c)","\t\t\t\t}","\t\t\t\trp += 8","\t\t\t\txp += 8","\t\t\t\tcontinue","\t\t\t}","\t\t}","\t}","}","","func dctypes(x, y K) (K, T, K, K) {","\txt, yt := tp(x), tp(y)","\tt := T(maxi(int32(xt), int32(yt)))","\tif xt \u003c Dt \u0026\u0026 yt \u003c Dt {","\t\treturn 0, t, x, y","\t}","\tvar k K","\tif xt \u003e Lt {","\t\tk, x = spl2(x)","\t\tif yt \u003e Lt {","\t\t\tvar yk K","\t\t\tyk, y = spl2(y)","\t\t\tif match(k, yk) == 0 {","\t\t\t\ttrap(Value)","\t\t\t}","\t\t\tdx(yk)","\t\t}","\t} else if yt \u003e Lt {","\t\tk, y = spl2(y)","\t}","\treturn k, t, x, y","}","func uptypes(x, y K, b2i int32) (K, K) {","\txt, yt := tp(x)\u002615, tp(y)\u002615","\trt := T(maxi(int32(xt), int32(yt)))","\tif rt == 0 {","\t\trt = it","\t}","\tif rt == bt \u0026\u0026 b2i != 0 {","\t\trt = it","\t}","\tif xt \u003c rt {","\t\tx = uptype(x, rt)","\t}","\tif yt \u003c rt {","\t\ty = uptype(y, rt)","\t}","\treturn x, y","}","func uptype(x K, dst T) (r K) {","\txt := tp(x)","\txp := int32(x)","\tif xt\u002615 == dst {","\t\treturn x","\t}","\tif xt \u003c 16 {","\t\tif dst == ct {","\t\t\treturn Kc(xp)","\t\t} else if dst == it {","\t\t\treturn Ki(xp)","\t\t} else if dst == ft {","\t\t\treturn Kf(float64(xp))","\t\t} else if dst == zt {","\t\t\tvar f float64","\t\t\tif xt == ft {","\t\t\t\tf = F64(xp)","\t\t\t\tdx(x)","\t\t\t} else {","\t\t\t\tf = float64(xp)","\t\t\t}","\t\t\treturn Kz(f, 0)","\t\t} else {","\t\t\treturn trap(Type)","\t\t}","\t}","\tif xt \u003c It \u0026\u0026 dst == ft {","\t\tx, xt = uptype(x, it), It","\t}","\tif xt \u003c Ft \u0026\u0026 dst == zt {","\t\tx, xt = uptype(x, ft), Ft","\t}","\txn := nn(x)","\txp = int32(x)","\tr = mk(dst+16, xn)","\trp := int32(r)","\tif dst == ct {","\t\tMemorycopy(rp, xp, xn)","\t} else if dst == it {","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tSetI32(rp, I8(xp))","\t\t\txp++","\t\t\trp += 4","\t\t}","\t} else if dst == ft {","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tSetF64(rp, float64(I32(xp)))","\t\t\txp += 4","\t\t\trp += 8","\t\t}","\t} else if dst == zt {","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tSetF64(rp, F64(xp))","\t\t\tSetF64(rp+8, 0.0)","\t\t\txp += 8","\t\t\trp += 16","\t\t}","\t} else {","\t\ttrap(Type)","\t}","\tdx(x)","\treturn r","}","","/*","func alpha(x K) K { // set alpha byte opaque (pixbuffers)","\tif tp(x) == It {","\t\tm := I32x4splat(-16777216)","\t\tp := int32(x)","\t\te := ep(x)","\t\tfor p \u003c e {","\t\t\tI32x4store(p, I32x4load(p).Add(m))","\t\t\tp += 16","\t\t\tcontinue","\t\t}","\t}","\treturn x","}","*/",""],"parse.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","var ps int32","","func Prs(x K) K { return parse(Tok(x)) } // `p\"src\"  `p(token list)","func parse(x K) (r K) {","\tif tp(x) != Lt {","\t\ttrap(Type)","\t}","\tpp = int32(x)","\tpe = pp + 8*nn(x)","\tr = es()","\tif pp != pe {","\t\ttrap(Parse)","\t}","\tlfree(x)","\treturn r","}","func es() (r K) {","\tr = mk(Lt, 0)","\tfor {","\t\tn := next()","\t\tif n == 0 {","\t\t\tbreak","\t\t}","\t\tif n == 59 {","\t\t\tcontinue","\t\t}","\t\tpp -= 8","\t\tx, _ := e(t())","\t\tif x == 0 {","\t\t\tbreak","\t\t}","\t\tif nn(r) != 0 {","\t\t\tr = cat1(r, 256) // drop","\t\t}","\t\tr = Cat(r, x)","\t}","\treturn r","}","func e(x K, xv int32) (r K, ev int32) { // Lt","\tif x == 0 {","\t\treturn 0, 0","\t}","\txs := ps","\ty, yv := t()","\tif y == 0 {","\t\treturn x, xv","\t}","\tif yv != 0 \u0026\u0026 xv == 0 {","\t\ta := int32(0)","\t\tx, y, a = pasn(x, y)","\t\tr, ev = e(t())","\t\tif (r == 0 || ev == 1) \u0026\u0026 a == 0 { // 1+ (projection)","\t\t\tx = cat1(ucat(cat1(cat1(ucat(l1(0), x), Ki(2)), 27), y), 92)","\t\t\tif ev == 1 { // 1+-","\t\t\t\treturn cat1(ucat(r, x), 91), 1","\t\t\t}","\t\t\treturn x, 1","\t\t}","\t\treturn dyadic(ucat(r, x), y), 0 // dyadic","\t}","\tr, ev = e(rx(y), yv)","\tdx(y)","\tif xv == 0 {","\t\treturn cat1(ucat(r, x), 83|K(xs)\u003c\u003c32), 0 // juxtaposition","\t} else if (r == y \u0026\u0026 xv+yv == 2) || ev == 1 {","\t\treturn cat1(ucat(r, x), 91), 1 // composition","\t}","\treturn idiom(monadic(ucat(r, x))), 0 // monadic","}","func t() (r K, verb int32) { // Lt","\tvar ln int32","\tr = next()","\tif r == 0 {","\t\treturn 0, 0","\t}","\tif tp(r) == 0 \u0026\u0026 int32(r) \u003c 127 {","\t\tif is(int32(r), 32) != 0 {","\t\t\tpp -= 8","\t\t\treturn 0, 0","\t\t}","\t}","\tif r == K('(') {","\t\tr = rlist(plist(41))","\t} else if r == K('{') {","\t\tr = plam(ps)","\t} else if r == K('[') {","\t\tr = es()","\t\tif next() != K(']') {","\t\t\ttrap(Parse)","\t\t}","\t\treturn r, 0","\t} else if tp(r) == st {","\t\tr = l2(r, 20|(K(ps)\u003c\u003c32)) // .`x (lookup)","\t} else {","\t\trt := tp(r)","\t\tif rt == 0 {","\t\t\tr, verb = quote(r)|K(ps)\u003c\u003c32, 1","\t\t} else if rt == St {","\t\t\tif nn(r) == 1 {","\t\t\t\tr = Fst(r)","\t\t\t}","\t\t}","\t\tr = l1(r)","\t}","f:","\tfor {","\t\tvar n K","\t\tn = next()","\t\tif n == 0 {","\t\t\tbreak f","\t\t}","\t\ta := int32(n)","\t\ttn := tp(n)","\t\tif tn == 0 \u0026\u0026 a \u003e 20 \u0026\u0026 a \u003c 27 { // +/","\t\t\tr, verb = cat1(r, n), 1","\t\t} else if n == 91 { // [","\t\t\tverb = 0","\t\t\tp := int32(0) // 92(project) or call(84)","\t\t\tn, ln, p = plist(93)","\t\t\tn, ln = pspec(r, n, ln)","\t\t\tif ln \u003c 0 {","\t\t\t\treturn n, 0","\t\t\t}","\t\t\tif ln == 1 {","\t\t\t\tr = cat1(ucat(Fst(n), r), 83)","\t\t\t} else {","\t\t\t\tn = rlist(n, ln, 0)","\t\t\t\tr = cat1(Cat(n, r), K(p))","\t\t\t}","\t\t} else {","\t\t\tpp -= 8","\t\t\tbreak f // within else-if","\t\t}","\t}","\treturn r, verb","}","func pasn(x, y K) (K, K, int32) {","\tl := K(I64(int32(y)))","\tv := int32(l)","\tsp := 0xffffff \u0026 int32(l\u003e\u003e32)","\tif nn(y) == 1 \u0026\u0026 tp(l) == 0 \u0026\u0026 v == 449 || (v \u003e 544 \u0026\u0026 v \u003c 565) {","\t\tdx(y)","\t\txn := nn(x)","\t\tif xn \u003e 2 { // indexed amd/dmd","\t\t\tif v \u003e 544 { // indexed-modified","\t\t\t\tl -= 96","\t\t\t}","\t\t\ts := ati(rx(x), xn-3)","\t\t\tlp := lastp(x)","\t\t\t// (+;.i.;`x;.;@) -\u003e x:@[x;.i.;+;rhs] which is (+;.i.;`x;.;211 or 212)","\t\t\t// lp+128 is @[amd..] or .[dmd..]","\t\t\tif lp == 92 {","\t\t\t\tlp = 84 // x[i;]:.. no projection","\t\t\t}","\t\t\tx = cat1(cat1(ucat(l1(l), ldrop(-2, x)), 20), (K(sp)\u003c\u003c32)|(lp+128))","\t\t\ty = l2(s, 448) // s:..","\t\t} else if v == 449 || v == 545 {","\t\t\ts := Fst(x) // (`x;.)","\t\t\tif loc != 0 \u0026\u0026 v == 449 {","\t\t\t\tloc = cat1(loc, s)","\t\t\t}","\t\t\tx = l1(s)","\t\t\ty = l1(448) // asn","\t\t} else { // modified","\t\t\ty = cat1(l2(unquote(l-32), Fst(rx(x))), 448)","\t\t}","\t\treturn x, y, 1","\t}","\treturn x, y, 0","}","func plam(s0 int32) (r K) {","\tslo := loc","\tloc = 0","\tar := int32(-1)","\tn := next()","\tif n == 91 { // argnames","\t\tn, ln, _ := plist(93)","\t\tloc = Ech(4, l1(n)) // [a]-\u003e,(`a;.)  [a;b]-\u003e((`a;.);(`b;.))","\t\tif ln \u003e 0 \u0026\u0026 tp(loc) != St {","\t\t\ttrap(Parse)","\t\t}","\t\tar = nn(loc)","\t\tif ar == 0 {","\t\t\tdx(loc)","\t\t\tloc = mk(St, 0)","\t\t}","\t} else {","\t\tpp -= 8","\t\tloc = mk(St, 0)","\t}","\tc := es() // todo: translate srcp","\tn = next()","\tif n != 125 {","\t\ttrap(Parse)","\t}","\tcn := nn(c)","\tcp := int32(c)","\tif ar \u003c 0 {","\t\tar = 0","\t\tfor i := int32(0); i \u003c cn; i++ {","\t\t\tr = K(I64(cp))","\t\t\tif tp(r) == 0 \u0026\u0026 int32(r) == 20 {","\t\t\t\tr = K(I64(cp - 8))","\t\t\t\ty := int32(r) \u003e\u003e 3","\t\t\t\tif tp(r) == st \u0026\u0026 y \u003e 0 \u0026\u0026 y \u003c 4 {","\t\t\t\t\tar = maxi(ar, y)","\t\t\t\t}","\t\t\t}","\t\t\tcp += 8","\t\t}","\t\tloc = Cat(ntake(ar, rx(xyz)), loc)","\t}","\ti := Add(seq(1+ps-s0), Ki(s0-1))","\ts := atv(rx(src()), i)","\tr = l3(c, Unq(loc), s)","\tloc = slo","\treturn l1(slam(r, ar))","}","func slam(r K, ar int32) K {","\trp := int32(r)","\tSetI32(rp-12, ar)","\treturn K(rp) | K(lf)\u003c\u003c59","}","func pspec(r, n K, ln int32) (K, int32) {","\tv := K(I64(int32(r)))","\tif nn(r) == 1 \u0026\u0026 ln \u003e 2 { // $[..] cond","\t\tif tp(v) == 0 \u0026\u0026 int32(v) == 465 {","\t\t\tdx(r)","\t\t\treturn cond(n, ln), -1","\t\t}","\t}","\tif nn(r) == 2 \u0026\u0026 ln \u003e 1 \u0026\u0026 int32(v) == 64 { // while[..]","\t\tdx(r)","\t\treturn whl(n, ln-1), -1","\t}","\treturn n, ln","}","func whl(x K, xn int32) (r K) {","\tr = cat1(Fst(rx(x)), 0)","\tp := nn(r) - 1","\tr = cat1(r, 384) // jif","\tr = cat1(r, 256) // drop","\txp := int32(x)","\tsum := int32(2)","\tfor i := int32(0); i \u003c xn; i++ {","\t\tif i != 0 {","\t\t\tr = cat1(r, 256)","\t\t}","\t\txp += 8","\t\ty := x0(xp)","\t\tsum += 1 + nn(y)","\t\tr = ucat(r, y)","\t}","\tr = cat1(cat1(r, Ki(-8*(2+nn(r)))), 320) // jmp back","\tSetI64(int32(r)+8*p, int64(Ki(8*sum)))   // jif","\tdx(x)","\treturn ucat(l1(0), r) // null for empty while","}","func cond(x K, xn int32) (r K) {","\txp := int32(x) + 8*xn","\tvar nxt, sum int32","\tstate := int32(1)","\tfor xp != int32(x) {","\t\txp -= 8","\t\tr = K(I64(xp))","\t\tif sum \u003e 0 {","\t\t\tstate = 1 - state","\t\t\tif state != 0 {","\t\t\t\tr = cat1(cat1(r, Ki(nxt)), 384) // jif","\t\t\t} else {","\t\t\t\tr = cat1(cat1(r, Ki(sum)), 320) // j","\t\t\t}","\t\t\tSetI64(xp, int64(r))","\t\t}","\t\tnxt = 8 * nn(r)","\t\tsum += nxt","\t}","\treturn flat(x)","}","func plist(c K) (r K, n, p int32) {","\tn = 0","\tr = mk(Lt, 0)","\tp = 84","\tfor {","\t\tvar b K","\t\tb = next()","\t\tif b == 0 || b == c {","\t\t\tbreak","\t\t}","\t\tif n == 0 {","\t\t\tpp -= 8","\t\t}","\t\tif n != 0 \u0026\u0026 b != 59 {","\t\t\ttrap(Parse)","\t\t}","\t\tn++","\t\tx, _ := e(t())","\t\tif x == 0 {","\t\t\tp = 92","\t\t}","\t\tr = cat1(r, x)","\t}","\treturn r, n, p","}","func rlist(x K, n, p int32) (r K) {","\tif n == 0 {","\t\treturn l1(x)","\t}","\tif n == 1 {","\t\treturn Fst(x)","\t}","\tif p != 0 {","\t\tr = clist(x, n)","\t\tif r != 0 {","\t\t\treturn l1(r)","\t\t}","\t}","\treturn cat1(cat1(flat(Rev(x)), Ki(n)), 27)","}","func clist(x K, n int32) K {","\tp := int32(x)","\tfor i := int32(0); i \u003c n; i++ {","\t\txi := K(I64(p))","\t\tt := tp(xi)","\t\tif t != Lt {","\t\t\treturn 0","\t\t}","\t\tif nn(xi) != 1 {","\t\t\treturn 0","\t\t}","\t\tif tp(K(I64(int32(xi)))) == 0 {","\t\t\treturn 0","\t\t}","\t\tp += 8","\t}","\treturn uf(flat(x))","}","","func next() (r K) {","\tif pp == pe {","\t\treturn 0","\t}","\tr = K(I64(pp))","\tps = 0xffffff \u0026 int32(r\u003e\u003e32)","\tr = r \u0026^ (K(0xffffff) \u003c\u003c 32)","\tpp += 8","\treturn r","}","func lastp(x K) K { return K(I64(int32(x) + 8*(nn(x)-1))) }","func dyadic(x, y K) K {","\tl := lastp(y)","\tif quoted(l) != 0 {","\t\treturn cat1(ucat(x, ldrop(-1, y)), 64+unquote(l))","\t}","\treturn cat1(ucat(x, y), 128)","}","func monadic(x K) (r K) {","\tl := lastp(x)","\tif quoted(l) != 0 {","\t\tr = cat1(ldrop(-1, x), unquote(l))","\t\tif int32(l) == 449 { // :x (return: identity+jump)","\t\t\treturn cat1(cat1(r, Ki(1048576)), 320)","\t\t} else {","\t\t\treturn r","\t\t}","\t}","\treturn cat1(x, 83) // dyadic-@","}","func ldrop(n int32, x K) K { return explode(ndrop(n, x)) }","func svrb(p int32) int32 {","\tx := K(I64(p))","\treturn I32B(tp(x) == 0) * int32(x)","}","func idiom(x K) K {","\tl := int32(x) + 8*(nn(x)-2)","\ti := svrb(l) + svrb(l+8)\u003c\u003c6","\tif i == 263 || i == 264 { // *\u0026 7 4 -\u003e 40","\t\ti = 33 // 7-\u003e40(Fwh)  8-\u003e41(Las)","\t} else if i == 1166 { // ?^ 14 18","\t\ti = 23 // 14-\u003e37(Uqs)","\t} else {","\t\treturn x","\t}","\tSetI64(l, I64(l)+int64(i))","\treturn ndrop(-1, x)","}",""],"rand.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func rnd() (r int32) {","\tr = rand_","\tr ^= (r \u003c\u003c 13)","\tr ^= (r \u003e\u003e 17)","\tr ^= (r \u003c\u003c 5)","\trand_ = r","\treturn r","}","func roll(x K) (r K) { // ?x (atom) ?n(uniform 0..1) ?-n(normal) ?z(binormal)","\txt := tp(x)","\txp := int32(x)","\tif xt == it {","\t\tif xp \u003e 0 {","\t\t\treturn kx(72, x) // .rf uniform","\t\t} else {","\t\t\tr = kx(80, Ki((1+-xp)/2))","\t\t\tSetI32(int32(r)-12, -xp)","\t\t\treturn K(int32(r)) | K(Ft)\u003c\u003c59 // normal","\t\t}","\t}","\tif xt == zt {","\t\tdx(x)","\t\treturn kx(80, Ki(int32(F64floor(F64(xp))))) //.rz binormal","\t}","\treturn trap(Type)","}","func deal(x, y K) K { // x?y (x atom) n?n(with replacement) -n?n(without) n?L (-#L)?L shuffle","\tif tp(x) != it {","\t\ttrap(Type)","\t}","\txp := int32(x)","\tyt := tp(y)","\tif yt \u003e 16 {","\t\tyn := nn(y)","\t\tif xp \u003c 0 {","\t\t\txp = -xp","\t\t\tif xp \u003e= yn {","\t\t\t\treturn atv(y, shuffle(seq(xp), yn)) //(-#L)?L","\t\t\t} else {","\t\t\t\treturn atv(y, deal(x, Ki(yn))) // -n?L","\t\t\t}","\t\t} else {","\t\t\treturn atv(y, randI(nn(y), xp)) // n?L","\t\t}","\t}","\tif yt == ct {","\t\treturn Add(Kc(97), Flr(deal(x, Ki(int32(y)-96))))","\t}","\tif yt == st {","\t\treturn Ech(17, l2(Ks(0), deal(x, Fst(cs(y))))) // `$'x?*$y","\t}","\tif yt != it {","\t\ttrap(Type)","\t}","\typ := int32(y)","\tif xp \u003e 0 {","\t\treturn randI(yp, xp) // n?m","\t}","\t// todo n\u003c\u003cm","\treturn ntake(-xp, shuffle(seq(yp), -xp)) //-n?m (no duplicates)","}","func randi(n int32) int32 {","\tv := uint32(rnd())","\tprod := uint64(v) * uint64(n)","\tlow := uint32(prod)","\tif low \u003c uint32(n) {","\t\tthresh := uint32(-n) % uint32(n)","\t\tfor low \u003c thresh {","\t\t\tv = uint32(rnd())","\t\t\tprod = uint64(v) * uint64(n)","\t\t\tlow = uint32(prod)","\t\t}","\t}","\treturn int32(prod \u003e\u003e 32)","}","func randI(i, n int32) (r K) {","\tr = mk(It, n)","\trp := int32(r)","\te := rp + 4*n","\tif i == 0 {","\t\tfor rp \u003c e {","\t\t\tSetI32(rp, rnd())","\t\t\trp += 4","\t\t}","\t} else {","\t\tfor rp \u003c e {","\t\t\tSetI32(rp, randi(i))","\t\t\trp += 4","\t\t}","\t}","\treturn r","}","func shuffle(r K, m int32) K { // I, inplace","\trp := int32(r)","\tn := nn(r)","\tm = mini(n-1, m)","\tfor i := int32(0); i \u003c m; i++ {","\t\tii := i + randi(n-i)","\t\tj := rp + 4*(ii-i)","\t\tt := I32(rp)","\t\tSetI32(rp, I32(j))","\t\tSetI32(j, t)","\t\trp += 4","\t}","\treturn r","}",""],"reduce.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","type rdf = func(K, int32, T, int32) K","","func rd0(x K, yp int32, t T, n int32) K { return 0 }","func min(x K, yp int32, t T, n int32) K { // \u0026/x","\txp := int32(x)","\tswitch t - 17 {","\tcase 0: // Bt","\t\tif x == 0 {","\t\t\txp = 1","\t\t}","\t\treturn Kb(mini(xp, all(yp, n)))","\tcase 1: // Ct","\t\tif x == 0 {","\t\t\txp = 127","\t\t}","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\txp = mini(xp, I8(yp+i))","\t\t}","\t\treturn Kc(xp)","\tcase 2: // It","\t\tif x == 0 {","\t\t\txp = 2147483647","\t\t}","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\txp = mini(xp, I32(yp))","\t\t\typ += 4","\t\t}","\t\treturn Ki(xp)","\tcase 3: // St","\t\tif x == 0 {","\t\t\txp = (nn(K(I64(8))) \u003c\u003c 3) - 8","\t\t}","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\txp = mini(xp, I32(yp))","\t\t\typ += 4","\t\t}","\t\treturn Ks(xp)","\tcase 4: // Ft","\t\tf := F64(xp)","\t\tif x == 0 {","\t\t\tf = F64reinterpret_i64(uint64(0x7FF0000000000000))","\t\t}","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\tf = F64min(f, F64(yp))","\t\t\typ += 8","\t\t}","\t\treturn Kf(f)","\tdefault:","\t\treturn 0","\t}","}","func max(x K, yp int32, t T, n int32) K { // |/x","\txp := int32(x)","\tswitch t - 17 {","\tcase 0: // Bt","\t\treturn Kb(maxi(xp, any(yp, n)))","\tcase 1: // Ct","\t\tif x == 0 {","\t\t\txp = -128","\t\t}","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\txp = maxi(xp, I8(yp+i))","\t\t}","\t\treturn Kc(xp)","\tcase 2: // It","\t\tif x == 0 {","\t\t\txp = nai","\t\t}","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\txp = maxi(xp, I32(yp))","\t\t\typ += 4","\t\t}","\t\treturn Ki(xp)","\tcase 3: // St","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\txp = maxi(xp, I32(yp))","\t\t\typ += 4","\t\t}","\t\treturn Ks(xp)","\tcase 4: // Ft","\t\tf := F64(xp)","\t\tif x == 0 {","\t\t\tf = F64reinterpret_i64(uint64(0xFFF0000000000000))","\t\t}","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\tf = F64max(f, F64(yp))","\t\t\typ += 8","\t\t}","\t\treturn Kf(f)","\tdefault:","\t\treturn 0","\t}","}","func sum(x K, yp int32, t T, n int32) K { // +/x","\txp := int32(x)","\tswitch t - 17 {","\tcase 0: // Bt","\t\treturn Ki(xp + sumb(yp, n))","\tcase 1: // Ct","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\txp += I8(yp + i)","\t\t}","\t\treturn Kc(xp)","\tcase 2: // It","\t\treturn Ki(xp + sumi(yp, n))","\tcase 3: // St","\t\treturn 0","\tcase 4: // Ft","\t\tf := F64(xp)","\t\tif x == 0 {","\t\t\tf = 0.0","\t\t}","\t\treturn Kf(f + sumf(yp, n, 8))","\tcase 5: // Zt","\t\tvar re, im float64","\t\tif x != 0 {","\t\t\tre, im = F64(xp), F64(xp+8)","\t\t}","\t\treturn Kz(re+sumf(yp, n, 16), im+sumf(yp+8, n, 16))","\tdefault:","\t\treturn 0","\t}","}","func sumb(xp, xn int32) (r int32) {","\te := xp + xn","\tve := e \u0026^ 7","\tvar s int64","\tfor xp \u003c ve { // todo: I8x16popcnt when ready: https://github.com/WebAssembly/simd/pull/379","\t\ts += I64popcnt(uint64(I64(xp)))","\t\txp += 8","\t}","\tr = int32(s)","\tfor xp \u003c e {","\t\tr += I8(xp)","\t\txp++","\t}","\treturn r","}","func sumi(xp, xn int32) (r int32) {","\te := xp + 4*xn","\tfor xp \u003c e {","\t\tr += I32(xp)","\t\txp += 4","\t}","\treturn r","}","func sumf(xp, n, s int32) (r float64) {","\tif n \u003c 128 {","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\tr += F64(xp)","\t\t\txp += s","\t\t}","\t\treturn r","\t}","\tm := n / 2","\treturn sumf(xp, m, s) + sumf(xp+s*m, n-m, s)","}","func prd(x K, yp int32, t T, n int32) K { // */x","\txp := int32(x)","\tswitch t - 17 {","\tcase 0: // Bt","\t\tif x == 0 {","\t\t\txp = 1","\t\t}","\t\treturn Kb(mini(xp, all(yp, n)))","\tcase 1: // Ct","\t\tif x == 0 {","\t\t\txp = 1","\t\t}","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\txp *= I8(yp + i)","\t\t}","\t\treturn Kc(xp)","\tcase 2: // It","\t\tif x == 0 {","\t\t\txp = 1","\t\t}","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\txp *= I32(yp)","\t\t\typ += 4","\t\t}","\t\treturn Ki(xp)","\tcase 3: // St","\t\treturn 0","\tcase 4: // Ft","\t\tf := F64(xp)","\t\tif x == 0 {","\t\t\tf = 1.0","\t\t}","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\tf *= F64(yp)","\t\t\typ += 8","\t\t}","\t\treturn Kf(f)","\tdefault:","\t\treturn 0","\t}","}","","func sums(x K, yp int32, t T, n int32) (r K) {","\tif t != Bt \u0026\u0026 t != It {","\t\treturn 0","\t}","\tr = mk(It, n)","\trp := int32(r)","\ts := int32(x)","\te := yp","\tif t == Bt {","\t\te += n","\t\tfor yp \u003c e {","\t\t\ts += I8(yp)","\t\t\tSetI32(rp, s)","\t\t\trp += 4","\t\t\typ++","\t\t\tcontinue","\t\t}","\t} else {","\t\te += 4 * n","\t\tfor yp \u003c e {","\t\t\ts += I32(yp)","\t\t\tSetI32(rp, s)","\t\t\trp += 4","\t\t\typ += 4","\t\t\tcontinue","\t\t}","\t}","\treturn r","}","func prds(x K, yp int32, t T, n int32) (r K) {","\tif t != It {","\t\treturn 0","\t}","\tr = mk(It, n)","\trp := int32(r)","\ts := int32(x)","\tif x == 0 {","\t\ts = 1","\t}","\te := yp + 4*n","\tfor yp \u003c e {","\t\ts *= I32(yp)","\t\tSetI32(rp, s)","\t\trp += 4","\t\typ += 4","\t\tcontinue","\t}","\treturn r","}","func mins(x K, yp int32, t T, n int32) K {","\tif t != Bt {","\t\treturn 0","\t} else {","\t\treturn 0","\t}","}","func maxs(x K, yp int32, t T, n int32) K {","\tif t != Bt || x != 0 {","\t\treturn 0","\t} else {","\t\ti := int32(fwh(yp, n))","\t\tr := mk(Bt, n)","\t\trp := int32(r)","\t\tif i \u003c 0 {","\t\t\ti = n","\t\t}","\t\tMemoryfill(rp, 0, i)","\t\tMemoryfill(rp+i, 1, n-i)","\t\treturn r","\t}","}",""],"sort.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func Srt(x K) (r K) { // ^x","\txt := tp(x)","\tif xt \u003c 16 {","\t\ttrap(Type)","\t}","\tif xt == Dt {","\t\tr, x = spl2(x)","\t\ti := Asc(rx(x))","\t\treturn Key(atv(r, rx(i)), atv(x, i))","\t}","\txn := nn(x)","\tif xn \u003c 2 {","\t\treturn x","\t}","\tswitch xt - 17 {","\tcase 0:","\t\tr = srtB(x, xn)","\tcase 1:","\t\tr = srtC(x, xn)","\tcase 2:","\t\tr = srtI(x, xn)","\tcase 3:","\t\tr = srtI(x, xn)","\tcase 4:","\t\tr = srtF(x, xn)","\tdefault:","\t\tr = atv(x, Asc(rx(x)))","\t}","\treturn r","}","func Asc(x K) K { // \u003cx  \u003c`file","\tif tp(x) == st {","\t\treturn readfile(cs(x))","\t}","\treturn grade(x, 343)","}","func Dsc(x K) K { return grade(x, 336) } // \u003ex","func grade(x K, f int32) (r K) { // \u003cx \u003ex","\txt := tp(x)","\tif xt \u003c 16 {","\t\ttrap(Type)","\t}","\tif xt == Dt {","\t\tr, x = spl2(x)","\t\treturn Atx(r, grade(x, f))","\t}","\tn := nn(x)","\tif xt == Tt {","\t\treturn kxy(104, x, Kb(I32B(f == 336))) //gdt ngn:{(!#x){x@\u003cy x}/|.+x}","\t}","\tif n \u003c 2 {","\t\tdx(x)","\t\treturn seq(n)","\t}","\tr = seq(n)","\trp := int32(r)","\txp := int32(x)","\tif n \u003c 16 {","\t\tigrd(rp, xp, n, sz(xt), f+int32(xt))","\t} else {","\t\tw := mk(It, n)","\t\twp := int32(w)","\t\tMemorycopy(wp, rp, 4*n)","\t\tmsrt(wp, rp, 0, n, xp, sz(xt), f+int32(xt))","\t\tdx(w)","\t}","\tdx(x)","\treturn r","}","func srtB(x K, n int32) (r K) { // ^B","\tr = mk(Bt, n)","\trp := int32(r)","\ts := n - sumb(int32(x), n)","\tMemoryfill(rp, 0, s)","\tMemoryfill(rp+s, 1, n-s)","\tdx(x)","\treturn r","}","func srtC(x K, n int32) (r K) {","\tr = mk(Ct, n)","\ty := ntake(256, Ki(0))","\typ := int32(y)","\txp := int32(x)","\tfor i := int32(0); i \u003c n; i++ {","\t\tp := yp + 4*I8(xp+i)","\t\tSetI32(p, 1+I32(p))","\t\tcontinue","\t}","\trp := int32(r)","\tfor i := int32(0); i \u003c 256; i++ {","\t\ts := I32(yp + 4*i)","\t\tMemoryfill(rp, i, s)","\t\trp += s","\t\tcontinue","\t}","\tdx(x)","\tdx(y)","\treturn r","}","func srtI(x K, n int32) K {","\tif n \u003c 32 {","\t\tx = use(x)","\t\tisrtsI(int32(x), n)","\t\treturn x","\t}","\t// return atv(x, Asc(rx(x))) // merge?","\treturn radixI(x, n)","}","func srtF(x K, n int32) K {","\tif n \u003c 32 { // todo limit?","\t\treturn atv(x, Asc(rx(x)))","\t}","\treturn radixF(x, n)","}","func isrtsI(xp, n int32) { // insertion sort ints inplace","\tfor i := int32(1); i \u003c n; i++ {","\t\tx := I32(xp + 4*i)","\t\tj := i - 1","\t\tfor j \u003e= 0 \u0026\u0026 I32(xp+4*j) \u003e x {","\t\t\tjj := xp + 4*j","\t\t\tSetI32(4+jj, I32(jj))","\t\t\tj--","\t\t}","\t\tSetI32(xp+4+4*j, x)","\t\tcontinue","\t}","}","","func msrt(x, r, a, b, p, s, f int32) {","\tif b-a \u003c 2 {","\t\treturn","\t}","\tc := (a + b) \u003e\u003e 1","\tmsrt(r, x, a, c, p, s, f)","\tmsrt(r, x, c, b, p, s, f)","\tmrge(x, r, 4*a, 4*b, 4*c, p, s, f)","}","func mrge(x, r, a, b, c, p, s, f int32) {","\ti, j := a, c","\tvar q int32","\tfor k := a; k \u003c b; k += 4 {","\t\tif i \u003c c \u0026\u0026 j \u003c b {","\t\t\tq = Func[f].(f2i)(p+s*I32(x+i), p+s*I32(x+j))","\t\t} else {","\t\t\tq = 0","\t\t}","\t\tif i \u003e= c || q != 0 {","\t\t\tSetI32(r+k, I32(x+j))","\t\t\tj += 4","\t\t} else {","\t\t\tSetI32(r+k, I32(x+i))","\t\t\ti += 4","\t\t}","\t}","}","","func igrd(rp, xp, n, s, f int32) { // insertion grade with comparison","\tfor i := int32(1); i \u003c n; i++ { // f: gt(\u003c) lt(\u003e)","\t\tx := I32(rp + 4*i)","\t\tj := i - 1","\t\tfor j \u003e= 0 {","\t\t\tif Func[f].(f2i)(xp+s*I32(rp+4*j), xp+s*x) == 0 {","\t\t\t\tbreak","\t\t\t}","\t\t\tjj := rp + 4*j","\t\t\tSetI32(4+jj, I32(jj))","\t\t\tj--","\t\t}","\t\tSetI32(rp+4+4*j, x)","\t\tcontinue","\t}","}","","func radixI(x K, n int32) K { // ^I  see:shawnsmithdev/zermelo","\tx = use(x)","\tb := ntake(n, Ki(0))","\to := mk(It, 256)","\tn *= 4","\top := int32(o)","\tfr := int32(x)","\tto := int32(b)","L:","\tfor ko := int32(0); ko \u003c 32; ko += 8 {","\t\ts := int32(1)","\t\tvar prev int32 = nai","\t\tMemoryfill(op, 0, 1024)","\t\tfor i := int32(0); i \u003c n; i += 4 {","\t\t\te := I32(fr + i)","\t\t\tok := op + 4*(255\u0026(e\u003e\u003eko))","\t\t\tSetI32(ok, 1+I32(ok))","\t\t\tif s != 0 {","\t\t\t\ts = I32B(e \u003e= prev)","\t\t\t\tprev = e","\t\t\t}","\t\t\tcontinue","\t\t}","\t\tif s != 0 {","\t\t\tif (ko\u003e\u003e3)%2 == 1 {","\t\t\t\tMemorycopy(to, fr, n)","\t\t\t}","\t\t\tbreak L","\t\t}","\t\tw := int32(0)","\t\tif ko == 24 {","\t\t\tw = radixp(op, 0, 128, radixp(op, 128, 256, w))","\t\t} else {","\t\t\tw = radixp(op, 0, 256, w)","\t\t}","\t\tfor i := int32(0); i \u003c n; i += 4 {","\t\t\te := I32(fr + i)","\t\t\tok := op + 4*(255\u0026(e\u003e\u003eko))","\t\t\tSetI32(to+4*I32(ok), e)","\t\t\tSetI32(ok, 1+I32(ok))","\t\t\tcontinue","\t\t}","\t\tto, fr = swap(to, fr)","\t}","\tdx(o)","\tdx(b)","\treturn x","}","func radixp(op, a, b, w int32) int32 {","\top += 4 * a","\tfor i := a; i \u003c b; i++ {","\t\tc := I32(op)","\t\tSetI32(op, w)","\t\tw += c","\t\top += 4","\t\tcontinue","\t}","\treturn w","}","func radixF(x K, n int32) K { // ^F","\tx = use(x)","\tb := ntake(n, Kf(0))","\to := mk(It, 256)","\tn *= 8","\top := int32(o)","","\txp := int32(x)","\tna := int32(0)","\tfor i := int32(0); i \u003c n; i += 8 {","\t\tv := F64(xp + i)","\t\tif v != v {","\t\t\tSetF64(xp+i, F64(xp+na))","\t\t\tSetF64(xp+na, v)","\t\t\tna += 8","\t\t}","\t}","\tfr := int32(x) + na","\tto := int32(b)","\tn -= na","","\tvar u uint64","L:","\tfor ko := int32(0); ko \u003c 64; ko += 8 {","\t\ts := int32(1)","\t\tprev := float64(0)","\t\tMemoryfill(op, 0, 1024)","\t\tfor i := int32(0); i \u003c n; i += 8 {","\t\t\tu = floatflp(uint64(I64(fr + i)))","\t\t\tok := op + 4*int32(255\u0026(u\u003e\u003euint64(ko)))","\t\t\tSetI32(ok, 1+I32(ok))","\t\t\tif s != 0 {","\t\t\t\tv := F64(fr + i)","\t\t\t\ts = I32B(v \u003e= prev)","\t\t\t\tprev = v","\t\t\t}","\t\t}","\t\tif s != 0 {","\t\t\tif (ko\u003e\u003e3)%2 == 1 {","\t\t\t\tMemorycopy(to, fr, n)","\t\t\t}","\t\t\tbreak L","\t\t}","\t\tradixp(op, 0, 256, 0)","\t\tfor i := int32(0); i \u003c n; i += 8 {","\t\t\tv := I64(fr + i)","\t\t\tu = floatflp(uint64(v))","\t\t\tok := op + 4*int32(255\u0026(u\u003e\u003euint64(ko)))","\t\t\tSetI64(to+8*I32(ok), v)","\t\t\tSetI32(ok, 1+I32(ok))","\t\t}","\t\tto, fr = swap(to, fr)","\t}","\tdx(o)","\tdx(b)","\treturn x","}","func floatflp(x uint64) uint64 {","\tif (x \u0026 0x8000000000000000) == 0x8000000000000000 {","\t\treturn x ^ 0xFFFFFFFFFFFFFFFF","\t}","\treturn x ^ 0x8000000000000000","}","","func swap(x, y int32) (int32, int32) { return y, x }","","func guC(xp, yp int32) int32 { return I32B(I8(xp) \u003c I8(yp)) }","func guI(xp, yp int32) int32 { return I32B(I32(xp) \u003c I32(yp)) }","func guF(xp, yp int32) int32 { return ltf(F64(xp), F64(yp)) }","func guZ(xp, yp int32) int32 { return ltz(F64(xp), F64(xp+8), F64(yp), F64(yp+8)) }","func guL(xp, yp int32) int32 { return ltL(K(I64(xp)), K(I64(yp))) }","","func gdC(xp, yp int32) int32 { return I32B(I8(xp) \u003e I8(yp)) }","func gdI(xp, yp int32) int32 { return I32B(I32(xp) \u003e I32(yp)) }","func gdF(xp, yp int32) int32 { return guF(yp, xp) }","func gdZ(xp, yp int32) int32 { return guZ(yp, xp) }","func gdL(xp, yp int32) int32 { return guL(yp, xp) }","","func ltL(x, y K) (r int32) { // sort lists lexically","\txt := tp(x)","\tif xt != tp(y) {","\t\treturn I32B(xt \u003c tp(y))","\t}","\tif xt \u003c 16 {","\t\treturn int32(Les(rx(x), rx(y)))","\t}","\txp, yp := int32(x), int32(y)","\tif xt \u003e Lt {","\t\ta, b := K(I64(xp)), K(I64(yp))","\t\tif match(a, b) == 0 {","\t\t\treturn ltL(a, b)","\t\t}","\t\treturn ltL(K(I64(xp+8)), K(I64(yp+8)))","\t}","\txn, yn := nn(x), nn(y)","\tn := mini(xn, yn)","\tswitch sz(xt) \u003e\u003e 2 {","\tcase 0:","\t\tr = taoC(xp, yp, n)","\tcase 1:","\t\tr = taoI(xp, yp, n)","\tcase 2:","\t\tif xt == Lt {","\t\t\tr = taoL(xp, yp, n)","\t\t} else {","\t\t\tr = taoF(xp, yp, n)","\t\t}","\tdefault:","\t\tr = taoZ(xp, yp, n)","\t}","\tif r == 2 {","\t\treturn I32B(xn \u003c yn)","\t} else {","\t\treturn r","\t}","}","func taoC(xp, yp, n int32) int32 {","\te := xp + n","\tfor xp \u003c e {","\t\tif I8(xp) != I8(yp) {","\t\t\treturn I32B(I8(xp) \u003c I8(yp))","\t\t}","\t\typ++","\t\txp++","\t}","\treturn 2","}","func taoI(xp, yp, n int32) int32 {","\te := xp + 4*n","\tfor xp \u003c e {","\t\tif I32(xp) != I32(yp) {","\t\t\treturn I32B(I32(xp) \u003c I32(yp))","\t\t}","\t\typ += 4","\t\txp += 4","\t}","\treturn 2","}","func taoL(xp, yp, n int32) int32 {","\te := xp + 8*n","\tfor xp \u003c e {","\t\tx, y := K(I64(xp)), K(I64(yp))","\t\tif match(x, y) == 0 {","\t\t\treturn ltL(x, y)","\t\t}","\t\typ += 8","\t\txp += 8","\t}","\treturn 2","}","func taoF(xp, yp, n int32) int32 {","\te := xp + 8*n","\tfor xp \u003c e {","\t\tx, y := F64(xp), F64(yp)","\t\tif eqf(x, y) == 0 {","\t\t\treturn ltf(x, y)","\t\t}","\t\typ += 8","\t\txp += 8","\t}","\treturn 2","}","func taoZ(xp, yp, n int32) int32 {","\te := xp + 16*n","\tfor xp \u003c e {","\t\txr, xi, yr, yi := F64(xp), F64(xp+8), F64(yp), F64(yp+8)","\t\tif eqz(xr, xi, yr, yi) == 0 {","\t\t\treturn ltz(xr, xi, yr, yi)","\t\t}","\t\typ += 16","\t\txp += 16","\t}","\treturn 2","}",""],"string.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func Kst(x K) K { return Atx(Ks(32), x) } // `k@","func Lst(x K) K { return Atx(Ks(40), x) } // `l@","","/*","func Kst(x K) (r K) {","\txt := tp(x)","\tif xt \u003c 16 {","\t\tr = Str(x)","\t\tif xt == ct {","\t\t\tr = emb(34, 34, r)","\t\t} else if xt == st {","\t\t\tr = ucat(Ku(96), r)","\t\t}","\t} else {","\t\txn := nn(x)","\t\tif xn == 0 {","\t\t\tdx(x)","\t\t\treturn kst0(xt - 17)","\t\t}","\t\tif xt == Lt {","\t\t\tx = Ech(28, l1(x)) // Kst","\t\t} else if xt \u003c Lt \u0026\u0026 xt != Ct {","\t\t\tx = Str(x)","\t\t}","\t\tswitch xt - 17 {","\t\tcase 0:","\t\t\tr = cat1(Ech(4, l1(x)), Kc('b'))","\t\tcase 1:","\t\t\tr = emb(34, 34, x)","\t\tcase 2:","\t\t\tr = join(Kc(' '), x)","\t\tcase 3:","\t\t\tr = ucat(Ku(96), join(Kc('`'), x))","\t\tcase 4:","\t\t\tr = join(Kc(' '), x)","\t\tcase 5:","\t\t\tr = join(Kc(' '), x)","\t\tcase 6:","\t\t\tif xn == 1 {","\t\t\t\tr = Fst(x)","\t\t\t} else {","\t\t\t\tr = emb(40, 41, join(Kc(';'), x))","\t\t\t}","\t\t\tr = r","\t\tcase 7: // Dt","\t\t\tx, r = spl2(x)","\t\t\tx = Kst(x)","\t\t\tif xn == 1 {","\t\t\t\tx = emb(40, 41, x)","\t\t\t\txn = 0","\t\t\t}","\t\t\tr = ucat(cat1(x, Kc('!')), Kst(r)) // todo ()!..","\t\tdefault:","\t\t\txn = 0","\t\t\tr = ucat(Ku(43), Kst(Flp(x)))","\t\t}","\t\tif xn == 1 {","\t\t\tr = ucat(Ku(44), r)","\t\t}","\t}","\treturn r","}","func kst0(t T) (r K) {","\tswitch t {","\tcase 0:","\t\tr = 1647321904 // 0#0b","\tcase 1:","\t\tr = 8738 // \"\"","\tcase 2:","\t\tr = 12321 // !0","\tcase 3:","\t\tr = 6300464 // 0#`","\tcase 4:","\t\tr = 774906672 // 0#0.","\tcase 5:","\t\tr = 1630544688 // 0#0a","\tcase 6:","\t\tr = 10536 // ()","\tdefault:","\t\tr = trap(Nyi)","\t}","\treturn Ku(uint64(r))","}","func Lst(x K) (r K) { // `l@  matrix-output (list-of-chars)","\txt := tp(x)","\tif xt \u003c Lt {","\t\treturn Str(x)","\t}","\tn := nn(x)","\tswitch xt - Lt {","\tcase 0: // Lt","\t\tr = mk(Lt, n)","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\txi := x0(int32(x) + 8*i)","\t\t\tti := tp(xi)","\t\t\tif ti == ct {","\t\t\t\txi = Enl(xi)","\t\t\t} else if ti != Ct {","\t\t\t\txi = Kst(xi)","\t\t\t}","\t\t\tSetI64(int32(r)+8*i, int64(xi))","\t\t}","\t\treturn r","\tcase 1: // Dt","\t\tr, x = spl2(x)","\t\treturn Ech(13, l2(Ecl(13, l2(pads(Lst(r)), Kc('|'))), Lst(x)))","\tdefault: // Tt","\t\treturn trap(Nyi)","\t}","}","func pads(x K) (r K) { // padl","\tn := nn(x)","\tr = mk(Lt, n)","\trp := int32(r)","\txp := int32(x)","\tm := maxcount(xp, n)","\tfor i := int32(0); i \u003c n; i++ {","\t\tSetI64(rp, int64(ntake(m, x0(xp))))","\t\trp += 8","\t\txp += 8","\t}","\tdx(x)","\treturn r","}","*/","","func Str(x K) (r K) {","\txt := tp(x)","\tif xt \u003e 16 {","\t\treturn Ech(17, l1(x))","\t}","\txp := int32(x)","\tif xt \u003e dt {","\t\tswitch xt - cf {","\t\tcase 0: // cf","\t\t\trx(x)","\t\t\tr = ucats(Rev(Str(K(xp) | K(Lt)\u003c\u003c59)))","\t\tcase 1: // df","\t\t\tr = Str(x0(xp))","\t\t\tp := x1(xp)","\t\t\tif int32(p)%2 != 0 {","\t\t\t\tp = cat1(Str(20+p), Kc(':'))","\t\t\t} else {","\t\t\t\tp = Str(21 + p)","\t\t\t}","\t\t\tr = ucat(r, p)","\t\tcase 2: //pf","\t\t\tf, l, i := spl3(rx(x))","\t\t\tft := tp(f)","\t\t\tf = Str(f)","\t\t\tdx(i)","\t\t\tif nn(i) == 1 \u0026\u0026 I32(int32(i)) == 1 \u0026\u0026 (ft == 0 || ft == df) {","\t\t\t\tr = ucat(Kst(Fst(l)), f)","\t\t\t} else {","\t\t\t\tr = ucat(f, emb('[', ']', ndrop(-1, ndrop(1, Kst(l)))))","\t\t\t}","\t\tcase 3: //lf","\t\t\tr = x2(xp)","\t\tdefault: // native","\t\t\tr = x1(xp)","\t\t}","\t\tdx(x)","\t\treturn r","\t} else {","\t\tswitch xt {","\t\tcase 0:","\t\t\tif xp \u003e 448 {","\t\t\t\treturn Str(K(xp) - 448)","\t\t\t}","\t\t\tswitch xp \u003e\u003e 6 {","\t\t\tcase 0: //  0..63  monadic","\t\t\tcase 1: // 64..127 dyadic","\t\t\t\txp -= 64","\t\t\tcase 2: // 128     dyadic indirect","\t\t\t\txp -= 128","\t\t\tcase 3: // 192     tetradic","\t\t\t\txp -= 192","\t\t\tdefault:","\t\t\t\treturn ucat(Ku('`'), si(xp))","\t\t\t}","\t\t\tr = Ku(uint64(I8(227 + xp)))","\t\tcase bt:","\t\t\tr = Ku(uint64(25136 + xp)) // 0b 1b","\t\tcase ct:","\t\t\tr = Ku(uint64(xp))","\t\tcase it:","\t\t\tr = si(xp)","\t\tcase st:","\t\t\tr = cs(x)","\t\tcase ft:","\t\t\tr = sf(F64(xp))","\t\tcase zt:","\t\t\tr = sfz(F64(xp), F64(xp+8))","\t\tdefault:","\t\t\tr = trap(Err)","\t\t}","\t}","\tdx(x)","\treturn r","}","func emb(a, b int32, x K) K { return cat1(Cat(Kc(a), x), Kc(b)) }","func si(x int32) (r K) {","\tif x == 0 {","\t\treturn Ku(uint64('0'))","\t} else if x == nai {","\t\treturn Ku(20016) // 0N","\t} else if x \u003c 0 {","\t\treturn ucat(Ku(uint64('-')), si(-x))","\t}","\tr = mk(Ct, 0)","\tfor x != 0 {","\t\tr = cat1(r, Kc('0'+x%10))","\t\tx /= 10","\t}","\treturn Rev(r)","}","func sf(x float64) (r K) {","\tif x != x {","\t\treturn Ku(28208) // 0n","\t}","\tu := uint64(I64reinterpret_f64(x))","\tif u == uint64(0x7FF0000000000000) {","\t\treturn Ku(30512) // 0w","\t} else if u == uint64(0xFFF0000000000000) {","\t\treturn Ku(7811117) // -0w","\t}","\tif x \u003c 0 {","\t\treturn ucat(Ku(uint64('-')), sf(-x))","\t}","\tif x \u003e 0 \u0026\u0026 (x \u003e= 1e6 || x \u003c= 1e-6) {","\t\treturn se(x)","\t}","\tr = mk(Ct, 0)","\t/*","\t\tu = uint64(x)","\t\tif u == 0 {","\t\t\tr = cat1(r, Kc('0'))","\t\t}","\t\tfor u != 0 {","\t\t\tr = cat1(r, Kc(int32('0'+u%10)))","\t\t\tu /= 10","\t\t}","\t*/","","\ti := int64(x)","\tif i == 0 {","\t\tr = cat1(r, Kc('0'))","\t}","\tfor i != 0 {","\t\tr = cat1(r, Kc(int32('0'+i%10)))","\t\ti /= 10","\t}","","\tr = Rev(r)","\tr = cat1(r, Kc('.'))","\tx -= F64floor(x)","\tfor i := int32(0); i \u003c 6; i++ {","\t\tx *= 10","\t\tr = cat1(r, Kc('0'+(int32(x)%10)))","\t\tcontinue","\t}","\tn := nn(r)","\trp := int32(r)","\tvar c int32","\tfor i := int32(0); i \u003c n; i++ {","\t\tif I8(rp) == '0' {","\t\t\tc++","\t\t} else {","\t\t\tc = 0","\t\t}","\t\trp++","\t}","\treturn ndrop(-c, r)","}","func se(x float64) K {","\tf, e := frexp(x)","\tx = 0.3010299956639812 * float64(e) // log10(2)*","\tei := int32(F64floor(x))","\tx = x - float64(ei)","\treturn ucat(cat1(sf(f*pow(10.0, x)), Kc('e')), si(ei))","}","func sfz(re, im float64) (r K) {","\tif (re != re) || (im != im) {","\t\treturn Ku(6385200) // 0na","\t}","\tz := hypot(re, im)","\ta := ang2(im, re)","\tr = cat1(trdot(sf(z)), Kc('a'))","\tif a != 0.0 {","\t\tr = ucat(r, trdot(sf(a)))","\t}","\treturn r","}","func trdot(x K) K {","\tn := nn(x)","\tif I8(int32(x)+n-1) == '.' {","\t\treturn ndrop(-1, x)","\t}","\treturn x","}","","func Cst(x, y K) K { // x$y","\tyt := tp(y)","\tif yt \u003e Zt {","\t\treturn Ecr(17, l2(x, y))","\t}","\tif yt == ct {","\t\ty, yt = Enl(y), Ct","\t}","\tif tp(x) != st || yt != Ct {","\t\ttrap(Type)","\t}","\tif int32(x) == 0 { // `$\"sym\"","\t\treturn sc(y)","\t}","\treturn prs(ts(x), y)","}","func prs(t T, y K) (r K) { // s$C","\typ, yn := int32(y), nn(y)","\tp, e := pp, pe","\tpp = yp","\tpe = yp + yn","\ttt := t \u0026 15","\tif tt == 1 {","\t\tr = tbln()","\t}","\tif tt == 2 {","\t\tif t == Ct {","\t\t\treturn y // `C$","\t\t} else {","\t\t\treturn Fst(y) // `c$\"x\"","\t\t}","\t}","\tif t == 4 {","\t\tr = Fst(tsym()) // `s$\"`a\"","\t} else if t \u003e 2 \u0026\u0026 t \u003c= 6 {","\t\tr = tnum()","\t\tif tp(r) \u003c t \u0026\u0026 r != 0 {","\t\t\tr = uptype(r, t) // `f$\"1\"","\t\t}","\t}","\tif t \u003e Ct \u0026\u0026 t \u003c Lt {","\t\tif pp == pe {","\t\t\tr = mk(t, 0) // `I$\"\" -\u003e !0","\t\t} else {","\t\t\tif t == 20 {","\t\t\t\tr = tsym() // `S$\"`a`b\"","\t\t\t} else {","\t\t\t\tr = tnms()","\t\t\t\tif tp(r)\u002615 \u003c t\u002615 \u0026\u0026 r != 0 {","\t\t\t\t\tr = uptype(r, t\u002615) // `F$\"1 2\"","\t\t\t\t}","\t\t\t}","\t\t\tif tp(r) == t-16 {","\t\t\t\tr = Enl(r) // `I$\"1\" -\u003e ,1","\t\t\t}","\t\t}","\t}","\tif tp(r) != t || pp \u003c pe {","\t\tdx(r)","\t\tr = 0","\t}","\tpp, pe = p, e","\tdx(y)","\treturn r //0(parse error)","}","func ts(x K) T {","\tc := int32(Fst(cs(x)))","\tfor i := int32(520); i \u003c 546; i++ {","\t\tif I8(i) == c {","\t\t\treturn T(i - 520)","\t\t}","\t\tcontinue","\t}","\ttrap(Value)","\treturn 0","}","","func Rtp(y K, x K) K { // `b@ `c@ `i@ `s@ `f@ `z@ (reinterpret data)","\tt := ts(y)","\txt := tp(x)","\tt += T(16 * I32B(t \u003c 16))","\tif xt \u003c 16 || t \u003c 17 || t \u003e Zt {","\t\ttrap(Type)","\t}","\tn := nn(x) * sz(xt)","\ts := sz(t)","\tif n%s != 0 {","\t\ttrap(Length)","\t}","\tx = use(x)","\tSetI32(int32(x)-12, n/s)","\tx = K(t)\u003c\u003c59 | K(int32(x))","\tif t == Bt {","\t\treturn Not(Eql(Kb(0), x))","\t} // todo: St may contain non-multiples of 8 or out-of-range values","\treturn x","}",""],"system.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func main() { // _start","\tkinit()","\tdoargs()","\twrite(Ku(2932601077199979)) // \"ktye/k\\n\"","\tstore()","\tfor {","\t\twrite(Ku(32))","\t\tx := read()","\t\ttry(x)","\t}","}","func store() {","\tg := (1 \u003c\u003c (I32(128) - 16)) - Memorysize2()","\tif g \u003e 0 {","\t\tMemorygrow2(g)","\t}","\tMemorycopy2(0, 0, 1\u003c\u003cI32(128))","}","func catch() {","\tMemorycopy3(0, 0, int32(65536)*Memorysize2())","}","func try(x K) {","\tdefer Catch(catch)","\trepl(x)","\tstore()","}","func repl(x K) {","\tn := nn(x)","\txp := int32(x)","\ts := int32(0)","\tif n \u003e 0 {","\t\ts = I8(xp)","\t\tif I8(xp) == 92 { // \\","\t\t\tif n == 1 {","\t\t\t\thelp()","\t\t\t} else {","\t\t\t\tc := I8(1 + xp)","\t\t\t\tif I8(1+xp) == '\\\\' {","\t\t\t\t\tExit(0)","\t\t\t\t} else if c == 'm' {","\t\t\t\t\tdx(x)","\t\t\t\t\tdx(Out(Ki(I32(128))))","\t\t\t\t} else if c == 'c' {","\t\t\t\t\tdx(x)","\t\t\t\t\treset()","\t\t\t\t}","\t\t\t}","\t\t\treturn","\t\t}","\t}","\tx = val(x)","\tif x != 0 {","\t\tif s == 32 {","\t\t\tdx(Out(x))","\t\t} else {","\t\t\twrite(cat1(join(Kc(10), Lst(x)), Kc(10)))","\t\t}","\t}","}","func doargs() {","\ta := ndrop(1, getargv())","\tan := nn(a)","\tap := int32(a)","\tee := Ku(25901) // -e","\tfor i := int32(0); i \u003c an; i++ {","\t\tx := x0(ap)","\t\tif match(x, ee) != 0 { // -e (exit)","\t\t\tif i \u003c an-1 {","\t\t\t\tdx(x)","\t\t\t\tx = x1(ap)","\t\t\t\tdx(ee)","\t\t\t\tdx(a)","\t\t\t\trepl(x)","\t\t\t}","\t\t\tExit(0)","\t\t}","\t\tdofile(x, readfile(rx(x)))","\t\tap += 8","\t}","\tdx(ee)","\tdx(a)","}","func dofile(x K, c K) {","\tkk := Ku(27438) // .k","\ttt := Ku(29742) // .t","\txe := ntake(-2, rx(x))","\tif match(xe, kk) != 0 { // file.k (execute)","\t\tdx(val(c))","\t} else if match(xe, tt) != 0 { // file.t (test)","\t\ttest(c)","\t} else { // file (assign file:bytes..)","\t\tdx(Asn(sc(rx(x)), c))","\t}","\tdx(xe)","\tdx(x)","\tdx(tt)","\tdx(kk)","}","","func Out(x K) K {","\twrite(cat1(Kst(rx(x)), Kc(10)))","\treturn x","}","func Otu(x, y K) K {","\twrite(cat1(Kst(x), Kc(':')))","\treturn Out(y)","}","func read() (r K) {","\tr = mk(Ct, 504)","\treturn ntake(ReadIn(int32(r), 504), r)","}","func write(x K) {","\tWrite(0, 0, int32(x), nn(x))","\tdx(x)","}","func getargv() (r K) {","\tn := Args()","\tr = mk(Lt, n)","\trp := int32(r)","\tfor i := int32(0); i \u003c n; i++ {","\t\ts := mk(Ct, Arg(i, 0))","\t\tArg(i, int32(s))","\t\tSetI64(rp, int64(s))","\t\trp += 8","\t}","\treturn r","}","func readfile(x K) (r K) { // x C","\tif nn(x) == 0 {","\t\tr = mk(Ct, 496)","\t\tr = ntake(ReadIn(int32(r), 496), r)","\t\treturn r","\t}","\tn := Read(int32(x), nn(x), 0)","\tif n \u003c 0 {","\t\ttrap(Io)","\t}","\tr = mk(Ct, n)","\tRead(int32(x), nn(x), int32(r))","\tdx(x)","\treturn r","}","func writefile(x, y K) K { // x, y C","\tr := Write(int32(x), nn(x), int32(y), nn(y))","\tif r != 0 {","\t\ttrap(Io)","\t}","\tdx(x)","\treturn y","}","func iwrite(x int32) { write(cat1(Kst(Ki(x)), Kc(10))) }","func help() {","\ttrap(Nyi)","}",""],"test.go":["package main","","func test(x K) {","\tif tp(x) != Ct {","\t\ttrap(Type)","\t}","\tl := ndrop(-1, split(Kc(10), rx(x)))","\tn := nn(l)","\tdx(l)","\tfor i := int32(0); i \u003c n; i++ {","\t\ttesti(rx(x), i)","\t}","\tdx(x)","}","func testi(l K, i int32) {","\tvar x, y K","\tx = split(Ku(12064), ati(split(Kc(10), l), i))","\tif nn(x) != 2 {","\t\ttrap(Length)","\t}","\tx, y = spl2(x)","\tdx(Out(ucat(ucat(rx(x), Ku(12064)), rx(y))))","\tx = Kst(val(x))","\tif match(x, y) == 0 {","\t\tx = Out(x)","\t\ttrap(Err)","\t}","\tdx(x)","\tdx(y)","}",""],"token.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","type ftok = func() K","","func tok(x K) (r K) {","\tvar y K","\tx = cmt(x)","\ts := cat1(src(), Kc(10))","\tpp = nn(s)","\ts = Cat(s, x)  // src contains all src","\tpp += int32(s) // pp is the parser position within src","\tpe = pp + nn(x)","\tr = mk(Lt, 0)","\tfor {","\t\tws()","\t\tif pp == pe {","\t\t\tbreak","\t\t}","\t\tfor i := int32(192); i \u003c 199; i++ { // tbln, tchr, tnms, tvrb, tpct, tvar, tsym","\t\t\ty = Func[i].(ftok)()","\t\t\tif y != 0 {","\t\t\t\ty |= K(int64(pp-int32(s)) \u003c\u003c 32)","\t\t\t\tr = cat1(r, y)","\t\t\t\tbreak","\t\t\t}","\t\t\tif i == 198 { // last-1","\t\t\t\ttrap(Parse)","\t\t\t}","\t\t}","\t}","\tSetI64(552, int64(s))","\treturn r","}","func src() K { return K(I64(552)) }","func tbln() K {","\tn := pe - pp","\tfor i := int32(0); i \u003c n; i++ {","\t\tc := I8(pp + i)","\t\tif c != '0' \u0026\u0026 c != '1' {","\t\t\tif i \u003c 1 || c != 'b' {","\t\t\t\treturn 0","\t\t\t}","\t\t\treturn pbln(i)","\t\t}","\t}","\treturn 0","}","func pbln(n int32) (r K) {","\tr = mk(Bt, n)","\trp := int32(r)","\tfor i := int32(0); i \u003c n; i++ {","\t\tSetI8(rp, I8(pp+i)-'0')","\t\trp++","\t}","\tpp += 1 + n","\tif n == 1 {","\t\treturn Fst(r)","\t}","\treturn r","}","func tchr() (r K) {","\tif I8(pp) == '0' \u0026\u0026 pp \u003c pe { // 0x01ab (lower case only)","\t\tif I8(1+pp) == 'x' {","\t\t\tpp += 2","\t\t\treturn thex()","\t\t}","\t}","\tif I8(pp) != 34 {","\t\treturn 0","\t}","\tpp++","\tr = mk(Ct, 0)","\tvar q int32","\tfor {","\t\tif pp == pe {","\t\t\ttrap(Parse)","\t\t}","\t\tc := I8(pp)","\t\tpp++","\t\tif c == 34 \u0026\u0026 q == 0 {","\t\t\tbreak","\t\t}","\t\tif c == '\\\\' \u0026\u0026 q == 0 {","\t\t\tq = 1","\t\t\tcontinue","\t\t}","\t\tif q != 0 {","\t\t\tc = cq(c)","\t\t\tq = 0","\t\t}","\t\tr = cat1(r, Kc(c))","\t}","\tif nn(r) == 1 {","\t\treturn Fst(r)","\t}","\treturn r","}","func cq(c int32) int32 { // \\t \\n \\r \\\" \\\\   -\u003e 9 10 13 34 92","\tif c == 116 {","\t\treturn 9","\t}","\tif c == 110 {","\t\treturn 10","\t}","\tif c == 114 {","\t\treturn 13","\t}","\treturn c","}","func thex() (r K) {","\tr = mk(Ct, 0)","\tfor pp \u003c pe-1 {","\t\tc := I8(pp)","\t\tif is(c, 128) == 0 {","\t\t\tbreak","\t\t}","\t\tr = cat1(r, Kc((hx(c)\u003c\u003c4)+hx(I8(1+pp))))","\t\tpp += 2","\t}","\tif nn(r) == 1 {","\t\treturn Fst(r)","\t}","\treturn r","}","func hx(c int32) int32 {","\tif is(c, 4) != 0 {","\t\treturn c - '0'","\t} else {","\t\treturn c - 'W'","\t}","}","func tnms() (r K) {","\tr = tnum()","\tfor pp \u003c pe-1 \u0026\u0026 I8(pp) == ' ' {","\t\tpp++","\t\tx := tnum()","\t\tif x == 0 {","\t\t\tbreak","\t\t}","\t\tr = ncat(r, x)","\t}","\treturn r","}","func tnum() (r K) {","\tc := I8(pp)","\tif c == '-' || c == '.' {","\t\tif is(I8(pp-1), 64) != 0 {","\t\t\treturn 0 // e.g. x-1 is (x - 1) not (x -1)","\t\t}","\t}","\tif c == '-' \u0026\u0026 pp \u003c 1+pe {","\t\tpp++","\t\tr = tunm()","\t\tif r == 0 {","\t\t\tpp--","\t\t\treturn 0","\t\t}","\t\treturn Neg(r)","\t}","\treturn tunm()","}","func tunm() K {","\tp := pp","\tr := pu()","\tif r == 0 \u0026\u0026 p == pp {","\t\tif I8(p) == '.' {","\t\t\tif is(I8(1+p), 4) != 0 {","\t\t\t\treturn pflt(r)","\t\t\t}","\t\t}","\t\treturn 0","\t}","\tif pp \u003c pe {","\t\tc := I8(pp)","\t\tif c == '.' {","\t\t\treturn pflt(r)","\t\t}","\t\tif c == 'p' {","\t\t\treturn ppi(float64(r))","\t\t}","\t\tif c == 'a' {","\t\t\treturn pflz(float64(r))","\t\t}","\t\tif c == 'e' || c == 'E' {","\t\t\treturn Kf(pexp(float64(r)))","\t\t}","\t\tif r == 0 {","\t\t\tif c == 'N' {","\t\t\t\tpp++","\t\t\t\treturn missing(it)","\t\t\t}","\t\t\tif c == 'n' || c == 'w' {","\t\t\t\tq := Kf(0)","\t\t\t\tSetI64(int32(q), int64(0x7FF8000000000001)) // 0n","\t\t\t\tif c == 'w' {","\t\t\t\t\tSetF64(int32(q), inf) // 0w","\t\t\t\t}","\t\t\t\tpp++","\t\t\t\tif pp \u003c pe \u0026\u0026 I8(pp) == 'a' {","\t\t\t\t\tdx(q)","\t\t\t\t\treturn pflz(F64(int32(q)))","\t\t\t\t}","\t\t\t\treturn q","\t\t\t}","\t\t}","\t}","\treturn Ki(int32(r))","}","func pu() (r int64) {","\tfor pp \u003c pe {","\t\tc := I8(pp)","\t\tif is(c, 4) == 0 {","\t\t\tbreak","\t\t}","\t\tr = 10*r + int64(c-'0')","\t\tpp++","\t}","\treturn r","}","func pexp(f float64) float64 {","\tpp++","\te := int64(1)","\tif pp \u003c pe {","\t\tc := I8(pp)","\t\tif c == '-' || c == '+' {","\t\t\tif c == '-' {","\t\t\t\te = int64(-1)","\t\t\t}","\t\t\tpp++","\t\t}","\t}","\te *= pu()","\treturn f * pow(10.0, float64(e))","}","func pflt(i int64) K {","\tf := float64(i)","\td := 1.0","\tpp++ // .","\tvar c int32","\tfor pp \u003c pe {","\t\tc = I8(pp)","\t\tif is(c, 4) == 0 {","\t\t\tbreak","\t\t}","\t\td /= 10.0","\t\tf += d * float64(c-'0')","\t\tpp++","\t}","\tif pp \u003c pe {","\t\tc = I8(pp)","\t\tif c == 'e' || c == 'E' {","\t\t\tf = pexp(f)","\t\t}","\t}","\tif pp \u003c pe {","\t\tc = I8(pp)","\t\tif c == 'a' {","\t\t\treturn pflz(f)","\t\t}","\t\tif c == 'p' {","\t\t\treturn ppi(f)","\t\t}","\t}","\treturn Kf(f)","}","func pflz(f float64) (r K) {","\tpp++","\tif pp \u003c pe {","\t\tr = tunm()","\t}","\treturn Rot(Kf(f), r)","}","func ppi(f float64) K {","\tpp++","\treturn Kf(pi * f)","}","","func tvrb() K {","\tc := I8(pp)","\tif is(c, 1) == 0 {","\t\treturn 0","\t}","\tpp++","\tif c == 92 \u0026\u0026 I8(pp-2) == 32 { // \\out","\t\treturn K(29)","\t}","\to := int32(1)","\tif pp \u003c pe {","\t\tif I8(pp) == 58 { // :","\t\t\tpp++","\t\t\tif is(c, 8) != 0 {","\t\t\t\to = 2 // ':","\t\t\t} else {","\t\t\t\to = 97 // +:","\t\t\t}","\t\t}","\t}","\treturn K(o + idx(c, 228, 253))","}","func tpct() K {","\tc := I8(pp)","\tif is(c, 48) != 0 { // ([{}]); \\n","\t\tpp++","\t\treturn K(c)","\t}","\tif c == 10 {","\t\tpp++","\t\treturn K(';')","\t}","\treturn 0","}","func tvar() (r K) {","\tc := I8(pp)","\tif is(c, 2) == 0 {","\t\treturn 0","\t}","\tpp++","\tr = Ku(uint64(c))","\tfor pp \u003c pe {","\t\tc = I8(pp)","\t\tif is(c, 6) == 0 {","\t\t\tbreak","\t\t}","\t\tr = cat1(r, K(c)|K(ct)\u003c\u003c59)","\t\tpp++","\t}","\treturn sc(r)","}","func tsym() (r K) {","\tvar s K","\tfor I8(pp) == 96 {","\t\tpp++","\t\tif r == 0 {","\t\t\tr = mk(St, 0)","\t\t}","\t\ts = 0","\t\tif pp \u003c pe {","\t\t\ts = tchr()","\t\t\tif tp(s) == ct {","\t\t\t\ts = sc(Enl(s))","\t\t\t} else if s != 0 {","\t\t\t\ts = sc(s)","\t\t\t} else {","\t\t\t\ts = tvar()","\t\t\t}","\t\t}","\t\tif s == 0 {","\t\t\ts = K(st) \u003c\u003c 59","\t\t}","\t\tr = cat1(r, s)","\t\tif pp == pe {","\t\t\tbreak","\t\t}","\t}","\treturn r","}","func ws() {","\tfor pp \u003c pe {","\t\tc := I8(pp)","\t\tif c == 10 || c \u003e 32 {","\t\t\tbreak","\t\t}","\t\tpp++","\t}","\treturn","}","func cmt(x K) (r K) {","\tn := nn(x)","\tr = mk(Ct, n)","\tb := int32(1)","\th := int32(0)","\tfor i := int32(0); i \u003c n; i++ {","\t\tc := I8(int32(x) + i)","\t\tif h != 0 {","\t\t\tif c == 10 {","\t\t\t\th = 0","\t\t\t}","\t\t} else {","\t\t\tif c == 47 \u0026\u0026 b != 0 {","\t\t\t\th = 1","\t\t\t} else if c \u003c 33 {","\t\t\t\tb = 1","\t\t\t} else {","\t\t\t\tb = 0","\t\t\t}","\t\t}","\t\tif h != 0 {","\t\t\tc = 32","\t\t}","\t\tSetI8(int32(r)+i, c)","\t}","\tdx(x)","\treturn r","}","","//func is(x, m int32) (r bool) { return m\u0026I8(100+x) != 0 }","func is(x, m int32) int32 { return m \u0026 I8(100+x) }",""],"verbs.go":["package main","","import (","\t. \"github.com/ktye/wg/module\"",")","","func nyi(x K) K { return trap(Nyi) }","func Idy(x K) K { return x } // :x","func Dex(x, y K) K { // x:y","\tdx(x)","\treturn y","}","func Flp(x K) K { // +x","\txt := tp(x)","\tswitch xt - Lt {","\tcase 0: // Lt   n:#x;  m:|/#x (,/m#/:x)[(!m)+\\:m*!n]","\t\tn := nn(x)","\t\txp := int32(x)","\t\tm := Ki(maxcount(xp, n))","\t\tx = Atx(Rdc(13, l1(Ecr(15, l2(m, x)))), Ecl(2, l2(Til(m), Mul(m, Til(Ki(n))))))","\t\treturn x","\tcase 1: // Dt","\t\treturn td(x)","\tcase 2: // Tt","\t\treturn Key(spl2(x))","\tdefault:","\t\treturn x","\t}","}","func maxcount(xp int32, n int32) (r int32) { // |/#l","\tfor i := int32(0); i \u003c n; i++ {","\t\tx := K(I64(xp))","\t\txp += 8","\t\tif tp(x) \u003c 16 {","\t\t\tr = maxi(1, r)","\t\t} else {","\t\t\tr = maxi(nn(x), r)","\t\t}","\t}","\treturn r","}","func Fst(x K) K { // *x","\tt := tp(x)","\tif t \u003c 16 {","\t\treturn x","\t}","\tif t == Dt {","\t\tx = Val(x)","\t}","\treturn ati(x, 0)","}","func Las(x K) K { // *|x","\tt := tp(x)","\tif t \u003c 16 {","\t\treturn x","\t}","\tif t == Dt {","\t\tx = Val(x)","\t}","\tn := nn(x)","\tif n == 0 {","\t\treturn Fst(x)","\t}","\treturn ati(x, n-1)","}","","func Cnt(x K) K { // #x","\tt := tp(x)","\tdx(x)","\tif t \u003c 16 {","\t\treturn Ki(1)","\t}","\treturn Ki(nn(x))","}","func Til(x K) (r K) {","\txt := tp(x)","\tif xt \u003e Lt {","\t\tr = x0(int32(x))","\t\tdx(x)","\t\treturn r","\t}","\tif xt == it {","\t\treturn seq(int32(x))","\t}","\tif xt == It {","\t\treturn kx(120, x) // odo","\t}","\treturn trap(Type)","}","func seq(n int32) (r K) {","\tn = maxi(n, 0)","\tr = mk(It, n)","\tif n == 0 {","\t\treturn r","\t}","\tseqi(int32(r), ep(r))","\treturn r","}","func seqi(p, e int32) {","\tSetI32(p, 0)","\tSetI32(p+4, 1)","\tSetI32(p+8, 2)","\tSetI32(p+12, 3)","\tv := I32x4load(p)","\tw := I32x4splat(4)","\tfor p \u003c e {","\t\tI32x4store(p, v)","\t\tv = v.Add(w)","\t\tp += 16","\t\tcontinue","\t}","}","func Unq(x K) (r K) { // ?x","\txt := tp(x)","\tif xt \u003c 16 {","\t\treturn roll(x)","\t}","\tif xt \u003e= Lt {","\t\tif xt == Dt {","\t\t\ttrap(Type)","\t\t}","\t\tif xt == Tt {","\t\t\tr, x = spl2(x)","\t\t\treturn key(r, Flp(Unq(Flp(x))), xt)","\t\t}","\t\treturn kx(96, x) // .uqf","\t}","\txn := nn(x)","\tr = mk(xt, 0)","\tfor i := int32(0); i \u003c xn; i++ {","\t\txi := ati(rx(x), i)","\t\tif int32(In(rx(xi), rx(r))) == 0 {","\t\t\tr = cat1(r, xi)","\t\t} else {","\t\t\tdx(xi)","\t\t}","\t}","\tdx(x)","\treturn r","}","func Uqs(x K) K { // ?^x","\txt := tp(x)","\tif xt \u003c 16 {","\t\ttrap(Type)","\t}","\treturn kx(88, x) // .uqs","}","func Grp(x K) K    { return kx(128, x) }                             // =x grp.","func grp(x, y K) K { return Atx(Drp(rx(x), rx(y)), Grp(Atx(y, x))) } // s?T","func Key(x, y K) K { return key(x, y, Dt) }                          // x!y","func key(x, y K, t T) (r K) { // Dt or Tt","\txt, yt := tp(x), tp(y)","\tif xt \u003c 16 {","\t\tif yt \u003c 16 {","\t\t\treturn Key(Enl(x), Enl(y))","\t\t} else {","\t\t\tif xt == st \u0026\u0026 yt == Tt {","\t\t\t\treturn keyt(x, y)","\t\t\t}","\t\t\tx = ntake(nn(y), x)","\t\t}","\t}","\txn := nn(x)","\tif yt \u003c 16 {","\t\ty = ntake(nn(x), y)","\t}","\tif xn != nn(y) {","\t\ttrap(Length)","\t}","\tif t == Tt {","\t\tif xn \u003e 0 {","\t\t\txn = nn(K(I64(int32(y))))","\t\t}","\t}","\tr = l2(x, y)","\tSetI32(int32(r)-12, xn)","\treturn K(int32(r)) | K(t)\u003c\u003c59","}","func keyt(x, y K) K { return Key(Tak(rx(x), rx(y)), Drp(x, y)) } // `s!t (key table: (`s#t)!`s_t)","","func Tak(x, y K) (r K) { // x#y","\txt := tp(x)","\tyt := tp(y)","\tif yt == Dt {","\t\tif xt == it {","\t\t\tr, y = spl2(y)","\t\t\tr = Tak(rx(x), r)","\t\t\ty = Tak(x, y)","\t\t\treturn Key(r, y)","\t\t} else {","\t\t\treturn Key(rx(x), Atx(y, x))","\t\t}","\t} else if yt == Tt {","\t\tif xt\u002615 == st {","\t\t\tif xt == st {","\t\t\t\tx = Enl(x)","\t\t\t}","\t\t\treturn key(rx(x), Atx(y, x), yt)","\t\t} else {","\t\t\treturn Ecr(15, l2(x, y))","\t\t}","\t}","\tif xt == it || xt == bt {","\t\treturn ntake(int32(x), y)","\t}","\tif xt \u003e 16 \u0026\u0026 xt == yt {","\t\treturn atv(y, Wer(In(rx(y), x))) // set take","\t}","\treturn Atx(rx(y), Wer(Cal(x, l1(y)))) // f#","}","func ntake(n int32, y K) (r K) {","\tt := tp(y)","\tif n \u003c 0 {","\t\tif tp(y) \u003c 16 {","\t\t\treturn ntake(-n, y)","\t\t}","\t\tn += nn(y)","\t\tif n \u003c 0 {","\t\t\treturn ucat(ntake(-n, missing(t-16)), y)","\t\t}","\t\treturn ndrop(n, y)","\t}","\typ := int32(y)","\tif t \u003c 5 {","\t\tt += 16","\t\tr = mk(t, n)","\t\ts := sz(t)","\t\trp := int32(r)","\t\tif s == 1 {","\t\t\tMemoryfill(rp, yp, n)","\t\t} else {","\t\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\t\tSetI32(rp, yp)","\t\t\t\trp += 4","\t\t\t}","\t\t}","\t\treturn r","\t} else if t == ft {","\t\tr = mk(Ft, n)","\t\trp := int32(r)","\t\tf := F64(yp)","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\tSetF64(rp, f)","\t\t\trp += 8","\t\t}","\t\tdx(y)","\t\treturn r","\t} else if t == zt {","\t\tr = mk(Zt, n)","\t\trp := int32(r)","\t\tre, im := F64(yp), F64(yp+8)","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\tSetF64(rp, re)","\t\t\tSetF64(rp+8, im)","\t\t\trp += 16","\t\t}","\t\tdx(y)","\t\treturn r","\t} else if t \u003c 16 {","\t\tr = mk(Lt, n)","\t\trp := int32(r)","\t\tfor i := int32(0); i \u003c n; i++ {","\t\t\tSetI64(rp, int64(rx(y)))","\t\t\trp += 8","\t\t}","\t\tdx(y)","\t\treturn r","\t}","\treturn Atx(y, seq(n))","}","func Drp(x, y K) (r K) { // x_y","\txt := tp(x)","\tyt := tp(y)","\tif yt \u003e Lt {","\t\tif yt == Dt || (yt == Tt \u0026\u0026 xt\u002615 == st) {","\t\t\tr, y = spl2(y)","\t\t\tif xt \u003c 16 {","\t\t\t\tx = Enl(x)","\t\t\t}","\t\t\tx = Wer(Not(In(rx(r), x)))","\t\t\treturn key(Atx(r, rx(x)), Atx(y, x), yt)","\t\t} else {","\t\t\treturn Ecr(16, l2(x, y))","\t\t}","\t}","\tif xt == it || xt == bt {","\t\treturn ndrop(int32(x), y)","\t}","\tif xt \u003e 16 \u0026\u0026 xt == yt {","\t\treturn atv(y, Wer(Not(In(rx(y), x)))) // set drop","\t}","\tif yt == it {","\t\treturn atv(x, Wer(Not(Eql(y, seq(nn(x))))))","\t}","\treturn Atx(rx(y), Wer(Not(Cal(x, l1(y))))) // f#","}","func ndrop(n int32, y K) (r K) {","\tyt := tp(y)","\tif yt \u003c 16 || yt \u003e Lt {","\t\ttrap(Type)","\t}","\tyn := nn(y)","\tif n \u003c 0 {","\t\treturn ntake(maxi(0, yn+n), y)","\t}","\trn := yn - n","\tif rn \u003c 0 {","\t\tdx(y)","\t\treturn mk(yt, 0)","\t}","\ts := sz(yt)","\typ := int32(y)","\tif I32(yp-4) == 1 \u0026\u0026 bucket(s*yn) == bucket(s*rn) \u0026\u0026 yt \u003c Lt {","\t\tr = rx(y)","\t\tSetI32(yp-12, rn)","\t} else {","\t\tr = mk(yt, rn)","\t}","\trp := int32(r)","\tMemorycopy(rp, yp+s*n, s*rn)","\tif yt == Lt {","\t\trl(r)","\t\tr = uf(r)","\t}","\tdx(y)","\treturn r","}","","func Cut(x, y K) (r K) { // x^y","\tyt := tp(y)","\tif yt == it || yt == ft {","\t\treturn Pow(y, x)","\t}","\txt := tp(x)","\tif xt == It {","\t\treturn cuts(x, y)","\t}","\tif xt == Ct \u0026\u0026 yt == Ct { // \"set\"^\"abc\"","\t\tx = Wer(In(rx(y), x))","\t\treturn rcut(y, Cat(Ki(0), Add(Ki(1), rx(x))), Cat(x, Ki(nn(y))))","\t}","\tif xt != it || yt \u003c 16 {","\t\ttrap(Type)","\t}","\txp := int32(x)","\tif xp \u003c= 0 {","\t\txp = nn(y) / -xp","\t}","\tr = mk(Lt, xp)","\trp := int32(r)","\te := ep(r)","\tn := nn(y) / xp","\tx = seq(n)","\tfor rp \u003c e {","\t\tSetI64(rp, int64(atv(rx(y), rx(x))))","\t\tx = Add(Ki(n), x)","\t\trp += 8","\t\tcontinue","\t}","\tdx(x)","\tdx(y)","\treturn r","}","func cuts(x, y K) K { return rcut(y, rx(x), cat1(ndrop(1, x), Ki(nn(y)))) }","func rcut(x, a, b K) (r K) { // a, b start-stop ranges","\tn := nn(a)","\tap, bp := int32(a), int32(b)","\tr = mk(Lt, n)","\trp := int32(r)","\tfor i := int32(0); i \u003c n; i++ {","\t\to := I32(ap)","\t\tn := I32(bp) - o","\t\tif n \u003c 0 {","\t\t\ttrap(Value)","\t\t}","\t\tSetI64(rp, int64(atv(rx(x), Add(Ki(o), seq(n)))))","\t\trp += 8","\t\tap += 4","\t\tbp += 4","\t}","\tdx(a)","\tdx(b)","\tdx(x)","\treturn r","}","func split(x, y K) K {","\txt, yt := tp(x), tp(y)","\txn := int32(1)","\tif yt == xt+16 {","\t\tx = Wer(Eql(x, rx(y)))","\t} else {","\t\tif xt == yt \u0026\u0026 xt == Ct {","\t\t\txn = nn(x)","\t\t\tx = Find(x, rx(y))","\t\t} else {","\t\t\ttrap(Type)","\t\t}","\t}","\treturn rcut(y, Cat(Ki(0), Add(Ki(xn), rx(x))), cat1(x, Ki(nn(y))))","}","func join(x, y K) (r K) {","\txt := tp(x)","\tif xt \u003c 16 {","\t\tx = Enl(x)","\t\txt = tp(x)","\t}","\tyt := tp(y)","\tif yt != Lt {","\t\ttrap(Type)","\t}","\typ := int32(y)","\tyn := nn(y)","\tr = mk(xt, 0)","\tfor i := int32(0); i \u003c yn; i++ {","\t\tv := x0(yp)","\t\tif tp(v) != xt {","\t\t\ttrap(Type)","\t\t}","\t\tif i \u003e 0 {","\t\t\tr = ucat(r, rx(x))","\t\t}","\t\tr = ucat(r, v)","\t\typ += 8","\t}","\tdx(x)","\tdx(y)","\treturn r","}","func lin(x, y, z K) K { return cal(Val(Ks(112)), l3(x, y, z)) } // x y'z  (z.k: `\".lin\")","func Bin(x, y K) (r K) { // x'y","\txt := tp(x)","\tyt := tp(y)","\tif xt \u003c 16 || xt \u003e Ft { // n' win?","\t\tif xt == it \u0026\u0026 yt \u003e 16 {","\t\t\treturn win(int32(x), y)","\t\t} else {","\t\t\treturn trap(Type)","\t\t}","\t}","\tif xt == yt || yt == Lt {","\t\treturn Ecr(40, l2(x, y))","\t} else if xt == yt+16 {","\t\tr = Ki(ibin(x, y, xt))","\t} else {","\t\ttrap(Type)","\t}","\tdx(x)","\tdx(y)","\treturn r","}","func ibin(x, y K, t T) int32 {","\tvar k, j, h int32","\tn := nn(x)","\txp := int32(x)","\typ := int32(y)","\tj = n - 1","\ts := sz(t)","\tswitch s \u003e\u003e 2 {","\tcase 0:","\t\tfor {","\t\t\tif k \u003e j {","\t\t\t\treturn k - 1","\t\t\t}","\t\t\th = (k + j) \u003e\u003e 1","\t\t\tif I8(xp+h) \u003e yp {","\t\t\t\tj = h - 1","\t\t\t} else {","\t\t\t\tk = h + 1","\t\t\t}","\t\t}","\tcase 1:","\t\tfor {","\t\t\tif k \u003e j {","\t\t\t\treturn k - 1","\t\t\t}","\t\t\th = (k + j) \u003e\u003e 1","\t\t\tif I32(xp+4*h) \u003e yp {","\t\t\t\tj = h - 1","\t\t\t} else {","\t\t\t\tk = h + 1","\t\t\t}","\t\t}","\tdefault:","\t\tf := F64(yp)","\t\tfor {","\t\t\tif k \u003e j {","\t\t\t\treturn k - 1","\t\t\t}","\t\t\th = (k + j) \u003e\u003e 1","\t\t\tif F64(xp+8*h) \u003e f {","\t\t\t\tj = h - 1","\t\t\t} else {","\t\t\t\tk = h + 1","\t\t\t}","\t\t}","\t}","\treturn 0 // not reached","}","func win(n int32, x K) (r K) {","\ty := seq(n)","\tr = mk(Lt, 0)","\tm := 1 + nn(x) - n","\tfor i := int32(0); i \u003c m; i++ {","\t\tr = ucat(r, l1(atv(rx(x), rx(y))))","\t\ty = Add(Ki(1), y)","\t}","\tdx(x)","\tdx(y)","\treturn r","}","","func Flr(x K) (r K) { // _x","\txt := tp(x)","\txp := int32(x)","\tif xt \u003c 16 {","\t\tswitch xt - 2 {","\t\tcase 0: // c","\t\t\treturn Kc(lc(xp))","\t\tcase 1: // i","\t\t\treturn Kc(xp)","\t\tcase 2: // s","\t\t\treturn Ki(int32(xp))","\t\tcase 3: // f","\t\t\tdx(x)","\t\t\treturn Ki(int32(F64floor(F64(xp))))","\t\tcase 4: // z","\t\t\tdx(x)","\t\t\treturn Kf(F64(xp))","\t\tdefault:","\t\t\treturn x","\t\t}","\t}","\txn := nn(x)","\tvar rp int32","\tswitch xt - 18 {","\tcase 0: //C","\t\treturn lower(x)","\tcase 1: //I","\t\tr = mk(Ct, xn)","\t\trp = int32(r)","\t\te := rp + xn","\t\tfor rp \u003c e {","\t\t\tSetI8(rp, I32(xp))","\t\t\txp += 4","\t\t\trp++","\t\t}","\tcase 2: //S","\t\tx = use(x)","\t\treturn K(int32(x)) | K(It)\u003c\u003c59","\t\t//return Ech(16, l1(x))","\tcase 3: //F","\t\tr = mk(It, xn)","\t\trp = int32(r)","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tSetI32(rp, int32(F64floor(F64(xp))))","\t\t\txp += 8","\t\t\trp += 4","\t\t}","\tcase 4: // Z","\t\tr = mk(Ft, xn)","\t\trp = int32(r)","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tSetI64(rp, I64(xp))","\t\t\txp += 16","\t\t\trp += 8","\t\t}","\tdefault: // L/D/T","\t\treturn Ech(16, l1(x))","\t}","\tdx(x)","\treturn r","}","func lower(x K) (r K) {","\tr = use(x)","\tp := int32(r)","\te := p + nn(r)","\tfor p \u003c e {","\t\tSetI8(p, lc(I8(p)))","\t\tp++","\t}","\treturn r","}","func lc(x int32) int32 {","\tif x \u003e= 'A' \u0026\u0026 x \u003c= 'Z' {","\t\treturn x + 32","\t} else {","\t\treturn x","\t}","}","","func Rev(x K) (r K) { // |x","\tt := tp(x)","\tif t \u003c 16 {","\t\treturn x","\t}","\tif t == Dt {","\t\tr, x = spl2(x)","\t\treturn Key(Rev(r), Rev(x))","\t}","\txn := nn(x)","\tif xn \u003c 2 {","\t\treturn x","\t}","\tr = mk(It, xn)","\trp := int32(r) + 4*xn","\tfor i := int32(0); i \u003c xn; i++ {","\t\trp -= 4","\t\tSetI32(rp, i)","\t}","\treturn atv(x, r)","}","","func Wer(x K) (r K) { // \u0026x","\tt := tp(x)","\tif t \u003c 16 {","\t\tx = Enl(x)","\t\tt = tp(x)","\t}","\tif t == Dt {","\t\tr, x = spl2(x)","\t\treturn Atx(r, Wer(x))","\t}","\tvar n, rp int32","\txn := nn(x)","\txp := int32(x)","\tif t == Bt {","\t\tn = sumb(xp, xn)","\t\tr = mk(It, n)","\t\trp = int32(r)","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tif I8(xp) != 0 {","\t\t\t\tSetI32(rp, i)","\t\t\t\trp += 4","\t\t\t}","\t\t\txp++","\t\t}","\t} else if t == It {","\t\tn = sumi(xp, xn)","\t\tr = mk(It, n)","\t\trp = int32(r)","\t\tfor i := int32(0); i \u003c xn; i++ {","\t\t\tj := I32(xp)","\t\t\tfor k := int32(0); k \u003c j; k++ {","\t\t\t\tSetI32(rp, i)","\t\t\t\trp += 4","\t\t\t}","\t\t\txp += 4","\t\t}","\t} else if xn == 0 {","\t\tr = mk(It, 0)","\t} else {","\t\ttrap(Type)","\t}","\tdx(x)","\treturn r","}","func Fwh(x K) K { // *\u0026x","\tt := tp(x)","\tif t == Bt {","\t\tdx(x)","\t\treturn Ki(fwh(int32(x), nn(x)))","\t}","\treturn Fst(Wer(x))","}","func fwh(xp, n int32) int32 { // *\u0026B","\te := xp + n","\tve := e \u0026^ 15","\tp := xp","f:","\tfor p \u003c ve {","\t\tif I8x16load(p).Any_true() != 0 {","\t\t\tbreak f","\t\t}","\t\tp += 16","\t}","\tfor p \u003c e {","\t\tif I8(p) != 0 {","\t\t\treturn p - xp","\t\t}","\t\tp++","\t}","\treturn nai","}","","func Typ(x K) K { // @x","\tdx(x)","\treturn sc(Enl(Kc(I8(520 + int32(tp(x))))))","}","func Tok(x K) K { // `t@\"src\"","\tif tp(x) == Ct {","\t\treturn tok(x)","\t} else {","\t\treturn x","\t}","}","func Val(x K) (r K) {","\txt := tp(x)","\tif xt == st {","\t\treturn lup(x)","\t}","\tif xt == Ct {","\t\treturn val(x)","\t}","\tif xt == lf || xt == xf { // lambda: (code;locals;string;arity)","\t\txp := int32(x) //    native: (ptr;string;arity)","\t\tr = l2(x0(xp), x1(xp))","\t\tif xt == lf {","\t\t\tr = cat1(r, x2(xp))","\t\t}","\t\tr = cat1(r, Ki(nn(x)))","\t\tdx(x)","\t\treturn r","\t}","\tif xt == Lt {","\t\treturn exec(x) // .L e.g. 1+2 is (1;2;`66)","\t}","\tif xt \u003e Lt {","\t\tr = x1(int32(x))","\t\tdx(x)","\t\treturn r","\t} else {","\t\treturn trap(Type)","\t}","}","func val(x K) K {","\tx = parse(tok(x))","\txn := nn(x)","\txp := int32(x) + 8*(xn-1)","\ta := int32(0)","\tif xn \u003e 2 \u0026\u0026 I64(xp) == 64 {","\t\ta = 1","\t}","\tx = exec(x)","\tif a != 0 {","\t\tdx(x)","\t\treturn 0","\t}","\treturn x","}","func Fin(x K) K { return Wer(Not(Xpt(x))) } // find x (index of non-missing)","func Xpt(x K) K { // fill x","\txt := tp(x)","\tif xt \u003e= Lt {","\t\treturn Ech(38, l1(x))","\t} else {","\t\treturn Eql(missing(xt-T(16*I32B(xt \u003e 16))), x)","\t}","}","func Fil(x, y K) (r K) { // x fill y","\txt, yt := tp(x), tp(y)","\tif yt \u003e= Lt {","\t\treturn Ecr(38, l2(x, y))","\t}","\tif xt == yt \u0026\u0026 xt \u003c 16 {","\t\tif int32(Xpt(y)) != 0 {","\t\t\treturn x","\t\t} else {","\t\t\treturn y","\t\t}","\t}","\tr = Wer(Xpt(rx(y)))","\tif xt == yt-16 {","\t\treturn Amd(y, r, 1, x)","\t}","\tif xt == yt {","\t\treturn stv(y, r, atv(x, rx(r)))","\t} else {","\t\treturn trap(Type)","\t}","}","func Enc(x, y K) (r K) { // x\\\\y","\txt := tp(x)","\tn := int32(0)","\tif xt == It {","\t\tn = nn(x)","\t}","\tr = mk(It, 0)","\tyn := int32(Cnt(rx(y)))","l:","\tfor {","\t\tn--","\t\txi := ati(rx(x), n)","\t\tr = Cat(r, Enl(idiv(rx(y), xi, 1)))","\t\ty = idiv(y, xi, 0)","\t\tif int32(y) == 0 || n == 0 {","\t\t\tbreak","\t\t}","\t\tif tp(y) \u003e 16 {","\t\t\tif sumi(int32(y), yn) == 0 {","\t\t\t\tbreak l","\t\t\t}","\t\t}","\t}","\tdx(x)","\tdx(y)","\treturn Rev(r)","}","func Dec(x, y K) (r K) { // x//y   {z+x*y}/[0;x;y]","\tif tp(y) \u003c 16 {","\t\ttrap(Type)","\t}","\tr = Fst(rx(y))","\tn := nn(y)","\tfor i := int32(1); i \u003c n; i++ {","\t\tr = Add(ati(rx(y), i), Mul(ati(rx(x), i), r))","\t}","\tdx(x)","\tdx(y)","\treturn r","}",""],"z.go":["package main","","import . \"github.com/ktye/wg/module\"","","func zk() {","\tData(600, \"``x`y`z`k`l`a`b`while`\\\"rf.\\\"`\\\"rz.\\\"`\\\"uqs.\\\"`\\\"uqf.\\\"`\\\"gdt.\\\"`\\\"lin.\\\"`\\\"odo.\\\"`\\\"grp.\\\"\\n`\\\"x.\\\":{,/+\\\"0123456789abcdef\\\"@(x%16;16/x:256/256+x)}\\n`\\\"t.\\\":`45\\n`\\\"p.\\\":`46\\n`\\\"b.\\\":(`46)[`b;]\\n`\\\"c.\\\":(`46)[`c;]\\n`\\\"i.\\\":(`46)[`i;]\\n`\\\"s.\\\":(`46)[`s;]\\n`\\\"f.\\\":(`46)[`f;]\\n`\\\"z.\\\":(`46)[`z;]\\n`\\\"uqs.\\\":{x@\u0026~0b~':x:^x}\\n`\\\"uqf.\\\":{x@\u0026(!#x)=x?x}\\n`\\\"gdt.\\\":{[t;g](!#t)($[g;{x@\u003ey x};{x@\u003cy x}])/|.t}\\n`\\\"odo.\\\":{{y@(#y)/!x}/:[*/x;\u0026'x#'|*\\\\-1_1,|x]}\\n`\\\"grp.\\\":{(x@*'g)!g:(\u0026~x~':x i)^i:\u003cx}\\nany:`30;abs:`32;sin:`44;cos:`39;find:`31;fill:`38;imag:`33;conj:`34;angle:`35;exp:`42;log:`43\\n`\\\"pad.\\\":{(|/#'x)#'x}\\n`\\\"l.\\\":{\\nkt:{[x;y;k;T]x:$[`T~@x;T[x;k];`pad(\\\"\\\";\\\"-\\\"),$x];(x,'\\\"|\\\"),'T[y;k]}\\nd:{[x;k;kt;T]r:!x;x:.x;$[`T~@x;kt[r;x;k;T];,'[,'[`pad(k'r);\\\"|\\\"];k'x]]}\\nT:{[x;k]$[`L':@'.x;,k x;(,*x),(,(#*x)#\\\"-\\\"),1_x:\\\" \\\"/:'+`pad@'$(!x),'.x]}\\nt:@x;k:`kxy 1\\ndd:(\\\"\\\";,\\\"..\\\")20\u003c#x:$[(@x)':`L`D`T;x;x~*x;x;[t:`L;,x]]\\nx:$[x~*x;x;(20\u0026#x)#x]\\n$[`D~t;d[x;k;kt;T];`T~t;T[x;k];x~*x;,k x;k'x],dd}\\n`\\\"str.\\\":{q:{c,(\\\"\\\\\\\\\\\"/:(0,i)^@[x;i;(qs!\\\"tnr\\\\\\\"\\\\\\\\\\\")x i:\u0026x':qs:\\\"\\\\t\\\\n\\\\r\\\\\\\"\\\\\\\\\\\"]),c:_34}\\n$[|/x':\\\"\\\\t\\\\n\\\\r\\\"__!31;\\\"0x\\\",`x@x;q x]}\\n`\\\"kxy.\\\":{\\na:{t:@x;x:$x;$[`c~t;`str x;`s~t;\\\"`\\\",x;x]}\\nd:{[x;k]r:\\\"!\\\",k@.x;n:#!x;x:k@!x;$[(1~n)|(@.x)':`D`T;\\\"(\\\",x,\\\")\\\";x],r}\\nv:{[x;k;m;n]m*:(.`\\\".kstm\\\")t:@x; dd:(\\\"\\\";\\\"..\\\")m\u003c#x;x:(m\u0026#x)#x\\nx:$[`L~t;k'x;`C~t;x;$x]\\nx:$[`B~t;(*'x),\\\"b\\\";`C~t;`str x;`S~t;c,(c:\\\"`\\\")/:x;`L~t;$[1~n;*x;\\\"(\\\",(\\\";\\\"/:x),\\\")\\\"];\\\" \\\"/:x]\\n((\\\"\\\";\\\",\\\")(1~n)),x,dd}\\nt:@y;n:#y;k:`kxy x;m:x\\n$[n~0;(.`\\\".kst0\\\")@t;`T~t;\\\"+\\\",d[+y;k];`D~t;d[y;k];y~*y;a y;v[y;k;m;n]]}\\n`\\\".kst0\\\":`B`C`I`S`F`Z`L!(\\\"0#0b\\\";c,c:_34;\\\"!0\\\";\\\"0#`\\\";\\\"0#0.\\\";\\\"0#0a\\\";\\\"()\\\")\\n`\\\".kstm\\\":`B`C`I`S`F`Z`L!100 100 30 30 20 10 20\\n`\\\"k.\\\":`kxy 1000000\\n`\\\"rf.\\\": {.5+(x?0)%4294967295.}\\n`\\\"rf1.\\\":{.5+(1.+x?0)%4294967295.}        \\n`\\\"rz.\\\": {(%-2*log `rf1 x)@360.*`rf x}\\n`\\\"lin.\\\":{$[`L~@z;(.`\\\"lin.\\\")[x;y]'z;[dx:0.+1_-':x;dy:0.+1_-':y;b:(-2+#x)\u00260|x'z;(y b)+(dy b)*(z-x b)%dx b]]}\\n`\\\"split.\\\":{$[`L~@x;`split@'x;\\\" \\\"\\\\:$[\\\" \\\"=x@-1+#x:x@\u0026~i\u0026~':i:\\\" \\\"=x;-1_x;x]]}\\n`\\\"edit.\\\":{et:{\\\"+\\\",(`k@!x),\\\"!\\\",el@.x}\\nel:{t:(`S`B`C`I`F`Z!``b`c`i`f`z)@@'x; (`k@t),\\\"$'+`split@'\\\\\\\"\\\\\\\\n\\\\\\\"\\\\\\\\:-1_1_\\\\\\\"\\\\n\\\",(\\\"\\\\n\\\"/:\\\" \\\"/:'+`pad@'$x),\\\"\\\\n\\\\\\\"\\\"}\\n$[`T~t:@x;et x;`L~t;el x;`C~t;\\\"-1_1_\\\\\\\"\\\\n\\\",x,\\\"\\\\n\\\\\\\"\\\";\\\"*\\\",el@,x]}\\ndot:{[xt;y]{+/x*y}\\\\:[xt;y]}\\nsolve:{qslv:{H:x 0;r:x 1;n:x 2;m:x 3;j:0;K:!m\\nwhile[j\u003cn;y[K]-:(+/(conj H[j;K])*y K)*H[j;K];K:1_K;j+:1]\\ni:n-1;J:!n;y[i]%:r@i\\nwhile[i;j:i_J;i-:1;y[i]:(y[i]-+/H[j;i]*y@j)%r@i]\\nn#y}\\nq:$[`i~@*|x;x;qr x];$[`L~@y;qslv/:[q;y];qslv[q;y]]}\\nqr:{K:!m:#*x;I:!n:#x;j:0;r:n#0a;turn:$[`Z~@*x;{(-x)@angle y};{x*1. -1@y\u003e0}]\\nwhile[j\u003cn;I:1_I\\nr[j]:turn[s:abs@abs/j_x j;xx:x[j;j]]\\nx[j;j]-:r[j]\\nx[j;K]%:%s*(s+abs xx)\\nx[I;K]-:{+/x*y}/:[(conj x[j;K]);x[I;K]]*\\\\:x[j;K]\\nK:1_K;j+:1];(x;r;n;m)}\\navg:{(+/x)%0.+#x}\\nvar:{(+/x*x:(x-avg x))%-1+#x}\\nstd:{%var x}\\nrem:{x/x+x/y}\\nej:{(y j),'x_z i j:\u0026~0N=i:(z x)?y x}\\n`\\\"pack.\\\":{w:{(`c@,#x),x};($t),$[`s~t:@x;`pack@$x;x~*x;w `c@,x;`L~@x;(`c@,#x),,/`pack@'x;(@x)':`D`T;(`pack@.x),`pack@!x;`S~t;,/`pack@$x;w `c x]}\\n`\\\"unpack.\\\":{s:x;g:{[n]r:n#s;s::n_s;r};n:{*`i@g 4};u:{x;$[(t:*g 1)':\\\"bcifz\\\";*(`$t)g n[];t~\\\"s\\\";`$u 0;t~\\\"S\\\";`$u 0;t~\\\"L\\\";u'!n[];t~\\\"D\\\";(u 0)!u 0;t~\\\"T\\\";+(u 0)!u 0;(`$_t+32)g n[]]};u 0}\\ncsv:{c:{s:`$'x@i:\u0026x':\\\"ifzs\\\";n:`i$\\\" \\\"\\\\:-1_@[x;i;\\\" \\\"];y[a]:(y[a],''\\\"a\\\"),''y[1+a:\u0026s=`z];s$'y n};s:$[\\\" \\\"~(*x);`split@;(*x)\\\\:];x:1_x;y:+s'$[`L~@y;y;\\\"\\\\n\\\"\\\\:y];$[#x;c[x;y];y]}\\nPW:800;PH:600;FH:20;FONT:\\\"monospace\\\"\\n`\\\"pltnn.\\\":{wi:\u003c/\u003c/:;$[#i:\u0026wi[*x;+\\\\plt`px`pw]\u0026wi[x 1;+\\\\plt`py`ph];*i;0]}\\n`\\\"pltco.\\\":{[p;x;y]w:p`fh;h:p`fh;X:p`px;Y:p`py;W:p`pw;H:p`ph;C:(X+W%2;Y+H%2);R:(W%2)\u0026(H%2)-h;d:$[`xy~p`t;(X+w;X+W-w;Y+H-h;Y+h);((C-R),C+R)0 2 3 1];a:p`a; ((d 0 1)(a 0 1)'x;(d 2 3)(a 2 3)'y)}\\n`\\\"pltcl.\\\":{[x;y]p:.`\\\"pltco.\\\";n:`pltnn(x;y); xy:p[plt n;x;y]; `\u003c$[`polar~plt[n;`t];$imag/|xy;\\\"x:\\\",($xy 0), \\\" y:\\\",($xy 1)],_10 32}\\n`\\\"pltzo.\\\":{[x;y;w;h]n:`pltnn(x;y);p:.`\\\"pltco.\\\";xy0:p[plt n;x;y+h]; xy1:p[plt n;x+w;y]; plt[`a;n]:(xy0,xy1)0 2 1 3; plt[`t;n]:`xy; draw[`plts@`plt;(PW;PH)]}\\nplot:{n:#x;i:!0;r:!0\\nabsa:{af:{v:.x;(!x)!(*v;y v 1)};am:{af[x;abs]};an:{af[x;angle]}\\ni::^(\u0026{$[1~#x;0b;`Z~@$[L~@v:(.x)1;*v;v]]}'x),!#x\\nr::\u00261_~':i;x:x i;x[r]:am'x r;x[1+r]:an'x 1+r;x}\\nmult:{x[`pw]%:n;x[`px]:i*x`pw;x[r;`ph]:3\\\\2*PH;x[1+r;`py`ph]:(3\\\\2*PH;3\\\\PH);x[`a;1+r;2 3]:,0 360.;x}\\nplt::mult@(`plot@)'absa$[(@x)':`L`T;*(x;n:#x);,x]\\nShow[draw[`plts@`plt;(PW;PH)];.`\\\"pltcl.\\\";.`\\\"pltzo.\\\"]}\\n`\\\"plot.\\\":{[d]l:$!d;v:.d; t:$[2~#d;`xy;`polar];\\ny:$[t~`xy; $[`L~@y:v 1;y;,y];          $[`L~@y:_*v;y;,y]]\\nx:$[t~`xy; $[`L~@x:v 0;x;(,x)@(#y)#0]; $[`L~@x:imag@*v;x;,x]]\\nxt:`tics(\u0026/\u0026/x;|/|/x);yt:`tics(\u0026/\u0026/y;|/|/y)\\na:$[t~`xy;(xt 0;*-1#xt;yt 0;*-1#yt);(-a;a;-a;a:*|`tics@0.,|/|/abs@*v)]\\nc:c@(#c:11826975 950271 2924588 2631638 12412820 4937356 12744675 8355711 2276796 13614615)/!#x\\nstyle:$[t~`polar;\\\"..\\\";`i~@**y;\\\"||\\\";\\\"--\\\"]\\nsize: $[t~`polar;2;style~\\\"||\\\";(--/((**x),-1#*x))%-1+#*x ;2]\\nlines:{`style`size`color`x`y!(style;size;z;x;0.+y)}'[x;y;c]\\npw:PW;ph:PH;`L`T`t`l`a`f`fh`px`py`pw`ph!(lines;\\\"\\\";t;l;a;FONT;FH;0;0;pw;ph)}\\n`\\\"plts.\\\":{[sym];x:.sym;$[`D~@x;`Plot x;,/(`Plot@)'x]}\\n`\\\"Plot.\\\":{[x];w:x`fh; h:x`fh; X:x`px; Y:x`py; W:x`pw; H:x`ph; a:x`a;T:x`T;grey:13882323\\nC:(X+W%2;Y+H%2);R:(W%2)\u0026(H%2)-h\\ndst:$[`xy~x`t;(X+w;X+W-w;Y+H-h;Y+h);((C-R),C+R)0 2 3 1];rdst:(X+w;Y+h;W-2*w;H-2*h)\\nxs:(a 0 1)(dst 0 1)'\\nys:(a 2 3)(dst 2 3)'\\nbars:{[l]$[\\\"|\\\"':l`style;(`color;l`color),,/{(`Rect;((-dx%2)+xs x;ys y;dx:-/xs(l`size;0.);(ys a 2)-ys y))}'[l`x;l`y];()]}\\nline:{[l]$[\\\"-\\\"':l`style;(`linewidth;l`size;`color;l`color;`poly;(xs l`x;ys l`y));()]}\\ndots:{[l]$[\\\".\\\"':l`style;(`color;l`color),,/{(`Circle;(xs x;ys y;1.5*l`size))}'[l`x;l`y];()]}\\nc:(`clip;(X;Y;W;H);`font;(x`f;x`fh);`color;0;`text;((X+W%2;Y+h);1;T))\\nxy:{[]c,:(`text;((X+w;Y+H);0;$a 0);`text;((X+W%2;Y+H);1;(x`l)0);`text;((X+W-w;Y+H);2;$a 1))\\nc,:(`Text;((X+w;Y+H-h);0;$a 2);`Text;((X+w;Y+H%2);2;(x`l)1);`Text;((X+w;Y+h);2;$a 3))\\nc,:(`color;0;`linewidth;2;`rect;rdst)\\nc,:(`linewidth;1;`color;grey)\\nc,:(`clip;rdst)\\nc,:,/{(`line;0.+(x;dst 2;x;dst 3))}'xs`tics x[`a;0 1]\\nc,:,/{(`line;0.+(dst 0;x;dst 1;x))}'ys`tics x[`a;2 3]}\\npo:{[]c,:(`text;((C 0;Y+H);1;(x`l)0);`text;(C+.75*R;6;$(x`a)3))\\nc,:(`font;(x`f;_h*.8)),,/{(`text;(C+R*(_;imag)@'x;y;z))}'[1@270.+a;0 0 6 6 4 4 2 2;$a:30 60 120 150 210 240 300 330]\\nc,:(`color;0),/{(`line;,/+C+(R-w%2;R)*/:(_;imag)@'x)}'1@30.*!12\\nc,:(`color;grey;`linewidth;1;`line;((-R)+*C;C 1;R+*C;C 1);`line;(*C;(-R)+C 1;*C;R+C 1))\\nc,:,/{(`circle;0.+C,x)}'r:(xs@`tics 0.,x[`a;3])-*C\\nc,:(`color;0;`linewidth;2;`circle;C,R)}\\n$[`xy~x`t;xy[];po[]]\\nc,:,/bars'x`L\\nc,:,/line'x`L\\nc,:,/dots'x`L}\\n`\\\"tics.\\\":{[minmax]nice:{[x;r]f:x%0.+10^ex:_log[10;x];(1 2 5 10.@*\u0026(~f\u003e1 2 5 0w;f\u003c1.5 3 7 0w)[r])*10^ex};e:nice[-/|minmax;0];s:nice[e%4.;1];n:_1.5+e%s;$[~(minmax 1)\u003e*-2#r:s*(_(*minmax)%s)+!n;-1_r;r]}\\n`\\\"ceg.\\\":{(x i)!0-':1+i:\u0026(1_~~':x),1b}\\nhist:{$[`i~@x;hist[(x;\u0026/y;|/y);y];(Y;(`38)[0;(`ceg@^1+((d%2.0)+-1_Y:(x 1)+(d:(--/1_x)%-1.+n)*!n)'y)@!n:_0.+*x])]}\\n\")","\tzn := int32(6625) // should end before 8k","\tx := mk(Ct, zn)","\tMemorycopy(int32(x), 600, zn)","\tdx(Val(x))","}",""]}
