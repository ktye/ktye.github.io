{"apl.go":["// Package cmd contains shared code between cmd/apl, cmd/iv and cmd/lui","package cmd","","import (","\t\"bufio\"","\t\"fmt\"","\t\"io\"","\t\"os\"","","\t\"github.com/ktye/iv/apl\"",")","","// Apl runs the interpreter in file mode if arguments are given, otherwise as a repl.","func Apl(a *apl.Apl, stdin io.Reader, args []string) error {","\t// Execute files.","\tif len(args) \u003e 0 {","\t\tfor _, name := range args {","\t\t\tvar r io.Reader","\t\t\tif name == \"-\" {","\t\t\t\tr = stdin","\t\t\t\tname = \"stdin\"","\t\t\t} else {","\t\t\t\tf, err := os.Open(name)","\t\t\t\tif err != nil {","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t\tdefer f.Close()","\t\t\t\tr = f","\t\t\t}","\t\t\treturn a.EvalFile(r, name)","\t\t}","\t\treturn nil","\t}","","\t// Run interactively.","\tscanner := bufio.NewScanner(stdin)","\tfmt.Printf(\"        \")","\tfor scanner.Scan() {","\t\ts := scanner.Text()","\t\tif err := a.ParseAndEval(s); err != nil {","\t\t\tfmt.Println(err)","\t\t}","\t\tfmt.Printf(\"        \")","\t}","\treturn nil","}",""],"array.go":["package primitives","","import (","\t\"fmt\"","\t\"reflect\"","\t\"sort\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/domain\"",")","","// arrays is the domain for binary arithmetic functions which","// may be scalars or arrays on both sides.","// If this function suceeds, only these cases are possible:","//\t- one or both are empty (apl.EmptyArray)","//\t- one is scalar and the other an array","//\t- both are arrays of the same shape","// A single element array is converted to a scalar, if the other is a larger array.","type arrays struct{}","","func (ars arrays) To(a *apl.Apl, L, R apl.Value) (apl.Value, apl.Value, bool) {","\tif L == nil {","\t\treturn L, R, false","\t}","\tisScalar := domain.IsScalar(nil)","\t_, scalarL := isScalar.To(a, L)","\t_, scalarR := isScalar.To(a, R)","\tif scalarL \u0026\u0026 scalarR {","\t\treturn L, R, false","\t}","","\tal, isLarray := L.(apl.Array)","\tar, isRarray := R.(apl.Array)","","\t// Both are arrays and must have the same shape or at least one is empty.","\t// They must also contain only numbers.","\tif isLarray \u0026\u0026 isRarray {","\t\t// 0-Size arrays are converted to empty arrays.","\t\t// TODO: is this correct?","\t\tif al.Size() == 0 {","\t\t\treturn apl.EmptyArray{}, ar, true","\t\t} else if ar.Size() == 0 {","\t\t\treturn al, apl.EmptyArray{}, true","\t\t}","\t\tlshape := al.Shape()","\t\trshape := ar.Shape()","\t\tif len(lshape) == len(rshape) {","\t\t\tfor i := range lshape {","\t\t\t\tif lshape[i] != rshape[i] {","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t\tif i == len(lshape)-1 {","\t\t\t\t\t// Both arrays have the same shape","\t\t\t\t\treturn al, ar, true","\t\t\t\t}","\t\t\t}","\t\t}","\t\t// Convert single element arrays to scalars.","\t\tif al.Size() == 1 {","\t\t\treturn al.At(0), ar, true","\t\t}","\t\tif ar.Size() == 1 {","\t\t\treturn al, ar.At(0), true","\t\t}","\t\treturn L, R, false","\t}","\tif isLarray \u0026\u0026 scalarR {","\t\treturn L, R, true","\t} else if scalarL \u0026\u0026 isRarray {","\t\treturn L, R, true","\t}","\treturn L, R, false","}","func (ars arrays) String(f apl.Format) string { return \"arithmetic arrays\" }","","// ArraysWithAxis is the domain for binary arithmetic functions","// with an axis specification.","// The axis specification is bound to the right argument in an Axis value.","// It converts L, R and the axis specification to Arrays.","type arraysWithAxis struct{}","","func (ars arraysWithAxis) To(a *apl.Apl, L, R apl.Value) (apl.Value, apl.Value, bool) {","\tif L == nil {","\t\treturn L, R, false","\t}","\tax, ok := R.(apl.Axis)","\tif ok == false {","\t\treturn L, R, false","\t}","","\ttoArray := domain.ToArray(nil)","\tal, ok := toArray.To(a, L)","\tif ok == false {","\t\treturn L, R, false","\t}","\tar, ok := toArray.To(a, ax.R)","\tif ok == false {","\t\treturn L, R, false","\t}","","\ttoIdxArray := domain.ToIndexArray(nil)","\tx, ok := toIdxArray.To(a, ax.A)","\tif ok == false {","\t\treturn L, R, false","\t}","","\treturn al, apl.Axis{A: x, R: ar}, true","}","func (ars arraysWithAxis) String(f apl.Format) string { return \"arithmetic arrays with axis\" }","","// array1 tries to apply the elementary function returned by arith1(fn)","// monadically to each element of the array R","func array1(symbol string, fn func(*apl.Apl, apl.Value) (apl.Value, bool)) func(*apl.Apl, apl.Value, apl.Value) (apl.Value, error) {","\tefn := arith1(symbol, fn)","\treturn func(a *apl.Apl, _ apl.Value, R apl.Value) (apl.Value, error) {","\t\tar := R.(apl.Array)","\t\tres := apl.NewMixed(apl.CopyShape(ar))","\t\tsame := true","\t\tvar t reflect.Type","\t\tfor i := range res.Values {","\t\t\tval, err := efn(a, nil, ar.At(i))","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tres.Values[i] = val","\t\t\tif i == 0 {","\t\t\t\tt = reflect.TypeOf(val)","\t\t\t} else if same {","\t\t\t\tif reflect.TypeOf(val) != t {","\t\t\t\t\tsame = false","\t\t\t\t}","\t\t\t}","\t\t}","\t\tif same {","\t\t\tu, _ := a.Unify(res, false)","\t\t\treturn u, nil","\t\t}","\t\treturn res, nil","\t}","}","","// array2 tries to apply the elementary function returned by arith2(fn)","// dyadically to the elements of the arrays L and R.","// L and R have been tested and converted by arrays.","func array2(symbol string, fn func(*apl.Apl, apl.Value, apl.Value) (apl.Value, bool)) func(*apl.Apl, apl.Value, apl.Value) (apl.Value, error) {","\tefn := arith2(symbol, fn)","\treturn func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\t// If one or both are empty, return an EmptyArray{}","\t\t// TODO: or should we test against the array size (0 dimsions anywhere)","\t\t// and return what? EmptyArray{} or array of the same shape?","\t\t_, emptyL := L.(apl.EmptyArray)","\t\t_, emptyR := R.(apl.EmptyArray)","\t\tif emptyL || emptyR {","\t\t\treturn apl.EmptyArray{}, nil","\t\t}","","\t\tal, isLarray := L.(apl.Array)","\t\tar, isRarray := R.(apl.Array)","","\t\tvar shape []int","\t\tif isLarray == false {","\t\t\tshape = apl.CopyShape(ar)","\t\t} else {","\t\t\tshape = apl.CopyShape(al)","\t\t}","\t\tres := apl.NewMixed(shape)","\t\tsame := true","\t\tvar t reflect.Type","\t\tfor i := range res.Values {","\t\t\tlv := L","\t\t\tif isLarray {","\t\t\t\tlv = al.At(i)","\t\t\t}","\t\t\trv := R","\t\t\tif isRarray {","\t\t\t\trv = ar.At(i)","\t\t\t}","\t\t\tval, err := efn(a, lv, rv)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t} else {","\t\t\t\tres.Values[i] = val","\t\t\t}","\t\t\tif i == 0 {","\t\t\t\tt = reflect.TypeOf(val)","\t\t\t} else if same {","\t\t\t\tif reflect.TypeOf(val) != t {","\t\t\t\t\tsame = false","\t\t\t\t}","\t\t\t}","\t\t}","\t\tif same {","\t\t\treturn a.UnifyArray(res), nil","\t\t}","\t\treturn res, nil","\t}","}","","// ArrayAxis is like array2 but with R bound in an axis specification.","func arrayAxis(symbol string, fn func(*apl.Apl, apl.Value, apl.Value) (apl.Value, bool)) func(*apl.Apl, apl.Value, apl.Value) (apl.Value, error) {","\tefn := arith2(symbol, fn)","\treturn func(a *apl.Apl, L, ax apl.Value) (apl.Value, error) {","\t\taxis := ax.(apl.Axis)","\t\tR := axis.R","\t\tX := axis.A.(apl.IntArray)","","\t\t_, emptyL := L.(apl.EmptyArray)","\t\t_, emptyR := R.(apl.EmptyArray)","\t\tif emptyL || emptyR {","\t\t\treturn apl.EmptyArray{}, nil","\t\t}","","\t\tal := L.(apl.Array)","\t\tar := R.(apl.Array)","\t\tls := al.Shape()","\t\trs := ar.Shape()","","\t\t// We assume L has higher rank, otherwise flip L and R.","\t\tflip := false","\t\tif len(ls) \u003c len(rs) {","\t\t\tflip = true","\t\t\tal, ar = ar, al","\t\t\tls, rs = rs, ls","\t\t}","","\t\t// See APL2 p.55 for conformance:","\t\t// \tL f[X] R","\t\t// (⍴,X) ←→ (⍴⍴L)⌊⍴⍴R","\t\t// (⍴,X) ←→ ∧/X∊⍳(⍴⍴L)⌈⍴⍴R","\t\tif len(X.Dims) != 1 {","\t\t\treturn nil, fmt.Errorf(\"axis specification must have rank 1: %T\", len(X.Dims))","\t\t}","","\t\t// X≡X[⍋X]","\t\tx := make([]int, len(X.Ints))","\t\tcopy(x, X.Ints)","\t\tsort.Ints(x)","\t\tfor i := range x {","\t\t\tx[i] -= int(a.Origin)","\t\t}","","\t\t// (⍴L)[X] ←→ (⍴R).","\t\tif len(rs) != len(x) {","\t\t\treturn nil, fmt.Errorf(\"axis rank must match lower argument rank\")","\t\t}","\t\tfor i, n := range x {","\t\t\tif n \u003c 0 || n \u003e= len(ls) {","\t\t\t\treturn nil, fmt.Errorf(\"axis exceeds higher argument rank\")","\t\t\t}","\t\t\tif i \u003e 0 \u0026\u0026 n == x[i-1] {","\t\t\t\treturn nil, fmt.Errorf(\"axis values are not unique\")","\t\t\t}","\t\t\tif ls[n] != rs[i] {","\t\t\t\treturn nil, fmt.Errorf(\"arguments with axis do not conform\")","\t\t\t}","\t\t}","","\t\t// There is no explicit algorithm description in APL2, DyaRef or ISO. We do:","\t\t// Extend the rank of argument with lower rank (already flipped to R),","\t\t// to the higher rank by filling missing axes with 1s.","\t\t// Apply the function elementwise, but use index 1 if an axis has only one element.","\t\trightShape := make([]int, len(ls))","\t\tfor i := range rightShape {","\t\t\trightShape[i] = 1","\t\t}","\t\tfor i, n := range x {","\t\t\trightShape[n] = rs[i]","\t\t}","","\t\tvar err error","\t\tsame := true","\t\tvar t reflect.Type","\t\tvar lv, rv, v apl.Value","\t\tres := apl.NewMixed(apl.CopyShape(al))","\t\tidx := make([]int, len(res.Dims))","\t\tic, rdx := apl.NewIdxConverter(rightShape)","\t\tfor i := range res.Values {","\t\t\tcopy(rdx, idx)","\t\t\tfor k := range rdx {","\t\t\t\tif rdx[k] \u003e= rightShape[k] {","\t\t\t\t\trdx[k] = 0","\t\t\t\t}","\t\t\t}","\t\t\tlv = al.At(i)","\t\t\trv = ar.At(ic.Index(rdx))","\t\t\tif flip {","\t\t\t\tlv, rv = rv, lv","\t\t\t}","\t\t\tv, err = efn(a, lv, rv)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tres.Values[i] = v","\t\t\tif i == 0 {","\t\t\t\tt = reflect.TypeOf(v)","\t\t\t} else if same {","\t\t\t\tif reflect.TypeOf(v) != t {","\t\t\t\t\tsame = false","\t\t\t\t}","\t\t\t}","\t\t\tapl.IncArrayIndex(idx, res.Dims)","\t\t}","\t\tif same {","\t\t\tu, _ := a.Unify(res, false)","\t\t\treturn u, nil","\t\t}","\t\treturn res, nil","\t}","}",""],"assign.go":["package operators","","import (","\t\"fmt\"","\t\"reflect\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(operator{","\t\tsymbol:  \"←\",","\t\tDomain:  MonadicOp(nil),","\t\tdoc:     \"assign, variable specification\",","\t\tderived: assign,","\t})","}","","func assign(a *apl.Apl, f, g apl.Value) apl.Function {","\tderived := func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\tas, ok := f.(*apl.Assignment)","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"cannot assign to %T\", f)","\t\t}","\t\tif L != nil {","\t\t\treturn nil, fmt.Errorf(\"assign cannot be called dyadically\")","\t\t}","","\t\tif as.Identifiers != nil {","\t\t\tif as.Indexes != nil {","\t\t\t\treturn nil, fmt.Errorf(\"vector and indexed assignment cannot exist simulaneously\")","\t\t\t}","\t\t\treturn assignVector(a, as.Identifiers, R, as.Modifier)","\t\t}","","\t\t// Special case: channel scope: ⎕←C","\t\tif c, ok := R.(apl.Channel); ok \u0026\u0026 as.Identifier == \"⎕\" {","\t\t\treturn c.Scope(a), nil","\t\t}","","\t\treturn R, assignScalar(a, as.Identifier, as.Indexes, as.Modifier, R)","\t}","\treturn function(derived)","}","","// AssignVector does a vector assignment from R to the given names.","// A modifier function may be applied.","func assignVector(a *apl.Apl, names []string, R apl.Value, mod apl.Function) (apl.Value, error) {","\tvar ar apl.Array","\tif v, ok := R.(apl.Array); ok {","\t\tar = v","\t} else {","\t\tar = a.UnifyArray(apl.MixedArray{Dims: []int{1}, Values: []apl.Value{R}})","\t}","","\tvar scalar apl.Value","\tif s := ar.Shape(); len(s) != 1 {","\t\treturn nil, fmt.Errorf(\"vector assignment: rank of right argument must be 1\")","\t} else if s[0] != 1 \u0026\u0026 s[0] != len(names) {","\t\treturn nil, fmt.Errorf(\"vector assignment is non-conformant\")","\t} else if s[0] == 1 {","\t\tif ar.Size() \u003c 1 {","\t\t\treturn nil, fmt.Errorf(\"vector assignment: collapsed dimension\")","\t\t}","\t\tscalar = ar.At(0)","\t}","","\tvar err error","\tfor i, name := range names {","\t\tvar v apl.Value","\t\tif scalar != nil {","\t\t\tv = scalar","\t\t} else {","\t\t\tif err := apl.ArrayBounds(ar, i); err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tv = ar.At(i)","\t\t}","\t\terr = assignScalar(a, name, nil, mod, v)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t}","","\treturn R, nil","}","","// AssignScalar assigns to a named scalar variable.","// If indexes is non-nil, it must be an IndexArray for indexed assignment.","// Mod may be a dyadic modifying function.","func assignScalar(a *apl.Apl, name string, indexes apl.Value, f apl.Function, R apl.Value) error {","\tif f == nil \u0026\u0026 indexes == nil {","\t\treturn a.Assign(name, R.Copy())","\t}","","\tw, env := a.LookupEnv(name)","\tif w == nil {","\t\treturn fmt.Errorf(\"assign %s: modified/indexed: variable does not exist\", name)","\t}","","\tv, err := assignValue(a, w, indexes, f, R)","\tif err != nil {","\t\treturn fmt.Errorf(\"assign %s: %s\", name, err)","\t}","\tif v != nil {","\t\treturn a.AssignEnv(name, v.Copy(), env)","\t}","\treturn nil","}","","// assignValue assigns to a given value. It may return a new value, or nil with no error.","func assignValue(a *apl.Apl, dst apl.Value, indexes apl.Value, f apl.Function, R apl.Value) (apl.Value, error) {","\t// Modified assignment without indexing.","\tif indexes == nil {","\t\tif v, err := f.Call(a, dst, R); err != nil {","\t\t\treturn nil, err","\t\t} else {","\t\t\treturn v, nil","\t\t}","\t}","","\tidx, ok := indexes.(apl.IntArray)","\tif ok == false {","\t\tto := ToIndexArray(nil)","\t\tif v, ok := to.To(a, indexes); ok == false {","\t\t\treturn nil, fmt.Errorf(\"indexed assignment could not convert to IndexArray: %T\", indexes)","\t\t} else if _, ok := v.(apl.EmptyArray); ok {","\t\t\treturn nil, fmt.Errorf(\"indexed assignment could not convert to IndexArray: %T\", indexes)","\t\t} else {","\t\t\tidx = v.(apl.IntArray)","\t\t}","\t}","","\tif t, ok := dst.(apl.Table); ok {","\t\treturn nil, assignTable(a, t, idx, f, R)","\t}","","\tif obj, ok := dst.(apl.Object); ok {","\t\treturn nil, assignObject(a, obj, idx, f, R)","\t}","","\tif lst, ok := dst.(apl.List); ok {","\t\treturn nil, assignList(a, lst, idx, f, R)","\t}","","\tar, ok := dst.(apl.ArraySetter)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"variable is no settable array: %T\", dst)","\t}","","\t// Try to keep the original array type, upgrade only if needed.","\tupgrade := func() {","\t\tga := apl.NewMixed(apl.CopyShape(ar))","\t\tfor i := range ga.Values {","\t\t\tif i \u003e= ar.Size() {","\t\t\t\treturn","\t\t\t}","\t\t\tga.Values[i] = ar.At(i)","\t\t}","\t\tar = ga","\t}","","\t// modAssign assigns ar at index i with v possibly modified by f.","\tmodAssign := func(i int, v apl.Value) error {","\t\tif i == -1 {","\t\t\t// Index -1 is used by some indexed assignments to mark skipps.","\t\t\t// E.g. replicate and compress / and \\","\t\t\treturn nil","\t\t}","\t\tif f == nil {","\t\t\tif err := ar.Set(i, v); err == nil {","\t\t\t\treturn nil","\t\t\t}","\t\t\tupgrade()","\t\t\treturn ar.Set(i, v)","\t\t}","\t\tvar err error","\t\tif err = apl.ArrayBounds(ar, i); err != nil {","\t\t\treturn err","\t\t}","\t\tv, err = f.Call(a, ar.At(i), v)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif err = ar.Set(i, v); err == nil {","\t\t\treturn nil","\t\t}","\t\tupgrade()","\t\treturn ar.Set(i, v)","\t}","","\tvar src apl.Array","\tvar scalar apl.Value","\tif av, ok := R.(apl.Array); ok {","\t\tsrc = av","\t\tif av.Size() == 1 {","\t\t\tscalar = av.At(0).Copy()","\t\t}","\t} else {","\t\tscalar = R.Copy()","\t}","\tif scalar != nil {","\t\t// Scalar or 1-element assignment.","\t\tfor _, d := range idx.Ints {","\t\t\tif err := modAssign(int(d), scalar); err != nil {","\t\t\t\treturn ar, err","\t\t\t}","\t\t}","\t} else {","","\t\t// Shapes must conform. Single element axis are collapsed.","\t\tcollapse := func(s []int) []int {","\t\t\tn := 0","\t\t\tfor _, i := range s {","\t\t\t\tif i == 1 {","\t\t\t\t\tn++","\t\t\t\t}","\t\t\t}","\t\t\tif n == 0 {","\t\t\t\treturn s","\t\t\t}","\t\t\tr := make([]int, len(s)-n)","\t\t\tk := 0","\t\t\tfor _, i := range s {","\t\t\t\tif i != 1 {","\t\t\t\t\tr[k] = i","\t\t\t\t\tk++","\t\t\t\t}","\t\t\t}","\t\t\treturn r","\t\t}","\t\tds := collapse(idx.Shape())","\t\tss := collapse(src.Shape())","\t\tif len(ds) != len(ss) {","\t\t\treturn nil, fmt.Errorf(\"indexed assignment: arrays have different rank: %d != %d\", len(ds), len(ss))","\t\t}","\t\tfor i := range ds {","\t\t\tif ss[i] != ds[i] {","\t\t\t\treturn nil, fmt.Errorf(\"indexed assignment: arrays are not conforming: %v != %v\", ss, ds)","\t\t\t}","\t\t}","\t\tfor i, d := range idx.Ints {","\t\t\tif err := apl.ArrayBounds(src, i); err != nil {","\t\t\t\treturn ar, err","\t\t\t}","\t\t\tif err := modAssign(int(d), src.At(i).Copy()); err != nil {","\t\t\t\treturn ar, err","\t\t\t}","\t\t}","\t}","\treturn ar, nil","}","","// assignTable updates a table.","// indexes are given in a fake IntArray. See primitives/index.go: tableSelection.","// R must be a table or array of corresponding size, an object for each row or a scalar value.","func assignTable(a *apl.Apl, t apl.Table, idx apl.IntArray, f apl.Function, R apl.Value) error {","\trows := idx.Ints[:idx.Dims[0]]","\tcols := idx.Ints[idx.Dims[0]:]","\tkeys := make([]apl.Value, len(cols))","\tfor i := range keys {","\t\tall := t.Keys()","\t\tif i \u003c 0 || i \u003e= len(keys) {","\t\t\treturn fmt.Errorf(\"table-update: col idx out of range\")","\t\t}","\t\tkeys[i] = all[cols[i]].Copy()","\t}","","\tif ar, ok := R.(apl.Array); ok {","\t\t// convert array R to table.","\t\tshape := ar.Shape()","\t\tif len(shape) == 1 \u0026\u0026 ar.Size() == len(rows) {","\t\t\t// Reshape column vectors.","\t\t\tif rs, ok := ar.(apl.Reshaper); ok == false {","\t\t\t\treturn fmt.Errorf(\"table-update: cannot reshape right vector: %T\", ar)","\t\t\t} else {","\t\t\t\tshape = []int{shape[0], 1}","\t\t\t\tar = rs.Reshape(shape).(apl.Array)","\t\t\t}","\t\t}","","\t\tif len(shape) != 2 {","\t\t\treturn fmt.Errorf(\"table-update: array on the right must have rank 2\")","\t\t}","\t\tif shape[0] != len(rows) || shape[1] != len(cols) {","\t\t\treturn fmt.Errorf(\"table-update: array on the right has wrong shape\")","\t\t}","\t\tm := make(map[apl.Value]apl.Value)","\t\tfor k, key := range keys {","\t\t\tu := t.At(key).(apl.Uniform)","\t\t\tcol := u.Make([]int{len(rows)})","\t\t\tto := ToType(reflect.TypeOf(u.Zero()), nil)","\t\t\tfor i := range rows {","\t\t\t\tval := ar.At(i*shape[1] + k)","\t\t\t\tv, ok := to.To(a, val)","\t\t\t\tif ok == false {","\t\t\t\t\treturn fmt.Errorf(\"table-update: cannot convert %T to %T\", val, u.Zero())","\t\t\t\t}","\t\t\t\tif err := col.Set(i, v); err != nil {","\t\t\t\t\treturn fmt.Errorf(\"table-update: convert array: %s\", err)","\t\t\t\t}","\t\t\t}","\t\t\tm[key] = col","\t\t}","\t\td := apl.Dict{","\t\t\tK: keys,","\t\t\tM: m,","\t\t}","\t\tR = apl.Table{Dict: \u0026d, Rows: shape[0]}","\t} else if _, ok := R.(apl.Object); ok == false {","\t\t// convert scalar R to dict.","\t\td := apl.Dict{","\t\t\tK: keys,","\t\t\tM: make(map[apl.Value]apl.Value),","\t\t}","\t\tfor _, k := range keys {","\t\t\td.M[k] = R.Copy()","\t\t}","\t\tR = \u0026d","\t}","","\t// set applies the modify function if available, assigns to the indexes of the old column","\t// and makes sure the result is uniform.","\tset := func(col apl.Uniform, newcol apl.Array) (apl.Uniform, error) {","\t\tif f != nil {","\t\t\tleft := apl.MakeArray(col, []int{len(rows)})","\t\t\tfor i := range rows {","\t\t\t\tleft.Set(i, col.At(rows[i]))","\t\t\t}","\t\t\tv, err := f.Call(a, left, newcol)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tvr, ok := v.(apl.Array)","\t\t\tif ok == false {","\t\t\t\treturn nil, fmt.Errorf(\"mod does not return an array\")","\t\t\t} else if s := vr.Shape(); len(s) != 1 {","\t\t\t\treturn nil, fmt.Errorf(\"mod does not return a vector\")","\t\t\t} else if s[0] != len(rows) {","\t\t\t\treturn nil, fmt.Errorf(\"mod returns vector of wrong size\")","\t\t\t}","\t\t\tif ur, ok := a.Unify(vr, true); ok == false {","\t\t\t\treturn nil, fmt.Errorf(\"modified vector cannot be unified\")","\t\t\t} else {","\t\t\t\tnewcol = ur.(apl.Uniform)","\t\t\t}","\t\t}","\t\trs := col.Shape()","\t\tif reflect.TypeOf(newcol) != reflect.TypeOf(col) {","\t\t\tnc := apl.NewMixed([]int{rs[0]})","\t\t\tfor i := range nc.Values {","\t\t\t\tnc.Values[i] = col.At(i)","\t\t\t}","\t\t\tfor i, k := range rows {","\t\t\t\tnc.Values[k] = newcol.At(i).Copy()","\t\t\t}","\t\t\tur, ok := a.Unify(nc, true)","\t\t\tif ok == false {","\t\t\t\treturn nil, fmt.Errorf(\"cannot unify array\")","\t\t\t}","\t\t\treturn ur.(apl.Uniform), nil","\t\t} else {","\t\t\tfor i, k := range rows {","\t\t\t\tcol.Set(k, newcol.At(i).Copy())","\t\t\t}","\t\t\treturn col, nil","\t\t}","\t}","","\to, ok := R.(apl.Object)","\tif ok == false {","\t\treturn fmt.Errorf(\"table-update: illegal right argument: %T\", R)","\t}","","\trk := o.Keys()","\tif len(rk) != len(keys) {","\t\treturn fmt.Errorf(\"table-update: keys on the right do not match\")","\t}","\tfor i := range keys {","\t\tif rk[i] != keys[i] {","\t\t\treturn fmt.Errorf(\"table-update: keys on the right do not match\")","\t\t}","\t}","\tfor _, key := range keys {","\t\tcol := t.Dict.At(key).(apl.Uniform)","\t\tvar err error","\t\tif rt, ok := R.(apl.Table); ok {","\t\t\trc := rt.At(key).(apl.Uniform)","\t\t\tif s := rc.Shape(); len(s) != 1 || s[0] != len(rows) {","\t\t\t\treturn fmt.Errorf(\"table-update: right table has %d rows instead of %d\", s[0], len(rows))","\t\t\t}","\t\t\tsubcol := apl.MakeArray(rc, []int{len(rows)})","\t\t\tfor i := range rows {","\t\t\t\tsubcol.Set(i, rc.At(i).Copy())","\t\t\t}","\t\t\tcol, err = set(col, subcol)","\t\t\tif err != nil {","\t\t\t\treturn fmt.Errorf(\"table-update: %s\", err)","\t\t\t}","\t\t} else {","\t\t\tsubcol := apl.NewMixed([]int{len(rows)})","\t\t\trv := o.At(key)","\t\t\tif _, ok := rv.(apl.Array); ok {","\t\t\t\treturn fmt.Errorf(\"table-update: dict contains an array, should be scalar\")","\t\t\t}","\t\t\tfor i := range subcol.Values {","\t\t\t\tsubcol.Values[i] = rv.Copy()","\t\t\t}","\t\t\tcol, err = set(col, a.UnifyArray(subcol))","\t\t\tif err != nil {","\t\t\t\treturn fmt.Errorf(\"table-update: %s\", err)","\t\t\t}","\t\t}","\t\tif err := t.Dict.Set(key, col); err != nil {","\t\t\treturn fmt.Errorf(\"table-update: %s\", err)","\t\t}","\t}","\treturn nil","}","","// assignObject assigns R to index keys of a object.","func assignObject(a *apl.Apl, obj apl.Object, idx apl.IntArray, f apl.Function, R apl.Value) error {","\tif len(idx.Ints) \u003e 1 \u0026\u0026 idx.Ints[0] \u003c 0 {","\t\treturn assignObjectDepth(a, obj, idx, f, R)","\t} else if len(idx.Ints) == 1 \u0026\u0026 idx.Ints[0] \u003c 0 {","\t\tidx.Ints[0] = -1 - idx.Ints[0] + a.Origin","\t}","\tvectorize := false","\tar, ok := R.(apl.Array)","\tif ok == true {","\t\tif len(idx.Ints) \u003e 1 {","\t\t\tif len(idx.Ints) == ar.Size() {","\t\t\t\tvectorize = true","\t\t\t} else {","\t\t\t\treturn fmt.Errorf(\"assing object: assignment does not conform\")","\t\t\t}","\t\t}","\t}","\tkeys := obj.Keys()","\tfor i := 0; i \u003c len(idx.Ints); i++ {","\t\tn := int(idx.Ints[i] - a.Origin)","\t\tif n \u003c 0 || n \u003e= len(keys) {","\t\t\treturn fmt.Errorf(\"assign object: index out of range\")","\t\t}","\t\tk := keys[n]","\t\tv := R // Set copies.","\t\tif vectorize == true {","\t\t\tif err := apl.ArrayBounds(ar, i); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tv = ar.At(i)","\t\t}","\t\tif f != nil {","\t\t\tif nv, err := f.Call(a, obj.At(k), v); err != nil {","\t\t\t\treturn fmt.Errorf(\"mod assign object: %s\", err)","\t\t\t} else {","\t\t\t\tv = nv","\t\t\t}","\t\t}","\t\tif err := obj.Set(k, v); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func assignObjectDepth(a *apl.Apl, obj apl.Object, idx apl.IntArray, f apl.Function, R apl.Value) (err error) {","\tk := -1 - idx.Ints[0]","\tkeys := obj.Keys()","\tif k \u003c 0 || k \u003e= len(keys) {","\t\treturn fmt.Errorf(\"assign obj-depth: index out of range\")","\t}","\tkey := keys[k]","\tv := obj.At(key)","\tif v == nil {","\t\treturn fmt.Errorf(\"assign obj-depth: nil value\")","\t}","","\tia := apl.IntArray{Dims: []int{idx.Dims[0] - 1}, Ints: idx.Ints[1:]}","\tif _, ok := v.(apl.Table); ok {","\t\terr = fmt.Errorf(\"assign obj-depth: tables are not supported\")","\t} else if o, ok := v.(apl.Object); ok {","\t\terr = assignObject(a, o, ia, f, R)","\t} else if l, ok := v.(apl.List); ok {","\t\terr = assignList(a, l, ia, f, R)","\t} else if ar, ok := v.(apl.Array); ok {","\t\tvar nv apl.Value","\t\tnv, err = assignValue(a, ar, ia, f, R)","\t\tif err == nil \u0026\u0026 nv != nil {","\t\t\tv = nv","\t\t}","\t} else {","\t\terr = fmt.Errorf(\"TODO: assign obj-depth: unsupported type: %T\", v)","\t}","\tif err == nil {","\t\treturn obj.Set(key, v)","\t}","\treturn err","}","","// assignList assigns R to the depth index of a list.","func assignList(a *apl.Apl, l apl.List, idx apl.IntArray, f apl.Function, R apl.Value) error {","\tif f != nil {","\t\tv, err := l.GetDeep(idx.Ints)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tv, err = f.Call(a, v, R)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tR = v","\t}","\treturn l.SetDeep(idx.Ints, R) // SetDeep copies.","}",""],"at.go":["package operators","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(operator{","\t\tsymbol:  \"@\",","\t\tDomain:  DyadicOp(nil),","\t\tdoc:     \"at\",","\t\tderived: at,","\t})","}","","func at(a *apl.Apl, f, g apl.Value) apl.Function {","\tderived := func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\t// g selects values from R.","\t\tar, ok := R.(apl.Array)","\t\tif ok == false {","\t\t\tar = a.UnifyArray(apl.MixedArray{Dims: []int{1}, Values: []apl.Value{R}})","\t\t}","\t\trs := ar.Shape()","","\t\t// If g is a function, it must return a boolean mask.","\t\tmask := make([]bool, ar.Size())","\t\tvar replshape []int","\t\tif fg, ok := g.(apl.Function); ok {","\t\t\tv, err := fg.Call(a, nil, ar)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tav, ok := v.(apl.Array)","\t\t\tif ok == false {","\t\t\t\treturn nil, fmt.Errorf(\"at: function g did not return an array: %T\", v)","\t\t\t}","\t\t\tsize := av.Size()","\t\t\tif size != len(mask) {","\t\t\t\treturn nil, fmt.Errorf(\"at: array returned by function g has wrong size\")","\t\t\t}","\t\t\tfor i := range mask {","\t\t\t\tif err := apl.ArrayBounds(av, i); err != nil {","\t\t\t\t\treturn nil, fmt.Errorf(\"at: %s\", err)","\t\t\t\t}","\t\t\t\tv := av.At(i)","\t\t\t\tif n, ok := v.(apl.Number); ok == false {","\t\t\t\t\treturn nil, fmt.Errorf(\"at: function g did not return a number: %T\", v)","\t\t\t\t} else if b, ok := a.Tower.ToBool(n); ok == false {","\t\t\t\t\treturn nil, fmt.Errorf(\"at: number returned by function g is not a boolean: %T\", n)","\t\t\t\t} else {","\t\t\t\t\tmask[i] = bool(b)","\t\t\t\t}","\t\t\t}","\t\t} else {","\t\t\t// g is an index array that selects major cells of R.","\t\t\tag, ok := g.(apl.Array)","\t\t\tif ok == false {","\t\t\t\tag = apl.MixedArray{Dims: []int{1}, Values: []apl.Value{g}}","\t\t\t}","\t\t\tvar gi apl.IntArray","\t\t\tif v, ok := ToIndexArray(nil).To(a, ag); ok == false {","\t\t\t\treturn nil, fmt.Errorf(\"at: g is not an index array\")","\t\t\t} else {","\t\t\t\tgi = v.(apl.IntArray)","\t\t\t}","\t\t\tif len(gi.Dims) != 1 {","\t\t\t\treturn nil, fmt.Errorf(\"at: g should have rank 1: %d\", len(gi.Dims))","\t\t\t}","\t\t\tn := ar.Size() / rs[0]","\t\t\tfor _, major := range gi.Ints {","\t\t\t\tmajor -= a.Origin","\t\t\t\tif major \u003c 0 || major \u003e= rs[0] {","\t\t\t\t\treturn nil, fmt.Errorf(\"at: selected major cell is out of range %d: [1, %d]\", major+1, rs[0])","\t\t\t\t}","\t\t\t\toff := n * int(major)","\t\t\t\tfor i := 0; i \u003c n; i++ {","\t\t\t\t\tmask[off+i] = true","\t\t\t\t}","\t\t\t}","\t\t\t// Keep shape of selected subarray.","\t\t\treplshape = apl.CopyShape(ar)","\t\t\treplshape[0] = gi.Dims[0]","\t\t}","","\t\t// Number of replacements.","\t\tn := 0","\t\tfor _, v := range mask {","\t\t\tif v {","\t\t\t\tn++","\t\t\t}","\t\t}","","\t\trepl := make([]apl.Value, n)","\t\tvar vr apl.Value","\t\tif fn, ok := f.(apl.Function); ok {","\t\t\t// Apply fn to the sub-array of R as a whole.","\t\t\tif replshape == nil {","\t\t\t\treplshape = []int{n}","\t\t\t}","\t\t\tre := apl.MakeArray(ar, replshape)","\t\t\tn := 0","\t\t\tfor i, m := range mask {","\t\t\t\tif m {","\t\t\t\t\tif err := apl.ArrayBounds(ar, i); err != nil {","\t\t\t\t\t\treturn nil, err","\t\t\t\t\t}","\t\t\t\t\tre.Set(n, ar.At(i).Copy())","\t\t\t\t\tn++","\t\t\t\t}","\t\t\t}","\t\t\tif v, err := fn.Call(a, L, re); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else {","\t\t\t\tvr = v","\t\t\t}","\t\t} else {","\t\t\t// f is an array of replacements.","\t\t\tvr = f","\t\t}","","\t\tre, ok := vr.(apl.Array)","\t\tif ok == false {","\t\t\tre = a.UnifyArray(apl.MixedArray{Dims: []int{1}, Values: []apl.Value{vr}})","\t\t}","\t\tif n := re.Size(); n == 1 {","\t\t\tfor i := range repl {","\t\t\t\trepl[i] = re.At(0)","\t\t\t}","\t\t} else if n != len(repl) {","\t\t\treturn nil, fmt.Errorf(\"at: number of replacements does not match selection\")","\t\t} else {","\t\t\tfor i := range repl {","\t\t\t\tif err := apl.ArrayBounds(ar, i); err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\trepl[i] = re.At(i)","\t\t\t}","\t\t}","","\t\tres := apl.NewMixed(apl.CopyShape(ar))","\t\tk := 0","\t\tfor i := range res.Values {","\t\t\tif mask[i] {","\t\t\t\tres.Values[i] = repl[k].Copy()","\t\t\t\tk++","\t\t\t} else {","\t\t\t\tif err := apl.ArrayBounds(ar, i); err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\tres.Values[i] = ar.At(i).Copy()","\t\t\t}","\t\t}","\t\treturn a.UnifyArray(res), nil","\t}","\treturn function(derived)","}",""],"axis.go":["package primitives","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/domain\"",")","","// splitAxis returns ax.R and converts ax.A to []int taking account of index origin.","// It R is not an axis it returns R and nil.","func splitAxis(a *apl.Apl, R apl.Value) (apl.Value, []int, error) {","\tax, ok := R.(apl.Axis)","\tif ok == false {","\t\treturn R, nil, nil","\t}","\tif _, ok := ax.A.(apl.EmptyArray); ok {","\t\treturn ax.R, nil, nil","\t}","\tto := domain.ToIndexArray(nil)","\tX, ok := to.To(a, ax.A)","\tif ok == false {","\t\treturn nil, nil, fmt.Errorf(\"axis is not an index array\")","\t}","\tar := X.(apl.IntArray)","\tshape := ar.Shape()","\tif len(shape) != 1 {","\t\treturn nil, nil, fmt.Errorf(\"axis has wrong shape: %d\", len(shape))","\t}","\tx := make([]int, len(ar.Ints))","\tfor i, n := range ar.Ints {","\t\tx[i] = int(n - a.Origin)","\t}","\treturn ax.R, x, nil","}","","// SplitCatAxis splits the right argument, if it contains an axis.","// The axis must be a numeric scalar value or a single element array.","// It may contain a fractional part.","// If it does not exist, it is set to the last axis.","// It returns the integer part of the axis and indicates if it is fractional.","// The index origin is substracted.","func splitCatAxis(a *apl.Apl, L, R apl.Value) (apl.Value, int, bool, error) {","\tax, ok := R.(apl.Axis)","\tif ok == false {","\t\tif ar, ok := R.(apl.Array); ok == false {","\t\t\treturn R, 0, false, nil","\t\t} else {","\t\t\treturn R, len(ar.Shape()) - 1, false, nil","\t\t}","\t}","\tR = ax.R","","\t// X∊⍳(⍴⍴L)⌈⍴⍴R","\trkL := 0","\tal, ok := L.(apl.Array)","\tif ok {","\t\trkL = len(al.Shape())","\t}","","\trkR := 0","\tar, ok := R.(apl.Array)","\tif ok {","\t\trkR = len(ar.Shape())","\t}","","\tmax := rkL","\tif rkR \u003e max {","\t\tmax = rkR","\t}","","\tvar x apl.Value","\tif xr, ok := ax.A.(apl.Array); ok {","\t\tif xr.Size() != 1 {","\t\t\treturn nil, 0, false, fmt.Errorf(\",: axis must be a scalar or single element array\")","\t\t} else {","\t\t\tx = xr.At(0)","\t\t}","\t} else {","\t\tx = ax.A","\t}","\tnum, ok := x.(apl.Number)","\tif ok == false {","\t\treturn nil, 0, false, fmt.Errorf(\"axis is not numeric\")","\t}","\tif n, ok := num.ToIndex(); ok {","\t\tn -= a.Origin","\t\tif n \u003c 0 || n \u003e= max {","\t\t\treturn nil, 0, false, fmt.Errorf(\"axis is out of range\")","\t\t}","\t\treturn R, n, false, nil","\t}","","\t// The axis is fractional, depending on the numerical tower.","\t// Substract index origin from the axis.","\tn := 0","\tif fl, ok := num.(floorer); ok == false {","\t\treturn nil, 0, false, fmt.Errorf(\"cannot floor axis: %T\", num)","\t} else {","\t\tif fnum, ok := fl.Floor(); ok == false {","\t\t\treturn nil, 0, false, fmt.Errorf(\"could not floor axis: %T\", num)","\t\t} else if i, ok := fnum.(apl.Number).ToIndex(); ok == false {","\t\t\treturn nil, 0, false, fmt.Errorf(\"|axis is not an index\")","\t\t} else {","\t\t\tn = int(i)","\t\t}","\t}","","\t// Substract index origin.","\tn -= int(a.Origin)","","\t// x must be between -1 and max.","\tif n \u003c -1 || n \u003e max {","\t\treturn nil, 0, false, fmt.Errorf(\"axis must be: X∊⍳(⍴⍴L)⌈⍴⍴R\")","\t}","\treturn R, n, true, nil","}",""],"bool.go":["package apl","","import (","\t\"fmt\"",")","","type Bool bool","","func (b Bool) String(f Format) string {","\tif f.PP \u003c 0 {","\t\tif b {","\t\t\treturn \"1b\"","\t\t}","\t\treturn \"0b\"","\t}","\tif b {","\t\treturn \"1\"","\t}","\treturn \"0\"","}","func (b Bool) Copy() Value { return b }","","func (i Bool) Less(v Value) (Bool, bool) {","\tj, ok := v.(Bool)","\tif ok == false {","\t\treturn false, false","\t}","\treturn i == false \u0026\u0026 j == true, true","}","","func (i Bool) ToIndex() (int, bool) {","\tif i {","\t\treturn 1, true","\t}","\treturn 0, true","}","","// BoolArray is a uniform array of type bool.","type BoolArray struct {","\tDims  []int","\tBools []bool","}","","func (b BoolArray) String(f Format) string {","\treturn ArrayString(f, b)","}","","func (b BoolArray) Copy() Value {","\tr := BoolArray{Dims: CopyShape(b), Bools: make([]bool, len(b.Bools))}","\tcopy(r.Bools, b.Bools)","\treturn r","}","","func (b BoolArray) At(i int) Value {","\treturn Bool(b.Bools[i])","}","","func (b BoolArray) Shape() []int {","\treturn b.Dims","}","","func (b BoolArray) Size() int {","\treturn len(b.Bools)","}","","func (b BoolArray) Zero() Value {","\treturn Bool(false)","}","","func (b BoolArray) Set(i int, v Value) error {","\tif i \u003c 0 || i \u003e len(b.Bools) {","\t\treturn fmt.Errorf(\"index out of range\")","\t}","\tif c, ok := v.(Bool); ok {","\t\tb.Bools[i] = bool(c)","\t\treturn nil","\t}","\treturn fmt.Errorf(\"cannot assign %T to BoolArray\", v)","}","","func (s BoolArray) Make(shape []int) Uniform {","\treturn BoolArray{","\t\tDims:  shape,","\t\tBools: make([]bool, Prod(shape)),","\t}","}","","func makeBoolArray(v []Value) BoolArray {","\tb := make([]bool, len(v))","\tfor i, e := range v {","\t\tb[i] = bool(e.(Bool))","\t}","\treturn BoolArray{","\t\tDims:  []int{len(v)},","\t\tBools: b,","\t}","}","","func (b BoolArray) Reshape(shape []int) Value {","\tres := BoolArray{","\t\tDims:  shape,","\t\tBools: make([]bool, Prod(shape)),","\t}","\tk := 0","\tfor i := range res.Bools {","\t\tres.Bools[i] = b.Bools[k]","\t\tk++","\t\tif k == len(b.Bools) {","\t\t\tk = 0","\t\t}","\t}","\treturn res","}",""],"boolean.go":["package primitives","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"","\t\"github.com/ktye/iv/apl/operators\"",")","","func init() {","\ttab := []struct {","\t\tsymbol  string","\t\tdoc     string","\t\tlogical string","\t}{","\t\t{\"^\", \"logical and\", \"and\"},","\t\t{\"∧\", \"logical and\", \"and\"},","\t\t{\"∨\", \"logical or\", \"or\"},","\t\t{\"⍲\", \"logical nand\", \"nand\"},","\t\t{\"⍱\", \"logical nor\", \"nor\"},","\t}","","\tfor _, e := range tab {","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc,","\t\t\tDomain: Dyadic(Split(IsScalar(nil), IsScalar(nil))),","\t\t\tfn:     arith2(e.symbol, logical(e.logical)),","\t\t})","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc,","\t\t\tDomain: arrays{},","\t\t\tfn:     array2(e.symbol, logical(e.logical)),","\t\t})","\t}","\tregister(primitive{","\t\tsymbol: \"~\",","\t\tdoc:    \"logical not\",","\t\tDomain: Monadic(IsScalar(nil)),","\t\tfn:     arith1(\"~\", logicalNot),","\t})","\tregister(primitive{","\t\tsymbol: \"~\",","\t\tdoc:    \"logical not\",","\t\tDomain: Monadic(IsArray(nil)),","\t\tfn:     array1(\"~\", logicalNot),","\t})","\tregister(primitive{","\t\tsymbol: \"~\",","\t\tdoc:    \"without, excluding\",","\t\tDomain: Dyadic(Split(ToVector(nil), ToVector(nil))),","\t\tfn:     without,","\t})","}","","// logical not, R is a Number.","func logicalNot(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\tb, ok := a.Tower.ToBool(R.(apl.Number))","\tif ok == false {","\t\treturn nil, false","\t}","\treturn apl.Bool(!b), true","}","","func logical(logical string) func(*apl.Apl, apl.Value, apl.Value) (apl.Value, bool) {","\treturn func(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\t\tl, lok := a.Tower.ToBool(L.(apl.Number))","\t\tr, rok := a.Tower.ToBool(R.(apl.Number))","\t\tif lok == false || rok == false {","\t\t\tif logical == \"and\" {","\t\t\t\treturn lcm(a, L, R)","\t\t\t} else if logical == \"or\" {","\t\t\t\treturn gcd(a, L, R)","\t\t\t}","\t\t\treturn nil, false","\t\t}","\t\tvar t apl.Bool","\t\tswitch logical {","\t\tcase \"and\":","\t\t\tt = l \u0026\u0026 r","\t\tcase \"or\":","\t\t\tt = l || r","\t\tcase \"nand\":","\t\t\tt = !(l \u0026\u0026 r)","\t\tcase \"nor\":","\t\t\tt = !(l || r)","\t\tdefault:","\t\t\tpanic(fmt.Sprintf(\"unknown logical: %s\", logical))","\t\t}","\t\treturn t, true","\t}","}","","// without: L and R are vectors.","// L~R is equivalent to (~L∊R)/L.","func without(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tif _, ok := R.(apl.EmptyArray); ok {","\t\treturn L, nil","\t}","\tif _, ok := L.(apl.EmptyArray); ok {","\t\treturn apl.EmptyArray{}, nil","\t}","","\tlr, err := membership(a, L, R)","\tif err != nil {","\t\treturn nil, err","\t}","","\tnot := arith1(\"~\", logicalNot)","\tif _, ok := L.(apl.Array); ok {","\t\tnot = array1(\"~\", logicalNot)","\t}","\tnlr, err := not(a, nil, lr)","\tif err != nil {","\t\treturn nil, err","\t}","","\tto := ToIndexArray(nil)","\tia, ok := to.To(a, nlr)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"without: cannot convert (~L∊R) to index array\")","\t}","","\treturn operators.Replicate(a, ia, L, 0)","}",""],"channel.go":["package primitives","","import (","\t\"fmt\"","\t\"time\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/numbers\"",")","","// primitive \u003c is defined in compare.go","","// channelSource sends any value R over a channel.","// \u003c[axis] R","func channelSource(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tr, ax, err := splitAxis(a, R)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"channel send: %s\", err)","\t}","\tif len(ax) \u003e 1 {","\t\treturn nil, fmt.Errorf(\"channel send: axis must be scalar\")","\t}","","\tif _, ok := r.(apl.Channel); ok {","\t\treturn nil, fmt.Errorf(\"channel send: right argument is a channel\")","\t}","","\tn := 1","\tif ax != nil {","\t\tn = ax[0]","\t}","\tn += int(a.Origin) // splitAxis substracts the origin.","","\tc := apl.NewChannel()","\tif n == 0 {","\t\t// Send only once, but do not close any channels.","\t\tgo func(v apl.Value) {","\t\t\tc[0] \u003c- v","\t\t}(r)","\t\treturn c, nil","\t}","","\t// Send v n times. If n is negative send until c[1] is closed.","\tgo func(v apl.Value, n int) {","\t\tdefer close(c[0])","\t\ti := 0","\t\tfor {","\t\t\tselect {","\t\t\tcase _, ok := \u003c-c[1]:","\t\t\t\tif ok == false {","\t\t\t\t\treturn","\t\t\t\t}","\t\t\tcase c[0] \u003c- v:","\t\t\t\ti++","\t\t\t\tif n \u003e 0 \u0026\u0026 i \u003e= n {","\t\t\t\t\treturn","\t\t\t\t}","\t\t\t}","\t\t}","\t}(r, n)","\treturn c, nil","}","","// channelCopy connects two channels. It writes to L what it reads from R.","// The function returns the number of values copied.","func channelCopy(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tl := L.(apl.Channel)","\tr := R.(apl.Channel)","\t// Should this run in a go-routine and return directly?","\tdefer close(l[0])","\tret := apl.EmptyArray{}","\tfor {","\t\tselect {","\t\tcase _, ok := \u003c-l[1]:","\t\t\tif ok == false {","\t\t\t\tclose(r[1])","\t\t\t\treturn ret, nil","\t\t\t}","\t\tcase v, ok := \u003c-r[0]:","\t\t\tif ok == false {","\t\t\t\treturn ret, nil","\t\t\t}","\t\t\tselect {","\t\t\tcase _, ok := \u003c-l[1]:","\t\t\t\tif ok == false {","\t\t\t\t\tclose(r[1])","\t\t\t\t\treturn ret, nil","\t\t\t\t}","\t\t\tcase l[0] \u003c- v:","\t\t\t}","\t\t}","\t}","}","","// channelDelay returns a channel that sends at fixed intervals what it receives.","func channelDelay(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\td, ok := L.(numbers.Time).Duration()","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"channel delay: left argument is not a duration: %T\", L)","\t}","\tin := R.(apl.Channel)","\tout := in.Apply(a, Delay(d), nil, false)","\treturn out, nil","}","","// Delay is a function that pauses execution for a given duration.","// It is currently not bound to a primitive and only used by channel-delay.","type Delay time.Duration","","func (d Delay) Call(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\ttime.Sleep(time.Duration(d))","\treturn R, nil","}","","// channel1 applies the monadic elementary function to each value in a channel.","func channel1(symbol string, fn func(*apl.Apl, apl.Value) (apl.Value, bool)) func(*apl.Apl, apl.Value, apl.Value) (apl.Value, error) {","\treturn func(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\t\tc := R.(apl.Channel)","\t\treturn c.Apply(a, apl.Primitive(symbol), nil, false), nil","\t}","}","","// channel2 applies the dyadic elementary function to each value in a channel.","func channel2(symbol string, fn func(*apl.Apl, apl.Value, apl.Value) (apl.Value, bool)) func(*apl.Apl, apl.Value, apl.Value) (apl.Value, error) {","\treturn func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\tc := R.(apl.Channel)","\t\treturn c.Apply(a, apl.Primitive(symbol), L, false), nil","\t}","}",""],"comma.go":["package primitives","","import (","\t\"fmt\"","\t\"reflect\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \",\",","\t\tdoc:    \"ravel, ravel with axis\",","\t\tDomain: Monadic(nil),","\t\tfn:     ravel,","\t\tsel:    ravelSelection,","\t})","\tregister(primitive{","\t\tsymbol: \"∊\",","\t\tdoc:    \"enlist\",","\t\tDomain: Monadic(nil),","\t\tfn:     enlist,","\t})","\tregister(primitive{","\t\tsymbol: \",\",","\t\tdoc:    \"catenate, join along last axis\",","\t\tDomain: Dyadic(nil),","\t\tfn:     catenate,","\t})","\tregister(primitive{","\t\tsymbol: \"⍪\",","\t\tdoc:    \"catenate first\",","\t\tDomain: Dyadic(nil),","\t\tfn:     catenateFirst,","\t})","\tregister(primitive{","\t\tsymbol: \"⍪\",","\t\tdoc:    \"table\",","\t\tDomain: Monadic(nil),","\t\tfn:     table,","\t})","}","","// ravel returns a vector from all elements of R.","// R is already converted to an array.","func ravel(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tif _, ok := R.(apl.Axis); ok {","\t\treturn ravelWithAxis(a, R)","\t}","","\tto := ToArray(nil)","\tr, ok := to.To(a, R)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"ravel: cannot convert to array: %T\", R)","\t}","","\tar, _ := r.(apl.Array)","\tres := apl.NewMixed([]int{ar.Size()})","\tvar t reflect.Type","\tsame := true","\tfor i := range res.Values {","\t\tv := ar.At(i).Copy()","\t\tif i == 0 {","\t\t\tt = reflect.TypeOf(v)","\t\t} else if same {","\t\t\tif reflect.TypeOf(v) != t {","\t\t\t\tsame = false","\t\t\t}","\t\t}","\t\tres.Values[i] = v","\t}","\tif same {","\t\tu, _ := a.Unify(res, false)","\t\treturn u, nil","\t}","\treturn res, nil","}","","func ravelSelection(a *apl.Apl, L, R apl.Value) (apl.IntArray, error) {","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\treturn apl.IntArray{}, fmt.Errorf(\"ravel: cannot select from non-array: %T\", R)","\t}","\tai := apl.IntArray{Dims: []int{ar.Size()}}","\tai.Ints = make([]int, ai.Dims[0])","\tfor i := range ai.Ints {","\t\tai.Ints[i] = i","\t}","\treturn ai, nil","}","","func ravelWithAxis(a *apl.Apl, R apl.Value) (apl.Value, error) {","\tvar x []int","\tif r, vec, err := splitAxis(a, R); err == nil {","\t\tR = r","\t\tx = vec","\t} else if r, n, frac, err := splitCatAxis(a, apl.Int(0), R); err != nil {","\t\treturn nil, fmt.Errorf(\"ravel with axis: %s\", err)","\t} else {","\t\t// The result has rank ⍴⍴R+1 with the same shape as R,","\t\t// but a new axis 1 at position x.","\t\tif frac == false {","\t\t\treturn nil, fmt.Errorf(\"ravel with axis: expected fractional axis\")","\t\t}","\t\tx := n + 1","\t\tR = r","\t\tar, ok := R.(apl.Array)","\t\tif ok == false {","\t\t\treturn a.UnifyArray(apl.MixedArray{Dims: []int{1}, Values: []apl.Value{R.Copy()}}), nil","\t\t}","","\t\trs := ar.Shape()","\t\tshape := make([]int, len(rs)+1)","\t\toff := 0","\t\tfor i := range shape {","\t\t\tif i == x {","\t\t\t\tshape[i] = 1","\t\t\t\toff = -1","\t\t\t} else {","\t\t\t\tshape[i] = rs[i+off]","\t\t\t}","\t\t}","\t\tif rs, ok := ar.(apl.Reshaper); ok {","\t\t\treturn rs.Reshape(shape), nil","\t\t} else {","\t\t\treturn nil, fmt.Errorf(\"cannot reshape %T\", R)","\t\t}","\t}","","\t// The axis is an integer vector.","\t// It must be continuous and in ascending order.","\tfor i := range x {","\t\tif i \u003e 0 \u0026\u0026 x[i-1] != x[i]-1 {","\t\t\treturn nil, fmt.Errorf(\"ravel with axis: axis must be ascending and continuous\")","\t\t}","\t}","\tif len(x) == 1 {","\t\treturn R, nil","\t}","","\tar, Rarray := R.(apl.Array)","","\t// APL2: if the axis is empty, a new last axis of length 1 is appended.","\tif len(x) == 0 {","\t\tif Rarray == false {","\t\t\treturn a.UnifyArray(apl.MixedArray{Dims: []int{1}, Values: []apl.Value{R}}), nil","\t\t}","\t\tshape := apl.CopyShape(ar)","\t\tshape = append(shape, 1)","\t\tif rs, ok := ar.(apl.Reshaper); ok {","\t\t\treturn rs.Reshape(shape), nil","\t\t} else {","\t\t\treturn nil, fmt.Errorf(\"cannot reshape %T\", R)","\t\t}","\t}","","\tif Rarray == false {","\t\treturn nil, fmt.Errorf(\"ravel with axis: R must be an array: %T\", R)","\t}","\trs := ar.Shape()","","\t// The axis in x are combined.","\tprod := 1","\tfor _, n := range x {","\t\tprod *= rs[n]","\t}","\tshape := make([]int, 1+len(rs)-len(x))","\toff := 0","\tfor i := range shape {","\t\tif i == x[0] {","\t\t\tshape[i] = prod","\t\t\toff = len(x) - 1","\t\t} else {","\t\t\tshape[i] = rs[i+off]","\t\t}","\t}","\tif rs, ok := ar.(apl.Reshaper); ok {","\t\treturn rs.Reshape(shape), nil","\t} else {","\t\treturn nil, fmt.Errorf(\"cannot reshape %T\", R)","\t}","}","","// L and R are conformable if","//\tthey have the same rank, or","//\tat least one argument is scalar","//\tthey differ in rank by 1","// For arrays the length of all axis but the last must be the same.","func catenate(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tif l, r, first, ok := isTableCat(a, L, R); ok {","\t\treturn catenateTables(a, l, r, first)","\t}","","\t_, lst := L.(apl.List)","\t_, rst := R.(apl.List)","\tif lst || rst {","\t\treturn catenateLists(a, L, R)","\t}","","\tvar err error","\tvar x int","\tvar frac bool","\tR, x, frac, err = splitCatAxis(a, L, R)","\tif err != nil {","\t\treturn nil, err","\t}","\tif frac {","\t\treturn laminate(a, L, R, x+1)","\t}","","\tal, isLarray := L.(apl.Array)","\tar, isRarray := R.(apl.Array)","","\t// Left or right is an empty array","\tif isLarray \u0026\u0026 al.Size() == 0 {","\t\treturn R, nil","\t} else if isRarray \u0026\u0026 ar.Size() == 0 {","\t\treturn L, nil","\t}","","\t// Catenate two scalars.","\tif isLarray == false \u0026\u0026 isRarray == false {","\t\treturn a.UnifyArray(apl.MixedArray{","\t\t\tValues: []apl.Value{L.Copy(), R.Copy()},","\t\t\tDims:   []int{2},","\t\t}), nil","\t}","","\treshapeScalar := func(scalar apl.Value, othershape []int) apl.Array {","\t\tothershape[x] = 1","\t\tary := apl.NewMixed(othershape)","\t\tfor i := range ary.Values {","\t\t\tary.Values[i] = scalar.Copy()","\t\t}","\t\treturn a.UnifyArray(ary)","\t}","","\t// If one is scalar, reshape to match the other's shape, with","\t// the x axis length to 1.","\tif isLarray == false {","\t\tal = reshapeScalar(L, apl.CopyShape(ar))","\t} else if isRarray == false {","\t\tar = reshapeScalar(R, apl.CopyShape(al))","\t}","\tsl := al.Shape()","\tsr := ar.Shape()","","\treshape := func(ary apl.Array, shape []int) (apl.Array, error) {","\t\tif rs, ok := ary.(apl.Reshaper); ok {","\t\t\treturn rs.Reshape(shape).(apl.Array), nil","\t\t} else {","\t\t\treturn nil, fmt.Errorf(\"cannot reshape %T\", ary)","\t\t}","\t}","","\t// If ranks differ by 1: insert 1 at the axis.","\tinsert1 := func(s []int, i int) []int {","\t\ts = append(s, 0)","\t\tcopy(s[i+1:], s[i:])","\t\ts[x] = 1","\t\treturn s","\t}","\tif d := len(sl) - len(sr); d != 0 {","\t\tif d \u003c -1 || d \u003e 2 {","\t\t\treturn nil, fmt.Errorf(\"catenate: ranks differ more that 1\")","\t\t}","\t\tif d == -1 {","\t\t\tsl = insert1(apl.CopyShape(al), x)","\t\t\tal, err = reshape(al, sl)","\t\t} else if d == 1 {","\t\t\tsr = insert1(apl.CopyShape(ar), x)","\t\t\tar, err = reshape(ar, sr)","\t\t}","\t}","\tif err != nil {","\t\treturn nil, err","\t}","","\t// All axis lengths except for x must match.","\tnewshape := make([]int, len(sl))","\tfor i := range sl {","\t\tnewshape[i] = sl[i]","\t\tif i == x { // i == len(sl)-1 {","\t\t\tnewshape[i] = sl[i] + sr[i]","\t\t} else if sl[i] != sr[i] {","\t\t\treturn nil, fmt.Errorf(\"catenate: all axis lengths except for the catenation axis must match\")","\t\t}","\t}","\tres := apl.NewMixed(newshape)","","\t// Iterate over combined elements, taking from L or R.","\tsplit := sl[x]","\tdst := make([]int, len(newshape))","\tlc, src := apl.NewIdxConverter(sl)","\trc, _ := apl.NewIdxConverter(sr)","\tfor i := range res.Values {","\t\tvar v apl.Value","\t\tcopy(src, dst)","\t\tif n := src[x]; n \u003e= split {","\t\t\tsrc[x] -= split","\t\t\tv = ar.At(rc.Index(src))","\t\t} else {","\t\t\tv = al.At(lc.Index(src))","\t\t}","\t\tres.Values[i] = v.Copy()","\t\tapl.IncArrayIndex(dst, newshape)","\t}","\treturn a.UnifyArray(res), nil","}","","func catenateLists(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tl, lok := L.(apl.List)","\tr, rok := R.(apl.List)","\tif lok == false {","\t\tl = apl.List{L}","\t} else if rok == false {","\t\tr = apl.List{R}","\t}","\tres := make(apl.List, len(l)+len(r))","\tfor i, v := range l {","\t\tres[i] = v.Copy()","\t}","\tfor i, v := range r {","\t\tres[i+len(l)] = v.Copy()","\t}","\treturn res, nil","}","","func laminate(a *apl.Apl, L, R apl.Value, x int) (apl.Value, error) {","\tal, lok := L.(apl.Array)","\tar, rok := R.(apl.Array)","\tif lok == false \u0026\u0026 rok == false {","\t\tif x != 0 {","\t\t\treturn nil, fmt.Errorf(\"cannot laminate two scalar for given axis\")","\t\t}","\t\treturn a.UnifyArray(apl.MixedArray{Dims: []int{2}, Values: []apl.Value{L.Copy(), R.Copy()}}), nil","\t}","","\treshape := func(scalar apl.Value, shape []int) apl.Array {","\t\tary := apl.NewMixed(shape)","\t\tfor i := range ary.Values {","\t\t\tary.Values[i] = scalar.Copy()","\t\t}","\t\treturn a.UnifyArray(ary)","\t}","","\tif lok == false {","\t\tal = reshape(L, apl.CopyShape(ar))","\t} else if rok == false {","\t\tar = reshape(R, apl.CopyShape(al))","\t}","\tls := al.Shape()","\trs := ar.Shape()","","\tif len(ls) != len(rs) {","\t\treturn nil, fmt.Errorf(\"laminate: arguments must have the same rank\")","\t}","\tfor i := range ls {","\t\tif ls[i] != rs[i] {","\t\t\treturn nil, fmt.Errorf(\"laminate: arguments must have the same shape\")","\t\t}","\t}","","\t// The new array has one more dimension with length 2 at axis x,","\t// otherwise the shape is the same as for L and R.","\tshape := make([]int, len(ls)+1)","\toff := 0","\tfor i := range shape {","\t\tif i == x {","\t\t\tshape[i] = 2","\t\t\toff = -1","\t\t} else {","\t\t\tshape[i] = ls[i+off]","\t\t}","\t}","","\t// Iterate over the result and copy values from L or R depending,","\t// if the the index at axis x is 0 or 1.","\tres := apl.NewMixed(shape)","\tdst := make([]int, len(shape))","\tic, src := apl.NewIdxConverter(ls)","\tfor i := range res.Values {","\t\tvar v apl.Value","\t\tcopy(src[:x], dst[:x])","\t\tcopy(src[x:], dst[x+1:])","\t\tif dst[x] == 0 {","\t\t\tv = al.At(ic.Index(src))","\t\t} else {","\t\t\tv = ar.At(ic.Index(src))","\t\t}","\t\tres.Values[i] = v.Copy()","\t\tapl.IncArrayIndex(dst, shape)","\t}","\treturn a.UnifyArray(res), nil","}","","func catenateFirst(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tif _, ok := R.(apl.Axis); ok == true {","\t\treturn catenate(a, L, R)","\t}","\treturn catenate(a, L, apl.Axis{A: apl.Int(a.Origin), R: R})","}","","func table(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\treturn a.UnifyArray(apl.MixedArray{Dims: []int{1, 1}, Values: []apl.Value{R}}), nil","\t}","\trs := ar.Shape()","","\tprod := 1","\tfor _, n := range rs[1:] {","\t\tprod *= n","\t}","\tshape := []int{rs[0], prod}","","\tif rs, ok := ar.(apl.Reshaper); ok == false {","\t\treturn nil, fmt.Errorf(\"cannot reshape %T\", R)","\t} else {","\t\treturn rs.Reshape(shape), nil","\t}","}","","// enlist creates a flat list from a nested list catenating all elements by depth first.","func enlist(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tr, ok := R.(apl.List)","\tif ok == false {","\t\treturn apl.List{R.Copy()}, nil","\t}","","\tvar f func(l apl.List) apl.List","\tf = func(l apl.List) apl.List {","\t\tvar res apl.List","\t\tfor _, e := range l {","\t\t\tif v, ok := e.(apl.List); ok {","\t\t\t\tv = f(v)","\t\t\t\tres = append(res, v...)","\t\t\t} else {","\t\t\t\tres = append(res, e.Copy())","\t\t\t}","\t\t}","\t\treturn res","\t}","\treturn f(r), nil","}",""],"commands.go":["package a","","import (","\t\"time\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/numbers\"","\t\"github.com/ktye/iv/apl/scan\"",")","","// toCommand attaches the Rewrite method to the function.","type toCommand func([]scan.Token) []scan.Token","","func (f toCommand) Rewrite(t []scan.Token) []scan.Token {","\treturn f(t)","}","","func symbol(s string) scan.Token {","\treturn scan.Token{T: scan.Symbol, S: s}","}","","// rw0 is a scan.Command that rewrite the symbol with a 0 argument.","// Example:","//\t/q\tis rewritten to a→q 0","type rw0 string","","func (r rw0) Rewrite(t []scan.Token) []scan.Token {","\tsym := scan.Token{T: scan.Identifier, S: \"a→\" + string(r)}","\tnum := scan.Token{T: scan.Number, S: \"0\"}","\ttokens := make([]scan.Token, len(t)+2)","\ttokens[0] = sym","\ttokens[1] = num","\tcopy(tokens[2:], t)","\treturn tokens","}","","// printvar prints a string representation of the value.","// If the value is a string that is a valid variable name, it is dereferenced.","// This allows to print the definition of lambda functions.","func printvar(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\ts, ok := R.(apl.String)","\tif !ok {","\t\treturn apl.String(R.String(a.Format)), nil","\t}","\tv := a.Lookup(string(s))","\tif v == nil {","\t\treturn s, nil","\t}","\treturn apl.String(v.String(a.Format)), nil","}","","func printCmd(t []scan.Token) []scan.Token {","\treturn append([]scan.Token{scan.Token{T: scan.Identifier, S: \"a→p\"}}, t...)","}","","// Timer is used to time an expression. It is called by the rewrite command /t","// If the argument is a time, it returns the elapsed duration since that time.","// Otherwise it returns the current time.","func timer(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tt, ok := R.(numbers.Time)","\tif !ok {","\t\treturn numbers.Time(time.Now()), nil","\t}","\tdt := time.Since(time.Time(t))","\ty0, _ := time.Parse(\"15h04\", \"00h00\") // see apl/numbers/time.go","\treturn numbers.Time(y0.Add(dt)), nil","}","","// timeCmd rewrites the tokens to calculate the duration.","//\tT__← a→t 0 ⋄ [TOKENS] ⋄ a→t T__","func timeCmd(t []scan.Token) []scan.Token {","\tt__ := scan.Token{T: scan.Identifier, S: \"T__\"}","\tasn := symbol(\"←\")","\ttim := scan.Token{T: scan.Identifier, S: \"a→t\"}","\tnum := scan.Token{T: scan.Number, S: \"0\"}","\tdia := scan.Token{T: scan.Diamond, S: \"⋄\"}","","\ttokens := []scan.Token{t__, asn, tim, num, dia}","\ttokens = append(tokens, t...)","\treturn append(tokens, dia, tim, t__)","}",""],"commute.go":["package operators","","import (","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(operator{","\t\tsymbol:  \"⍨\",","\t\tDomain:  MonadicOp(Function(nil)),","\t\tdoc:     \"commute, duplicate\",","\t\tderived: commute,","\t})","}","","func commute(a *apl.Apl, f, _ apl.Value) apl.Function {","\tderived := func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\tf := f.(apl.Function)","\t\tif L == nil {","\t\t\tL = R.Copy()","\t\t}","\t\treturn f.Call(a, R, L)","\t}","\treturn function(derived)","}",""],"compare.go":["package primitives","","import (","\t\"reflect\"","\t\"time\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"","\t\"github.com/ktye/iv/apl/numbers\"",")","","func init() {","\ttab := []struct {","\t\tsymbol, doc string","\t}{","\t\t{\"=\", \"equality\"},","\t\t{\"\u003c\", \"less that\"},","\t\t{\"\u003e\", \"greater than\"},","\t\t{\"≠\", \"not equal\"},","\t\t{\"≤\", \"less or equal\"},","\t\t{\"≥\", \"greater or equal\"},","\t}","\tfor _, e := range tab {","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc,","\t\t\tDomain: Dyadic(Split(IsScalar(nil), IsScalar(nil))),","\t\t\tfn:     arith2(e.symbol, compare(e.symbol)),","\t\t})","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc,","\t\t\tDomain: arrays{},","\t\t\tfn:     array2(e.symbol, compare(e.symbol)),","\t\t})","\t}","","\tregister(primitive{","\t\tsymbol: \"\u003c\",","\t\tdoc:    \"channel send, source\",","\t\tDomain: Monadic(nil),","\t\tfn:     channelSource, // channel.go","\t})","\tregister(primitive{","\t\tsymbol: \"\u003c\",","\t\tdoc:    \"channel copy, connect\",","\t\tDomain: Dyadic(Split(IsChannel(nil), IsChannel(nil))),","\t\tfn:     channelCopy, // channel.go","\t})","\tregister(primitive{","\t\tsymbol: \"\u003c\",","\t\tdoc:    \"channel delay\",","\t\tDomain: Dyadic(Split(IsType(reflect.TypeOf(numbers.Time(time.Time{})), nil), IsChannel(nil))),","\t\tfn:     channelDelay, // channel.go","\t})","}","","func compare(symbol string) func(*apl.Apl, apl.Value, apl.Value) (apl.Value, bool) {","\treturn func(a *apl.Apl, L apl.Value, R apl.Value) (apl.Value, bool) {","\t\tswitch symbol {","\t\tcase \"=\":","\t\t\treturn equals(L, R)","\t\tcase \"\u003c\":","\t\t\treturn less(L, R)","\t\tcase \"\u003e\":","\t\t\teq, ls, ok := equalless(L, R)","\t\t\tif ok == false {","\t\t\t\treturn nil, false","\t\t\t}","\t\t\treturn apl.Bool(!eq \u0026\u0026 !ls), true","\t\tcase \"≠\":","\t\t\teq, ok := equals(L, R)","\t\t\tif ok == false {","\t\t\t\treturn nil, false","\t\t\t}","\t\t\treturn apl.Bool(!eq), true","\t\tcase \"≤\":","\t\t\teq, ls, ok := equalless(L, R)","\t\t\tif ok == false {","\t\t\t\treturn nil, false","\t\t\t}","\t\t\treturn apl.Bool(eq || ls), true","\t\tcase \"≥\":","\t\t\teq, ls, ok := equalless(L, R)","\t\t\tif ok == false {","\t\t\t\treturn nil, false","\t\t\t}","\t\t\treturn apl.Bool(eq || !ls), true","\t\t}","\t\treturn nil, false","\t}","}","","func equalless(L, R apl.Value) (apl.Bool, apl.Bool, bool) {","\teq, ok := equals(L, R)","\tif ok == false {","\t\treturn false, false, false","\t}","\tls, ok := less(L, R)","\tif ok == false {","\t\treturn false, false, false","\t}","\treturn eq, ls, true","}","func equals(L, R apl.Value) (apl.Bool, bool) {","\tif eq, ok := L.(equaler); ok {","\t\treturn eq.Equals(R)","\t}","\treturn apl.Bool(L == R), true","}","","type equaler interface {","\tEquals(apl.Value) (apl.Bool, bool)","}","","func less(L, R apl.Value) (apl.Bool, bool) {","\tif ls, ok := L.(lesser); ok {","\t\treturn ls.Less(R)","\t}","\treturn false, false","}","","type lesser interface {","\tLess(apl.Value) (apl.Bool, bool)","}",""],"complex.go":["package numbers","","import (","\t\"fmt\"","\t\"math\"","\t\"math/cmplx\"","\t\"strings\"","","\t\"github.com/ktye/iv/apl\"",")","","type Complex complex128","","// String formats a Float as a string.","// If the format string contains a single %, it is passed to fmt","// with the complex arguments.","// If it contains an \"a\", two format strings are assumed and magnitude","// and degree are passed to fmt.","// Otherwise real and imag parts are passed.","// By default - is replaced with ¯, expept if the format string","// starts with -.","// Examples:","//\t\"%.3f\", \"%ga%.0f\", \"-%v\", \"%.5fJ%.5f\"","func (c Complex) String(f apl.Format) string {","\tformat, minus := getformat(f, c)","\tif format == \"\" {","\t\tif f.PP \u003c 0 {","\t\t\tformat = \"%vJ%v\"","\t\t\tif f.PP == -2 { // json: there is no standard.","\t\t\t\tformat = \"[%v,%v]\"","\t\t\t} else if f.PP == -3 { // matlab","\t\t\t\tformat = \"%v\" // prints as \"(1-2i)\"","\t\t\t}","\t\t} else if f.PP == 0 {","\t\t\tformat = \"%.6GJ%.6G\"","\t\t} else {","\t\t\tformat = fmt.Sprintf(\"%%.%dGJ%%.%dG\", f.PP, f.PP)","\t\t}","\t}","\tvar s string","\tif strings.Count(format, \"%\") == 1 {","\t\ts = fmt.Sprintf(format, complex128(c))","\t} else {","\t\ta, b := real(c), imag(c)","\t\tif strings.Index(format, \"a\") != -1 || strings.Index(format, \"@\") != -1 {","\t\t\ta, b = cmplx.Polar(complex128(c))","\t\t\tb *= 180.0 / math.Pi","\t\t\tif b \u003c 0 {","\t\t\t\tb += 360","\t\t\t}","\t\t\tif a == 0 {","\t\t\t\tb = 0","\t\t\t}","\t\t\tif b == -0 || b == 360 {","\t\t\t\tb = 0","\t\t\t}","\t\t}","\t\ts = fmt.Sprintf(format, a, b)","\t}","\tif minus == false {","\t\ts = strings.Replace(s, \"-\", \"¯\", -1)","\t}","\treturn s","}","func (z Complex) Copy() apl.Value { return z }","","// ParseComplex parses a Complex from a string.","// The number may be given as MAGNITUDEaANGLE with the angle in degree,","// or as realJimag or REALjIMAG.","// Both parts are parsed as Floats.","// If neither \"a\" or \"J\" are within the string, it is parsed with 0 imag part.","func ParseComplex(s string) (apl.Number, bool) {","\tvar c Complex","\tif idx := strings.Index(s, \"a\"); idx != -1 {","\t\tmag, ok := ParseFloat(s[:idx])","\t\tif ok == false {","\t\t\treturn c, false","\t\t}","\t\tdeg, ok := ParseFloat(s[idx+1:])","\t\tif ok == false {","\t\t\treturn c, false","\t\t}","\t\tf := float64(mag.(Float))","\t\tswitch deg.(Float) {","\t\tcase 0:","\t\t\treturn Complex(complex(f, 0)), true","\t\tcase 90:","\t\t\treturn Complex(complex(0, f)), true","\t\tcase 180:","\t\t\treturn Complex(complex(-f, 0)), true","\t\tcase 270:","\t\t\treturn Complex(complex(0, -f)), true","\t\t}","\t\treturn Complex(cmplx.Rect(f, float64(deg.(Float))/180.0*math.Pi)), true","\t} else {","\t\tidx := strings.Index(s, \"J\")","\t\tif idx == -1 {","\t\t\tidx = strings.Index(s, \"j\")","\t\t}","\t\tif idx != -1 {","\t\t\tre, ok := ParseFloat(s[:idx])","\t\t\tif ok == false {","\t\t\t\treturn c, false","\t\t\t}","\t\t\tim, ok := ParseFloat(s[idx+1:])","\t\t\tif ok == false {","\t\t\t\treturn c, false","\t\t\t}","\t\t\treturn Complex(complex(float64(re.(Float)), float64(im.(Float)))), true","\t\t} else {","\t\t\tif n, ok := ParseFloat(s); ok == false {","\t\t\t\treturn c, false","\t\t\t} else {","\t\t\t\treturn Complex(complex(float64(n.(Float)), 0)), true","\t\t\t}","\t\t}","\t}","}","","// ToIndex converts a Complex to an int, if an exact conversion is possible.","func (c Complex) ToIndex() (int, bool) {","\tif imag(complex128(c)) != 0 {","\t\treturn 0, false","\t}","\tr := real(complex128(c))","\tn := int(r)","\tif float64(n) == r {","\t\treturn int(n), true","\t}","\treturn 0, false","}","","func (c Complex) Add() (apl.Value, bool) {","\treturn Complex(cmplx.Conj(complex128(c))), true","}","func (c Complex) Add2(R apl.Value) (apl.Value, bool) {","\treturn c + R.(Complex), true","}","","func (c Complex) Sub() (apl.Value, bool) {","\treturn -c, true","}","func (c Complex) Sub2(R apl.Value) (apl.Value, bool) {","\treturn c - R.(Complex), true","}","","func (c Complex) Mul() (apl.Value, bool) {","\tif c == 0 {","\t\treturn c, true","\t}","\tr := cmplx.Abs(complex128(c))","\treturn Complex(complex(real(c)/r, imag(c)/r)), true","}","func (c Complex) Mul2(R apl.Value) (apl.Value, bool) {","\treturn c * R.(Complex), true","}","","func (c Complex) Div() (apl.Value, bool) {","\tr := Complex(complex(1, 0) / complex128(c))","\tif e, ok := isException(r); ok {","\t\treturn e, true","\t}","\treturn r, true","}","func (c Complex) Div2(b apl.Value) (apl.Value, bool) {","\tr := Complex(complex128(c) / complex128(b.(Complex)))","\tif e, ok := isException(r); ok {","\t\treturn e, true","\t}","\treturn r, true","}","","func (c Complex) Pow() (apl.Value, bool) {","\treturn Complex(cmplx.Exp(complex128(c))), true","}","func (c Complex) Pow2(R apl.Value) (apl.Value, bool) {","\treturn Complex(cmplx.Pow(complex128(c), complex128(R.(Complex)))), true","}","","func (c Complex) Log() (apl.Value, bool) {","\tl := cmplx.Log(complex128(c))","\tif e, ok := isException(Complex(l)); ok {","\t\treturn e, true","\t}","\treturn Complex(l), true","}","func (c Complex) Log2(R apl.Value) (apl.Value, bool) {","\tl := cmplx.Log(complex128(c))","\tr := cmplx.Log(complex128(R.(Complex)))","\tif e, ok := isException(Complex(l)); ok {","\t\treturn e, true","\t}","\tif e, ok := isException(Complex(r)); ok {","\t\treturn e, true","\t}","\treturn Complex(r) / Complex(l), true","}","","func (c Complex) Abs() (apl.Value, bool) {","\t// This is a downtype. It only works, if the tower includes Float.","\treturn Float(cmplx.Abs(complex128(c))), true","}","","func (c Complex) Floor() (apl.Value, bool) {","\t// APL2 p 133.","\ta, b := real(complex128(c)), imag(complex128(c))","\tfa, fb := math.Floor(a), math.Floor(b)","\tif 1 \u003e (a-fa)+(b-fb) {","\t\treturn Complex(complex(fa, fb)), true","\t} else if 1 \u003c= (a-fa)+(b-fb) \u0026\u0026 (a-fa) \u003e= (b-fb) {","\t\treturn Complex(complex(1+fa, fb)), true","\t} else if 1 \u003c= (a-fa)+(b-fb) \u0026\u0026 (a-fa) \u003c (b-fb) {","\t\treturn Complex(complex(fa, 1+fb)), true","\t}","\tfmt.Println(\"Complex.Floor: unknown case: \", c)","\treturn nil, false","}","func (c Complex) Ceil() (apl.Value, bool) {","\tf, ok := (-c).Floor()","\tif ok == false {","\t\treturn nil, false","\t}","\treturn -f.(Complex), true","}","","func cgamma(z complex128) complex128 {","\t// complex gamma function using Lanczos approximation","\tp := []float64{0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7}","\tif real(z) \u003c 0.5 {","\t\t// gamma(z) gamma(1-z) = pi/sin(pi*z)","\t\treturn complex(math.Pi, 0) / (cmplx.Sin(math.Pi*z) * cgamma(1-z))","\t}","\tg := 7","\tx := complex(p[0], 0)","\tz -= complex(1, 0)","\tfor i := 1; i \u003c g+2; i++ {","\t\tx += complex(p[i], 0) / (z + complex(float64(i), 0))","\t}","\tt := z + complex(0.5+float64(g), 0)","\tz = cmplx.Pow(t, z+complex(0.5, 0)) * cmplx.Exp(-t) * x","\tsqrt2pi := math.Sqrt(2.0 * math.Pi)","\treturn complex(real(z)*sqrt2pi, imag(z)*sqrt2pi)","}","func cbeta(a, b complex128) complex128 {","\t// This is not a special implementation.","\treturn cgamma(a) * cgamma(b) / cgamma(a+b)","}","","func (c Complex) Gamma() (apl.Value, bool) {","\treturn Complex(cgamma(complex128(c) + 1)), true","}","func (c Complex) Gamma2(R apl.Value) (apl.Value, bool) {","\tl := complex128(c)","\tr := complex128(R.(Complex))","\tres := Complex(complex128(1.0 / ((r - l) * cbeta(r-l, l+1))))","\tif e, ok := isException(res); ok {","\t\treturn e, true","\t}","\treturn res, true","}","","func (c Complex) PiTimes() (apl.Value, bool) {","\treturn Complex(complex(math.Pi, 0)) * c, true","}","func (L Complex) Trig(R apl.Value) (apl.Value, bool) {","\tx := complex128(R.(Complex))","\tvar y complex128","\tswitch L {","\tcase 0:","\t\ty = cmplx.Sqrt(1.0 - x*x)","\tcase -1:","\t\ty = cmplx.Asin(x)","\tcase 1:","\t\ty = cmplx.Sin(x)","\tcase -2:","\t\ty = cmplx.Acos(x)","\tcase 2:","\t\ty = cmplx.Cos(x)","\tcase -3:","\t\ty = cmplx.Atan(x)","\tcase 3:","\t\ty = cmplx.Tan(x)","\tcase -4:","\t\ty = 0","\t\tif x != -1 {","\t\t\ty = (x + 1.0) * cmplx.Sqrt((x-1.0)/(x+1.0))","\t\t}","\tcase 4:","\t\ty = cmplx.Sqrt(1.0 + x*x)","\tcase -5:","\t\ty = cmplx.Asinh(x)","\tcase 5:","\t\ty = cmplx.Sinh(x)","\tcase -6:","\t\ty = cmplx.Acosh(x)","\tcase 6:","\t\ty = cmplx.Cosh(x)","\tcase -7:","\t\ty = cmplx.Atanh(x)","\tcase 7:","\t\ty = cmplx.Tanh(x)","\tcase -8:","\t\ty = -cmplx.Sqrt(x*x - 1.0)","\tcase 8:","\t\ty = cmplx.Sqrt(x*x - 1.0)","\tcase -9:","\t\ty = x","\tcase 9:","\t\treturn Float(real(x)), true","\tcase -10:","\t\treturn R.(Complex).Add()","\tcase 10:","\t\treturn Float(cmplx.Abs(x)), true","\tcase -11:","\t\ty = x * complex(0, 1)","\tcase 11:","\t\treturn Float(imag(x)), true","\tcase -12:","\t\ty = cmplx.Exp(x * complex(0, 1))","\tcase 12: // phase","\t\treturn Float(cmplx.Phase(x)), true","\tdefault:","\t\treturn nil, false","\t}","\treturn Complex(y), true","}","","// TODO (L Complex) Gcd(R apl.Value) (apl.Value, bool)",""],"complexs.go":["package numbers","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"",")","","// ComplexArray is a uniform array of complex128","type ComplexArray struct {","\tDims  []int","\tCmplx []complex128","}","","func (f ComplexArray) String(af apl.Format) string {","\treturn apl.ArrayString(af, f)","}","","func (f ComplexArray) Copy() apl.Value {","\tr := ComplexArray{Dims: apl.CopyShape(f), Cmplx: make([]complex128, len(f.Cmplx))}","\tcopy(r.Cmplx, f.Cmplx)","\treturn f","}","","func (f ComplexArray) At(i int) apl.Value {","\treturn Complex(f.Cmplx[i])","}","","func (f ComplexArray) Shape() []int {","\treturn f.Dims","}","","func (f ComplexArray) Size() int {","\treturn len(f.Cmplx)","}","","func (f ComplexArray) Zero() apl.Value {","\treturn Complex(0.0)","}","","func (f ComplexArray) Set(i int, v apl.Value) error {","\tif i \u003c 0 || i \u003e len(f.Cmplx) {","\t\treturn fmt.Errorf(\"index out of range\")","\t}","\tif c, ok := v.(Complex); ok {","\t\tf.Cmplx[i] = complex128(c)","\t\treturn nil","\t}","\treturn fmt.Errorf(\"cannot assign %T to ComplexArray\", v)","}","","func (f ComplexArray) Make(shape []int) apl.Uniform {","\treturn ComplexArray{","\t\tDims:  shape,","\t\tCmplx: make([]complex128, prod(shape)),","\t}","}","","func makeComplexArray(v []apl.Value) ComplexArray {","\tf := make([]complex128, len(v))","\tfor i, e := range v {","\t\tf[i] = complex128(e.(Complex))","\t}","\treturn ComplexArray{","\t\tDims:  []int{len(v)},","\t\tCmplx: f,","\t}","}","","func (f ComplexArray) Reshape(shape []int) apl.Value {","\tres := ComplexArray{","\t\tDims:  shape,","\t\tCmplx: make([]complex128, prod(shape)),","\t}","\tk := 0","\tfor i := range res.Cmplx {","\t\tres.Cmplx[i] = f.Cmplx[k]","\t\tk++","\t\tif k == len(f.Cmplx) {","\t\t\tk = 0","\t\t}","\t}","\treturn res","}",""],"convert.go":["package xgo","","import (","\t\"fmt\"","\t\"reflect\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/numbers\"",")","","// Exporter can be implemented by an apl.Value to be able convert it to a go value.","type Exporter interface {","\tExport() reflect.Value","}","","// export converts an apl value to a go value.","func export(v apl.Value, t reflect.Type) (reflect.Value, error) {","","\tif e, ok := v.(Exporter); ok {","\t\tx := e.Export()","\t\tif x.Type().ConvertibleTo(t) {","\t\t\treturn x.Convert(t), nil","\t\t}","\t}","","\tzero := reflect.Value{}","\tswitch t.Kind() {","","\tcase reflect.Int:","\t\treturn reflect.ValueOf(int(v.(apl.Int))), nil","","\tcase reflect.Float64:","\t\treturn reflect.ValueOf(float64(v.(numbers.Float))), nil","","\tcase reflect.Complex128:","\t\treturn reflect.ValueOf(complex128(v.(numbers.Complex))), nil","","\tcase reflect.String:","\t\treturn reflect.ValueOf(string(v.(apl.String))), nil","","\tcase reflect.Slice:","\t\tar, ok := v.(apl.Array)","\t\tif ok == false {","\t\t\treturn zero, fmt.Errorf(\"expected slice: %T\", v)","\t\t}","\t\tet := t.Elem()","\t\tn := ar.Size()","\t\ts := reflect.MakeSlice(t, n, n)","\t\tfor i := 0; i \u003c n; i++ {","\t\t\tif e, err := export(ar.At(i), et); err != nil {","\t\t\t\treturn zero, err","\t\t\t} else {","\t\t\t\tse := s.Index(i)","\t\t\t\tse.Set(e)","\t\t\t}","\t\t}","\t\treturn s, nil","","\tcase reflect.Struct:","\t\tif xv, ok := v.(Value); ok {","\t\t\tst := reflect.Value(xv).Type()","\t\t\tif st == reflect.PtrTo(t) {","\t\t\t\treturn reflect.Indirect(reflect.Value(xv)), nil","\t\t\t} else if st == t {","\t\t\t\treturn reflect.Value(xv), nil","\t\t\t}","\t\t}","\t\treturn zero, fmt.Errorf(\"xgo: export struct: cannot convert %T to %s\", v, t)","","\tdefault:","\t\treturn zero, fmt.Errorf(\"cannot convert to %v (%s)\", t, t.Kind())","\t}","}","","// convert converts a go value to an apl value.","func Convert(v reflect.Value) (apl.Value, error) {","\tswitch v.Kind() {","\tcase reflect.Int:","\t\treturn apl.Int(int(v.Int())), nil","","\tcase reflect.Uint:","\t\treturn apl.Int(int(v.Uint())), nil","","\tcase reflect.Float64:","\t\treturn numbers.Float(v.Float()), nil","","\tcase reflect.Complex128:","\t\treturn numbers.Complex(v.Complex()), nil","","\tcase reflect.String:","\t\treturn apl.String(v.String()), nil","","\tcase reflect.Slice:","\t\tn := v.Len()","\t\tar := apl.NewMixed([]int{n})","\t\tfor i := range ar.Values {","\t\t\tif e, err := Convert(v.Index(i)); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else {","\t\t\t\tar.Values[i] = e","\t\t\t}","\t\t}","\t\treturn ar, nil","","\tcase reflect.Struct:","\t\treturn Value(v.Addr()), nil // TODO: populate","","\tdefault:","\t\treturn nil, fmt.Errorf(\"cannot convert %s to an apl value\", v.Kind())","\t}","}",""],"decode.go":["package primitives","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"","\t\"github.com/ktye/iv/apl/operators\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"⊥\",","\t\tdoc:    \"decode, polynom, base value\",","\t\tDomain: Dyadic(Split(ToArray(nil), ToArray(nil))),","\t\tfn:     decode,","\t})","\tregister(primitive{","\t\tsymbol: \"⊤\",","\t\tdoc:    \"encode, representation\",","\t\tDomain: Dyadic(nil),","\t\tfn:     encode,","\t})","}","","func decode(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tal := L.(apl.Array)","\tar := R.(apl.Array)","\tls := al.Shape()","\trs := ar.Shape()","","\t// The last axis of L must match the first axis of R.","\t// Single element axis are extended.","\tif n := ls[len(ls)-1]; n != rs[0] {","\t\tif n == 1 {","\t\t\tal, ls = extendAxis(al, len(ls)-1, rs[0])","\t\t} else if rs[0] == 1 {","\t\t\tar, rs = extendAxis(ar, 0, n)","\t\t} else {","\t\t\treturn nil, fmt.Errorf(\"decode: last axis of L must match first axis of R: %v %v\", ls, rs)","\t\t}","\t}","","\t// The result of decode is a scalar product between a power matrix and R.","\t// The power matrix multiplies L along the last axis recursively from right to left,","\t// similar as the Index method of apl.IdxConverter.","\tp := apl.NewMixed(apl.CopyShape(al))","\tfor i := range p.Values {","\t\tp.Values[i] = al.At(i).Copy()","\t}","\tN := ls[len(ls)-1]","","\t// Shift last axis by 1 to the left than multiply scan from the right.","\tfmul := arith2(\"×\", mul2)","\tfor off := 0; off \u003c len(p.Values); off += N {","\t\tfor k := 0; k \u003c N-1; k++ {","\t\t\tp.Values[off+k] = p.Values[off+k+1]","\t\t}","\t\tp.Values[off+N-1] = apl.Int(1)","\t\tfor k := off + N - 1; k \u003e= off+1; k-- {","\t\t\tv, err := fmul(a, p.Values[k], p.Values[k-1])","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tp.Values[k-1] = v","\t\t}","\t}","","\tdot := operators.Scalarproduct(a, apl.Primitive(\"+\"), apl.Primitive(\"×\"))","\treturn dot.Call(a, a.UnifyArray(p), ar)","}","","// extendAxis extends the axis of length 1 to n","func extendAxis(ar apl.Array, axis, n int) (apl.Array, []int) {","\tdims := apl.CopyShape(ar)","\tdims[axis] = n","\tres := apl.NewMixed(dims)","\tridx := make([]int, len(res.Dims))","\tic, idx := apl.NewIdxConverter(ar.Shape())","\tfor i := range res.Values {","\t\tcopy(idx, ridx)","\t\tidx[axis] = 0","\t\tres.Values[i] = ar.At(ic.Index(idx)).Copy()","\t\tapl.IncArrayIndex(ridx, res.Dims)","\t}","\treturn res, res.Dims","}","","// ISO p.151","func encode(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tal, lok := L.(apl.Array)","\tar, rok := R.(apl.Array)","","\t// If L or R is empty, return (⍴L,⍴R)⍴0.","\t_, ae := L.(apl.EmptyArray)","\t_, re := R.(apl.EmptyArray)","\tif ae || re {","\t\tvar shape []int","\t\tif lok {","\t\t\tif ae {","\t\t\t\tshape = []int{0}","\t\t\t} else {","\t\t\t\tshape = append(shape, al.Shape()...)","\t\t\t}","\t\t}","\t\tif rok {","\t\t\tif re {","\t\t\t\tshape = append(shape, 0)","\t\t\t} else {","\t\t\t\tshape = append(shape, ar.Shape()...)","\t\t\t}","\t\t}","\t\tsv := apl.IntArray{Dims: []int{len(shape)}, Ints: shape}","\t\tzv := apl.IntArray{Dims: []int{1}, Ints: []int{0}}","\t\treturn rho2(a, sv, zv)","\t}","","\t// If L is a scalar, return L|R.","\tif lok == false {","\t\tif rok == false {","\t\t\tmod := arith2(\"|\", abs2)","\t\t\treturn mod(a, L, R)","\t\t} else {","\t\t\tmod := array2(\"|\", abs2)","\t\t\treturn mod(a, L, R)","\t\t}","\t}","","\t// L is a vector and R is a scalar.","\tls := al.Shape()","\tif len(ls) == 1 \u0026\u0026 rok == false {","\t\travelL := make([]apl.Value, ls[0])","\t\tfor i := range ravelL {","\t\t\travelL[i] = al.At(i).Copy()","\t\t}","\t\treturn encodeVecScalar(a, ravelL, R)","\t}","","\treturn encodeArray(a, al, R)","}","","// encodeVecScalar returns L⊤R for vector L and scalar R.","func encodeVecScalar(a *apl.Apl, L []apl.Value, R apl.Value) (apl.Value, error) {","\teq := arith2(\"=\", compare(\"=\"))","\tfsub := arith2(\"-\", sub2)","\tfdiv := arith2(\"÷\", div2)","\tmod := arith2(\"|\", abs2)","","\t// Two vectors Z (len ⍴A) and C (len 1+⍴A)","\tZ := make([]apl.Value, len(L))","\tC := make([]apl.Value, len(L)+1)","\tC[len(C)-1] = R","\tfor i := len(Z) - 1; i \u003e= 0; i-- {","\t\t// Z[i] ← L[i] ⊤ C[i+1]","\t\tv, err := mod(a, L[i], C[i+1])","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tZ[i] = v.Copy()","","\t\t// If L[i] is 0: C[i] ← 0","\t\ta0, err := eq(a, L[i], apl.Int(0))","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tif iszero := a0.(apl.Bool); iszero == true {","\t\t\tC[i] = apl.Int(0)","\t\t} else {","\t\t\t// Otherwise: C[i] ← (C[i+1] - Z[i])÷A[i]","\t\t\td, err := fsub(a, C[i+1], Z[i])","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\td, err = fdiv(a, d, L[i])","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tC[i] = d.Copy()","\t\t}","\t}","\treturn a.UnifyArray(apl.MixedArray{Dims: []int{len(Z)}, Values: Z}), nil","}","","func encodeArray(a *apl.Apl, al apl.Array, R apl.Value) (apl.Value, error) {","\tls := al.Shape()","\trs := []int{}","\tar, rok := R.(apl.Array)","\tif rok {","\t\trs = ar.Shape()","\t}","","\tfdiv := arith2(\"/\", div2)","\tflor := arith1(\"⌊\", min)","\tfmul := arith2(\"×\", mul2)","\tfsub := arith2(\"-\", sub2)","\tmod := arith2(\"|\", abs2)","\teq := arith2(\"=\", compare(\"=\"))","","\t// The shape of the result is the catenation of the shapes of L and R.","\tshape := make([]int, len(ls)+len(rs))","\tcopy(shape[:len(ls)], ls)","\tcopy(shape[len(ls):], rs)","\tres := apl.NewMixed(shape)","","\t// enc represents r in the given radix power vector and sets the result to vec.","\tenc := func(rad []apl.Value, r apl.Value, vec []apl.Value) error {","\t\tvar p apl.Value","\t\tfor i := range rad {","\t\t\tp = apl.Int(1)","\t\t\tif i \u003c len(rad)-1 {","\t\t\t\tp = rad[i+1]","\t\t\t}","\t\t\tv, err := fdiv(a, r, p)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\t// Dont take the residue for the last value.","\t\t\tif i \u003c len(rad)-1 {","\t\t\t\tv, err = flor(a, nil, v)","\t\t\t\tif err != nil {","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t}","\t\t\tvec[i] = v.Copy()","\t\t\tu, err := fmul(a, v, p)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tr, err = fsub(a, r, u)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","","\t\t// If L has no zero lead, numbers exceeding the representation is incomplete.","\t\tzerold, err := eq(a, rad[0], apl.Int(0))","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif zerold.(apl.Bool) == false {","\t\t\tvec[0], err = mod(a, rad[0], vec[0])","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","\t\treturn nil","\t}","","\t// Apply the powerradix vector to r and set the result","\tvec := make([]apl.Value, shape[0])","\tapply := func(rad []apl.Value, r apl.Value, n, off int) error {","\t\tif err := enc(rad, r, vec); err != nil {","\t\t\treturn err","\t\t}","\t\tfor i := range vec {","\t\t\tres.Values[i*n+off] = vec[i].Copy()","\t\t}","\t\treturn nil","\t}","","\t// Powerradix recursively multiplies from the right.","\t// The index 0 value is preserved to determine","\t// underrepesented values.","\tpowerradix := func(rad []apl.Value) error {","\t\tfor i := len(rad) - 2; i \u003e 0; i-- {","\t\t\tv, err := fmul(a, rad[i], rad[i+1])","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\trad[i] = v.Copy()","\t\t}","\t\treturn nil","\t}","","\t// Number of iterations over L omitting the first axis","\tNL := 1","\tif len(ls) \u003e 1 {","\t\tNL = apl.Prod(ls[1:])","\t}","\t// Number of iterations over R","\tNR := 0","\tif rok {","\t\tNR = ar.Size()","\t}","\t// Number of result elements divided by length of first axis","\tNN := 1","\tif len(shape) \u003e 1 {","\t\tNN = apl.Prod(shape[1:])","\t}","\trad := make([]apl.Value, shape[0])","\toff := 0","\tfor i := 0; i \u003c NL; i++ {","\t\t// Build radix vec from the first axis of L","\t\tfor k := 0; k \u003c len(rad); k++ {","\t\t\trad[k] = al.At(k*NL + i).Copy()","\t\t}","\t\tpowerradix(rad)","","\t\tif rok == false {","\t\t\tif err := apply(rad, R, NN, off); err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\toff++","\t\t}","\t\tfor k := 0; k \u003c NR; k++ {","\t\t\tif err := apply(rad, ar.At(k), NN, off); err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\toff++","\t\t}","\t}","\treturn a.UnifyArray(res), nil","}","","/* There should be a simpler algorithm for encodeArray:","// ISO p.151","// The shape of the result is ⍴L,⍴R","shape := apl.CopyShape(al)","if rok {","\tshape = append(shape, apl.CopyShape(ar)...)","}","res := apl.GeneralArray{Dims: shape}","res.Values = make([]apl.Value, apl.ArraySize(res))","","// Ravel list of R","var r []apl.Value","if rok == false {","\tr = []apl.Value{R}","} else {","\tr = make([]apl.Value, apl.ArraySize(ar))","\tfor i := 0; i \u003c len(r); i++ {","\t\tr[i], _ = ar.At(i)","\t}","}","N := len(r)","","// Ravel-along-axis one (see ISO p.23)","// A1: Vector item i of ravel-along-axis one of L","A1 := make([]apl.Value, apl.ArraySize(al)/ls[0])","var err error","for i := 0; i \u003c ls[0]; i++ {","\toff := i * len(A1)","\tfor k := range A1 {","\t\tA1[k], err = al.At(off + k)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t}","\tfmt.Println(\"A1\", A1)","\tfor j, B1 := range r {","\t\tP := j + N*i","\t\tv, err := encodeVecScalar(a, A1, B1)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tres.Values[P] = v","\t}","}","return res, nil","*/",""],"dict.go":["package primitives","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"","\t\"github.com/ktye/iv/apl/xgo\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"#\",","\t\tdoc:    \"keys, methods\",","\t\tDomain: Monadic(nil),","\t\tfn:     keys,","\t})","\tregister(primitive{","\t\tsymbol: \"#\",","\t\tdoc:    \"dict\",","\t\tDomain: Dyadic(nil),","\t\tfn:     dict,","\t})","}","","// keys: R: object","func keys(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tmethods := false","\tif _, ok := R.(apl.Axis); ok {","\t\tmethods = true","\t\tif r, _, err := splitAxis(a, R); err != nil {","\t\t\treturn nil, err","\t\t} else {","\t\t\tR = r","\t\t}","\t}","\tobj, ok := R.(apl.Object)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"keys: expected object: %T\", R)","\t}","\tif methods {","\t\to, ok := obj.(xgo.Value)","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"methods: expected xgo.Value: %T\", obj)","\t\t}","\t\ts := o.Methods()","\t\tif s == nil {","\t\t\treturn apl.EmptyArray{}, nil","\t\t}","\t\treturn apl.StringArray{Dims: []int{len(s)}, Strings: s}, nil","\t} else {","\t\tkeyval := obj.Keys()","\t\tvalues := make([]apl.Value, len(keyval))","\t\tfor i, v := range keyval {","\t\t\tvalues[i] = v.Copy()","\t\t}","\t\treturn a.UnifyArray(apl.MixedArray{","\t\t\tDims:   []int{len(values)},","\t\t\tValues: values,","\t\t}), nil","\t}","}","","func dict(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tal, ok := L.(apl.Array)","","\tif ok == false {","\t\treturn \u0026apl.Dict{","\t\t\tK: []apl.Value{L.Copy()},","\t\t\tM: map[apl.Value]apl.Value{","\t\t\t\tL: R.Copy(),","\t\t\t},","\t\t}, nil","\t}","","\tls := al.Shape()","\tif len(ls) != 1 {","\t\treturn nil, fmt.Errorf(\"dict: left argument must be a vector\")","\t}","","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\tmr := apl.NewMixed([]int{ls[0]})","\t\tfor i := range mr.Values {","\t\t\tmr.Values[i] = R.Copy()","\t\t}","\t\tar = mr","\t}","\trs := ar.Shape()","\tif len(rs) != 1 || rs[0] != ls[0] {","\t\treturn nil, fmt.Errorf(\"dict: left and right arguments do not conform\")","\t}","","\tk := make([]apl.Value, al.Size())","\tm := make(map[apl.Value]apl.Value)","\tfor i := 0; i \u003c al.Size(); i++ {","\t\tl := al.At(i).Copy()","\t\tm[l] = ar.At(i).Copy()","\t\tk[i] = l","\t}","\treturn \u0026apl.Dict{","\t\tK: k,","\t\tM: m,","\t}, nil","}",""],"domain.go":["package apl","","// Domain represents the application domain of a function or operator.","// Calling To converts the left and right input arguments and returns true,","// if the types or values are compatible with the function or operator.","// Otherwise they return false.","// If To returns false, it must return the original input values.","// This is important for a Not combination to work properly.","// String is used in documentation for a concise type/value description.","//","// Standard Domain implementations and universal combination functions","// are in the domain package.","type Domain interface {","\tTo(*Apl, Value, Value) (Value, Value, bool)","\tString(Format) string","}",""],"domino.go":["package primitives","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"","\t\"github.com/ktye/iv/apl/operators\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"⌹\",","\t\tdoc:    \"matrix inverse, domino\",","\t\tDomain: Monadic(ToArray(nil)),","\t\tfn:     domino,","\t})","\tregister(primitive{","\t\tsymbol: \"⌹\",","\t\tdoc:    \"matrix divide, solve linear system, domino\",","\t\tDomain: Dyadic(Split(ToArray(nil), ToArray(nil))),","\t\tfn:     domino2,","\t})","}","","// Domino is the general matrix divide for any numeric types.","// This gives exact results for rational numbers.","// There are faster methods for float and complex types as external packages.","func domino(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tif _, ok := R.(apl.EmptyArray); ok {","\t\treturn apl.EmptyArray{}, nil","\t}","\tar := R.(apl.Array)","\trs := ar.Shape()","\tif len(rs) \u003e 2 {","\t\treturn nil, fmt.Errorf(\"matrix inverse: rank cannot be \u003e 2: %d\", len(rs))","\t} else if len(rs) == 0 {","\t\treturn apl.EmptyArray{}, nil","\t} else if len(rs) == 1 {","\t\tf := array1(\"÷\", div)","\t\treturn f(a, nil, R)","\t}","\tif rs[0] != rs[1] {","\t\treturn nil, fmt.Errorf(\"matrix inverse only works for a quadratic matrix\")","\t}","","\tn := rs[0]","\tI := apl.IntArray{Dims: []int{n, n}}","\tI.Ints = make([]int, n*n)","\tfor i := 0; i \u003c n; i++ {","\t\tI.Ints[i*n+i] = 1","\t}","\treturn domino2(a, I, ar)","}","","func domino2(a *apl.Apl, RHS, R apl.Value) (apl.Value, error) {","\tal := RHS.(apl.Array)","\tar := R.(apl.Array)","\tls := al.Shape()","\trs := ar.Shape()","","\tif ar.Size() == 1 {","\t\tf := array2(\"÷\", div2)","\t\treturn f(a, al, ar)","\t}","","\tif len(rs) != 2 {","\t\treturn nil, fmt.Errorf(\"matrix divide: right argument matrix must have rank 2\")","\t}","\tif rs[0] \u003c rs[1] {","\t\treturn nil, fmt.Errorf(\"matrix divide: right argument matrix has more columns than rows\")","\t}","\tif len(ls) == 1 {","\t\tif rsh, ok := al.(apl.Reshaper); ok {","\t\t\tv := rsh.Reshape([]int{ls[0], 1})","\t\t\tal = v.(apl.Array)","\t\t} else {","\t\t\treturn nil, fmt.Errorf(\"matrix divide: cannot reshape left argument vector: %T\", al)","\t\t}","\t\tls = al.Shape()","\t} else if len(ls) != 2 {","\t\treturn nil, fmt.Errorf(\"matrix divide: left argument must have rank 2: %d\", len(ls))","\t}","\tif ls[0] != rs[0] {","\t\treturn nil, fmt.Errorf(\"matrix divide: left and right matrices must have the same number of rows\")","\t}","","\t// For overdetermined systems, multiply with complex conjugate.","\t// We have no special QR algorithm for the general case.","\tif rs[0] \u003e rs[1] {","\t\tconj := array1(\"+\", add)","\t\th, err := conj(a, nil, ar)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\th, err = transpose(a, nil, h)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tAH := h.(apl.Array)","","\t\tmmul := operators.Scalarproduct(a, apl.Primitive(\"+\"), apl.Primitive(\"×\"))","\t\tAHA, err := mmul.Call(a, AH, ar)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tAHB, err := mmul.Call(a, AH, al)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","","\t\tar = AHA.(apl.Array)","\t\tal = AHB.(apl.Array)","\t\trs = ar.Shape()","\t\tls = al.Shape()","\t}","","\tres := apl.NewMixed([]int{rs[0], ls[1]})","","\t// A is a copy of ar as a 2d slice of Values.","\t// It will be overwritten by LU.","\tn := rs[0]","\tA := make([][]apl.Value, n)","\tfor i := range A {","\t\tA[i] = make([]apl.Value, n)","\t\tfor k := range A[i] {","\t\t\tA[i][k] = ar.At(i*n + k).Copy()","\t\t}","\t}","","\t// LU Decomposition overwrites M and returns the permutation matrix.","\tP, err := lu(a, A)","\tif err != nil {","\t\treturn nil, err","\t}","","\t// TODO: solve for each column vector of al.","\tb := make([]apl.Value, n)","\tx := make([]apl.Value, n)","\tfor k := 0; k \u003c ls[1]; k++ {","\t\t// Copy column k of RHS to b.","\t\tfor i := 0; i \u003c n; i++ {","\t\t\tb[i] = al.At(i*ls[1] + k).Copy()","\t\t}","","\t\t// Solve for x.","\t\tluSolve(a, A, b, P, x)","","\t\t// Copy x to result array.","\t\tfor i := 0; i \u003c n; i++ {","\t\t\tres.Values[i*ls[1]+k] = x[i].Copy()","\t\t}","\t}","\treturn a.UnifyArray(res), nil","}","","// LU decomposition.","func lu(a *apl.Apl, A [][]apl.Value) ([]int, error) {","\tfabs := arith1(\"|\", abs)","\tfmul := arith2(\"×\", mul2)","\tfdiv := arith2(\"÷\", div2)","\tfsub := arith2(\"-\", sub2)","\tfless := arith2(\"\u003c\", compare(\"\u003c\"))","","\tn := len(A)","\tP := make([]int, n)","\tfor i := range P {","\t\tP[i] = i","\t}","","\tvar max apl.Value","\tfor i := 0; i \u003c n; i++ {","","\t\t// Find row max.","\t\tmax = apl.Int(0)","\t\timax := i","\t\tfor k := i; k \u003c n; k++ {","\t\t\tabsA, err := fabs(a, nil, A[k][i])","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tlt, err := fless(a, max, absA)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tif lt.(apl.Bool) == true {","\t\t\t\tmax = absA","\t\t\t\timax = k","\t\t\t}","\t\t}","","\t\t// We do not compare against a tolerance, but against 0.","\t\tif isEqual(a, apl.Int(0), max) {","\t\t\treturn nil, fmt.Errorf(\"matrix is singular\")","\t\t}","","\t\tif imax != i {","\t\t\tP[i], P[imax] = P[imax], P[i]","\t\t\tA[i], A[imax] = A[imax], A[i]","\t\t\t// P[n]++ only needed to compute the determinant.","\t\t}","","\t\tfor j := i + 1; j \u003c n; j++ {","\t\t\tv, err := fdiv(a, A[j][i], A[i][i])","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tA[j][i] = v","\t\t\tfor k := i + 1; k \u003c n; k++ {","\t\t\t\tv, err := fmul(a, A[j][i], A[i][k])","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\tv, err = fsub(a, A[j][k], v)","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\tA[j][k] = v","\t\t\t}","\t\t}","\t}","\treturn P, nil","}","","func luSolve(a *apl.Apl, A [][]apl.Value, b []apl.Value, P []int, x []apl.Value) error {","\tfmul := arith2(\"×\", mul2)","\tfdiv := arith2(\"÷\", div2)","\tfsub := arith2(\"-\", sub2)","\tn := len(A)","\tfor i := 0; i \u003c n; i++ {","\t\tx[i] = b[P[i]]","\t\tfor k := 0; k \u003c i; k++ {","\t\t\tv, err := fmul(a, A[i][k], x[k])","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tv, err = fsub(a, x[i], v)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tx[i] = v","\t\t}","\t}","\tfor i := n - 1; i \u003e= 0; i-- {","\t\tfor k := i + 1; k \u003c n; k++ {","\t\t\tv, err := fmul(a, A[i][k], x[k])","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tv, err = fsub(a, x[i], v)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tx[i] = v","\t\t}","\t\tv, err := fdiv(a, x[i], A[i][i])","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tx[i] = v","\t}","\treturn nil","}",""],"dot.go":["package operators","","import (","\t\"fmt\"","\t\"reflect\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(operator{","\t\tsymbol:  \".\",","\t\tDomain:  DyadicOp(Split(Function(nil), Function(nil))),","\t\tdoc:     \"inner product\",","\t\tderived: innerproduct,","\t})","\tregister(operator{","\t\tsymbol:  \".\",","\t\tDomain:  DyadicOp(Split(primitive(\"+\"), primitive(\"×\"))),","\t\tdoc:     \"scalar product\",","\t\tderived: Scalarproduct,","\t})","}","","func innerproduct(a *apl.Apl, f, g apl.Value) apl.Function {","\tderived := func(a *apl.Apl, l, r apl.Value) (apl.Value, error) {","\t\tf := f.(apl.Function)","\t\tg := g.(apl.Function)","\t\tif f == apl.Primitive(\"∘\") {","\t\t\treturn outer(a, l, r, f, g)","\t\t}","\t\treturn inner(a, l, r, f, g)","\t}","\treturn function(derived)","}","","func Scalarproduct(a *apl.Apl, f, g apl.Value) apl.Function {","\tdf := f.(apl.Primitive) // +","\tdg := g.(apl.Primitive) // ×","\tderived := func(a *apl.Apl, l, r apl.Value) (apl.Value, error) {","","\t\t// Special case for a scalar product.","\t\t// If both have the same type and implement a ScalarProducter, use the interface.","\t\tif reflect.TypeOf(l) == reflect.TypeOf(r) {","\t\t\tif sc, ok := l.(scalarProducter); ok {","\t\t\t\treturn sc.ScalarProduct(r)","\t\t\t}","\t\t}","\t\treturn inner(a, l, r, df, dg)","\t}","\treturn function(derived)","}","","func inner(a *apl.Apl, l, r apl.Value, f, g apl.Function) (apl.Value, error) {","\tal, lok := l.(apl.Array)","\tar, rok := r.(apl.Array)","","\tif lok == false \u0026\u0026 rok == false {","\t\t// Both are scalars, compute l g r.","\t\tv, err := g.Call(a, l, r)","\t\treturn v, err","\t}","","\t// If one is a scalar, convert it to a vector.","\tif lok == false {","\t\trs := ar.Shape()","\t\tif rs == nil || rs[0] == 0 {","\t\t\t// TODO fill function?","\t\t\treturn nil, fmt.Errorf(\"inner: empty rhs array\")","\t\t}","\t\tu := apl.NewMixed([]int{rs[0]})","\t\tfor i := range u.Values {","\t\t\tu.Values[i] = l.Copy()","\t\t}","\t\tal = a.UnifyArray(u)","\t} else if rok == false {","\t\tls := al.Shape()","\t\tif ls == nil || ls[0] == 0 {","\t\t\treturn nil, fmt.Errorf(\"inner: empty lhs array\")","\t\t}","\t\tu := apl.NewMixed([]int{ls[len(ls)-1]})","\t\tfor i := range u.Values {","\t\t\tu.Values[i] = r.Copy()","\t\t}","\t\tar = a.UnifyArray(u)","\t}","","\t// The result is a new array with a shape of both arrays combined, without the inner dimension.","\tls := al.Shape()","\trs := ar.Shape()","\tif len(ls) == 0 || len(rs) == 0 {","\t\treturn nil, fmt.Errorf(\"inner: empty array\")","\t}","\tinner := ls[len(ls)-1]","\tif inner != rs[0] {","\t\treturn nil, fmt.Errorf(\"inner dimensions must agree\")","\t}","","\t// If both arrays are vectors, compute a scalar.","\tif len(ls) == 1 \u0026\u0026 len(rs) == 1 {","\t\tvar v apl.Value","\t\tfor k := inner - 1; k \u003e= 0; k-- {","\t\t\tif u, err := g.Call(a, al.At(k), ar.At(k)); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else if k == inner-1 {","\t\t\t\tv = u","\t\t\t} else {","\t\t\t\tif u, err := f.Call(a, u, v); err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t} else {","\t\t\t\t\tv = u","\t\t\t\t}","\t\t\t}","\t\t}","\t\treturn v.Copy(), nil","\t}","","\tshape := make([]int, len(ls)+len(rs)-2)","\tcopy(shape, ls[:len(ls)-1])","\tcopy(shape[len(ls)-1:], rs[1:])","\tres := apl.NewMixed(shape)","","\t// Iterate of all elements of the resulting array.","\tic, idx := apl.NewIdxConverter(shape)","\tlic, lidx := apl.NewIdxConverter(ls)","\tric, ridx := apl.NewIdxConverter(rs)","\tsplit := len(ls) - 1","\tfor i := range res.Values {","\t\tic.Indexes(i, idx)","","\t\t// Split the indexes in idx into the original indexes of both arrays.","\t\tcopy(lidx, idx[:split])     // The last index is open.","\t\tcopy(ridx[1:], idx[split:]) // The first index is open.","\t\tvar v apl.Value","\t\tfor k := inner - 1; k \u003e= 0; k-- {","\t\t\tlidx[len(lidx)-1] = k","\t\t\tridx[0] = k","\t\t\tif u, err := g.Call(a, al.At(lic.Index(lidx)), ar.At(ric.Index(ridx))); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else if k == inner-1 {","\t\t\t\tv = u","\t\t\t} else {","\t\t\t\tif u, err := f.Call(a, u, v); err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t} else {","\t\t\t\t\tv = u","\t\t\t\t}","\t\t\t}","\t\t}","\t\tres.Values[i] = v.Copy()","\t}","\treturn a.UnifyArray(res), nil","}","","// A scalarProducter implements a ScalarProduct which receives an argument of the same type.","// This can be implemented by matrix multiplication for special types.","type scalarProducter interface {","\tScalarProduct(interface{}) (apl.Value, error)","}","","func outer(a *apl.Apl, L, R apl.Value, f, g apl.Function) (apl.Value, error) {","\tto := ToArray(nil)","\tll, ok := to.To(a, L)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"outer product: left argument cannot be converted to array: %T\", L)","\t}","\tal := ll.(apl.Array)","\tls := al.Shape()","","\trr, ok := to.To(a, R)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"outer product: right argument cannot be converted to array: %T\", L)","\t}","\tar := rr.(apl.Array)","\trs := ar.Shape()","","\t// The shape of the result is (⍴L),⍴R","\tshape := make([]int, 0, len(ls)+len(rs))","\tshape = append(shape, apl.CopyShape(al)...)","\tshape = append(shape, apl.CopyShape(ar)...)","\tres := apl.NewMixed(shape)","","\tlc, lidx := apl.NewIdxConverter(ls)","\trc, ridx := apl.NewIdxConverter(rs)","\tdst := make([]int, len(shape))","\tfor i := range res.Values {","\t\tcopy(lidx, dst[:len(lidx)])","\t\tcopy(ridx, dst[len(lidx):])","\t\tv, err := g.Call(a, al.At(lc.Index(lidx)), ar.At(rc.Index(ridx)))","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tres.Values[i] = v.Copy()","\t\tapl.IncArrayIndex(dst, shape)","\t}","\treturn a.UnifyArray(res), nil","}",""],"each.go":["package operators","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(operator{","\t\tsymbol:  \"¨\",","\t\tDomain:  MonadicOp(Function(nil)),","\t\tdoc:     \"each, map\",","\t\tderived: each,","\t})","\tregister(operator{","\t\tsymbol:  \"¨\",","\t\tDomain:  MonadicOp(IsPrimitive(\"\u003c\")),","\t\tdoc:     \"channel each\",","\t\tderived: channelEach,","\t})","}","","func each(a *apl.Apl, LO, RO apl.Value) apl.Function {","\tf := LO.(apl.Function)","\tderived := func(a *apl.Apl, l, r apl.Value) (apl.Value, error) {","\t\tif l == nil {","\t\t\treturn each1(a, r, f)","\t\t}","\t\treturn each2(a, l, r, f)","","\t}","\treturn function(derived)","}","","func each1(a *apl.Apl, R apl.Value, f apl.Function) (apl.Value, error) {","\tif lst, ok := R.(apl.List); ok {","\t\treturn eachList(a, lst, f)","\t}","\tif c, ok := R.(apl.Channel); ok {","\t\treturn eachChannel(a, nil, c, f)","\t}","","\tar, ok := R.(apl.Array)","\tif ok {","\t\tif ar.Size() == 0 {","\t\t\t// TODO: Fill function of LO should be applied","\t\t\t// with the prototype of R.","\t\t\t// The result has the same shape as R.","\t\t\treturn apl.EmptyArray{}, nil","\t\t}","\t} else {","\t\t// Apply f to scalar R.","\t\treturn f.Call(a, nil, R)","\t}","","\tres := apl.NewMixed(apl.CopyShape(ar))","\tfor i := range res.Values {","\t\tv, err := f.Call(a, nil, ar.At(i))","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tif _, ok := v.(apl.Array); ok {","\t\t\treturn nil, fmt.Errorf(\"each: result must be a scalar\")","\t\t}","\t\tres.Values[i] = v.Copy()","\t}","\treturn a.UnifyArray(res), nil","}","","func eachList(a *apl.Apl, l apl.List, f apl.Function) (apl.Value, error) {","\tres := make(apl.List, len(l))","\tfor i := range res {","\t\tv, err := f.Call(a, nil, l[i])","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tres[i] = v.Copy()","\t}","\treturn res, nil","}","","// EachChannel returns a channel and applies the function f to each value in the input channel.","// The result is written to the output channel.","// If f returns an EmptyArray, no output value is written.","// This can be used as a filter. Empty strings however are written.","func eachChannel(a *apl.Apl, L apl.Value, r apl.Channel, f apl.Function) (apl.Value, error) {","\treturn r.Apply(a, f, L, false), nil","}","","// ChannelEach sends each value in R over a channel.","func channelEach(a *apl.Apl, _, _ apl.Value) apl.Function {","\tderived := func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\tif L != nil {","\t\t\treturn nil, fmt.Errorf(\"channel each cannot be called dyadically\")","\t\t}","\t\tvar all []apl.Value","\t\tc := apl.NewChannel()","\t\tar, ok := R.(apl.Array)","\t\tif ok == false {","\t\t\tall = []apl.Value{R.Copy()}","\t\t} else {","\t\t\tall = make([]apl.Value, ar.Size())","\t\t\tfor i := range all {","\t\t\t\tall[i] = ar.At(i).Copy()","\t\t\t}","\t\t}","\t\tgo c.SendAll(all)","\t\treturn c, nil","\t}","\treturn function(derived)","}","","func each2(a *apl.Apl, L, R apl.Value, f apl.Function) (apl.Value, error) {","\tif c, ok := R.(apl.Channel); ok {","\t\treturn eachChannel(a, L, c, f)","\t}","","\t_, okl := L.(apl.List)","\t_, okr := R.(apl.List)","\tif okl || okr {","\t\treturn eachList2(a, L, R, f)","\t}","","\tar, rok := R.(apl.Array)","\tal, lok := L.(apl.Array)","\tvar rs, ls []int","","\tif rok == false \u0026\u0026 lok == false {","\t\treturn f.Call(a, L, R)","\t}","\tif rok == true \u0026\u0026 ar.Size() == 0 {","\t\treturn apl.EmptyArray{}, nil // TODO fill function","\t}","\tif lok == true \u0026\u0026 al.Size() == 0 {","\t\treturn apl.EmptyArray{}, nil // TODO fill function","\t}","","\tif rok == true {","\t\trs = ar.Shape()","\t}","\tif lok == true {","\t\tls = al.Shape()","\t}","","\tif rok == true \u0026\u0026 lok == true {","\t\tif len(ls) != len(rs) {","\t\t\treturn nil, fmt.Errorf(\"each: ranks L and R are different\")","\t\t}","\t\tfor i := range ls {","\t\t\tif ls[i] != rs[i] {","\t\t\t\treturn nil, fmt.Errorf(\"each: shapes of L and R must conform\")","\t\t\t}","\t\t}","\t}","","\tvar shape []int","\tvar lv, rv apl.Value","\tif rok == true {","\t\tshape = apl.CopyShape(ar)","\t} else {","\t\tshape = apl.CopyShape(al)","\t\trv = R","\t}","\tif lok == false {","\t\tlv = L","\t}","","\tres := apl.NewMixed(shape)","\tfor i := range res.Values {","\t\tif rok == true {","\t\t\trv = ar.At(i)","\t\t}","\t\tif lok == true {","\t\t\tlv = al.At(i)","\t\t}","\t\tv, err := f.Call(a, lv, rv)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tif _, ok := v.(apl.Array); ok {","\t\t\treturn nil, fmt.Errorf(\"each: result must be a scalar\")","\t\t}","\t\tres.Values[i] = v.Copy()","\t}","\treturn a.UnifyArray(res), nil","}","","func eachList2(a *apl.Apl, L, R apl.Value, f apl.Function) (apl.Value, error) {","\tl, lok := L.(apl.List)","\tr, rok := R.(apl.List)","\tsize := 0","\tif lok {","\t\tsize = len(l)","\t}","\tif rok {","\t\tif len(r) != size {","\t\t\treturn nil, fmt.Errorf(\"each list: different list sizes\")","\t\t}","\t}","","\tres := make(apl.List, size)","\tfor i := range res {","\t\tlv := L","\t\trv := R","\t\tif lok {","\t\t\tlv = l[i]","\t\t}","\t\tif rok {","\t\t\trv = r[i]","\t\t}","\t\tv, err := f.Call(a, lv, rv)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tres[i] = v.Copy()","\t}","\treturn res, nil","}",""],"elementary.go":["package primitives","","import (","\t\"fmt\"","\t\"reflect\"","\t\"time\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"","\t\"github.com/ktye/iv/apl/numbers\"",")","","func init() {","\ttab := []struct {","\t\tsymbol    string","\t\tdoc, doc2 string","\t\tmonadic   func(*apl.Apl, apl.Value) (apl.Value, bool)","\t\tdyadic    func(*apl.Apl, apl.Value, apl.Value) (apl.Value, bool)","\t}{","\t\t{\"+\", \"identity, complex conjugate\", \"plus, addition\", add, add2},","\t\t{\"-\", \"reverse sign\", \"substract, substraction\", sub, sub2},","\t\t{\"×\", \"signum, sign of, direction\", \"multiply\", mul, mul2},","\t\t{\"÷\", \"reciprocal\", \"div, division, divide\", div, div2},","\t\t{\"*\", \"exponential\", \"power\", pow, pow2},","\t\t{\"⍟\", \"natural logarithm\", \"log, logarithm\", log, log2},","\t\t{\"|\", \"magnitude, absolute value\", \"residue, modulo\", abs, abs2},","\t\t{\"⌊\", \"floor\", \"min, minimum\", min, min2},","\t\t{\"⌈\", \"ceil\", \"max, maximum\", max, max2},","\t\t{\"!\", \"factorial\", \"binomial\", factorial, binomial},","\t\t{\"○\", \"pi times\", \"circular, trigonometric\", pitimes, circular},","\t}","","\tfor _, e := range tab {","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc,","\t\t\tDomain: Monadic(IsScalar(nil)),","\t\t\tfn:     arith1(e.symbol, e.monadic),","\t\t})","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc,","\t\t\tDomain: Monadic(IsArray(nil)),","\t\t\tfn:     array1(e.symbol, e.monadic),","\t\t})","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc,","\t\t\tDomain: Monadic(Or(IsObject(nil), IsTable(nil))),","\t\t\tfn:     table1(e.symbol, e.monadic),","\t\t})","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc,","\t\t\tDomain: Monadic(IsChannel(nil)),","\t\t\tfn:     channel1(e.symbol, e.monadic),","\t\t})","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc2,","\t\t\tDomain: Dyadic(Split(IsScalar(nil), IsScalar(nil))),","\t\t\tfn:     arith2(e.symbol, e.dyadic),","\t\t})","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc2,","\t\t\tDomain: arrays{},","\t\t\tfn:     array2(e.symbol, e.dyadic),","\t\t})","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc2,","\t\t\tDomain: arraysWithAxis{},","\t\t\tfn:     arrayAxis(e.symbol, e.dyadic),","\t\t})","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc2,","\t\t\tDomain: Dyadic(Any(Or(IsTable(nil), IsObject(nil)))),","\t\t\tfn:     tableAny(e.symbol, e.dyadic),","\t\t})","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc2,","\t\t\tDomain: Dyadic(Both(Or(IsTable(nil), IsObject(nil)))),","\t\t\tfn:     tableBoth(e.symbol, e.dyadic),","\t\t})","\t\tregister(primitive{","\t\t\tsymbol: e.symbol,","\t\t\tdoc:    e.doc2,","\t\t\tDomain: Dyadic(Split(nil, IsChannel(nil))),","\t\t\tfn:     channel2(e.symbol, e.dyadic),","\t\t})","\t}","\tregister(primitive{","\t\tsymbol: \"⌊\",","\t\tdoc:    \"round date\",","\t\tDomain: Dyadic(","\t\t\tSplit(","\t\t\t\tIsString(nil),","\t\t\t\tOr(","\t\t\t\t\tIsType(reflect.TypeOf(numbers.Time(time.Time{})), nil),","\t\t\t\t\tIsType(reflect.TypeOf(numbers.TimeArray{}), nil),","\t\t\t\t),","\t\t\t),","\t\t),","\t\tfn: roundTime,","\t})","}","","// arith1 tries to apply fn to the right argument.","// If it does not succeed directly, it tests if the argument is a number and uptypes until","// the function application succeeds.","func arith1(symbol string, fn func(*apl.Apl, apl.Value) (apl.Value, bool)) func(*apl.Apl, apl.Value, apl.Value) (apl.Value, error) {","","\treturn func(a *apl.Apl, _ apl.Value, R apl.Value) (apl.Value, error) {","\t\t// Try to call the function directly.","\t\tif res, ok := fn(a, R); ok {","\t\t\treturn res, nil","\t\t}","","\t\tn, ok := R.(apl.Number)","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"%s: not a numeric type %T\", symbol, R)","\t\t}","\t\tnum := a.Tower.ToNumeric(n)","\t\tif num == nil {","\t\t\treturn nil, fmt.Errorf(\"%s: unknown numeric type %T\", symbol, n)","\t\t}","\t\tfor i := num.Class; ; i++ {","\t\t\tif res, ok := fn(a, n); ok {","\t\t\t\treturn res, nil","\t\t\t}","\t\t\tn, ok = num.Uptype(n)","\t\t\tif ok == false {","\t\t\t\tbreak","\t\t\t}","\t\t\tnum = a.Tower.Numbers[reflect.TypeOf(n)]","\t\t}","\t\treturn nil, fmt.Errorf(\"%s: not supported for %T\", symbol, R)","\t}","}","","// arith2 tries to apply fn dyadically to the left and right argument.","// If they are not of the same type, it tests if the aruguments are numeric and","// uptypes to the same numeric type.","func arith2(symbol string, fn func(*apl.Apl, apl.Value, apl.Value) (apl.Value, bool)) func(*apl.Apl, apl.Value, apl.Value) (apl.Value, error) {","","\treturn func(a *apl.Apl, L apl.Value, R apl.Value) (apl.Value, error) {","\t\t// Try to call the function directly.","\t\tif reflect.TypeOf(L) == reflect.TypeOf(R) {","\t\t\tif res, ok := fn(a, L, R); ok {","\t\t\t\treturn res, nil","\t\t\t}","\t\t}","","\t\tln, ok := L.(apl.Number)","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"%s: left argument is not a numeric type %T\", symbol, L)","\t\t}","\t\trn, ok := R.(apl.Number)","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"%s: right argument is not a numeric type %T\", symbol, R)","\t\t}","","\t\tvar err error","\t\tln, rn, err = a.Tower.SameType(ln, rn)","\t\tif err != nil {","\t\t\treturn nil, fmt.Errorf(\"%s: %s\", symbol, err)","\t\t}","\t\tnum := a.Tower.ToNumeric(ln)","\t\tif num == nil {","\t\t\treturn nil, fmt.Errorf(\"%s: unknown numeric type %T\", symbol, ln)","\t\t}","","\t\tfor i := num.Class; i \u003c len(a.Tower.Numbers); i++ {","\t\t\tif res, ok := fn(a, ln, rn); ok {","\t\t\t\treturn res, nil","\t\t\t}","\t\t\tln, ok = num.Uptype(ln)","\t\t\tif ok == false {","\t\t\t\tbreak","\t\t\t}","\t\t\trn, ok = num.Uptype(rn)","\t\t\tnum = a.Tower.Numbers[reflect.TypeOf(ln)]","\t\t}","\t\treturn nil, fmt.Errorf(\"%s: not supported for types %T\", symbol, L)","\t}","}","","// + add, add2","type adder interface {","\tAdd() (apl.Value, bool)","}","","type adder2 interface {","\tAdd2(apl.Value) (apl.Value, bool)","}","","func add(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\tif d, ok := R.(adder); ok {","\t\treturn d.Add()","\t}","\treturn nil, false","}","func add2(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\tif d, ok := L.(adder2); ok {","\t\treturn d.Add2(R)","\t}","\treturn nil, false","}","","// - sub, sub2","type substracter interface {","\tSub() (apl.Value, bool)","}","","type substracter2 interface {","\tSub2(apl.Value) (apl.Value, bool)","}","","func sub(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\tif d, ok := R.(substracter); ok {","\t\treturn d.Sub()","\t}","\treturn nil, false","}","func sub2(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\tif d, ok := L.(substracter2); ok {","\t\treturn d.Sub2(R)","\t}","\treturn nil, false","}","","// × mul, mul2","type multiplier interface {","\tMul() (apl.Value, bool)","}","","type multiplier2 interface {","\tMul2(apl.Value) (apl.Value, bool)","}","","func mul(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\tif d, ok := R.(multiplier); ok {","\t\treturn d.Mul()","\t}","\treturn nil, false","}","func mul2(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\tif d, ok := L.(multiplier2); ok {","\t\treturn d.Mul2(R)","\t}","\treturn nil, false","}","","// ÷ div, div2","type divider interface {","\tDiv() (apl.Value, bool)","}","","type divider2 interface {","\tDiv2(apl.Value) (apl.Value, bool)","}","","func div(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\tif d, ok := R.(divider); ok {","\t\treturn d.Div()","\t}","\treturn nil, false","}","func div2(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\tif d, ok := L.(divider2); ok {","\t\treturn d.Div2(R)","\t}","\treturn nil, false","}","","// * pow, pow2","type power interface {","\tPow() (apl.Value, bool)","}","","type power2 interface {","\tPow2(apl.Value) (apl.Value, bool)","}","","func pow(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\tif d, ok := R.(power); ok {","\t\treturn d.Pow()","\t}","\treturn nil, false","}","func pow2(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\tif d, ok := L.(power2); ok {","\t\treturn d.Pow2(R)","\t}","\treturn nil, false","}","","// ⍟ log, log2","type loger interface {","\tLog() (apl.Value, bool)","}","","type loger2 interface {","\tLog2(apl.Value) (apl.Value, bool)","}","","func log(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\tif d, ok := R.(loger); ok {","\t\treturn d.Log()","\t}","\treturn nil, false","}","func log2(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\tif d, ok := L.(loger2); ok {","\t\treturn d.Log2(R)","\t}","\treturn nil, false","}","","// | abs, abs2","type abser interface {","\tAbs() (apl.Value, bool)","}","","func abs(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\t// Complex numbers should implement their own Abs method.","\tif a, ok := R.(abser); ok {","\t\treturn a.Abs()","\t}","\tzero, r, err := a.Tower.SameType(a.Tower.Import(apl.Int(0)), R.(apl.Number))","\tif err != nil {","\t\treturn nil, false","\t}","\tif isless, ok := less(r, zero); ok == false {","\t\treturn nil, false","\t} else if isless {","\t\treturn sub(a, R)","\t} else {","\t\treturn R, true","\t}","}","func abs2(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\t// R-L×⌊R÷L+0=L","\t// L0 ← L=0","","\tL0, _, err := a.Tower.SameType(apl.Bool(a.IsZero(L.(apl.Number))), L.(apl.Number))","\tif err != nil {","\t\treturn nil, false","\t}","\tx, ok := add2(a, L, L0)","\tif ok == false {","\t\treturn nil, false","\t}","\tx, ok = div2(a, R, x)","\tif ok == false {","\t\treturn nil, false","\t}","\tx, ok = min(a, x)","\tif ok == false {","\t\treturn nil, false","\t}","","\tL, x, err = a.Tower.SameType(L.(apl.Number), x.(apl.Number))","\tif err != nil {","\t\treturn nil, false","\t}","\tx, ok = mul2(a, L, x)","\tif ok == false {","\t\treturn nil, false","\t}","\treturn sub2(a, R, x)","}","","// ⌊ min, min2","type floorer interface {","\tFloor() (apl.Value, bool)","}","","// min returns the largest integer that is less or equal to R","func min(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\tif floor, ok := R.(floorer); ok {","\t\treturn floor.Floor()","\t}","\treturn nil, false","}","func min2(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\tif isless, ok := less(L, R); ok == false {","\t\treturn nil, false","\t} else {","\t\tif isless {","\t\t\treturn L, true","\t\t} else {","\t\t\treturn R, true","\t\t}","\t}","}","","// ⌈ max, max2","type ceiler interface {","\tCeil() (apl.Value, bool)","}","","// max returns the smallest integer that is larger or equal to R","func max(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\tif ceil, ok := R.(ceiler); ok {","\t\treturn ceil.Ceil()","\t}","\treturn nil, false","}","func max2(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\tif isless, ok := less(L, R); ok == false {","\t\treturn nil, false","\t} else {","\t\tif isless {","\t\t\treturn R, true","\t\t} else {","\t\t\treturn L, true","\t\t}","\t}","}","","// ! factorial, binomial","type gammaer interface {","\tGamma() (apl.Value, bool)","}","type gammaer2 interface {","\tGamma2(R apl.Value) (apl.Value, bool)","}","","// factorial returns the factorial for non-negative integers.","// It is not defined for negative integers and applies the gamma function","// for other arguments.","func factorial(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\tif g, ok := R.(gammaer); ok {","\t\treturn g.Gamma()","\t}","\treturn nil, false","}","func binomial(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\tif g, ok := L.(gammaer2); ok {","\t\treturn g.Gamma2(R)","\t}","\treturn nil, false","}","","// ○ pitimes, circular","type pitimer interface {","\tPiTimes() (apl.Value, bool)","}","type triger interface {","\tTrig(R apl.Value) (apl.Value, bool)","}","","func pitimes(a *apl.Apl, R apl.Value) (apl.Value, bool) {","\tif p, ok := R.(pitimer); ok {","\t\treturn p.PiTimes()","\t}","\treturn nil, false","}","func circular(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\tif t, ok := L.(triger); ok {","\t\treturn t.Trig(R)","\t}","\treturn nil, false","}","","// ^ ∧ ∨ lcm, gcd least common multiply, greatest common divisor","type gcder interface {","\tGcd(R apl.Value) (apl.Value, bool)","}","","func lcm(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\t// lcm(R, L) = abs(L times R) / gcd(L, R)","\t// If any of L or R is 0, return 0","\tif a.IsZero(L.(apl.Number)) || a.IsZero(R.(apl.Number)) {","\t\treturn apl.Int(0), true","\t}","\tp, ok := mul2(a, L, R)","\tif ok == false {","\t\treturn nil, false","\t}","\tab, ok := abs(a, p)","\tif ok == false {","\t\treturn nil, false","\t}","\tg, ok := gcd(a, L, R)","\tif ok == false {","\t\treturn nil, false","\t}","\treturn div2(a, ab, g)","}","func gcd(a *apl.Apl, L, R apl.Value) (apl.Value, bool) {","\t// If any of L or R is 0, return the other.","\tif a.IsZero(L.(apl.Number)) {","\t\treturn R, true","\t}","\tif a.IsZero(R.(apl.Number)) {","\t\treturn L, true","\t}","\tif g, ok := L.(gcder); ok {","\t\treturn g.Gcd(R)","\t}","\treturn nil, false","}","","// roundTime rounds (usually truncates) a time or duration.","// L is a string:","//\tY, M, D, h, m, s, W (week), Q (quarter) for time input","//\th, m, s, ms, us, μs, ns for duration input","// R is a Time value (or duration).","func roundTime(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\ts := L.(apl.String)","\tta, ok := R.(numbers.TimeArray)","\tif ok {","\t\tres := numbers.TimeArray{Dims: apl.CopyShape(ta), Times: make([]time.Time, ta.Size())}","\t\tfor i := 0; i \u003c ta.Size(); i++ {","\t\t\tif t, err := numbers.Time(ta.Times[i]).Round(string(s)); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else {","\t\t\t\tres.Times[i] = time.Time(t)","\t\t\t}","\t\t}","\t\treturn res, nil","\t}","\treturn R.(numbers.Time).Round(string(s))","}",""],"enclose.go":["package primitives","","import (","\t\"strings\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"⊂\",","\t\tdoc:    \"enclose, string catenation\",","\t\tDomain: Monadic(strvec{}),","\t\tfn:     strcat,","\t})","\tregister(primitive{","\t\tsymbol: \"⊂\",","\t\tdoc:    \"join strings\",","\t\tDomain: Dyadic(Split(IsString(nil), strvec{})),","\t\tfn:     strjoin,","\t})","\tregister(primitive{","\t\tsymbol: \"⊃\",","\t\tdoc:    \"split runes\",","\t\tDomain: Monadic(IsString(nil)),","\t\tfn:     runesplit,","\t})","\tregister(primitive{","\t\tsymbol: \"⊃\",","\t\tdoc:    \"first\",","\t\tDomain: Monadic(IsList(nil)),","\t\tfn:     first,","\t})","\tregister(primitive{","\t\tsymbol: \"⊃\",","\t\tdoc:    \"split string\",","\t\tDomain: Dyadic(Split(IsString(nil), IsString(nil))),","\t\tfn:     strsplit,","\t})","}","","// strvec accepts an array if all elements are strings.","// The result is a string vector.","type strvec struct{}","","func (s strvec) To(a *apl.Apl, v apl.Value) (apl.Value, bool) {","\tar, ok := v.(apl.Array)","\tif ok == false {","\t\treturn v, false","\t}","\tvec := apl.StringArray{Dims: []int{ar.Size()}, Strings: make([]string, ar.Size())}","\tfor i := 0; i \u003c vec.Size(); i++ {","\t\tif s, ok := ar.At(i).(apl.String); ok {","\t\t\tvec.Strings[i] = string(s)","\t\t} else {","\t\t\treturn v, false","\t\t}","\t}","\treturn vec, true","}","func (s strvec) String(f apl.Format) string {","\treturn \"array of strings\"","}","","func strcat(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tar := R.(apl.StringArray)","\treturn apl.String(strings.Join(ar.Strings, \"\")), nil","}","","func strjoin(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tv := R.(apl.StringArray)","\treturn apl.String(strings.Join(v.Strings, string(L.(apl.String)))), nil","}","","func runesplit(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tr := []rune(string(R.(apl.String)))","\tv := make([]string, len(r))","\tfor i, s := range r {","\t\tv[i] = string(s)","\t}","\treturn apl.StringArray{Dims: []int{len(v)}, Strings: v}, nil","}","","// split a string to an string vector","// If L is a string, use it as the separator for strings.Split","// If L is \"\", use strings.Field","func strsplit(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tl := L.(apl.String)","\tr := R.(apl.String)","\tvar v []string","\tif l == \"\" {","\t\tv = strings.Fields(string(r))","\t} else {","\t\tv = strings.Split(string(r), string(l))","\t}","\treturn apl.StringArray{Dims: []int{len(v)}, Strings: v}, nil","}","","func first(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tr := R.(apl.List)","\tif len(r) == 0 {","\t\treturn apl.EmptyArray{}, nil","\t}","\treturn r[0], nil","}",""],"env.go":["package io","","import (","\t\"bytes\"","\t\"fmt\"","\t\"io\"","\t\"io/ioutil\"","\t\"os\"","\t\"strings\"","\t\"text/tabwriter\"","","\t\"github.com/ktye/iv/apl\"",")","","// Env returns the environment as an object.","// Assigning to a key changes the environment variable.","func env(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\treturn Env{}, nil","}","","type Env struct{}","","func (e Env) String(f apl.Format) string {","\tv := os.Environ()","\tvar b strings.Builder","\ttw := tabwriter.NewWriter(\u0026b, 1, 0, 1, ' ', 0)","\tfor _, s := range v {","\t\ts = strings.Replace(s, \"=\", \":\\t\", 1)","\t\tfmt.Fprintln(tw, s)","\t}","\ttw.Flush()","\treturn b.String()","}","func (e Env) Copy() apl.Value { return e }","","func (e Env) Keys() []apl.Value {","\tv := os.Environ()","\tres := make([]apl.Value, len(v))","\tfor i, s := range v {","\t\tidx := strings.Index(s, \"=\")","\t\tif idx \u003e 0 {","\t\t\ts = s[:idx]","\t\t}","\t\tres[i] = apl.String(s)","\t}","\treturn res","}","","func (e Env) At(a *apl.Apl, v apl.Value) apl.Value {","\ts, ok := v.(apl.String)","\tif ok == false {","\t\treturn apl.String(\"\")","\t}","\tval, ok := os.LookupEnv(string(s))","\tif ok {","\t\treturn apl.String(val)","\t}","\treturn nil","}","","func (e Env) Set(a *apl.Apl, key, val apl.Value) error {","\tk, ok := key.(apl.String)","\tif ok == false {","\t\treturn fmt.Errorf(\"setenv: key must be a string: %T\", key)","\t}","\tv, ok := val.(apl.String)","\tif ok == false {","\t\treturn fmt.Errorf(\"setenv: value must be a string: %T\", val)","\t}","\treturn os.Setenv(string(k), string(v))","}","","type envfs struct{}","","func (e envfs) FileSystem(root string) (FileSystem, error) {","\tif root != \"/\" {","\t\treturn nil, fmt.Errorf(\"envfs can only be registered with root file env:///, not %s\", root)","\t}","\treturn envfs{}, nil","}","","func (e envfs) String() string { return \"env:///\" }","","func (e envfs) Open(name, mpt string) (io.ReadCloser, error) {","\tif name == \"\" {","\t\tv := os.Environ()","\t\tvar buf bytes.Buffer","\t\ttw := tabwriter.NewWriter(\u0026buf, 1, 0, 1, ' ', 0)","\t\tfor _, s := range v {","\t\t\ts = strings.Replace(s, \"=\", \"\\t\", 1)","\t\t\tfmt.Fprintln(tw, mpt+s)","\t\t}","\t\ttw.Flush()","\t\treturn ioutil.NopCloser(\u0026buf), nil","\t}","\tv, ok := os.LookupEnv(name)","\tif ok {","\t\treturn ioutil.NopCloser(strings.NewReader(v)), nil","\t}","\treturn nil, \u0026os.PathError{","\t\tOp:   \"open\",","\t\tPath: name,","\t\tErr:  fmt.Errorf(\"environment variable does not exist\"),","\t}","}","","func (e envfs) Write(name string) (io.WriteCloser, error) {","\tvar b strings.Builder","\treturn envwriter{name: name, Builder: \u0026b}, nil","}","","type envwriter struct {","\tname string","\t*strings.Builder","}","","func (e envwriter) Close() error {","\treturn os.Setenv(e.name, e.String())","}",""],"error.go":["package apl","","// Error carries an error value.","// It is used by go routines to signal errors.","// To send err over Channel c, use: c[0]\u003c-Error{e}","type Error struct {","\tE error","}","","func (e Error) String(f Format) string {","\tif e.E == nil {","\t\treturn \"\u003cnil error\u003e\"","\t}","\treturn e.E.Error()","}","func (e Error) Copy() Value { return e }",""],"eval.go":["package apl","","import (","\t\"bufio\"","\t\"fmt\"","\t\"io\"","\t\"runtime/debug\"","\t\"strings\"",")","","// Program contains a slice of parsed expressions.","type Program []expr","","// Eval executes an apl program.","// It can be called in a loop for every line of input.","func (a *Apl) Eval(p Program) (err error) {","\tdefer func() {","\t\tif r := recover(); r != nil {","\t\t\terr = fmt.Errorf(\"panic: %s\\n%s\", r, string(debug.Stack()))","\t\t}","\t}()","\twrite := func(val Value) {","\t\tswitch v := val.(type) {","\t\tcase Image:","\t\t\tif a.stdimg != nil {","\t\t\t\ta.stdimg.WriteImage(v)","\t\t\t} else {","\t\t\t\tfmt.Fprintln(a.stdout, val.String(a.Format))","\t\t\t}","\t\tdefault:","\t\t\tfmt.Fprintln(a.stdout, val.String(a.Format))","\t\t}","\t}","","\tvar val Value","\tfor _, expr := range p {","\t\tval, err = expr.Eval(a)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif isAssignment(expr) == false {","\t\t\tswitch v := val.(type) {","\t\t\tcase Channel:","\t\t\t\ti := 0","\t\t\t\tfor e := range v[0] {","\t\t\t\t\tif i == 0 {","\t\t\t\t\t\ti++","\t\t\t\t\t\tif _, ok := e.(Image); ok \u0026\u0026 a.stdimg != nil {","\t\t\t\t\t\t\ta.stdimg.StartLoop()","\t\t\t\t\t\t\tdefer a.stdimg.StopLoop()","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\twrite(e)","\t\t\t\t}","\t\t\tdefault:","\t\t\t\twrite(val)","\t\t\t}","\t\t}","\t}","\treturn nil","}","","// EvalProgram evaluates all expressions in the program and returns the values.","func (a *Apl) EvalProgram(p Program) ([]Value, error) {","\tres := make([]Value, len(p))","\tfor i, e := range p {","\t\tif v, err := e.Eval(a); err != nil {","\t\t\treturn nil, err","\t\t} else {","\t\t\tres[i] = v","\t\t}","\t}","\treturn res, nil","}","","func (p Program) String(f Format) string {","\tv := make([]string, len(p))","\tfor i := range p {","\t\tv[i] = p[i].String(f)","\t}","\treturn strings.Join(v, \"⋄\")","}","","// EvalFile parses and evalutes from a reader.","// It handles multiline statements.","// The file argument is used only in the error message.","func (a *Apl) EvalFile(r io.Reader, file string) (err error) {","\tline := 0","\tdefer func() {","\t\tif err != nil {","\t\t\terr = fileError{file: file, line: line, err: err}","\t\t}","\t}()","","\tok := true","\tvar p Program","\tb := NewLineBuffer(a)","\tscanner := bufio.NewScanner(r)","\tfor scanner.Scan() {","\t\tline++","\t\tok, err = b.Add(scanner.Text())","\t\tif err != nil {","\t\t\treturn","\t\t}","","\t\tif ok {","\t\t\tp, err = b.Parse()","\t\t\tif err != nil {","\t\t\t\treturn","\t\t\t}","","\t\t\terr = a.Eval(p)","\t\t\tif err != nil {","\t\t\t\treturn","\t\t\t}","\t\t}","\t}","\tif ok == false \u0026\u0026 b.Len() \u003e 0 {","\t\treturn fmt.Errorf(\"multiline statement is not terminated\")","\t}","\treturn nil","}","","type fileError struct {","\tfile string","\tline int","\terr  error","}","","func (f fileError) Error() string {","\treturn fmt.Sprintf(\"%s:%d: %s\", f.file, f.line, f.err.Error())","}","","type expr interface {","\tEval(*Apl) (Value, error)","\tString(f Format) string","}","","func isAssignment(e expr) bool {","\t// Assignment is implemented as an operator.","\tif fn, ok := e.(*function); ok \u0026\u0026 fn != nil {","\t\tif d, ok := fn.Function.(*derived); ok \u0026\u0026 d.op == \"←\" {","\t\t\treturn true","\t\t}","\t}","\treturn false","}",""],"exception.go":["package numbers","","import (","\t\"math\"","\t\"math/cmplx\"","","\t\"github.com/ktye/iv/apl\"",")","","const (","\tNaN    exception = \"NaN\"","\tInf    exception = \"∞\"","\tNegInf exception = \"¯∞\"",")","","type exception string","","func (e exception) String(f apl.Format) string {","\treturn string(e)","}","func (e exception) Copy() apl.Value { return e }","","func isException(n apl.Number) (exception, bool) {","\tif f, ok := n.(Float); ok {","\t\tif math.IsNaN(float64(f)) {","\t\t\treturn NaN, true","\t\t}","\t\tif math.IsInf(float64(f), 1) {","\t\t\treturn Inf, true","\t\t}","\t\tif math.IsInf(float64(f), -1) {","\t\t\treturn NegInf, true","\t\t}","\t}","\tif c, ok := n.(Complex); ok {","\t\tif cmplx.IsNaN(complex128(c)) {","\t\t\treturn NaN, true","\t\t}","\t\tif cmplx.IsInf(complex128(c)) {","\t\t\treturn Inf, true","\t\t}","\t}","\treturn \"\", false","}",""],"exp.go":["package bigfloat","","import (","\t\"math\"","\t\"math/big\"",")","","// Exp returns a big.Float representation of exp(z). Precision is","// the same as the one of the argument. The function returns +Inf","// when z = +Inf, and 0 when z = -Inf.","func Exp(z *big.Float) *big.Float {","","\t// exp(0) == 1","\tif z.Sign() == 0 {","\t\treturn big.NewFloat(1).SetPrec(z.Prec())","\t}","","\t// Exp(+Inf) = +Inf","\tif z.IsInf() \u0026\u0026 z.Sign() \u003e 0 {","\t\treturn big.NewFloat(math.Inf(+1)).SetPrec(z.Prec())","\t}","","\t// Exp(-Inf) = 0","\tif z.IsInf() \u0026\u0026 z.Sign() \u003c 0 {","\t\treturn big.NewFloat(0).SetPrec(z.Prec())","\t}","","\tguess := new(big.Float)","","\t// try to get initial estimate using IEEE-754 math","\tzf, _ := z.Float64()","\tif zfs := math.Exp(zf); zfs == math.Inf(+1) || zfs == 0 {","\t\t// too big or too small for IEEE-754 math,","\t\t// perform argument reduction using","\t\t//     e^{2z} = (e^z)²","\t\thalfZ := new(big.Float).Mul(z, big.NewFloat(0.5))","\t\thalfExp := Exp(halfZ.SetPrec(z.Prec() + 64))","\t\treturn new(big.Float).Mul(halfExp, halfExp).SetPrec(z.Prec())","\t} else {","\t\t// we got a nice IEEE-754 estimate","\t\tguess.SetFloat64(zfs)","\t}","","\t// f(t)/f'(t) = t*(log(t) - z)","\tf := func(t *big.Float) *big.Float {","\t\tx := new(big.Float)","\t\tx.Sub(Log(t), z)","\t\treturn x.Mul(x, t)","\t}","","\tx := newton(f, guess, z.Prec())","","\treturn x","}",""],"find.go":["package primitives","","import (","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"⍷\",","\t\tdoc:    \"find\",","\t\tDomain: Dyadic(Split(ToArray(nil), ToArray(nil))),","\t\tfn:     find,","\t})","}","","func find(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tif _, ok := R.(apl.EmptyArray); ok {","\t\treturn apl.EmptyArray{}, nil","\t}","","\tvar al apl.Array","\tel, Lempty := L.(apl.EmptyArray)","\tif Lempty == false {","\t\tal = L.(apl.Array)","\t} else {","\t\tal = el","\t}","\tls := al.Shape()","","\tar := R.(apl.Array)","\trs := ar.Shape()","","\tres := apl.BoolArray{Dims: apl.CopyShape(ar)}","\tres.Bools = make([]bool, apl.Prod(res.Dims))","","\t// If the rank of L is arger than the rank of R, nothing is found.","\tif len(ls) \u003e len(rs) {","\t\treturn res, nil","\t}","","\t// If the rank of L is smaller than the rank of R, fill it with ones","\t// at the beginning.","\tif d := len(rs) - len(ls); d \u003e 0 {","\t\tshape := apl.CopyShape(ar)","\t\tfor i := range shape {","\t\t\tif i \u003c d {","\t\t\t\tshape[i] = 1","\t\t\t} else {","\t\t\t\tshape[i] = ls[i-d]","\t\t\t}","\t\t}","\t\tl := apl.MakeArray(al, shape)","\t\tfor i := 0; i \u003c l.Size(); i++ {","\t\t\tl.Set(i, al.At(i).Copy())","\t\t}","\t\tal = l","\t\tls = shape","\t}","\tnl := al.Size()","","\tfeq := arith2(\"=\", compare(\"=\"))","\tic, idx := apl.NewIdxConverter(rs)","\tfor i := range res.Bools {","\t\tif nl \u003e len(res.Bools)-i {","\t\t\tres.Bools[i] = false","\t\t} else {","\t\t\tiseq := true","\t\t\tfor k := 0; k \u003c len(idx); k++ {","\t\t\t\tidx[k] = 0","\t\t\t}","\t\t\tfor k := 0; k \u003c nl; k++ {","\t\t\t\teq, err := feq(a, al.At(k), ar.At(i+ic.Index(idx)))","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\tif eq.(apl.Bool) == false {","\t\t\t\t\tiseq = false","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t\tapl.IncArrayIndex(idx, ls)","\t\t\t}","\t\t\tif iseq {","\t\t\t\tres.Bools[i] = true","\t\t\t}","\t\t}","\t}","\treturn res, nil","}",""],"float.go":["package numbers","","import (","\t\"fmt\"","\t\"math\"","\t\"math/big\"","\t\"strconv\"","\t\"strings\"","","\t\"github.com/ktye/iv/apl\"",")","","type Float float64","","// String formats a Float as a string.","// The format string is passed to fmt and - is replaced by ¯,","// except if the first rune is -.","func (n Float) String(f apl.Format) string {","\tformat, minus := getformat(f, n)","\tif format == \"\" {","\t\tswitch prec := f.PP; {","\t\tcase prec == 0:","\t\t\tformat = \"%.6G\"","\t\tcase prec == -16:","\t\t\tformat = \"%b\"","\t\tcase prec \u003c 0:","\t\t\tformat = \"%v\"","\t\tdefault:","\t\t\tformat = fmt.Sprintf(\"%%.%dG\", prec)","\t\t}","\t}","\ts := fmt.Sprintf(format, float64(n))","\tif minus == false {","\t\ts = strings.Replace(s, \"-\", \"¯\", -1)","\t}","\treturn s","}","func (f Float) Copy() apl.Value { return f }","","// ParseFloat parses a Float. It replaces ¯ with -, then uses ParseFloat.","// A trailing . is stripped, so that \"2.\" is parsed as a float.","func ParseFloat(s string) (apl.Number, bool) {","\ts = strings.Replace(s, \"¯\", \"-\", -1)","\tif n, err := strconv.ParseFloat(strings.TrimSuffix(s, \".\"), 64); err == nil {","\t\treturn Float(n), true","\t}","\treturn Float(0), false","}","","// ToIndex converts a Float to an int, if an exact conversion is possible.","func (f Float) ToIndex() (int, bool) {","\tn := int(f)","\tif Float(n) == f {","\t\treturn n, true","\t}","\treturn 0, false","}","","func floatToComplex(f apl.Number) (apl.Number, bool) {","\treturn Complex(complex(float64(f.(Float)), 0)), true","}","","func (f Float) Less(R apl.Value) (apl.Bool, bool) {","\treturn apl.Bool(f \u003c R.(Float)), true","}","","func (f Float) Add() (apl.Value, bool) {","\treturn f, true","}","func (f Float) Add2(R apl.Value) (apl.Value, bool) {","\treturn f + R.(Float), true","}","","func (f Float) Sub() (apl.Value, bool) {","\treturn -f, true","}","func (f Float) Sub2(R apl.Value) (apl.Value, bool) {","\treturn f - R.(Float), true","}","","func (f Float) Mul() (apl.Value, bool) {","\tif f \u003e 0 {","\t\treturn apl.Int(1), true","\t} else if f \u003c 0 {","\t\treturn apl.Int(-1), true","\t}","\treturn apl.Int(0), true","}","func (f Float) Mul2(R apl.Value) (apl.Value, bool) {","\treturn f * R.(Float), true","}","","func (f Float) Div() (apl.Value, bool) {","\tn := 1.0 / float64(f)","\tif e, ok := isException(Float(n)); ok {","\t\treturn e, true","\t}","\treturn Float(n), true","}","func (f Float) Div2(b apl.Value) (apl.Value, bool) {","\tn := Float(float64(f) / float64(b.(Float)))","\tif e, ok := isException(n); ok {","\t\treturn e, true","\t}","\treturn Float(n), true","}","","func (f Float) Pow() (apl.Value, bool) {","\treturn Float(math.Exp(float64(f))), true","}","func (f Float) Pow2(R apl.Value) (apl.Value, bool) {","\treturn Float(math.Pow(float64(f), float64(R.(Float)))), true","}","","func (f Float) Log() (apl.Value, bool) {","\tl := math.Log(float64(f))","\tif e, ok := isException(Float(l)); ok {","\t\treturn e, true","\t}","\treturn Float(l), true","}","func (f Float) Log2(R apl.Value) (apl.Value, bool) {","\tl := math.Log(float64(f))","\tr := math.Log(float64(R.(Float)))","\tif e, ok := isException(Float(l)); ok {","\t\treturn e, true","\t}","\tif e, ok := isException(Float(r)); ok {","\t\treturn e, true","\t}","\treturn Float(r) / Float(l), true","}","","func (f Float) Abs() (apl.Value, bool) {","\treturn Float(math.Abs(float64(f))), true","}","func (f Float) Abs2(R apl.Value) (apl.Value, bool) {","\treturn Float(math.Remainder(float64(f), float64(R.(Float)))), true","}","","func (f Float) Floor() (apl.Value, bool) {","\treturn Float(math.Floor(float64(f))), true","}","func (f Float) Ceil() (apl.Value, bool) {","\treturn Float(math.Ceil(float64(f))), true","}","","func (f Float) Gamma() (apl.Value, bool) {","\ty := Float(math.Gamma(float64(f) + 1))","\tif e, ok := isException(y); ok {","\t\treturn e, true","\t}","\treturn y, true","}","","func beta(a, b float64) float64 {","\tga, sa := math.Lgamma(a)","\tgb, sb := math.Lgamma(b)","\tgab, sab := math.Lgamma(a + b)","\tsn := float64(sa * sb * sab)","\treturn sn * math.Exp(ga+gb-gab)","}","func (L Float) Gamma2(R apl.Value) (apl.Value, bool) {","\t// Dyalog: Beta(X,Y) ←→ ÷Y×(X-1)!X+Y-1","\t// Solving for R and L, with: R=X+Y-1 and L=X-1","\t// L!R = (R over L) = 1/((R-L)*beta(R-L, L+1))","\tr := float64(R.(Float))","\tl := float64(L)","\tf := Float(1.0 / ((r - l) * beta(r-l, l+1)))","\tif e, ok := isException(f); ok {","\t\treturn e, true","\t}","\treturn f, true","}","","func (L Float) PiTimes() (apl.Value, bool) {","\treturn Float(math.Pi) * L, true","}","func (L Float) Trig(R apl.Value) (apl.Value, bool) {","\tx := float64(R.(Float))","\tvar y float64","\tswitch L {","\tcase 0:","\t\ty = math.Sqrt(1.0 - x*x)","\tcase -1:","\t\ty = math.Asin(x)","\tcase 1:","\t\ty = math.Sin(x)","\tcase -2:","\t\ty = math.Acos(x)","\tcase 2:","\t\ty = math.Cos(x)","\tcase -3:","\t\ty = math.Atan(x)","\tcase 3:","\t\ty = math.Tan(x)","\tcase -4:","\t\ty = 0","\t\tif x != -1 {","\t\t\ty = (x + 1.0) * math.Sqrt((x-1.0)/(x+1.0))","\t\t}","\tcase 4:","\t\ty = math.Sqrt(1.0 + x*x)","\tcase -5:","\t\ty = math.Asinh(x)","\tcase 5:","\t\ty = math.Sinh(x)","\tcase -6:","\t\ty = math.Acosh(x)","\tcase 6:","\t\ty = math.Cosh(x)","\tcase -7:","\t\ty = math.Atanh(x)","\tcase 7:","\t\ty = math.Tanh(x)","\tcase -8:","\t\ty = -math.Sqrt(x*x - 1.0)","\tcase 8:","\t\ty = math.Sqrt(x*x - 1.0)","\tcase -9, 9:","\t\ty = x // 9: real part","\tcase -10:","\t\ty = x","\tcase 10:","\t\ty = math.Abs(x)","\tcase -11:","\t\treturn nil, false","\tcase 11:","\t\ty = x // imag part","\tcase -12:","\t\treturn nil, false","\tcase 12: // phase","\t\ty = 1","\t\tif x == 0 {","\t\t\ty = 0","\t\t} else if x \u003c 0 {","\t\t\ty = -1","\t\t}","\tdefault:","\t\treturn nil, false","\t}","\treturn Float(y), true","}","","func (L Float) Gcd(R apl.Value) (apl.Value, bool) {","\tl := math.Abs(float64(L))","\tr := math.Abs(float64(R.(Float)))","","\tab, lok := big.NewRat(1, 1).SetString(fmt.Sprintf(\"%v\", l))","\tcd, rok := big.NewRat(1, 1).SetString(fmt.Sprintf(\"%v\", r))","\tif lok == false || rok == false {","\t\treturn nil, false","\t}","\ta := ab.Num()","\tb := ab.Denom()","\tc := cd.Num()","\td := cd.Denom()","\tad := big.NewInt(0).Mul(a, d)","\tcb := big.NewInt(0).Mul(c, b)","\tgcd := big.NewInt(0).GCD(nil, nil, ad, cb)","\tbd := big.NewInt(0).Mul(b, d)","\trat := big.NewRat(1, 1).SetFrac(gcd, bd)","\tf, _ := rat.Float64()","\treturn Float(f), true","}",""],"floats.go":["package numbers","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"",")","","// FloatArray is a uniform array of float64.","type FloatArray struct {","\tDims   []int","\tFloats []float64","}","","func (f FloatArray) String(af apl.Format) string {","\treturn apl.ArrayString(af, f)","}","func (f FloatArray) Copy() apl.Value {","\tr := FloatArray{Dims: apl.CopyShape(f), Floats: make([]float64, len(f.Floats))}","\tcopy(r.Floats, f.Floats)","\treturn r","}","","func (f FloatArray) At(i int) apl.Value {","\treturn Float(f.Floats[i])","}","","func (f FloatArray) Shape() []int {","\treturn f.Dims","}","","func (f FloatArray) Size() int {","\treturn len(f.Floats)","}","","func (f FloatArray) Zero() apl.Value {","\treturn Float(0.0)","}","","func (f FloatArray) Set(i int, v apl.Value) error {","\tif i \u003c 0 || i \u003e len(f.Floats) {","\t\treturn fmt.Errorf(\"index out of range\")","\t}","\tif c, ok := v.(Float); ok {","\t\tf.Floats[i] = float64(c)","\t\treturn nil","\t}","\treturn fmt.Errorf(\"cannot assign %T to FloatArray\", v)","}","","func (f FloatArray) Make(shape []int) apl.Uniform {","\treturn FloatArray{","\t\tDims:   shape,","\t\tFloats: make([]float64, prod(shape)),","\t}","}","","func makeFloatArray(v []apl.Value) FloatArray {","\tf := make([]float64, len(v))","\tfor i, e := range v {","\t\tf[i] = float64(e.(Float))","\t}","\treturn FloatArray{","\t\tDims:   []int{len(v)},","\t\tFloats: f,","\t}","}","","func (f FloatArray) Reshape(shape []int) apl.Value {","\tres := FloatArray{","\t\tDims:   shape,","\t\tFloats: make([]float64, prod(shape)),","\t}","\tk := 0","\tfor i := range res.Floats {","\t\tres.Floats[i] = f.Floats[k]","\t\tk++","\t\tif k == len(f.Floats) {","\t\t\tk = 0","\t\t}","\t}","\treturn res","}","","func prod(shape []int) int {","\tif len(shape) == 0 {","\t\treturn 0","\t}","\tn := shape[0]","\tfor i := 1; i \u003c len(shape); i++ {","\t\tn *= shape[i]","\t}","\treturn n","}",""],"fmt.go":["package apl","","import (","\t\"fmt\"","\t\"io\"","\t\"reflect\"","\t\"strings\"","\t\"text/tabwriter\"","\t\"unicode\"","","\t\"github.com/ktye/iv/apl/scan\"",")","","// SetPP is called when a value is assigned to Quad-PP.","// If R is an integer, PP is set to this value.","// If R is a dict that maps from values to string, the format strings of the types are set.","// If R is the empty array, all format strings are removed and PP is reset.","//","// PP \u003e= 0 sets the precision when printing floating point numbers.","// When nothing else is set, the default format string is %.(prec)G.","// PP \u003c 0 always uses full precision for numbers and quoted format for strings (%q).","// Additionally, there are several special interpretations for PP \u003c 0:","//  -1:  arrays formatted in a table","//  -2:  arrays formatted in a single line of json","//  -3:  arrays formatted in a single line compatible with matlab","//  -8:  integers formatted as octal numbers with 0 prefix","// -16:  integers formatted as hexadecimal numbers with 0x prefix, floats with %b (-123456p-78)","func (a *Apl) SetPP(R Value) error {","\tif _, ok := R.(EmptyArray); ok {","\t\ta.Format.PP = 0","\t\ta.Format.Fmt = make(map[reflect.Type]string)","\t\treturn nil","\t} else if d, ok := R.(Object); ok {","\t\tkeys := d.Keys()","\t\tfor _, k := range keys {","\t\t\tv := d.At(k)","\t\t\tif v != nil {","\t\t\t\tif s, ok := v.(String); ok {","\t\t\t\t\ta.Format.Fmt[reflect.TypeOf(k)] = string(s)","\t\t\t\t}","\t\t\t}","\t\t}","\t} else if n, ok := R.(Number); ok {","\t\tif i, ok := n.ToIndex(); ok {","\t\t\ta.Format.PP = i","\t\t\treturn nil","\t\t}","\t}","\treturn fmt.Errorf(\"illegal type for PP: %T\", R)","}","","// ArrayString can be used by an array implementation.","// It formats an n-dimensional array using a tabwriter for PP\u003e=-1.","// Each dimension is terminated by k newlines, where k is the dimension index.","// For PP==-2, it uses a single line json notation with nested brackets and","// for PP==-3, it formats in a single line matlab syntax (rank \u003c= 2).","func ArrayString(f Format, v Array) string {","\tif f.PP == -2 {","\t\treturn jsonArray(f, v)","\t} else if f.PP == -3 {","\t\treturn matArray(f, v)","\t}","\tshape := v.Shape()","\tif len(shape) == 0 {","\t\treturn \"\"","\t} else if len(shape) == 1 {","\t\ts := make([]string, shape[0])","\t\tfor i := 0; i \u003c shape[0]; i++ {","\t\t\ts[i] = v.At(i).String(f)","\t\t}","\t\treturn strings.Join(s, \" \")","\t}","\tsize := 1","\tfor _, n := range shape {","\t\tsize *= n","\t}","","\tidx := make([]int, len(shape))","\tinc := func() int {","\t\tfor i := 0; i \u003c len(idx); i++ {","\t\t\tk := len(idx) - 1 - i","\t\t\tidx[k]++","\t\t\tif idx[k] == shape[k] {","\t\t\t\tidx[k] = 0","\t\t\t} else {","\t\t\t\treturn i","\t\t\t}","\t\t}","\t\treturn -1 // should not happen","\t}","\tvar buf strings.Builder","\ttw := tabwriter.NewWriter(\u0026buf, 1, 0, 1, ' ', tabwriter.AlignRight) // tabwriter.AlignRight)","\tfor i := 0; i \u003c size; i++ {","\t\tfmt.Fprintf(tw, \"%s\\t\", v.At(i).String(f))","\t\tif term := inc(); term \u003e 0 {","\t\t\tfor k := 0; k \u003c term; k++ {","\t\t\t\tfmt.Fprintln(tw)","\t\t\t}","\t\t} else if term == -1 {","\t\t\tfmt.Fprintln(tw)","\t\t}","\t}","\ttw.Flush()","\ts := buf.String()","\tif len(s) \u003e 0 \u0026\u0026 s[len(s)-1] == '\\n' {","\t\t// Don't print the final newline.","\t\treturn s[:len(s)-1]","\t}","\treturn s","}","","// stringArray converts the array to a string array of the same shape.","// All elements are printed with the current PP.","func stringArray(f Format, v Array) StringArray {","\tsa := StringArray{Dims: CopyShape(v), Strings: make([]string, v.Size())}","\tfor i := range sa.Strings {","\t\tsa.Strings[i] = v.At(i).String(f)","\t}","\treturn sa","}","","// jsonArray is used for PP=-2","func jsonArray(f Format, v Array) string {","\tsa := stringArray(f, v)","\tvar vector func(v StringArray) string","\tvector = func(S StringArray) string {","\t\tif len(S.Dims) == 1 {","\t\t\treturn \"[\" + strings.Join(S.Strings[:S.Dims[0]], \",\") + \"]\"","\t\t}","\t\tvec := make([]string, S.Dims[0])","\t\tinc := Prod(S.Dims[1:])","\t\tfor i := 0; i \u003c S.Dims[0]; i++ {","\t\t\tsub := StringArray{Dims: S.Dims[1:], Strings: S.Strings[i*inc:]}","\t\t\tvec[i] = vector(sub)","\t\t}","\t\treturn \"[\" + strings.Join(vec, \",\") + \"]\"","\t}","\treturn vector(sa)","}","","// matArray is used for PP=-3. It only supported for rank 1 and 2.","func matArray(f Format, v Array) string {","\tsa := stringArray(f, v)","\tif len(sa.Dims) == 1 {","\t\treturn \"[\" + strings.Join(sa.Strings, \",\") + \"]\"","\t} else if len(sa.Dims) != 2 {","\t\treturn \"[rank error]\"","\t}","\tvar b strings.Builder","\tb.WriteString(\"[\")","\toff := 0","\tfor i := 0; i \u003c sa.Dims[0]; i++ {","\t\tb.WriteString(strings.Join(sa.Strings[off:off+sa.Dims[1]], \",\"))","\t\tif i \u003c sa.Dims[0]-1 {","\t\t\tb.WriteString(\";\")","\t\t}","\t\toff += sa.Dims[1]","\t}","\tb.WriteString(\"]\")","\treturn b.String()","}","","// ParseArray parses a rectangular n-dimensional array from a string representation.","// The result will have the same type as the prototype, or an error is returned.","// If the prototype is nil, a mixed array is returned.","// The function can parse arrays that have been formatted with ¯1⍕, ¯2⍕ and ¯3⍕.","// Json arrays (¯2⍕) can only be parsed, if they don't contain complex numbers.","func (a *Apl) ParseArray(prototype Value, s string) (Value, error) {","\tv, err := a.ScanRankArray(strings.NewReader(s), -1)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"parse array: %s\", err)","\t}","","\tif prototype != nil {","\t\tif u, ok := prototype.(Uniform); ok {","\t\t\tres, ok := a.Unify(v.(Array), true)","\t\t\tif ok == false {","\t\t\t\treturn nil, fmt.Errorf(\"parse array: array has no uniform type\")","\t\t\t}","\t\t\tif reflect.TypeOf(res) != reflect.TypeOf(u) {","\t\t\t\treturn nil, fmt.Errorf(\"parse array: result has wrong type %T != %T\", res, u)","\t\t\t}","\t\t\treturn res, nil","\t\t}","\t}","\treturn v, nil","}","","// ScanRankArray returns the next sub-array from a RuneScanner of a given rank.","// If rank is 0, it returns a Value that is not an array.","// If the rank is negative, it is not restricted.","// If result may have a smaller rank than requested without an error.","// The format is the same as for ParseArray.","func (a *Apl) ScanRankArray(s io.RuneScanner, rank int) (Value, error) {","\tvar values []Value","\tc := 0","\tvar shape []int","\tfor {","\t\tr, _, err := s.ReadRune()","\t\tif err == io.EOF {","\t\t\tbreak","\t\t} else if r == '\\n' || r == ';' || r == ']' {","\t\t\tif len(values) == 0 {","\t\t\t\tcontinue","\t\t\t}","\t\t\tc++","\t\t\tif c == rank {","\t\t\t\tbreak","\t\t\t} else if c \u003e len(shape) {","\t\t\t\tif shape == nil {","\t\t\t\t\tshape = []int{len(values)}","\t\t\t\t} else {","\t\t\t\t\tp := Prod(shape)","\t\t\t\t\tshape = append([]int{len(values) / p}, shape...)","\t\t\t\t}","\t\t\t}","\t\t} else if unicode.IsSpace(r) || r == ',' || r == '[' || r == '(' || r == ')' {","\t\t\tcontinue","\t\t} else if r == '\"' { // Parse a string.","\t\t\tc = 0","\t\t\ts.UnreadRune()","\t\t\tif str, err := scan.ReadString(s); err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"parse array: %s\", err)","\t\t\t} else {","\t\t\t\tif rank == 0 {","\t\t\t\t\treturn String(str), nil","\t\t\t\t}","\t\t\t\tvalues = append(values, String(str))","\t\t\t}","","\t\t} else { // Parse an number.","\t\t\tc = 0","\t\t\ts.UnreadRune()","\t\t\tnum, err := scan.ScanNumber(s)","\t\t\tif err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"parse array: %s\", err)","\t\t\t}","\t\t\tif n, err := a.Tower.Parse(num); err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"parse array: %s\", err)","\t\t\t} else {","\t\t\t\tif rank == 0 {","\t\t\t\t\treturn n, nil","\t\t\t\t}","\t\t\t\tvalues = append(values, n.Number)","\t\t\t}","\t\t}","\t}","\t// The algorithm does not check if the array is uniform in between.","\t// We just test at the end, if the size matches the shape. This may include false positives.","\tif len(values) == 0 {","\t\treturn nil, io.EOF","\t}","\tif rank \u003c 0 {","\t\t// For rank \u003c 0, we read everything. Data could be closed or not.","\t\trank = len(shape)","\t\tif Prod(shape) == len(values) {","\t\t\trank = len(shape) - 1","\t\t}","\t}","\tfor i := 0; i \u003c= rank-len(shape); i++ {","\t\tp := Prod(shape)","\t\tif len(shape) == 0 {","\t\t\tp = 1","\t\t} else if p == 0 {","\t\t\treturn nil, fmt.Errorf(\"parse array: divide by zero: values: %v shape: %v\", values, shape)","\t\t}","\t\tshape = append([]int{len(values) / p}, shape...)","\t\tif Prod(shape) != len(values) {","\t\t\treturn nil, fmt.Errorf(\"parse array: array is not rectangular: ×/%v ≠ %v\", shape, len(values))","\t\t}","\t\t// Continue and fill leading 1s if the rank is higher than data.","\t}","\treturn MixedArray{","\t\tDims:   shape,","\t\tValues: values,","\t}, nil","}",""],"format.go":["package primitives","","import (","\t\"bytes\"","\t\"encoding/csv\"","\t\"fmt\"","\t\"reflect\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"⍕\",","\t\tdoc:    \"format, convert to string\",","\t\tDomain: Monadic(nil),","\t\tfn: func(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\t\t\treturn apl.String(R.String(a.Format)), nil","\t\t},","\t})","\tregister(primitive{","\t\tsymbol: \"⍕\",","\t\tdoc:    \"format, convert to string\",","\t\tDomain: Dyadic(nil),","\t\tfn:     format,","\t})","\tregister(primitive{","\t\tsymbol: \"⍕\",","\t\tdoc:    \"format, convert to string\",","\t\tDomain: Dyadic(Split(IsObject(nil), IsTable(nil))),","\t\tfn:     formatTable,","\t})","","\tregister(primitive{","\t\tsymbol: \"⍎\",","\t\tdoc:    \"execute, evaluate expression\",","\t\tDomain: Monadic(IsString(nil)),","\t\tfn:     execute,","\t})","\tregister(primitive{","\t\tsymbol: \"⍎\",","\t\tdoc:    \"parse data\",","\t\tDomain: Dyadic(Split(nil, IsString(nil))),","\t\tfn:     parseData,","\t})","}","","// Format converts the argument to string.","// If L is a number it is used as the precision (sets PP).","// If L is a string L is used as a format string.","// Special formatting is used, if the string is \"csv\", \"json\", \"mat\" or \"x\".","func format(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tf := apl.Format{","\t\tPP:  a.Format.PP,","\t\tFmt: make(map[reflect.Type]string),","\t}","\tfor k, v := range a.Format.Fmt {","\t\tf.Fmt[k] = v","\t}","","\tif n, ok := L.(apl.Number); ok {","\t\tif i, ok := n.ToIndex(); ok {","\t\t\tf.PP = i","\t\t}","\t} else if s, ok := L.(apl.String); ok {","\t\tswitch s {","\t\tcase \"csv\":","\t\t\treturn formatCsv(f, nil, R)","\t\tcase \"json\":","\t\t\tf.PP = -2","\t\tcase \"mat\":","\t\t\tf.PP = -3","\t\tcase \"x\":","\t\t\tf.PP = -16","\t\tdefault:","\t\t\tt := reflect.TypeOf(R)","\t\t\tf.Fmt[t] = string(s)","\t\t}","\t}","\treturn apl.String(R.String(f)), nil","}","","// L is an object and R a Table.","// Corresponding values of L are used as format arguments to values in R.","// If L contains the key CSV, formatCSV is used.","func formatTable(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tt := R.(apl.Table)","\td := L.(apl.Object)","\tif d.At(apl.String(\"CSV\")) != nil {","\t\treturn formatCsv(a.Format, d, R)","\t}","\tvar b bytes.Buffer","\tif err := t.WriteFormatted(a.Format, d, \u0026b); err != nil {","\t\treturn nil, err","\t}","\treturn apl.String(b.Bytes()), nil","}","","// formatCSV formats R in csv format.","// R must be a rank 2 array or a table.","// If L with corresponding keys.","func formatCsv(f apl.Format, L apl.Object, R apl.Value) (apl.Value, error) {","\tvar b bytes.Buffer","\tw := csv.NewWriter(\u0026b)","","\tar, ok := R.(apl.Array)","\tif ok {","\t\tshape := ar.Shape()","\t\tif len(shape) != 2 {","\t\t\treturn nil, fmt.Errorf(\"format csv: R must be rank 2: shape is %v\", shape)","\t\t}","\t\tif shape[0] == 0 || shape[1] == 0 {","\t\t\treturn apl.String(\"\"), nil","\t\t}","\t\trecords := make([]string, shape[1])","\t\tidx := 0","\t\tfor i := 0; i \u003c shape[0]; i++ {","\t\t\tfor k := 0; k \u003c shape[1]; k++ {","\t\t\t\trecords[k] = ar.At(idx).String(f)","\t\t\t\tidx++","\t\t\t}","\t\t\tif err := w.Write(records); err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"format csv: %s\", err)","\t\t\t}","\t\t}","\t\tw.Flush()","\t\treturn apl.String(b.Bytes()), nil","\t} else if t, ok := R.(apl.Table); ok {","\t\tvar b bytes.Buffer","\t\tif err := t.Csv(f, L, \u0026b); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn apl.String(b.Bytes()), nil","\t}","\treturn nil, fmt.Errorf(\"format csv: unexpected type: %T\", R)","}","","// Execute evaluates the string in R.","// If it evaluates to multiple values, return the last but display all.","func execute(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\ts := R.(apl.String)","\tp, err := a.Parse(string(s))","\tif err != nil {","\t\treturn nil, err","\t}","\tvalues, err := a.EvalProgram(p)","\tif err != nil {","\t\treturn nil, err","\t} else if len(values) == 0 {","\t\treturn apl.EmptyArray{}, nil // Does this ever happen?","\t}","\tfor _, v := range values[:len(values)-1] {","\t\t// TODO: do not display shy values.","\t\tfmt.Fprintln(a.GetOutput(), v.String(a.Format))","\t}","\treturn values[len(values)-1], nil","}","","// ParseData parses data from strings that has been written with ¯1⍕V.","// L may be \"A\", \"D\" or \"T\" for array, dict or table.","// If L is a value of type array, dict or table it is used as a prototype with stricter requirements.","func parseData(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tvar p apl.Value","\tls, ok := L.(apl.String)","\tif ok == false {","\t\tp = L","\t\tif _, ok := L.(apl.Array); ok {","\t\t\tls = \"A\"","\t\t} else if _, ok := L.(*apl.Dict); ok {","\t\t\tls = \"D\"","\t\t} else if _, ok := L.(apl.Table); ok {","\t\t\tls = \"T\"","\t\t} else {","\t\t\treturn nil, fmt.Errorf(\"parse data: left argument is an unknown prototype %T\", L)","\t\t}","\t}","\trs := R.(apl.String)","\tswitch ls {","\tcase \"A\":","\t\treturn a.ParseArray(p, string(rs))","\tcase \"D\":","\t\treturn a.ParseDict(p, string(rs))","\tcase \"T\":","\t\treturn a.ParseTable(p, string(rs))","\t}","\treturn nil, fmt.Errorf(\"parse data: left argument is an unknown type: %s\", ls)","}",""],"fs.go":["package io","","import (","\t\"fmt\"","\t\"io\"","\t\"io/ioutil\"","\t\"os\"","\t\"path/filepath\"","\t\"strings\"","\t\"sync\"",")","","// RegisterProtocol registers a file system protocol, such as \"zip\".","// Protocols are recognized by mount with the syntax: \"zip://\".","// They are registered by external packages supporting special file systems.","func RegisterProtocol(name string, p Protocol) {","\tif protocols == nil {","\t\tprotocols = make(map[string]Protocol)","\t}","\tprotocols[name] = p","}","","// FileSystem is the interface for a file system provider.","// A directory returns the names of it's content in the reader, with directories ending in a slash.","type FileSystem interface {","\tOpen(string, string) (io.ReadCloser, error)","\tString() string","}","","// FileWriter may be implemented by a filesystem to be writable.","type FileWriter interface {","\tWrite(string) (io.WriteCloser, error)","}","","type writable interface {","\tWrite(string) (io.WriteCloser, error)","}","","// fs stores the leading part of the path which is cut from file names.","type fs string","","func (o fs) String() string {","\treturn string(o)","}","","func (o fs) Open(name, mpt string) (io.ReadCloser, error) {","\tf, err := os.Open(o.path(name))","\tif err != nil {","\t\treturn nil, err","\t}","\tfi, err := f.Stat()","\tif err != nil {","\t\tf.Close()","\t\treturn nil, err","\t}","\tif fi.IsDir() == false {","\t\treturn f, nil","\t}","","\tdefer f.Close()","\tdir, err := f.Readdir(-1)","\tif err != nil {","\t\treturn nil, err","\t}","\tnames := make([]string, len(dir))","\tfor i, d := range dir {","\t\tnames[i] = mpt + name + d.Name()","\t\tif d.IsDir() {","\t\t\tnames[i] += \"/\"","\t\t}","\t}","\treturn ioutil.NopCloser(strings.NewReader(strings.Join(names, \"\\n\"))), nil","}","","func (o fs) path(name string) string {","\treturn filepath.Join(string(o), filepath.FromSlash(name))","}","","// Mtab is the mounting table.","// Currently this is shared over all apl instances. This could be changed.","var mtab struct {","\tsync.Mutex","\ttab []mpoint","}","","// Mpoint defines a mount point.","type mpoint struct {","\tmpt string","\tsrc FileSystem","}","","// Open opens a file or directory from the filesystem.","func Open(name string) (io.ReadCloser, error) {","\tif fs, mpt, err := lookup(name); err != nil {","\t\treturn nil, err","\t} else {","\t\trelpath := strings.TrimPrefix(name, mpt)","\t\treturn fs.Open(relpath, mpt)","\t}","}","","// Create opens a file for writing from the filesystem.","func Create(name string) (io.WriteCloser, error) {","\tmtab.Lock()","\tdefer mtab.Unlock()","\tn := len(mtab.tab)","\tif n == 0 {","\t\treturn nil, fmt.Errorf(\"mtab is empty\")","\t}","","\tvar fsys FileSystem","\tvar relpath string","\tvar mpt string","\tfor i := n - 1; i \u003e= 0; i-- {","\t\tt := mtab.tab[i]","\t\tif strings.HasPrefix(name, t.mpt) {","\t\t\tmpt = t.mpt","\t\t\tfsys = t.src","\t\t\trelpath = strings.TrimPrefix(name, t.mpt)","\t\t\tbreak","\t\t}","\t}","\tif fsys == nil {","\t\treturn nil, \u0026os.PathError{","\t\t\tOp:   \"create\",","\t\t\tPath: name,","\t\t\tErr:  fmt.Errorf(\"filesystem not found\"),","\t\t}","\t}","\twfs, ok := fsys.(writable)","\tif ok == false {","\t\treturn nil, \u0026os.PathError{","\t\t\tOp:   \"create\",","\t\t\tPath: name,","\t\t\tErr:  fmt.Errorf(\"filesystem is readonly: %s\", mpt),","\t\t}","\t}","\treturn wfs.Write(relpath)","}","","func lookup(name string) (FileSystem, string, error) {","\tmtab.Lock()","\tdefer mtab.Unlock()","\tn := len(mtab.tab)","\tif n == 0 {","\t\treturn nil, \"\", fmt.Errorf(\"mtab is empty\")","\t}","","\t// Files may shadow each other.","\t// The last mounted file system is tested first.","\tfor i := n - 1; i \u003e= 0; i-- {","\t\tt := mtab.tab[i]","\t\tif strings.HasPrefix(name, t.mpt) {","\t\t\treturn t.src, t.mpt, nil","\t\t}","\t}","\treturn nil, \"\", \u0026os.PathError{","\t\tOp:   \"open\",","\t\tPath: name,","\t\tErr:  fmt.Errorf(\"not found\"),","\t}","}","","// Mount adds a FileSystem to mtab under the given name.","func Mount(mpt string, fs FileSystem) error {","\tmtab.Lock()","\tdefer mtab.Unlock()","","\tif strings.HasPrefix(mpt, \"/\") == false {","\t\treturn fmt.Errorf(\"io mount: mount point must start with /: %s\", mpt)","\t}","\tif strings.HasSuffix(mpt, \"/\") == false {","\t\treturn fmt.Errorf(\"io mount: mount point must end with a /: %s\", mpt)","\t}","","\tfor _, t := range mtab.tab {","\t\tif t.mpt == mpt {","\t\t\treturn fmt.Errorf(\"mount point already used: %s\", mpt)","\t\t}","\t}","\tmtab.tab = append(mtab.tab, mpoint{mpt, fs})","\treturn nil","}","","// Umount removes the moint point.","func Umount(mpt string) {","\tmtab.Lock()","\tdefer mtab.Unlock()","","\tn := -1","\tfor i, t := range mtab.tab {","\t\tif t.mpt == mpt {","\t\t\tn = i","\t\t}","\t}","\tif n \u003c 0 {","\t\treturn","\t}","\tmtab.tab = append(mtab.tab[:n], mtab.tab[n+1:]...)","}","","var protocols map[string]Protocol","","type Protocol interface {","\tFileSystem(string) (FileSystem, error)","}",""],"function.go":["package xgo","","import (","\t\"fmt\"","\t\"reflect\"","","\t\"github.com/ktye/iv/apl\"",")","","type Function struct {","\tName string","\tFn   reflect.Value","}","","func (f Function) String(af apl.Format) string {","\treturn f.Name","}","func (f Function) Copy() apl.Value { return f }","","// Call a go function.","// If it requires 1 argument, that is taken from the right value.","// Two arguments may be the right and left argument or a vector of 2 arguments.","// More than two arguments must be passed in a vector of the right size.","// If the function returns an error as the last value, it is checked and returned.","// Otherwise, or if the error is nil the result is converted and returned.","// More than one result will be returned as a List.","func (f Function) Call(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\terrarg := func(i int, err error) error {","\t\treturn fmt.Errorf(\"function %s argument %d: %s\", f.Name, i+1, err)","\t}","\tt := f.Fn.Type()","\targs := t.NumIn()","\tin := make([]reflect.Value, args)","\tvar err error","\tif args == 0 {","\t} else if args == 1 {","\t\tin[0], err = export(R, t.In(0))","\t\tif err != nil {","\t\t\treturn nil, errarg(0, err)","\t\t}","\t} else if args == 2 \u0026\u0026 L != nil {","\t\tin[0], err = export(R, t.In(0))","\t\tif err != nil {","\t\t\treturn nil, errarg(0, err)","\t\t}","\t\tin[1], err = export(L, t.In(1))","\t\tif err != nil {","\t\t\treturn nil, errarg(1, err)","\t\t}","\t} else if L == nil {","\t\tar, ok := R.(apl.Array)","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"function %s requires %d arguments\", f.Name, args)","\t\t}","\t\trs := ar.Shape()","\t\tif len(rs) \u003e 1 {","\t\t\treturn nil, fmt.Errorf(\"function argument has rank %d\", len(rs))","\t\t}","\t\tif n := ar.Size(); n != args {","\t\t\treturn nil, fmt.Errorf(\"function %s requires %d arguments, R has size %d\", f.Name, args, n)","\t\t} else {","\t\t\tfor i := 0; i \u003c args; i++ {","\t\t\t\tin[i], err = export(ar.At(i), t.In(i))","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, errarg(i, err)","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\tout := f.Fn.Call(in)","","\t// Test if the last output value is an error, check and remove it.","\tif len(out) \u003e 0 {","\t\tif last := out[len(out)-1]; last.Type().Implements(reflect.TypeOf((*error)(nil)).Elem()) {","\t\t\tif last.IsNil() == false {","\t\t\t\treturn nil, last.Interface().(error)","\t\t\t} else {","\t\t\t\tout = out[:len(out)-1]","\t\t\t}","\t\t}","\t}","","\tif len(out) == 0 {","\t\treturn apl.EmptyArray{}, nil","\t} else if len(out) == 1 {","\t\treturn Convert(out[0])","\t} else {","\t\tres := make(apl.List, len(out))","\t\tfor i := range out {","\t\t\tif v, err := Convert(out[i]); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else {","\t\t\t\tres[i] = v","\t\t\t}","\t\t}","\t\treturn res, nil","\t}","}",""],"functions.go":["package domain","","import (","\t\"github.com/ktye/iv/apl\"",")","","func Function(child SingleDomain) SingleDomain {","\treturn function{child}","}","","type function struct{ child SingleDomain }","","func (f function) To(a *apl.Apl, V apl.Value) (apl.Value, bool) {","\tif _, ok := V.(apl.Function); ok == false {","\t\treturn V, false","\t}","\tif f.child == nil {","\t\treturn V, true","\t}","\tif v, ok := f.child.To(a, V); ok {","\t\treturn v, true","\t}","\treturn V, false","}","func (f function) String(af apl.Format) string {","\tif f.child == nil {","\t\treturn \"function\"","\t}","\treturn \"function \" + f.child.String(af)","}","","func IsPrimitive(p string) SingleDomain {","\treturn primitive(p)","}","","type primitive string","","func (p primitive) To(a *apl.Apl, V apl.Value) (apl.Value, bool) {","\tif pf, ok := V.(apl.Primitive); ok \u0026\u0026 string(pf) == string(p) {","\t\treturn V, true","\t}","\treturn V, false","}","func (p primitive) String(f apl.Format) string {","\treturn string(p)","}",""],"gen.go":["// +build ignore","","package main","","import (","\t\"bufio\"","\t\"fmt\"","\t\"log\"","\t\"os\"","\t\"os/exec\"","\t\"regexp\"","\t\"strings\"","\t\"time\"",")","","var prefix = regexp.MustCompile(` *apl_test.go:[0-9]*:`)","var spaces = regexp.MustCompile(`^ *`)","","// This program is run by go generate.","// It runs go test -v in short mode, which only includes","// tests with the normal numeric tower.","// The output of go test is filtered and written to Tests.md.","func main() {","\tmktest()","\tmkref()","}","","func mktest() {","","\tcmd := exec.Command(\"go\", \"test\", \"-v\", \"-short\", \"-run\", \"Normal\")","\ttestout, err := cmd.StdoutPipe()","\tif err != nil {","\t\tlog.Fatal(err)","\t}","\tif err := cmd.Start(); err != nil {","\t\tlog.Fatal(err)","\t}","","\tw, err := os.Create(\"../../TESTS.md\")","\tif err != nil {","\t\tlog.Fatal(err)","\t}","\tdefer w.Close()","","\tscn := bufio.NewScanner(testout)","\tfor scn.Scan() {","\t\ts := scn.Text()","\t\tif strings.HasPrefix(s, \"===\") {","\t\t\tcontinue","\t\t}","\t\tif strings.HasPrefix(s, \"---\") {","\t\t\tcontinue","\t\t}","\t\ts = prefix.ReplaceAllString(s, \"\")","\t\ts = spaces.ReplaceAllString(s, \"\")","\t\tfmt.Fprintln(w, s)","\t}","","\tif err := cmd.Wait(); err != nil {","\t\tlog.Fatal(err)","\t}","\tfmt.Fprintf(w, \"```\\n\")","}","","func mkref() {","\tcmd := exec.Command(\"go\", \"test\", \"-v\", \"-short\", \"-run\", \"Doc\")","\ttestout, err := cmd.StdoutPipe()","\tif err != nil {","\t\tlog.Fatal(err)","\t}","\tif err := cmd.Start(); err != nil {","\t\tlog.Fatal(err)","\t}","","\tw, err := os.Create(\"../../REF.md\")","\tif err != nil {","\t\tlog.Fatal(err)","\t}","\tdefer w.Close()","","\tfmt.Fprintln(w, `# Reference","- [Primitive Functions](#primitive-functions)","- [Operators](#operators)","`)","","\tscn := bufio.NewScanner(testout)","\tfor scn.Scan() {","\t\ts := scn.Text()","\t\tif strings.HasPrefix(s, \"===\") {","\t\t\tcontinue","\t\t}","\t\tif strings.HasPrefix(s, \"---\") {","\t\t\tcontinue","\t\t}","\t\tfmt.Fprintln(w, s)","\t}","","\tif err := cmd.Wait(); err != nil {","\t\tlog.Fatal(err)","\t}","\tfmt.Fprintf(w, \"\\ngenerated by `go generate (apl/primitives/gen.go)` %s\\n\", time.Now().Format(\"2006-01-02 15:04:05\"))","}",""],"grade.go":["package primitives","","import (","\t\"fmt\"","\t\"reflect\"","\t\"sort\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"⍋\",","\t\tdoc:    \"grade up, sort index\",","\t\tDomain: Monadic(IsArray(nil)),","\t\tfn:     grade(true),","\t})","\tregister(primitive{","\t\tsymbol: \"⍒\",","\t\tdoc:    \"grade down, reverse sort index\",","\t\tDomain: Monadic(IsArray(nil)),","\t\tfn:     grade(false),","\t})","\tregister(primitive{","\t\tsymbol: \"⍋\",","\t\tdoc:    \"grade up with collating sequence\",","\t\tDomain: Dyadic(Split(IsVector(nil), IsArray(nil))),","\t\tfn:     grade2(true),","\t})","\tregister(primitive{","\t\tsymbol: \"⍒\",","\t\tdoc:    \"grade down with collating sequence\",","\t\tDomain: Dyadic(Split(IsVector(nil), IsArray(nil))),","\t\tfn:     grade2(false),","\t})","}","","func grade(up bool) func(*apl.Apl, apl.Value, apl.Value) (apl.Value, error) {","\treturn func(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\t\tsi, err := gradeSetup(a, R)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tif up {","\t\t\tsort.Sort(si)","\t\t} else {","\t\t\tsort.Sort(sort.Reverse(si))","\t\t}","\t\treturn apl.IntArray{","\t\t\tInts: si.idx,","\t\t\tDims: []int{len(si.idx)},","\t\t}, nil","\t}","}","","// gradeSetup prepares grading.","func gradeSetup(a *apl.Apl, R apl.Value) (sortIndexes, error) {","\tar := R.(apl.Array)","\tshape := ar.Shape()","\tif len(shape) == 0 {","\t\treturn sortIndexes{}, fmt.Errorf(\"gradeup: not an array\") // this should not happen","\t}","","\t// We store a copy of all values in b.","\t// The subarrays of the higher axis are flattened to b[i].","\t// Is this ok for comparison?","\tb := make([][]apl.Value, shape[0])","\tif len(shape) == 1 {","\t\t// In the vector case, wrap the elements to a single element slice.","\t\tfor i := range b {","\t\t\tb[i] = []apl.Value{ar.At(i).Copy()}","\t\t}","\t} else {","\t\tsubsize := apl.Prod(shape[1:])","\t\toff := 0","\t\tfor i := range b {","\t\t\tb[i] = make([]apl.Value, subsize)","\t\t\tfor k := range b[i] {","\t\t\t\tb[i][k] = ar.At(off + k).Copy()","\t\t\t}","\t\t\toff += subsize","\t\t}","\t}","","\t// All values must be numeric, or of the same type.","\t// The type must implement a Less method.","\tsametype := func() bool {","\t\tvar t reflect.Type","\t\tfor i := range b {","\t\t\tfor k := range b[i] {","\t\t\t\tv := b[i][k]","\t\t\t\tif i == 0 \u0026\u0026 k == 0 {","\t\t\t\t\tt = reflect.TypeOf(v)","\t\t\t\t} else {","\t\t\t\t\tif reflect.TypeOf(v) != t {","\t\t\t\t\t\treturn false","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t\treturn true","\t}","","\t// Convert all values to numbers of the highest class.","\tsameNumberTypes := func() bool {","\t\tclass := -1","\t\tfor i := range b {","\t\t\tfor k := range b[i] {","\t\t\t\tv := b[i][k]","\t\t\t\tvar num apl.Number","\t\t\t\tif n, ok := v.(apl.Int); ok {","\t\t\t\t\tnum = a.Tower.Import(apl.Int(n))","\t\t\t\t} else if n, ok := v.(apl.Bool); ok {","\t\t\t\t\tnum = a.Tower.Import(n)","\t\t\t\t} else if n, ok := v.(apl.Number); ok {","\t\t\t\t\tnum = n","\t\t\t\t} else {","\t\t\t\t\treturn false","\t\t\t\t}","\t\t\t\tn, ok := a.Tower.Numbers[reflect.TypeOf(num)]","\t\t\t\tif ok == false {","\t\t\t\t\treturn false","\t\t\t\t}","\t\t\t\tb[i][k] = num","\t\t\t\tif n.Class \u003e class {","\t\t\t\t\tclass = n.Class","\t\t\t\t}","\t\t\t}","\t\t}","\t\tfor i := range b {","\t\t\tfor k := range b[i] {","\t\t\t\tn := b[i][k].(apl.Number)","\t\t\t\tnum := a.Tower.Numbers[reflect.TypeOf(n)]","\t\t\t\tfor c := num.Class; c \u003c class; c++ {","\t\t\t\t\tu, ok := num.Uptype(n)","\t\t\t\t\tif ok == false {","\t\t\t\t\t\treturn false","\t\t\t\t\t}","\t\t\t\t\tb[i][k] = u","\t\t\t\t}","\t\t\t}","\t\t}","\t\treturn true","\t}","","\tissame := sametype()","\tif issame == true {","\t\tif _, ok := b[0][0].(lesser); ok == false {","\t\t\treturn sortIndexes{}, fmt.Errorf(\"grade up: types are not comparable\")","\t\t}","\t} else {","\t\tif sameNumberTypes() == false {","\t\t\treturn sortIndexes{}, fmt.Errorf(\"grade up: cannot convert to numbers\")","\t\t}","\t\tif _, ok := b[0][0].(lesser); ok == false {","\t\t\treturn sortIndexes{}, fmt.Errorf(\"grade up: cannot compare number type %T\", b[0][0])","\t\t}","\t}","","\tsi := sortIndexes{","\t\tb:   b,","\t\tidx: make([]int, len(b)),","\t}","\tfor i := range si.idx {","\t\tsi.idx[i] = i + a.Origin","\t}","\treturn si, nil","}","","// grade2 is the dyadic grade up/down.","// It is only implemented for vector left arguments.","// If L is a vector: L⍋R ←→ ⍋L⍳R","func grade2(up bool) func(*apl.Apl, apl.Value, apl.Value) (apl.Value, error) {","\treturn func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\tLiotaR, err := indexof(a, L, R)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tg := grade(up)","\t\treturn g(a, nil, LiotaR)","\t}","}","","type sortIndexes struct {","\tb   [][]apl.Value","\tidx []int","}","","func (s sortIndexes) Len() int { return len(s.b) }","func (s sortIndexes) Less(i, j int) bool {","\tx := s.b[i]","\ty := s.b[j]","\tfor n := range x {","\t\txl := x[n].(lesser)","\t\tyl := y[n].(lesser)","\t\tif isless, _ := xl.Less(y[n]); isless {","\t\t\treturn true","\t\t} else if isless, _ := yl.Less(x[n]); isless {","\t\t\treturn false","\t\t}","\t\t// On equality the next element is compared.","\t}","\treturn false","}","func (s sortIndexes) Swap(i, j int) {","\ts.b[i], s.b[j] = s.b[j], s.b[i]","\ts.idx[i], s.idx[j] = s.idx[j], s.idx[i]","}",""],"help.go":["package a","","import (","\t\"bytes\"","\t\"fmt\"","\t\"io/ioutil\"","","\t\"github.com/ktye/iv/apl\"",")","","// help returns the help text in a channel.","func help(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tvar buf bytes.Buffer","\tfmt.Fprintf(\u0026buf, \"Commands:\")","\tfor _, c := range a.Scanner.Commands() {","\t\tfmt.Fprintf(\u0026buf, \" %s\", c)","\t}","\tfmt.Fprintf(\u0026buf, \"\\n\\n\")","","\ta.Doc(\u0026buf)","\treturn apl.LineReader(ioutil.NopCloser(\u0026buf)), nil","}",""],"identifier.go":["package domain","","import \"github.com/ktye/iv/apl\"","","func IsIdentifier(child SingleDomain) SingleDomain {","\treturn identifier{child}","}","","type identifier struct{ child SingleDomain }","","func (id identifier) To(a *apl.Apl, V apl.Value) (apl.Value, bool) {","\t_, ok := V.(apl.Identifier)","\tif ok == false {","\t\treturn V, false","\t}","\treturn propagate(a, V, id.child)","}","","func (id identifier) String(f apl.Format) string {","\tname := \"identfier\"","\tif id.child == nil {","\t\treturn name","\t}","\treturn name + \" \" + id.child.String(f)","}",""],"identity.go":["package operators","","import (","\t\"math\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/numbers\"",")","","// identityItem returns the identity item for the given function f, when","// the function is applied as f/⍳0.","func identityItem(f apl.Value) apl.Value {","\t// Table from APL2: p 211, DyaRef p 170","\tif p, ok := f.(apl.Primitive); ok {","\t\tswitch p {","\t\tcase \"+\", \"-\", \"|\", \"∨\", \"\u003c\", \"\u003e\", \"≠\", \"⊤\", \"∪\", \"⌽\", \"⊖\":","\t\t\treturn apl.Int(0)","\t\tcase \"×\", \"÷\", \"*\", \"!\", \"^\", \"∧\", \"≤\", \"=\", \"≥\", \"/\", \"⌿\", `\\`, `⍀`:","\t\t\treturn apl.Int(1)","\t\tcase \"⌊\":","\t\t\treturn numbers.Float(-math.MaxFloat64)","\t\tcase \"⌈\":","\t\t\treturn numbers.Float(math.MaxFloat64)","\t\t}","\t}","\treturn nil","}",""],"image.go":["package apl","","import (","\t\"fmt\"","\t\"image\"","\t\"image/color\"","\t\"image/draw\"",")","","// An ImageWriter is anything that can handle image output.","// Apl's stdimg device uses it.","// A single image can be written directly with WriteImage.","// An animation needs Start- and StopLoop before and after.","type ImageWriter interface {","\tWriteImage(Image) error","\tStartLoop()","\tStopLoop()","}","","// An Image is a raster image.","//","// It can by converting from a numeric array of shape HEIGHT WIDTH.","// An Image is never empty, it always has rank 2.","// It cannot be reshaped, instead reshape it's int array before creating it.","//","// Formats:","//\tImg ← `img ⌶B       B BoolArray (0 White, 1 Black) // TODO or user def, or alpha?","//\tImg ← `img ⌶(I;P;)  I numeric array with values in the range ⎕IO+(0..0xFF) as indexes into P","//                           P (palette) vector of shape 256 with values as below:","//\tImg ← `img ⌶N       N numeric array, values between 0 and 0xFFFFFFFF (aarrggbb)","// Transparency has the value 0xFF000000, which is inverted compared to the go image library,","// to be able to specify opaque colors in the short form 0xRRGGBB.","// After creation, an image can be indexed and assigned to.","type Image struct {","\timage.Image","\tDims []int","}","","func (i Image) String(f Format) string {","\treturn i.toIntArray().String(f)","}","func (i Image) Copy() Value { return i } // Image is copied by reference.","","func (i Image) At(k int) Value {","\tic, idx := NewIdxConverter(i.Dims)","\tic.Indexes(k, idx)","\treturn colorValue(i.Image.At(idx[0], idx[1]))","}","func (i Image) Shape() []int {","\treturn i.Dims","}","func (i Image) Size() int {","\treturn Prod(i.Dims)","}","func (i Image) Set(k int, v Value) error {","\tnum, ok := v.(Number)","\tif ok == false {","\t\treturn fmt.Errorf(\"img set: value must be a number: %T\", v)","\t}","\tc, ok := num.ToIndex()","\tif ok == false {","\t\treturn fmt.Errorf(\"img set: value must be an integer: %T\", v)","\t}","\ty := k / i.Dims[1]","\tx := k - y*i.Dims[1]","\tr := i.Bounds()","\tif d, ok := i.Image.(draw.Image); ok {","\t\td.Set(x+r.Min.X, y+r.Min.Y, toColor(c))","\t\treturn nil","\t}","\treturn fmt.Errorf(\"img: image is not settable: %T\", i.Image)","}","","func (i Image) toIntArray() IntArray {","\tints := make([]int, Prod(i.Dims))","\tshape := make([]int, len(i.Dims))","\tcopy(shape, i.Dims)","\tidx := 0","\tr := i.Image.Bounds()","\tfor y := r.Min.Y; y \u003c r.Max.Y; y++ {","\t\tfor x := r.Min.X; x \u003c r.Max.X; x++ {","\t\t\tints[idx] = int(colorValue(i.Image.At(x, y)))","\t\t\tidx++","\t\t}","\t}","\treturn IntArray{Dims: shape, Ints: ints}","}","","// ColorValue converts a Color to an Int.","func colorValue(c color.Color) Int {","\tr, g, b, a := c.RGBA() // uint32 premultiplied with alpha.","\tu := (255-(a\u003e\u003e8))\u003c\u003c16 | r\u00260xFF00\u003c\u003c8 | g\u00260xFF00 | b\u003e\u003e8","\treturn Int(u)","}","func toColor(i int) color.Color {","\tu := uint32(i)","\treturn color.RGBA{uint8(u \u0026 0xFF0000 \u003e\u003e 16), uint8(u \u0026 0xFF00 \u003e\u003e 8), uint8(u \u0026 0xFF), ^uint8(u \u003e\u003e 24)}","}",""],"index.go":["package primitives","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\t// An expression such as A[1;2;] is translated by the parser to","\t//\t[1;2;] ⌷ A","\t// ⌷ cannot be used directly, as an index specification is converted by the parser.","\tregister(primitive{","\t\tsymbol: \"⌷\",","\t\tdoc:    \"index, []\",","\t\tDomain: Dyadic(Split(indexSpec{}, ToArray(nil))),","\t\tfn:     index,","\t\tsel:    indexSelection,","\t})","\tregister(primitive{","\t\tsymbol: \"⌷\",","\t\tdoc:    \"index list, []\",","\t\tDomain: Dyadic(Split(indexSpec{}, IsList(nil))),","\t\tfn:     listIndex,","\t\tsel:    listSelection,","\t})","\tregister(primitive{","\t\tsymbol: \"⌷\",","\t\tdoc:    \"index object, []\",","\t\tDomain: Dyadic(Split(indexSpec{}, IsObject(nil))),","\t\tfn:     objIndex,","\t\tsel:    objSelection,","\t})","\tregister(primitive{","\t\tsymbol: \"⌷\",","\t\tdoc:    \"index table, []\",","\t\tDomain: Dyadic(Split(indexSpec{}, IsTable(nil))),","\t\tfn:     tableIndex,","\t\tsel:    tableSelection,","\t})","}","","// indexSpec is the domain type for an index specification.","type indexSpec struct{}","","func (i indexSpec) To(a *apl.Apl, v apl.Value) (apl.Value, bool) {","\tif _, ok := v.(apl.IdxSpec); ok {","\t\treturn v, true","\t}","\treturn v, false","}","func (i indexSpec) String(f apl.Format) string {","\treturn \"[index specification]\"","}","","func index(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tspec := L.(apl.IdxSpec)","\tar := R.(apl.Array)","","\t// Special case for empty brackets.","\tif len(spec) == 0 {","\t\treturn R, nil","\t}","","\tidx, err := indexArray(a, spec, ar.Shape())","\tif err != nil {","\t\treturn nil, err","\t}","","\t// Special case, if the result is a scalar.","\tif len(idx.Ints) == 1 \u0026\u0026 len(idx.Dims) == 0 {","\t\tif err := apl.ArrayBounds(ar, int(idx.Ints[0])); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn ar.At(int(idx.Ints[0])), nil","\t}","","\tres := apl.MakeArray(ar, apl.CopyShape(idx))","\tfor i, n := range idx.Ints {","\t\tif err := apl.ArrayBounds(ar, n); err != nil {","\t\t\treturn nil, err","\t\t}","\t\tres.Set(i, ar.At(n).Copy())","\t}","\treturn res, nil","}","","func indexSelection(a *apl.Apl, L, R apl.Value) (apl.IntArray, error) {","\tspec := L.(apl.IdxSpec)","\tar := R.(apl.Array)","","\t// Special case for empty brackets.","\tif len(spec) == 0 {","\t\tai := apl.IntArray{Dims: apl.CopyShape(ar), Ints: make([]int, ar.Size())}","\t\tfor i := range ai.Ints {","\t\t\tai.Ints[i] = i","\t\t}","\t\treturn ai, nil","\t}","","\tif len(spec) == 1 {","\t\tif f, ok := spec[0].(apl.Function); ok {","\t\t\treturn funcArrayIndex(a, f, ar)","\t\t}","\t}","","\treturn indexArray(a, spec, ar.Shape())","}","","func objSelection(a *apl.Apl, L, R apl.Value) (apl.IntArray, error) {","\tobj := R.(apl.Object)","\td, isd := R.(*apl.Dict)","\tspec := L.(apl.IdxSpec)","\tif len(spec) != 1 {","\t\treturn objDepthSelection(a, obj, spec, apl.IntArray{})","\t}","","\tkeys := make(map[apl.Value]int)","\tfor i, k := range obj.Keys() {","\t\tkeys[k] = i + a.Origin","\t}","","\tas, ok := spec[0].(apl.Array)","\tif ok == false {","\t\tif idx, ok := keys[spec[0]]; ok == false {","\t\t\tif isd {","\t\t\t\t// Index-assignment into a non-existing key in a dict, creates a new key.","\t\t\t\tif err := d.Set(spec[0], apl.EmptyArray{}); err != nil {","\t\t\t\t\treturn apl.IntArray{}, err","\t\t\t\t} else {","\t\t\t\t\treturn apl.IntArray{Dims: []int{1}, Ints: []int{len(keys) + a.Origin}}, nil","\t\t\t\t}","\t\t\t} else {","\t\t\t\treturn apl.IntArray{}, fmt.Errorf(\"key does not exist: %s\", spec[0].String(apl.Format{}))","\t\t\t}","\t\t} else {","\t\t\treturn apl.IntArray{Dims: []int{1}, Ints: []int{idx}}, nil","\t\t}","\t}","","\tai := apl.IntArray{Dims: []int{as.Size()}, Ints: make([]int, as.Size())}","\tfor i := 0; i \u003c as.Size(); i++ {","\t\tkey := as.At(i)","\t\tk, ok := keys[key]","\t\tif ok == false {","\t\t\tif isd {","\t\t\t\tif err := d.Set(key, apl.EmptyArray{}); err != nil {","\t\t\t\t\treturn apl.IntArray{}, err","\t\t\t\t} else {","\t\t\t\t\tk = len(keys) + a.Origin","\t\t\t\t\tkeys[key] = k","\t\t\t\t}","\t\t\t} else {","\t\t\t\treturn apl.IntArray{}, fmt.Errorf(\"key does not exist: %s\", key.String(apl.Format{}))","\t\t\t}","\t\t}","\t\tai.Ints[i] = k","\t}","\treturn ai, nil","}","","// objDepthSelection returns a depth index into an object tree.","// Depth indexes for objects are returned as negative indexes starting at -1","// to distinguish them from vector indexes (multiple keys at the same level).","func objDepthSelection(a *apl.Apl, o apl.Object, spec apl.IdxSpec, ia apl.IntArray) (apl.IntArray, error) {","\tkey := spec[0]","\tval := o.At(key)","\tif val == nil {","\t\treturn ia, fmt.Errorf(\"obj depth sel: key does not exist: %v\", key)","\t}","","\tidx := -1","\tkeys := o.Keys()","\tfor i, k := range keys {","\t\tif k == key {","\t\t\tidx = i","\t\t}","\t}","\tif idx \u003c 0 {","\t\treturn ia, fmt.Errorf(\"obj depth sel: cannot find index\")","\t}","\tif len(ia.Dims) == 0 {","\t\tia.Dims = []int{1}","\t\tia.Ints = []int{-1 - idx}","\t} else {","\t\tia.Dims[0]++","\t\tia.Ints = append(ia.Ints, -1-idx)","\t}","\tif len(spec) \u003c 2 {","\t\treturn ia, nil","\t}","","\tadd := func(idx apl.IntArray) {","\t\tif n := len(idx.Ints); n \u003e 0 {","\t\t\tia.Dims[0] += n","\t\t\tia.Ints = append(ia.Ints, idx.Ints...)","\t\t}","\t}","","\tif _, ok := val.(apl.Table); ok {","\t\treturn ia, fmt.Errorf(\"obj depth sel: index into table is not supported\")","\t} else if o, ok := val.(apl.Object); ok {","\t\treturn objDepthSelection(a, o, spec[1:], ia)","\t} else if l, ok := val.(apl.List); ok {","\t\tidx, err := listSelection(a, l, spec[1:])","\t\tif err != nil {","\t\t\treturn ia, err","\t\t}","\t\tadd(idx)","\t\treturn ia, nil","\t} else {","\t\tidx, err := indexSelection(a, spec[1:], val)","\t\tif err != nil {","\t\t\treturn ia, err","\t\t}","\t\tadd(idx)","\t\treturn ia, nil","\t}","}","","// indexArray returns the indexes within the array A for the given index specification.","// The result may have a smaller size and shape as the input array.","// The indexes in the spec are origin dependend, but in IndexArray are always origin 0.","func indexArray(a *apl.Apl, spec apl.IdxSpec, shape []int) (apl.IntArray, error) {","\tintspec, err := spec2ints(a, spec, shape)","\tif err != nil {","\t\treturn apl.IntArray{}, err","\t}","","\t// Initially the rank is the same as spec.","\t// Single element axis will be reduced later.","\tres := apl.IntArray{Dims: make([]int, len(intspec))}","\tfor i := range intspec {","\t\tres.Dims[i] = len(intspec[i])","\t}","\tres.Ints = make([]int, apl.Prod(res.Dims))","","\tic, src := apl.NewIdxConverter(shape)","\tdst := make([]int, len(res.Dims))","\tfor i := range res.Ints {","\t\tfor k, n := range dst {","\t\t\tsrc[k] = intspec[k][n]","\t\t}","\t\tres.Ints[i] = ic.Index(src)","\t\tapl.IncArrayIndex(dst, res.Dims)","\t}","","\t// Reduce rank by collapsing single element axis.","\trs := make([]int, 0, len(res.Dims))","\tfor _, v := range res.Dims {","\t\tif v != 1 {","\t\t\trs = append(rs, v)","\t\t}","\t}","\tres.Dims = rs","\treturn res, nil","}","","// Spec2ints converts an index specification to [][]int for the given shape.","// spec is origin dependent, the result has always origin 0.","func spec2ints(a *apl.Apl, spec apl.IdxSpec, shape []int) ([][]int, error) {","\tif len(spec) != len(shape) {","\t\treturn nil, fmt.Errorf(\"indexing: array and index specification have different rank: %d != %d\", len(spec), len(shape))","\t}","","\tto := ToIndexArray(nil)","\tidx := make([][]int, len(shape))","\tfor i := range spec {","\t\tv, ok := to.To(a, spec[i])","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"index specification for axis %d is illegal: %T\", i+1, spec[i])","\t\t}","","\t\t// Empty axis are expanded to all elements of the axis.","\t\tif _, ok := v.(apl.EmptyArray); ok {","\t\t\tidx[i] = make([]int, shape[i])","\t\t\tfor k := range idx[i] {","\t\t\t\tidx[i][k] = k","\t\t\t}","\t\t\tcontinue","\t\t}","\t\tia := v.(apl.IntArray)","\t\tidx[i] = make([]int, len(ia.Ints))","\t\tfor k := range ia.Ints {","\t\t\tif n := ia.Ints[k] - a.Origin; n \u003c 0 || n \u003e= shape[i] {","\t\t\t\treturn nil, fmt.Errorf(\"index specification for axis %d is out of range\", i+1)","\t\t\t} else {","\t\t\t\tidx[i][k] = n","\t\t\t}","\t\t}","\t}","\treturn idx, nil","}","","// funcArrayIndex uses the dyadic function f to index into array A.","// f is called with the current index vector on the left and the array value on the right","// for each element. Indexes are selected if the function returns 1 otherwise it may return 0 or empty.","// Example: A←2 3⍴6 ⋄ A[{⍺[2]\u003e⍺[1]\u0026\u0026⍵\u003c4:1}].","// It returns an index vector with the selected indexes only (0-based).","func funcArrayIndex(a *apl.Apl, f apl.Function, A apl.Array) (apl.IntArray, error) {","\tshape := A.Shape()","\tres := apl.IntArray{Dims: []int{0}}","\tres.Ints = make([]int, 0, A.Size())","\tidx := make([]int, len(shape))","\tL := apl.IntArray{Dims: []int{len(idx)}}","\tL.Ints = make([]int, len(idx))","\tfor i := 0; i \u003c A.Size(); i++ {","\t\tfor k := range L.Ints {","\t\t\tL.Ints[k] = a.Origin + idx[k]","\t\t}","\t\tv, err := f.Call(a, L, A.At(i)) // TODO: copy?","\t\tif err != nil {","\t\t\treturn res, fmt.Errorf(\"func-array-index: %s\", err)","\t\t}","\t\tif _, ok := v.(apl.EmptyArray); ok {","\t\t\tcontinue","\t\t}","\t\tnum, ok := v.(apl.Number)","\t\tif ok == false {","\t\t\treturn res, fmt.Errorf(\"func-array-index: return value is not numeric: %T\", v)","\t\t}","\t\tn, ok := num.ToIndex()","\t\tif ok == false || (i \u003c 0 \u0026\u0026 i \u003e 1) {","\t\t\treturn res, fmt.Errorf(\"func-array-index: return value is not boolean: %T %s\", v, v.String(apl.Format{}))","\t\t}","\t\tif n == 1 {","\t\t\tres.Ints = append(res.Ints, i)","\t\t\tres.Dims[0]++","\t\t}","\t\tapl.IncArrayIndex(idx, shape)","\t}","\treturn res, nil","}","","// objIndex returns a dictionary with only the given keys.","// Keys may be indexed by integers, or strings.","func objIndex(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tobj := R.(apl.Object)","\tspec := L.(apl.IdxSpec)","\tif len(spec) != 1 {","\t\treturn objDepthIndex(a, obj, spec)","\t}","","\t// If the spec is a single value, return the value for the key.","\tsv, ok := spec[0].(apl.Array)","\tif ok == false {","\t\tv := obj.At(spec[0])","\t\tif v == nil {","\t\t\treturn nil, fmt.Errorf(\"key does not exist\")","\t\t}","\t\treturn v, nil","\t}","","\t// If the spec is a vector, create a dict with these keys.","\tls := sv.Shape()","\tif len(ls) != 1 {","\t\treturn nil, fmt.Errorf(\"object index must be a vector\")","\t}","\tk := make([]apl.Value, ls[0])","\tm := make(map[apl.Value]apl.Value)","\tfor i := 0; i \u003c ls[0]; i++ {","\t\tkey := sv.At(i)","\t\tv := obj.At(key)","\t\tif v == nil {","\t\t\treturn nil, fmt.Errorf(\"key does not exist: %s\", key.String(a.Format))","\t\t}","\t\tk[i] = key // TODO: copy?","\t\tm[key] = v // TODO: copy?","\t}","\treturn \u0026apl.Dict{K: k, M: m}, nil","}","","func objDepthIndex(a *apl.Apl, obj apl.Object, spec apl.IdxSpec) (apl.Value, error) {","\tkey := spec[0]","\tv := obj.At(key)","\tif v == nil {","\t\treturn nil, fmt.Errorf(\"key does not exist: %q\", key.String(apl.Format{}))","\t}","\tif len(spec) == 1 {","\t\treturn v, nil","\t}","\tif _, ok := v.(apl.Table); ok {","\t\treturn nil, fmt.Errorf(\"obj-depth-index: table is not supported\")","\t} else if o, ok := v.(apl.Object); ok {","\t\treturn objIndex(a, spec[1:], o)","\t} else if l, ok := v.(apl.List); ok {","\t\treturn listIndex(a, spec[1:], l)","\t} else if ar, ok := v.(apl.Array); ok {","\t\treturn index(a, spec[1:], ar)","\t}","\treturn nil, fmt.Errorf(\"obj-depth-index: cannot index into %T\", v)","}","","// listIndexing indexes a list at depth.","// indexes may be negative.","func listIndex(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tlst := R.(apl.List)","\tai, err := listSelection(a, L, R)","\tif err != nil {","\t\treturn nil, err","\t}","","\t// Index at depth.","\t// Indexes may be negative (count from the end).","\tidx := ai.Ints","\tfor i, k := range idx {","\t\tv := lst[k]","\t\tif i == len(idx)-1 {","\t\t\treturn v.Copy(), nil","\t\t} else {","\t\t\tlst = v.(apl.List)","\t\t}","\t}","\treturn lst, nil","}","","// listSelection returns the index for selective assignment.","// The returned array is a single depth-index, not multiple indexes.","// This is different from array indexing.","func listSelection(a *apl.Apl, L, R apl.Value) (apl.IntArray, error) {","\tlst := R.(apl.List)","\tspec := L.(apl.IdxSpec)","","\tvar ai apl.IntArray","\tif len(spec) == 1 {","\t\tif _, ok := spec[0].(apl.List); ok {","\t\t\treturn ai, fmt.Errorf(\"indexing with a list is not supported\")","\t\t}","\t}","","\t// Convert spec to ints.","\tto := ToIndexArray(nil)","\tidx := make([]int, len(spec))","\tfor i := range spec {","\t\tv, ok := to.To(a, spec[i])","\t\tif ok == false {","\t\t\treturn ai, fmt.Errorf(\"list index is no integer\")","\t\t}","\t\tai := v.(apl.IntArray)","\t\tif s := ai.Shape(); len(s) != 1 || s[0] != 1 {","\t\t\treturn ai, fmt.Errorf(\"list index is no integer: %T\", v)","\t\t}","\t\tidx[i] = ai.Ints[0] - a.Origin","\t}","","\t// Index at depth.","\t// Indexes may be negative (count from the end).","\tfor i, k := range idx {","\t\tif k \u003c 0 {","\t\t\tk = len(lst) + k","\t\t}","\t\tif k \u003c 0 || k \u003e= len(lst) {","\t\t\treturn ai, fmt.Errorf(\"list index out of range\")","\t\t}","\t\tidx[i] = k","\t\tv := lst[k]","\t\tif i \u003c len(idx)-1 {","\t\t\tif l, ok := v.(apl.List); ok {","\t\t\t\tlst = l","\t\t\t} else {","\t\t\t\treturn ai, fmt.Errorf(\"list index is too deep\")","\t\t\t}","\t\t}","\t}","\treturn apl.IntArray{Dims: []int{len(idx)}, Ints: idx}, nil","}","","// tableSelection returns the indexes for selective assignment on tables.","// T[rowidx], T[rowidx; colkeys], T[rowfunc], T[rowfunc, colkeys], T[colkeys]","// It returns a flat index vector (0-based) with catenated row and col indexes.","// The shape only counts row indexes.","// A rowfunc can be used as a selection function.","// It is called in an environment with column variables predeclared with the names of the","// keys (if they are strings, and valid variable names).","// The left is the row index vector and right argument is the table itself.","// E.g. T[{(⍺\u003e10)^Time\u003e2015.11.22}]","// The function should returns a boolean selection vector of the size of number of columns.","func tableSelection(a *apl.Apl, L, R apl.Value) (apl.IntArray, error) {","\tT := R.(apl.Table)","\tspec := L.(apl.IdxSpec)","\tvar idx apl.IntArray","\tif len(spec) \u003c 1 || len(spec) \u003e 2 {","\t\treturn idx, fmt.Errorf(\"table-select: index spec len must be 1 or 2: %d\", len(spec))","\t}","","\tvar colidx []int","\tcols := T.Dict.Keys()","\tcolmap := make(map[apl.Value]int)","\tfor i := range cols {","\t\tcolmap[cols[i]] = i","\t}","\tif len(spec) \u003c 2 {","\t\t// special case: spec[0] is a string, or string vector.","\t\tto := ToStringArray(nil)","\t\tif sa, ok := to.To(a, spec[0]); ok {","\t\t\tstrings := sa.(apl.StringArray).Strings","\t\t\tcolidx = make([]int, len(strings))","\t\t\tfor i, s := range strings {","\t\t\t\tn, ok := colmap[apl.String(s)]","\t\t\t\tif ok == false {","\t\t\t\t\treturn idx, fmt.Errorf(\"table-select: columns does not exist: %s\", s)","\t\t\t\t}","\t\t\t\tcolidx[i] = n","\t\t\t}","\t\t\tspec[0] = apl.EmptyArray{}","\t\t} else {","\t\t\tcolidx = make([]int, len(cols))","\t\t\tfor i := range colidx {","\t\t\t\tcolidx[i] = i","\t\t\t}","\t\t}","\t} else {","\t\tar, ok := spec[1].(apl.Array)","\t\tif ok == false {","\t\t\tar = apl.MixedArray{","\t\t\t\tDims:   []int{1},","\t\t\t\tValues: []apl.Value{spec[1]},","\t\t\t}","\t\t}","\t\tcolidx = make([]int, ar.Size())","\t\tfor i := 0; i \u003c ar.Size(); i++ {","\t\t\tkey := ar.At(i)","\t\t\tn, ok := colmap[key]","\t\t\tif ok == false {","\t\t\t\treturn idx, fmt.Errorf(\"table-select: column does not exist: %s\", key.String(apl.Format{}))","\t\t\t}","\t\t\tcolidx[i] = n","\t\t}","\t\tif _, ok := spec[1].(apl.EmptyArray); ok {","\t\t\tcolidx = make([]int, len(cols))","\t\t\tfor i := range colidx {","\t\t\t\tcolidx[i] = i","\t\t\t}","\t\t}","\t}","","\ttoIdx := ToIndexArray(nil)","\tiav, ok := toIdx.To(a, spec[0])","\tif _, ok := spec[0].(apl.EmptyArray); ok {","\t\tia := apl.IntArray{Dims: []int{T.Rows}, Ints: make([]int, T.Rows)}","\t\tfor i := range ia.Ints {","\t\t\tia.Ints[i] = i + a.Origin","\t\t}","\t\tiav = ia","\t}","","\tvar ia apl.IntArray","\tif ok == false {","\t\tf, ok := spec[0].(apl.Function)","\t\tif ok == false {","\t\t\treturn idx, fmt.Errorf(\"table-select: first spec must be an index vector or a function: %T\", spec[0])","\t\t}","","\t\tvars := make(map[string]apl.Value)","\t\tfor _, key := range cols {","\t\t\tif s, ok := key.(apl.String); ok {","\t\t\t\tvars[string(s)] = T.Dict.At(key)","\t\t\t}","\t\t}","\t\tiv, err := interval(a, nil, apl.Int(T.Rows))","\t\tif err != nil {","\t\t\treturn idx, fmt.Errorf(\"table-select-func: %s\", err)","\t\t}","\t\tv, err := a.EnvCall(f, iv, T, vars)","\t\tif err != nil {","\t\t\treturn idx, fmt.Errorf(\"table-select-func: %s\", err)","\t\t}","","\t\tto := ToBoolArray(nil)","\t\tbools, ok := to.To(a, v)","\t\tif ok == false {","\t\t\treturn idx, fmt.Errorf(\"table-select-func: does not return a boolean vector: %T\", v)","\t\t}","\t\tif v, err := where(a, nil, bools); err != nil {","\t\t\treturn idx, fmt.Errorf(\"table-select-func: %s\", err)","\t\t} else {","\t\t\tar := v.(apl.IntArray)","\t\t\tia.Ints = ar.Ints","\t\t\tia.Dims = []int{len(ia.Ints)}","\t\t}","\t} else {","\t\tia = iav.(apl.IntArray)","\t}","","\tidx = apl.IntArray{Dims: []int{len(ia.Ints)}, Ints: make([]int, len(ia.Ints)+len(colidx))} // sic!","\tfor i, k := range ia.Ints {","\t\tif n := k - a.Origin; n \u003c 0 || n \u003e= T.Rows {","\t\t\treturn idx, fmt.Errorf(\"table-select: row index out of range: %d\", k)","\t\t} else {","\t\t\tidx.Ints[i] = n","\t\t}","\t}","\tfor i, k := range colidx {","\t\tidx.Ints[len(ia.Ints)+i] = k","\t}","\treturn idx, nil","}","","// tableIndex indexes into a table.","//\t- empty index","//\t\tT[]      converts to array","//\t- single column (only for string keys)","//\t\tT[`a]    returns a vector","//\t\tT[1⍴`a]  returns a single-column table","//\t- single row and column","//\t\tT[3;`a]  returns the scalar value","//\t- single row","//\t\tT[3]     returns a dict","//\t\tT[1⍴3]   returns a single-row table","//\t- multiple rows or columns","//\t\tT[1 3]     return a sub-table with all column","//\t\tT[;`a`b]   return a sub-table with all rows","//\t\tT[⍳3;`a`c] return a sub-table","//\t- functional row index","//\t\tT[{⍺\u003e1}]  return a table","func tableIndex(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tt := R.(apl.Table)","\tspec := L.(apl.IdxSpec)","","\t// Empty spec: convert to array.","\tif len(spec) == 0 {","\t\treturn table2array(a, t) // table.go","\t}","","\tconv := true","\tvar agg, grp apl.Value","\tif len(spec) \u003e 4 {","\t\treturn nil, fmt.Errorf(\"table: index specification is too long: %d\", len(spec))","\t}","\tif len(spec) \u003e 3 {","\t\tgrp = spec[3]","\t}","\tif len(spec) \u003e 2 {","\t\tagg = spec[2]","\t\tspec = spec[:2]","\t\tconv = false","\t}","\tif conv == true {","\t\tfor i := range spec {","\t\t\tif _, ok := spec[i].(apl.Function); ok {","\t\t\t\tconv = false","\t\t\t}","\t\t\tif _, ok := spec[i].(apl.EmptyArray); ok {","\t\t\t\tcontinue","\t\t\t}","\t\t\tif _, ok := spec[i].(apl.Array); ok {","\t\t\t\tconv = false","\t\t\t}","\t\t}","\t}","","\tidx, err := tableSelection(a, spec, t)","\tif err != nil {","\t\treturn nil, err","\t}","","\t// Both row and column index are stored on a single axis in an unusual way.","\trows := idx.Ints[:idx.Dims[0]]","\tcols := idx.Ints[idx.Dims[0]:]","\tkeys := t.Keys()","","\t// Return a single value.","\tif conv \u0026\u0026 len(rows) == 1 \u0026\u0026 len(cols) == 1 {","\t\treturn t.At(keys[cols[0]]).(apl.Array).At(rows[0]).Copy(), nil","\t}","","\t// Return a single column as an array.","\tif conv \u0026\u0026 len(cols) == 1 {","\t\treturn t.At(keys[cols[0]]).Copy(), nil","\t}","","\tres := apl.Table{Rows: len(rows)}","\td := apl.Dict{}","\td.K = make([]apl.Value, len(cols))","\td.M = make(map[apl.Value]apl.Value)","\tfor i, k := range cols {","\t\tkey := keys[k].Copy()","\t\td.K[i] = key","\t\tsrccol := t.At(key).(apl.Uniform)","\t\tcol := srccol.Make([]int{len(rows)})","\t\tfor n, m := range rows {","\t\t\tif err := col.Set(n, srccol.At(m).Copy()); err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t}","\t\td.M[key] = col","\t}","","\t// Return a dict for a single row.","\tif conv \u0026\u0026 len(rows) == 1 {","\t\treturn \u0026d, nil","\t}","\tres.Dict = \u0026d","","\tif agg != nil {","\t\treturn tableQuery(a, res, agg, grp)","\t}","\treturn res, nil","}",""],"init.go":["package rpc","","import (","\t\"encoding/gob\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/numbers\"",")","","func init() {","\t// Register types for communication.","\tgob.Register(apl.Bool(false))","\tgob.Register(apl.Int(0))","\tgob.Register(numbers.Float(0.0))","\tgob.Register(numbers.Complex(0))","\tgob.Register(apl.String(\"\"))","\tgob.Register(apl.List(nil))","\tgob.Register(apl.MixedArray{})","\tgob.Register(apl.IntArray{})","\tgob.Register(apl.Bool(false))","}",""],"int.go":["package apl","","import (","\t\"fmt\"","\t\"math/big\"","\t\"reflect\"","\t\"strconv\"","\t\"strings\"",")","","// Int is the Integer type. It is used for numbers an indexes.","type Int int","","func (i Int) ToIndex() (int, bool) {","\treturn int(i), true","}","","// String formats an integer as a string.","// The format string is passed to fmt and - is replaced by ¯,","// except if the first rune is -.","func (i Int) String(f Format) string {","\tformat := f.Fmt[reflect.TypeOf(i)]","\tminus := false","\tif len(format) \u003e 1 \u0026\u0026 format[0] == '-' {","\t\tminus = true","\t\tformat = format[1:]","\t}","\tif format == \"\" {","\t\tswitch f.PP {","\t\tcase -8:","\t\t\tformat = \"0%o\"","\t\tcase -16:","\t\t\tformat = \"0x%X\"","\t\tdefault:","\t\t\tformat = \"%v\"","\t\t}","\t}","\ts := fmt.Sprintf(format, i)","\tif minus == false {","\t\ts = strings.Replace(s, \"-\", \"¯\", 1)","\t}","\treturn s","}","","func (i Int) Copy() Value {","\treturn i","}","","func (i Int) Export() reflect.Value {","\treturn reflect.ValueOf(int(i))","}","","// ParseInt parses an integer. It replaces ¯ with -, then uses ParseInt.","// Decimal, Octal (0x..) and Hexadecimal (0..) formats are supported.","func ParseInt(s string) (Number, bool) {","\ts = strings.Replace(s, \"¯\", \"-\", -1)","\tif n, err := strconv.ParseInt(s, 0, 64); err == nil {","\t\treturn Int(n), true","\t}","\treturn Int(0), false","}","","func (i Int) Less(R Value) (Bool, bool) {","\treturn Bool(i \u003c R.(Int)), true","}","","func (i Int) Add() (Value, bool) {","\treturn i, true","}","func (i Int) Add2(R Value) (Value, bool) {","\treturn i + R.(Int), true","}","","func (i Int) Sub() (Value, bool) {","\treturn -i, true","}","func (i Int) Sub2(R Value) (Value, bool) {","\treturn i - R.(Int), true","}","","func (i Int) Mul() (Value, bool) {","\tif i \u003e 0 {","\t\treturn Int(1), true","\t} else if i \u003c 0 {","\t\treturn Int(-1), true","\t}","\treturn Int(0), true","}","func (i Int) Mul2(R Value) (Value, bool) {","\treturn i * R.(Int), true","}","","func (i Int) Div() (Value, bool) {","\tif i == 1 {","\t\treturn Int(1), true","\t} else if i == -1 {","\t\treturn Int(-1), true","\t}","\treturn nil, false","}","func (a Int) Div2(b Value) (Value, bool) {","\tn := int(b.(Int))","\tif n == 0 {","\t\treturn nil, false","\t}","\tr := int(a) / n","\tif r*n == int(a) {","\t\treturn Int(r), true","\t}","\treturn nil, false","}","","func (i Int) Pow() (Value, bool) {","\tif i == 0 {","\t\treturn Int(1), true","\t}","\treturn nil, false","}","func (i Int) Pow2(R Value) (Value, bool) {","\treturn nil, false","}","","func (i Int) Log() (Value, bool) {","\treturn nil, false","}","func (i Int) Log2() (Value, bool) {","\treturn nil, false","}","","func (i Int) Abs() (Value, bool) {","\tif i \u003c 0 {","\t\treturn -i, true","\t}","\treturn i, true","}","","func (i Int) Ceil() (Value, bool) {","\treturn i, true","}","func (i Int) Floor() (Value, bool) {","\treturn i, true","}","","func (i Int) Gamma() (Value, bool) {","\t// 20 is the limit for int64.","\tif i \u003c 0 || i \u003e 20 {","\t\treturn nil, false","\t} else if i == 0 {","\t\treturn Int(1), true","\t}","\tn := 1","\tfor k := 1; k \u003c= int(i); k++ {","\t\tn *= k","\t}","\treturn Int(n), true","}","func (L Int) Gamma2(r Value) (Value, bool) {","\tm1exp := func(n Int) Int {","\t\tif n%2 == 0 {","\t\t\treturn 1","\t\t}","\t\treturn -1","\t}","\tR := r.(Int)","\t// This is the table from APL2 p 66","\tif L \u003e= 0 \u0026\u0026 R \u003e= 0 \u0026\u0026 R-L \u003e= 0 {","\t\tlg, ok := L.Gamma()","\t\tif ok == false {","\t\t\treturn nil, false","\t\t}","\t\trg, ok := R.Gamma()","\t\tif ok == false {","\t\t\treturn nil, false","\t\t}","\t\trlg, ok := (R - L).Gamma()","\t\tif ok == false {","\t\t\treturn nil, false","\t\t}","\t\treturn rg.(Int) / (lg.(Int) * rlg.(Int)), true","\t} else if L \u003e= 0 \u0026\u0026 R \u003e= 0 \u0026\u0026 R-L \u003c 0 {","\t\treturn Int(0), true","\t} else if L \u003e= 0 \u0026\u0026 R \u003c 0 \u0026\u0026 R-L \u003c 0 {","\t\tv, ok := L.Gamma2(L - (1 + R))","\t\tif ok == false {","\t\t\treturn nil, false","\t\t}","\t\treturn m1exp(L) * v.(Int), true","\t} else if L \u003c 0 \u0026\u0026 R \u003e= 0 \u0026\u0026 R-L \u003e= 0 {","\t\treturn Int(0), true","\t} else if L \u003c 0 \u0026\u0026 R \u003c 0 \u0026\u0026 R-L \u003e= 0 {","\t\tal1 := 1 + L","\t\tif al1 \u003c 0 {","\t\t\tal1 = -al1","\t\t}","\t\tv, ok := (-(R + 1)).Gamma2(al1)","\t\tif ok == false {","\t\t\treturn nil, false","\t\t}","\t\treturn m1exp(R-L) * v.(Int), true","\t} else if L \u003c 0 \u0026\u0026 R \u003c 0 \u0026\u0026 R-L \u003c 0 {","\t\treturn Int(0), true","\t}","\treturn nil, false","}","","func (L Int) Gcd(R Value) (Value, bool) {","\tl := big.NewInt(int64(L))","\tr := big.NewInt(int64(R.(Int)))","\treturn Int(big.NewInt(0).GCD(nil, nil, l, r).Int64()), true","}",""],"iota.go":["package primitives","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"⍳\",","\t\tdoc:    \"interval, index generater, progression\",","\t\tDomain: Monadic(ToScalar(ToIndex(nil))),","\t\tfn:     interval,","\t})","\tregister(primitive{","\t\tsymbol: \"⍳\",","\t\tdoc:    `index of, first occurrence`,","\t\tDomain: Dyadic(Split(ToVector(nil), ToArray(nil))),","\t\tfn:     indexof,","\t})","\tregister(primitive{","\t\tsymbol: \"∊\",","\t\tdoc:    `membership`,","\t\tDomain: Dyadic(nil),","\t\tfn:     membership,","\t})","\tregister(primitive{","\t\tsymbol: \"⍸\",","\t\tdoc:    \"where\",","\t\tDomain: Monadic(ToBoolArray(nil)),","\t\tfn:     where,","\t})","\tregister(primitive{","\t\tsymbol: \"⍸\",","\t\tdoc:    \"interval index\",","\t\tDomain: Dyadic(Split(IsVector(nil), IsArray(nil))),","\t\tfn:     intervalindex,","\t})","}","","// interval: R: integer. index generator.","func interval(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tn := int(R.(apl.Int))","\tif n \u003c 0 {","\t\treturn nil, fmt.Errorf(\"iota: L is negative\")","\t}","\tif n == 0 {","\t\treturn apl.EmptyArray{}, nil","\t}","\tar := apl.IntArray{","\t\tInts: make([]int, n),","\t\tDims: []int{n},","\t}","\tfor i := 0; i \u003c n; i++ {","\t\tar.Ints[i] = a.Origin + i","\t}","\treturn ar, nil","}","","// indexof: L: vector, R: array","func indexof(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tal := L.(apl.Array) // vector","\tar := R.(apl.Array)","","\tnl := al.Size()","\tnotfound := nl + a.Origin","\tvals := make([]apl.Value, nl)","\tfor i := range vals {","\t\tvals[i] = al.At(i)","\t}","","\tindex := func(x apl.Value) int {","\t\tfor i := 0; i \u003c nl; i++ {","\t\t\tif ok := isEqual(a, x, vals[i]); ok {","\t\t\t\treturn i + a.Origin","\t\t\t}","\t\t}","\t\treturn notfound","\t}","","\tai := apl.IntArray{","\t\tInts: make([]int, ar.Size()),","\t\tDims: apl.CopyShape(ar),","\t}","\tfor i := range ai.Ints {","\t\tai.Ints[i] = index(ar.At(i))","\t}","\treturn ai, nil","}","","// membership. L and R may be arrays.","func membership(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\tar = apl.MixedArray{","\t\t\tDims:   []int{1},","\t\t\tValues: []apl.Value{R},","\t\t}","\t}","\tn := ar.Size()","","\tal, ok := L.(apl.Array)","\tif !ok {","\t\t// Scalar L: return a scalar boolean.","\t\tfor i := 0; i \u003c n; i++ {","\t\t\tif isEqual(a, ar.At(i), L) == true {","\t\t\t\treturn apl.Bool(true), nil","\t\t\t}","\t\t}","\t\treturn apl.Bool(false), nil","\t}","","\tres := apl.BoolArray{","\t\tDims:  apl.CopyShape(al),","\t\tBools: make([]bool, al.Size()),","\t}","\tfor k := range res.Bools {","\t\tl := al.At(k)","\t\tok = false","\t\tfor i := 0; i \u003c n; i++ {","\t\t\tr := ar.At(i)","\t\t\tif isEqual(a, l, r) == true {","\t\t\t\tok = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif ok {","\t\t\tres.Bools[k] = true","\t\t}","\t}","\treturn res, nil","}","","// where R is an IndexArray but only a boolean is allowed.","// In Dyalog where returns a nested index array for higher dimensional arrays.","// Here only vectors are supported.","func where(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tar := R.(apl.BoolArray)","\tshape := ar.Shape()","\tif ar.Size() == 0 {","\t\treturn apl.EmptyArray{}, nil","\t}","","\tif len(shape) != 1 {","\t\treturn nil, fmt.Errorf(\"where: only vectors are supported\")","\t}","","\tcount := 0","\tfor _, n := range ar.Bools {","\t\tif n == true {","\t\t\tcount++","\t\t}","\t}","","\tres := apl.IntArray{Dims: []int{count}, Ints: make([]int, count)}","\tn := 0","\tfor i, v := range ar.Bools {","\t\tif v == true {","\t\t\tres.Ints[n] = i + a.Origin","\t\t\tn++","\t\t}","\t}","\treturn res, nil","}","","// Intervalindex, L is a vector and R an array.","// L must be sorted.","func intervalindex(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tif _, ok := L.(apl.EmptyArray); ok {","\t\treturn apl.EmptyArray{}, nil","\t}","","\t// Test if values of L are increasing.","\tgradeup := grade(true)","\tgr, err := gradeup(a, nil, L)","\tif err != nil {","\t\treturn nil, err","\t}","\tia, ok := gr.(apl.IntArray)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"intervalindex: cannot grade left argument\")","\t}","\tfor i := range ia.Ints {","\t\tif ia.Ints[i] != i+a.Origin {","\t\t\treturn nil, fmt.Errorf(\"intervalindex: values of left argument must be increasing\")","\t\t}","\t}","","\tar := R.(apl.Array)","\trs := ar.Shape()","\trn := 1","\tif len(rs) \u003e 1 {","\t\trn = apl.Prod(rs[1:])","\t}","","\tal := L.(apl.Array)","\tls := al.Shape()","\tn := ls[0]","","\tfless := arith2(\"\u003c\", compare(\"\u003c\"))","","\tres := apl.IntArray{","\t\tDims: []int{rs[0]},","\t\tInts: make([]int, rs[0]),","\t}","\tfor i := 0; i \u003c rs[0]; i++ {","\t\tr := ar.At(i * rn)","\t\tfor k := 0; k \u003c n; k++ {","\t\t\tok, err := fless(a, r, al.At(k))","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tif bool(ok.(apl.Bool)) == true {","\t\t\t\tres.Ints[i] = k - 1 + a.Origin","\t\t\t\tbreak","\t\t\t}","\t\t\tif k == n-1 {","\t\t\t\tres.Ints[i] = n - 1 + a.Origin","\t\t\t}","\t\t}","\t}","\treturn res, nil","}","","// IsEqual compares if the values are equal.","// If they are numbers of different type, they are converted before comparison.","func isEqual(a *apl.Apl, x, y apl.Value) bool {","\t// TODO: should we use CT (comparison tolerance)?","\tif x == y {","\t\treturn true","\t}","","\tto := ToNumber(nil)","\txn, isxnum := to.To(a, x)","\tyn, isynum := to.To(a, y)","\tif isxnum == false || isynum == false {","\t\treturn false","\t}","\tif xn, yn, err := a.Tower.SameType(xn.(apl.Number), yn.(apl.Number)); err == nil {","\t\tif eq, ok := xn.(equaler); ok {","\t\t\tif iseq, ok := eq.Equals(yn); ok {","\t\t\t\treturn bool(iseq)","\t\t\t}","\t\t} else {","\t\t\treturn xn == yn","\t\t}","\t}","\treturn false","}",""],"iv.go":["package cmd","","import (","\t\"io\"","","\t\"github.com/ktye/iv/apl\"",")","","func Iv(a *apl.Apl, p string, w io.Writer) error {","\ta.SetOutput(w)","\tif err := a.ParseAndEval(`r←{\u003c⍤⍵ io→r 0}⋄s←{⍵⍴\u003c⍤0 io→r 0}`); err != nil {","\t\treturn err","\t}","\treturn a.ParseAndEval(p)","}",""],"jot.go":["package operators","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(operator{","\t\tsymbol:  \"∘\",","\t\tDomain:  DyadicOp(Split(nil, nil)),","\t\tdoc:     \"compose\",","\t\tderived: compose,","\t})","}","","func compose(a *apl.Apl, f, g apl.Value) apl.Function {","\tderived := func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\tfn, isfunc := f.(apl.Function)","\t\tgn, isgunc := g.(apl.Function)","\t\tif L == nil {","\t\t\tif isfunc \u0026\u0026 isgunc {","\t\t\t\t// Form 1: f∘g R","\t\t\t\tv, err := gn.Call(a, nil, R)","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\treturn fn.Call(a, nil, v.Copy())","\t\t\t} else if isgunc {","\t\t\t\t// Form II: A∘g R","\t\t\t\treturn gn.Call(a, f, R)","\t\t\t} else if isfunc {","\t\t\t\t// Form III: (f∘X) R","\t\t\t\treturn fn.Call(a, R, g)","\t\t\t}","\t\t} else {","\t\t\tif isfunc \u0026\u0026 isgunc {","\t\t\t\t// Form IV: L f∘g R","\t\t\t\tv, err := gn.Call(a, nil, R)","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\treturn fn.Call(a, L, v.Copy())","\t\t\t}","\t\t}","\t\treturn nil, fmt.Errorf(\"compose: cannot handle %T %T ∘ %T %T\", L, f, g, R)","\t}","\treturn function(derived)","}",""],"lambda.go":["package apl","","import (","\t\"fmt\"","\t\"strings\"",")","","// Env is the environment of the current lambda function.","// It contains local variables and a pointer to the parent environment.","type env struct {","\tparent *env","\tvars   map[string]Value","}","","// lambda is a function expression in braces {...}.","// It is also known under the term dynamic function or dfn.","type lambda struct {","\tbody guardList","}","","func (λ *lambda) String(f Format) string {","\tif λ.body == nil {","\t\treturn \"{}\"","\t}","\treturn fmt.Sprintf(\"{%s}\", λ.body.String(f))","}","func (λ *lambda) Copy() Value { return λ }","","func (λ *lambda) Eval(a *Apl) (Value, error) {","\treturn λ, nil","}","","func (λ *lambda) Call(a *Apl, l, r Value) (Value, error) {","\tif λ.body == nil {","\t\treturn EmptyArray{}, nil","\t}","","\te := env{","\t\tvars:   make(map[string]Value),","\t\tparent: a.env,","\t}","\tsave := a.env","\ta.env = \u0026e","\tdefer func() { a.env = save }()","","\te.vars[\"∇\"] = λ","tail:","\te.vars[\"⍺\"] = l","\te.vars[\"⍵\"] = r","","\tif v, err := λ.body.Eval(a); err != nil {","\t\treturn nil, err","\t} else if t, ok := v.(*tail); ok {","\t\tr, err = t.right.Eval(a)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tif t.left != nil {","\t\t\tl, err = t.left.Eval(a)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t}","\t\tgoto tail","\t} else {","\t\treturn v, nil","\t}","}","","// guardList is the body of a lambda expression.","// It represents a list of guarded expressions.","type guardList []*guardExpr","","func (l guardList) String(f Format) string {","\tv := make([]string, len(l))","\tfor i, g := range l {","\t\tv[i] = g.String(f)","\t}","\treturn strings.Join(v, \"⋄\")","}","","// Eval evaluates the guardList.","// It checks the condition of each guardExpr.","// Expressions are only evaluated, if the condition returns true or","// is nil.","// The function returns after the first evaluated expression, if it is","// not an assignment.","//","// TODO: Extensions to dfns:","//\t- in a guarded expr, continue if there is an assignment","//\t- in a nonguarded expr, always continue","func (l guardList) Eval(a *Apl) (Value, error) {","\tif len(l) == 0 {","\t\treturn EmptyArray{}, nil","\t}","\tvar ret Value = EmptyArray{}","\tfor i, g := range l {","\t\tisa := isAssignment(g.e)","\t\tif g.cond == nil \u0026\u0026 i \u003c len(l)-1 \u0026\u0026 isa == false {","\t\t\treturn nil, fmt.Errorf(\"λ contains non-reachable code\")","\t\t}","","\t\tif f, ok := g.e.(Function); ok \u0026\u0026 isa == false {","\t\t\tif fn, ok := f.(*function); ok {","\t\t\t\tif _, ok := fn.Function.(self); ok {","\t\t\t\t\treturn \u0026tail{fn.left, fn.right}, nil","\t\t\t\t}","\t\t\t}","\t\t}","","\t\tif v, err := g.Eval(a); err != nil {","\t\t\treturn nil, err","\t\t} else if v != nil {","\t\t\tret = v","\t\t\tif isa == false {","\t\t\t\treturn ret, nil","\t\t\t}","\t\t}","\t}","\treturn ret, nil","}","","// guardExpr contains a guarded expression.","// It's expressions is evaluated if the condition returns true or is nil.","type guardExpr struct {","\tcond expr","\te    expr","}","","func (g *guardExpr) String(f Format) string {","\tif g.cond == nil {","\t\treturn g.e.String(f)","\t} else {","\t\treturn g.cond.String(f) + \":\" + g.e.String(f)","\t}","}","","// Eval evaluates a guarded expression.","// If the condition exists, it is evaluated and must return a bool or a","// number convertable to boolean.","// If the condition is nil or returns true, the expression is evaluated,","// otherwise nil is returned and no error.","func (g *guardExpr) Eval(a *Apl) (Value, error) {","\tif g.cond == nil {","\t\treturn g.e.Eval(a)","\t}","","\tv, err := g.cond.Eval(a)","\tif err != nil {","\t\treturn nil, err","\t}","\tb, isbool := v.(Bool)","\tif isbool == false {","\t\tif n, ok := v.(Number); ok {","\t\t\tif nb, ok := a.Tower.ToBool(n); ok {","\t\t\t\tb = nb","\t\t\t\tisbool = true","\t\t\t}","\t\t}","\t}","\tif isbool == false {","\t\treturn nil, fmt.Errorf(\"λ condition does not return a bool: %s\", b.String(a.Format))","\t}","","\tif b == false {","\t\treturn nil, nil","\t} else {","\t\treturn g.e.Eval(a)","\t}","}","","// Self is both an expression and a Value self-pointing to a lambda function.","type self struct{}","","func (s self) String(f Format) string {","\treturn \"∇\"","}","func (s self) Copy() Value { return s }","","func (s self) Eval(a *Apl) (Value, error) {","\treturn s, nil","}","","func (s self) Call(a *Apl, L, R Value) (Value, error) {","\tif a.env.parent == nil {","\t\treturn nil, fmt.Errorf(\"cannot call ∇ outside lambda\")","\t}","\tv, ok := a.env.vars[\"∇\"]","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"∇ has not been registered\") // should not happen","\t}","\tλ, ok := v.(*lambda)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"∇ is not a lambda\") // should not happen","\t}","\treturn λ.Call(a, L, R)","}","","// Tail contains the left and right expression for a tail call.","type tail struct {","\tleft, right expr","}","","func (t tail) String(f Format) string {","\treturn fmt.Sprintf(\"tail{%s %s}\", t.left.String(f), t.right.String(f))","}","func (t tail) Copy() Value { return t }",""],"list.go":["package apl","","import (","\t\"fmt\"","\t\"strings\"",")","","// List is a collection of items, possibly nested.","// It also acts as a vector (a rank 1 array) but cannot be reshaped.","type List []Value","","func (l List) String(f Format) string {","\tif f.PP == -2 {","\t\treturn l.jsonString(f)","\t}","\tvar buf strings.Builder","\tbuf.WriteRune('(')","\tfor i := range l {","\t\tbuf.WriteString(l[i].String(f))","\t\tbuf.WriteRune(';')","\t}","\tbuf.WriteRune(')')","\treturn buf.String()","}","func (l List) Copy() Value {","\tr := make(List, len(l))","\tfor i := range l {","\t\tr[i] = l[i].Copy()","\t}","\treturn r","}","","func (l List) At(i int) Value {","\treturn l[i]","}","","func (l List) Shape() []int {","\treturn []int{len(l)}","}","","func (l List) Size() int {","\treturn len(l)","}","","func (l List) GetDeep(idx []int) (Value, error) {","\treturn l.getset(idx, nil)","}","","func (l List) SetDeep(idx []int, v Value) error {","\t_, err := l.getset(idx, v.Copy())","\treturn err","}","","func (l List) Depth() int {","\tmax := 1","\tfor _, e := range l {","\t\tif el, ok := e.(List); ok {","\t\t\tif d := el.Depth(); 1+d \u003e max {","\t\t\t\tmax = 1 + d","\t\t\t}","\t\t}","\t}","\treturn max","}","","func (l List) getset(idx []int, v Value) (Value, error) {","\tif len(idx) == 0 {","\t\treturn nil, fmt.Errorf(\"empty index\")","\t}","\tfor i, k := range idx {","\t\tif k \u003c 0 || k \u003e= len(l) {","\t\t\treturn nil, fmt.Errorf(\"index out of range\")","\t\t}","\t\tif i == len(idx)-1 {","\t\t\tif v != nil {","\t\t\t\tl[k] = v","\t\t\t\treturn nil, nil","\t\t\t} else {","\t\t\t\treturn l[k], nil","\t\t\t}","\t\t}","\t\tif lst, ok := l[k].(List); ok == false {","\t\t\treturn nil, fmt.Errorf(\"index is too deep\")","\t\t} else {","\t\t\tl = lst","\t\t}","\t}","\treturn nil, fmt.Errorf(\"not reached\")","}","","// jsonString formats the list as a json object.","func (l List) jsonString(f Format) string {","\tvar b strings.Builder","\tb.WriteRune('[')","\tfor i, v := range l {","\t\tif i \u003e 0 {","\t\t\tb.WriteRune(',')","\t\t}","\t\tb.WriteString(v.String(f))","\t}","\tb.WriteRune(']')","\treturn b.String()","}","","type list []expr","","func (l list) Eval(a *Apl) (Value, error) {","\tlst := make(List, len(l))","\tvar err error","\tfor i := range lst {","\t\tif l[i] == nil {","\t\t\tlst[i] = EmptyArray{}","\t\t\tcontinue","\t\t}","\t\tlst[i], err = l[i].Eval(a)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t}","\treturn lst, nil","}","","func (l list) String(f Format) string {","\tvar buf strings.Builder","\tbuf.WriteRune('(')","\tfor i := range l {","\t\tbuf.WriteString(l[i].String(f))","\t\tbuf.WriteRune(';')","\t}","\tbuf.WriteRune(')')","\treturn buf.String()","}",""],"log.go":["package bigfloat","","import (","\t\"math\"","\t\"math/big\"",")","","// Log returns a big.Float representation of the natural logarithm of","// z. Precision is the same as the one of the argument. The function","// panics if z is negative, returns -Inf when z = 0, and +Inf when z =","// +Inf","func Log(z *big.Float) *big.Float {","","\t// panic on negative z","\tif z.Sign() == -1 {","\t\tpanic(\"Log: argument is negative\")","\t}","","\t// Log(0) = -Inf","\tif z.Sign() == 0 {","\t\treturn big.NewFloat(math.Inf(-1)).SetPrec(z.Prec())","\t}","","\tprec := z.Prec() + 64 // guard digits","","\tone := big.NewFloat(1).SetPrec(prec)","\ttwo := big.NewFloat(2).SetPrec(prec)","\tfour := big.NewFloat(4).SetPrec(prec)","","\t// Log(1) = 0","\tif z.Cmp(one) == 0 {","\t\treturn big.NewFloat(0).SetPrec(z.Prec())","\t}","","\t// Log(+Inf) = +Inf","\tif z.IsInf() {","\t\treturn big.NewFloat(math.Inf(+1)).SetPrec(z.Prec())","\t}","","\tx := new(big.Float).SetPrec(prec)","","\t// if 0 \u003c z \u003c 1 we compute log(z) as -log(1/z)","\tvar neg bool","\tif z.Cmp(one) \u003c 0 {","\t\tx.Quo(one, z)","\t\tneg = true","\t} else {","\t\tx.Set(z)","\t}","","\t// We scale up x until x \u003e= 2**(prec/2), and then we'll be allowed","\t// to use the AGM formula for Log(x).","\t//","\t// Double x until the condition is met, and keep track of the","\t// number of doubling we did (needed to scale back later).","","\tlim := new(big.Float)","\tlim.SetMantExp(two, int(prec/2))","","\tk := 0","\tfor x.Cmp(lim) \u003c 0 {","\t\tx.Mul(x, x)","\t\tk++","\t}","","\t// Compute the natural log of x using the fact that","\t//     log(x) = π / (2 * AGM(1, 4/x))","\t// if","\t//     x \u003e= 2**(prec/2),","\t// where prec is the desired precision (in bits)","\tpi := pi(prec)","\tagm := agm(one, x.Quo(four, x)) // agm = AGM(1, 4/x)","","\tx.Quo(pi, x.Mul(two, agm)) // reuse x, we don't need it","","\tif neg {","\t\tx.Neg(x)","\t}","","\t// scale the result back multiplying by 2**-k","\t// reuse lim to reduce allocations.","\tx.Mul(x, lim.SetMantExp(one, -k))","","\treturn x.SetPrec(z.Prec())","}",""],"main.go":["// APL stream processor.","//","// Usage","//\tcat data | iv COMMANDS","package main","","import (","\t\"fmt\"","\t\"io\"","\t\"os\"","\t\"strings\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/numbers\"","\t\"github.com/ktye/iv/apl/operators\"","\t\"github.com/ktye/iv/apl/primitives\"","\t\"github.com/ktye/iv/cmd\"",")","","var stdin io.ReadCloser = os.Stdin","","func main() {","\tif len(os.Args) \u003c 2 {","\t\tfatal(fmt.Errorf(\"arguments expected\"))","\t}","\ta := newApl(stdin)","\tfatal(cmd.Iv(a, strings.Join(os.Args[1:], \" \"), os.Stdout))","}","","func newApl(r io.ReadCloser) *apl.Apl {","\tstdin = r","\ta := apl.New(nil)","\tnumbers.Register(a)","\tprimitives.Register(a)","\toperators.Register(a)","","\t// Add a minimal io package that's sole purpose is to allow","\t// to read from stdin.","\tpkg := map[string]apl.Value{","\t\t\"r\": apl.ToFunction(readfd),","\t}","\ta.RegisterPackage(\"io\", pkg)","\treturn a","}","","func fatal(err error) {","\tif err != nil {","\t\tfmt.Fprintln(os.Stderr, err)","\t\tos.Exit(1)","\t}","}","","func readfd(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tfd, ok := R.(apl.Int)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"iv/io read: argument must be 0 (stdin)\")","\t}","\tif fd != 0 {","\t\treturn nil, fmt.Errorf(\"monadic \u003c: right argument must be 0 (stdin)\")","\t}","\treturn apl.LineReader(stdin), nil","}",""],"match.go":["package primitives","","import (","\t\"reflect\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"≡\",","\t\tdoc:    \"depth, level of nesting\",","\t\tDomain: Monadic(nil),","\t\tfn:     depth,","\t})","\tregister(primitive{","\t\tsymbol: \"≢\",","\t\tdoc:    \"tally, number of major cells\",","\t\tDomain: Monadic(nil),","\t\tfn:     tally,","\t})","","\tregister(primitive{","\t\tsymbol: \"≡\",","\t\tdoc:    \"match\",","\t\tDomain: Dyadic(nil),","\t\tfn:     match,","\t})","\tregister(primitive{","\t\tsymbol: \"≢\",","\t\tdoc:    \"not match\",","\t\tDomain: Dyadic(nil),","\t\tfn:     notmatch,","\t})","}","","// depth reports the level of nesting.","// Nested arrays are not supported, so depth is always 1 for arrays and 0 for scalars.","func depth(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tif l, ok := R.(apl.List); ok {","\t\treturn apl.Int(l.Depth()), nil","\t}","\tif _, ok := R.(apl.Array); ok {","\t\treturn apl.Int(1), nil","\t}","\treturn apl.Int(0), nil","}","","// tally returns the number of major cells of R.","// It is equlivalent to {⍬⍴(⍴⍵),1}.","func tally(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tif t, ok := R.(apl.Table); ok {","\t\treturn apl.Int(t.Rows), nil","\t}","\tif o, ok := R.(apl.Object); ok {","\t\treturn apl.Int(len(o.Keys())), nil","\t}","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\treturn apl.Int(1), nil","\t}","\tshape := ar.Shape()","\tif len(shape) == 0 {","\t\treturn apl.Int(0), nil","\t}","\treturn apl.Int(shape[0]), nil","}","","func match(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tal, isal := L.(apl.Array)","\tar, isar := R.(apl.Array)","\tif isal != isar {","\t\treturn apl.Bool(false), nil","\t}","\tif isal == false {","\t\t// Compare scalars, convert numbers to the same type.","\t\treturn apl.Bool(isEqual(a, L, R)), nil","\t} else {","\t\tsl := al.Shape()","\t\tsr := ar.Shape()","\t\tif len(sr) != len(sl) {","\t\t\treturn apl.Bool(false), nil","\t\t} else if len(sr) == 0 {","\t\t\t// Empty arrays must have the same type.","\t\t\tif reflect.TypeOf(ar) == reflect.TypeOf(al) {","\t\t\t\treturn apl.Bool(true), nil","\t\t\t} else {","\t\t\t\treturn apl.Bool(false), nil","\t\t\t}","\t\t}","\t\tfor i := range sl {","\t\t\tif sl[i] != sr[i] {","\t\t\t\treturn apl.Bool(false), nil","\t\t\t}","\t\t}","\t\tfeq := arith2(\"=\", compare(\"=\"))","\t\tfor i := 0; i \u003c ar.Size(); i++ {","\t\t\tif iseq, err := feq(a, ar.At(i), al.At(i)); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else if iseq.(apl.Bool) == false {","\t\t\t\treturn apl.Bool(false), nil","\t\t\t}","\t\t}","\t\treturn apl.Bool(true), nil","\t}","}","","func notmatch(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tif eq, err := match(a, L, R); err != nil {","\t\treturn nil, err","\t} else {","\t\treturn !(eq.(apl.Bool)), nil","\t}","}",""],"method.go":["package xgo","","/* TODO remove","import (","\t\"fmt\"","\t\"reflect\"","","\t\"github.com/ktye/iv/apl\"",")","","type Method struct {","\tValue  reflect.Value","\tMethod string","}","","func (m Method) String(a *apl.Apl) {","\tfmt.Srintf(\"%v→%s\", m.Value.Type(), m.Method)","}","","func (m Method) Call(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tvar zero reflect.Value","\tif m.Value == zero {","\t\treturn nil, fmt.Errorf(\"method has no value\")","\t}","\tfn := reflect.ValueOf(m.Value).MethodByName(m.Method)","\tif fn == zero {","\t\treturn nil, fmt.Errorf(\"method %s does not exist\", m.Method)","\t}","\tfn := Function{Name: m.Method, Fn: fn}","\treturn fn.Call(a, L, R)","}","*/",""],"misc.go":["package bigfloat","","import \"math/big\"","","// agm returns the arithmetic-geometric mean of a and b.","// a and b must have the same precision.","func agm(a, b *big.Float) *big.Float {","","\tif a.Prec() != b.Prec() {","\t\tpanic(\"agm: different precisions\")","\t}","","\tprec := a.Prec()","","\t// do not overwrite a and b","\ta2 := new(big.Float).Copy(a).SetPrec(prec + 64)","\tb2 := new(big.Float).Copy(b).SetPrec(prec + 64)","","\tif a2.Cmp(b2) == -1 {","\t\ta2, b2 = b2, a2","\t}","\t// a2 \u003e= b2","","\t// set lim to 2**(-prec)","\tlim := new(big.Float)","\tlim.SetMantExp(big.NewFloat(1).SetPrec(prec+64), -int(prec+1))","","\thalf := big.NewFloat(0.5)","\tt := new(big.Float)","","\tfor t.Sub(a2, b2).Cmp(lim) != -1 {","\t\tt.Copy(a2)","\t\ta2.Add(a2, b2).Mul(a2, half)","\t\tb2 = Sqrt(b2.Mul(b2, t))","\t}","","\treturn a2.SetPrec(prec)","}","","var piCache *big.Float","var piCachePrec uint","var enablePiCache bool = true","","func init() {","\tif !enablePiCache {","\t\treturn","\t}","","\tpiCache, _, _ = new(big.Float).SetPrec(1024).Parse(\"3.\"+","\t\t\"14159265358979323846264338327950288419716939937510\"+","\t\t\"58209749445923078164062862089986280348253421170679\"+","\t\t\"82148086513282306647093844609550582231725359408128\"+","\t\t\"48111745028410270193852110555964462294895493038196\"+","\t\t\"44288109756659334461284756482337867831652712019091\"+","\t\t\"45648566923460348610454326648213393607260249141273\"+","\t\t\"72458700660631558817488152092096282925409171536444\", 10)","","\tpiCachePrec = 1024","}","","// pi returns pi to prec bits of precision","func pi(prec uint) *big.Float {","","\tif prec \u003c= piCachePrec \u0026\u0026 enablePiCache {","\t\treturn new(big.Float).Copy(piCache).SetPrec(prec)","\t}","","\t// Following R. P. Brent, Multiple-precision zero-finding","\t// methods and the complexity of elementary function evaluation,","\t// in Analytic Computational Complexity, Academic Press,","\t// New York, 1975, Section 8.","","\thalf := big.NewFloat(0.5)","\ttwo := big.NewFloat(2).SetPrec(prec + 64)","","\t// initialization","\ta := big.NewFloat(1).SetPrec(prec + 64)    // a = 1","\tb := new(big.Float).Mul(Sqrt(two), half)   // b = 1/√2","\tt := big.NewFloat(0.25).SetPrec(prec + 64) // t = 1/4","\tx := big.NewFloat(1).SetPrec(prec + 64)    // x = 1","","\t// limit is 2**(-prec)","\tlim := new(big.Float)","\tlim.SetMantExp(big.NewFloat(1).SetPrec(prec+64), -int(prec+1))","","\t// temp variables","\ty := new(big.Float)","\tfor y.Sub(a, b).Cmp(lim) != -1 { // assume a \u003e b","\t\ty.Copy(a)","\t\ta.Add(a, b).Mul(a, half) // a = (a+b)/2","\t\tb = Sqrt(b.Mul(b, y))    // b = √(ab)","","\t\ty.Sub(a, y)           // y = a - y","\t\ty.Mul(y, y).Mul(y, x) // y = x(a-y)²","\t\tt.Sub(t, y)           // t = t - x(a-y)²","\t\tx.Mul(x, two)         // x = 2x","\t}","","\ta.Mul(a, a).Quo(a, t) // π = a² / t","\ta.SetPrec(prec)","","\tif enablePiCache {","\t\tpiCache.Copy(a)","\t\tpiCachePrec = prec","\t}","","\treturn a","}","","// returns an approximate (to precision dPrec) solution to","//    f(t) = 0","// using the Newton Method.","// fOverDf needs to be a fuction returning f(t)/f'(t).","// t must not be changed by fOverDf.","// guess is the initial guess (and it's not preserved).","func newton(fOverDf func(z *big.Float) *big.Float, guess *big.Float, dPrec uint) *big.Float {","","\tprec, guard := guess.Prec(), uint(64)","\tguess.SetPrec(prec + guard)","","\tfor prec \u003c 2*dPrec {","\t\tguess.Sub(guess, fOverDf(guess))","\t\tprec *= 2","\t\tguess.SetPrec(prec + guard)","\t}","","\treturn guess.SetPrec(dPrec)","}",""],"mount.go":["package io","","import (","\t\"fmt\"","\t\"os\"","\t\"path/filepath\"","\t\"strings\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/scan\"",")","","// Mount mounts the filesystem indicated by R to the mount point L.","// If L is nil, it returns the mtab as a dictionary.","//","// R may contain a protocol suffix, such as zip:// that is matched against","// known file systems.","// If no protocol can be matched, R is considered to be an os path.","//","// The special file \".\" can be used, which is always the current working directory.","func mount(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tif L == nil {","\t\tmtab.Lock()","\t\tdefer mtab.Unlock()","","\t\td := apl.Dict{}","\t\tfor _, t := range mtab.tab {","\t\t\tname := apl.String(t.mpt)","\t\t\td.K = append(d.K, name)","\t\t\tif d.M == nil {","\t\t\t\td.M = make(map[apl.Value]apl.Value)","\t\t\t}","\t\t\td.M[name] = apl.String(t.src.String())","\t\t}","\t\treturn \u0026d, nil","\t}","\tvar mpt, src string","\tif s, ok := L.(apl.String); ok == false {","\t\treturn nil, fmt.Errorf(\"io mount: left argument must be a string %T\", L)","\t} else {","\t\tmpt = string(s)","\t}","\tif s, ok := R.(apl.String); ok == false {","\t\treturn nil, fmt.Errorf(\"io mount: right argument must be a string %T\", R)","\t} else {","\t\tsrc = string(s)","\t}","","\t// Test if the filesystem matches a registerd protocol.","\tfor name, f := range protocols {","\t\tpre := name + \"://\"","\t\tif strings.HasPrefix(src, pre) {","\t\t\tfsys, err := f.FileSystem(strings.TrimPrefix(src, pre))","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tif err := Mount(mpt, fsys); err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\treturn apl.EmptyArray{}, nil","\t\t}","\t}","","\t// Special case, \".\" remains always relative.","\tif src == \".\" {","\t\tif err := Mount(mpt, fs(\".\")); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn apl.EmptyArray{}, nil","\t}","","\t// Mount a directory.","\tfi, err := os.Stat(src)","\tif err != nil {","\t\treturn nil, err","\t}","\tif fi.IsDir() == false {","\t\treturn nil, fmt.Errorf(\"io mount: src is not a directory: %s\", src)","\t}","\tabs, err := filepath.Abs(src)","\tif err != nil {","\t\treturn nil, err","\t}","\tif err := Mount(mpt, fs(abs)); err != nil {","\t\treturn nil, err","\t}","\treturn apl.EmptyArray{}, nil","}","","// Umount removes the mount point R.","func umount(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\ts, ok := R.(apl.String)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"io umount: argument must be a string %T\", R)","\t}","\tUmount(string(s))","\treturn apl.EmptyArray{}, nil","}","","// cd changes the working directory.","// If R is empty, it returns the current directory.","func cd(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\ts, ok := R.(apl.String)","\tif ok == false {","\t\tdir, err := os.Getwd()","\t\tif err != nil {","\t\t\treturn nil, err","\t\t} else {","\t\t\treturn apl.String(dir), nil","\t\t}","\t}","\tif err := os.Chdir(string(s)); err != nil {","\t\treturn nil, err","\t}","\treturn apl.EmptyArray{}, nil","}","","func mCmd(t []scan.Token) []scan.Token {","\tif len(t) == 0 {","\t\t// List mtab.","\t\treturn []scan.Token{","\t\t\tscan.Token{T: scan.Identifier, S: \"io→mount\"},","\t\t\tscan.Token{T: scan.Number, S: \"0\"},","\t\t}","\t}","\tif len(t) \u003c 2 {","\t\treturn t // one argument is an error.","\t}","","\t// Replace . / of the next two tokens to strings.","\tfor i := 0; i \u003c 2; i++ {","\t\tif t[i].T == scan.Symbol \u0026\u0026 (t[i].S == \"/\" || t[i].S == \".\") {","\t\t\tt[i].T = scan.String","\t\t}","\t}","\ttokens := []scan.Token{t[1], scan.Token{T: scan.Identifier, S: \"io→mount\"}, t[0]}","\treturn append(tokens, t[2:]...)","}","","func cdCmd(t []scan.Token) []scan.Token {","\tcdt := scan.Token{T: scan.Identifier, S: \"io→cd\"}","\tif len(t) == 0 {","\t\treturn []scan.Token{cdt, scan.Token{T: scan.Number, S: \"0\"}}","\t}","\treturn append([]scan.Token{cdt}, t...)","}","","type toCommand func([]scan.Token) []scan.Token","","func (f toCommand) Rewrite(t []scan.Token) []scan.Token {","\treturn f(t)","}",""],"multiline.go":["package apl","","import (","\t\"fmt\"","\t\"strings\"","","\t\"github.com/ktye/iv/apl/scan\"",")","","// ParseLines parses multiple lines separated by newline, that may contain continuation lines.","// Continuation lines are only allowed for lambda functions.","func (a *Apl) ParseLines(lines string) (Program, error) {","\tb := NewLineBuffer(a)","\tv := strings.Split(lines, \"\\n\")","\tfor i, s := range v {","\t\tif ok, err := b.Add(s); err != nil {","\t\t\treturn nil, err","\t\t} else if i == len(v)-1 {","\t\t\tif ok == false {","\t\t\t\treturn nil, fmt.Errorf(\"unbalanced {\")","\t\t\t}","\t\t\treturn b.Parse()","\t\t}","\t}","\treturn nil, nil","}","","// LineBuffer buffers multiline statements for lambda functions.","type LineBuffer struct {","\ta      *Apl","\ttokens []scan.Token","\tlevel  int","}","","func NewLineBuffer(a *Apl) *LineBuffer {","\treturn \u0026LineBuffer{a: a}","}","","// Add a line to the buffer.","// The function returns ok, if the line is complete and can be parsed.","func (b *LineBuffer) Add(line string) (bool, error) {","\tif b.a == nil {","\t\treturn false, fmt.Errorf(\"linebuffer is not initialized (no APL)\")","\t}","\ttokens, err := b.a.Scan(line)","\tif err != nil {","\t\tb.reset()","\t\treturn false, err","\t}","\tif len(tokens) == 0 {","\t\treturn false, nil","\t}","","\t// Join with diamonds. Ommit the diamond if the last token is LeftBrace","\t// or the next token is a RightBrace.","\tdiamond := true","\tif len(b.tokens) == 0 {","\t\tdiamond = false","\t} else if b.tokens[len(b.tokens)-1].T == scan.LeftBrace {","\t\tdiamond = false","\t}","\tif len(tokens) \u003e 0 \u0026\u0026 diamond == true {","\t\tb.tokens = append(b.tokens, scan.Token{T: scan.Diamond, S: \"⋄\"})","\t}","\tb.tokens = append(b.tokens, tokens...)","","\tfor _, t := range tokens {","\t\tif t.T == scan.LeftBrace {","\t\t\tb.level++","\t\t} else if t.T == scan.RightBrace {","\t\t\tb.level--","\t\t\tif b.level \u003c 0 {","\t\t\t\tb.reset()","\t\t\t\treturn false, fmt.Errorf(\"too many }\")","\t\t\t}","\t\t}","\t}","\tif b.level == 0 {","\t\treturn true, nil","\t}","\treturn false, nil","}","","// Parse parses the tokens in the buffer.","// Lines must be pushed to the buffer with Add and Parse should only be called if Add returned true.","func (b *LineBuffer) Parse() (Program, error) {","\tdefer b.reset()","\treturn b.a.parse(b.tokens)","}","","func (b *LineBuffer) Len() int {","\treturn len(b.tokens)","}","","func (b *LineBuffer) reset() {","\tb.level = 0","\tif len(b.tokens) \u003e 0 {","\t\tb.tokens = b.tokens[:0]","\t}","}",""],"numeric.go":["package domain","","import \"github.com/ktye/iv/apl\"","","// ToNumber accepts scalars and single size arrays.","// and converts them to scalars if they contain one of the types:","// apl.Bool, apl.Int, apl.Float or apl.Complex.","func ToNumber(child SingleDomain) SingleDomain {","\treturn number{child, true}","}","","// IsNumber accepts scalars if they contain of of the types:","// apl.Bool, apl.Int, apl.Float or apl.Complex","func IsNumber(child SingleDomain) SingleDomain {","\treturn number{child, false}","}","","type number struct {","\tchild   SingleDomain","\tconvert bool","}","","func (n number) To(a *apl.Apl, V apl.Value) (apl.Value, bool) {","\tif _, ok := V.(apl.Number); ok {","\t\treturn propagate(a, V, n.child)","\t}","\tif n.convert == false {","\t\treturn V, false","\t}","\tif ar, ok := V.(apl.Array); ok {","\t\tif n.convert == false {","\t\t\treturn V, false","\t\t}","\t\tif n := ar.Size(); n != 1 {","\t\t\treturn V, false","\t\t}","\t\tv := ar.At(0)","\t\tif _, ok := v.(apl.Number); ok {","\t\t\treturn propagate(a, v, n.child)","\t\t}","\t}","\treturn V, false","}","func (n number) String(f apl.Format) string {","\tname := \"number\"","\tif n.convert {","\t\tname = \"tonumber\"","\t}","\tif n.child == nil {","\t\treturn name","\t}","\treturn name + \" \" + n.child.String(f)","}","","// ToIndex converts the scalar to an Index.","func ToIndex(child SingleDomain) SingleDomain {","\treturn index{child}","}","","type index struct {","\tchild SingleDomain","}","","func (idx index) To(a *apl.Apl, V apl.Value) (apl.Value, bool) {","\tif b, ok := V.(apl.Bool); ok {","\t\tif b == true {","\t\t\treturn apl.Int(1), true","\t\t}","\t\treturn apl.Int(0), true","\t}","\tif n, ok := V.(apl.Int); ok {","\t\treturn n, true","\t}","\tif n, ok := V.(apl.Number); ok == false {","\t\treturn V, false","\t} else {","\t\tif i, ok := n.ToIndex(); ok == false {","\t\t\treturn V, false","\t\t} else {","\t\t\treturn propagate(a, apl.Int(i), idx.child)","\t\t}","\t}","}","func (idx index) String(f apl.Format) string {","\tif idx.child == nil {","\t\treturn \"index\"","\t} else {","\t\treturn \"index \" + idx.child.String(f)","\t}","}",""],"object.go":["package apl","","import (","\t\"fmt\"","\t\"strings\"","\t\"text/tabwriter\"",")","","// Object is a compound type that has keys and values.","//","// Values are accessed by indexing with keys.","//\tObject[Key]","// Keys are usually strings, but dont have to be.","// To set a key, use indexed assignment:","//\tObject[Name]←X","// This also works for vectors","//\tObject[`k1`k2`k3] ← 5 6 7","//","// Keys are returned by #Object.","// Number of keys can also be obtained by ⍴Object.","//","// Indexing by vector returns a Dict with the specified keys.","//\tObject[\"key1\" \"key2\"].","//","// Method calls (calling a function stored in a key) or a go method","// for an xgo object cannot be applied directly:","//\tObject[`f] R  ⍝ cannot be parsed","// Instead, assign it to a function variable, or commute:","//\tf←Object[`f] ⋄ f R","//      Object[`f]⍨R","type Object interface {","\tValue","\tKeys() []Value","\tAt(Value) Value","\tSet(Value, Value) error","}","","// Dict is a dictionary object.","// A Dict is created with the L#R, where","// L is a key or a vector of keys and R conforming values.","// Dicts can be indexed with their keys.","// Example:","//\tD←`alpha#1 2 3   ⍝ Single key","//\tD←`a`b`c#1 2 3   ⍝ 3 Keys","//\tD[`a]            ⍝ returns value 1","//\tD[`a`c]          ⍝ returns a dict with 2 keys","type Dict struct {","\tK []Value","\tM map[Value]Value","}","","func (d *Dict) Keys() []Value {","\treturn d.K","}","","func (d *Dict) At(key Value) Value {","\tif d.M == nil {","\t\treturn nil","\t}","\treturn d.M[key]","}","","// Set updates the value for the given key, or creates a new one,","// if the key does not exist.","// Keys must be valid variable names.","func (d *Dict) Set(key Value, v Value) error {","\tif d.M == nil {","\t\td.M = make(map[Value]Value)","\t}","\tif _, ok := d.M[key]; ok == false {","\t\td.K = append(d.K, key.Copy())","\t}","\td.M[key.Copy()] = v.Copy()","\treturn nil","}","","func (d *Dict) String(f Format) string {","\tif f.PP == -2 {","\t\treturn d.jsonString(f)","\t} else if f.PP == -3 {","\t\treturn d.matString(f)","\t}","\tvar buf strings.Builder","\ttw := tabwriter.NewWriter(\u0026buf, 1, 0, 1, ' ', 0)","\tfor _, k := range d.K {","\t\tfmt.Fprintf(tw, \"%s:\\t%s\\n\", k.String(f), d.M[k].String(f))","\t}","\ttw.Flush()","\ts := buf.String()","\tif len(s) \u003e 0 \u0026\u0026 s[len(s)-1] == '\\n' {","\t\treturn s[:len(s)-1]","\t}","\treturn s","}","","func (d *Dict) Copy() Value {","\tr := Dict{}","\tif d.K != nil {","\t\tr.K = make([]Value, len(d.K))","\t\tfor i := range d.K {","\t\t\tr.K[i] = d.K[i].Copy()","\t\t}","\t}","\tif d.M != nil {","\t\tr.M = make(map[Value]Value)","\t\tfor k, v := range d.M {","\t\t\tr.M[k.Copy()] = v.Copy()","\t\t}","\t}","\treturn \u0026r","}","","func (d *Dict) jsonString(f Format) string {","\tvar b strings.Builder","\tb.WriteRune('{')","\tkeys := d.Keys()","\tfor i, key := range keys {","\t\tif i \u003e 0 {","\t\t\tb.WriteRune(',')","\t\t}","\t\tk := key.String(f)","\t\tval := d.At(key)","\t\tv := val.String(f)","\t\tb.WriteString(k)","\t\tb.WriteRune(':')","\t\tb.WriteString(v)","\t}","\tb.WriteRune('}')","\treturn b.String()","}","","func (d *Dict) matString(f Format) string {","\tvar b strings.Builder","\tb.WriteString(\"struct(\")","\tkeys := d.Keys()","\tfor i, key := range keys {","\t\tif i \u003e 0 {","\t\t\tb.WriteRune(',')","\t\t}","\t\tk := key.String(f)","\t\tval := d.At(key)","\t\tv := val.String(f)","\t\tb.WriteString(k)","\t\tb.WriteRune(',')","\t\tb.WriteString(v)","\t}","\tb.WriteRune(')')","\treturn b.String()","}","","func (a *Apl) ParseDict(prototype Value, s string) (*Dict, error) {","\tif prototype != nil {","\t\t_, ok := prototype.(*Dict)","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"ParseDict: prototype is not a dict: %T\", prototype)","\t\t}","\t}","\treturn nil, fmt.Errorf(\"TODO ParseDict\")","}",""],"op.go":["package apl","","import \"fmt\"","","// Operators take functions or arrays as operands and produce derived functions.","// An operator can be monadic or dyadic but is never ambivalent.","// Their derived functions are.","//","// Operators have long scope on the left and short scope on the right.","//","// Example","//\t/ is a monadic operator","//\t+/ is a derived function (summation), which is monadic: +/1 2 3 4","//\t2+/ is a derived function (n-wise summation), which is dyadic: 2 +/ 1 2 3 4","//","// Derived receives the left and possibly right operands to the operator","// and returns a derived function.","// It is called only, if Domain.To returns true.","//","// If multiple operator handlers are registerd for a symbol (operator overloading), they","// all must have the same arity.","// The first operator registered determines the arity that all others have to follow.","type Operator interface {","\tDomain","\tDyadicOp() bool","\tDerived(*Apl, Value, Value) Function","\tSelect(*Apl, Value, Value, Value, Value) (IntArray, error)","\tDoc() string","}","","// derived is a function which is derived from an operator and one or two arguments,","// which may be functions or arrays","type derived struct {","\top string","\t// operands of the derived expression","\tlo  expr                                       // left operand","\tro  expr                                       // right operand","\tsel func(*Apl, Value, Value) (IntArray, error) // selection function for reduce and scan","}","","func (d *derived) Eval(a *Apl) (Value, error) {","\treturn d, nil","}","","func (d *derived) String(f Format) string {","\tleft := \"\"","\tright := \"\"","\tif d.lo == nil \u0026\u0026 d.ro == nil {","\t\treturn d.op","\t}","\tif d.lo != nil {","\t\tleft = d.lo.String(f) + \" \"","\t}","\tif d.ro != nil {","\t\tright = \" \" + d.ro.String(f)","\t}","\treturn \"(\" + left + d.op + right + \")\"","}","func (d *derived) Copy() Value { return d }","","// Call tries to call a derived function.","// l and r are the left and right values to the derived function.","// The left and right operands are stored at d.lo and d.ro.","// The call tries all registered handlers for the given operator in reverse","// registration order until a handler accepts to build a derived function, which","// is then called with l and r.","func (d *derived) Call(a *Apl, l, r Value) (Value, error) {","\tops, ok := a.operators[d.op]","\tif ok == false || len(ops) == 0 || ops[0] == nil {","\t\treturn nil, fmt.Errorf(\"operator %s does not exist\", d.op)","\t}","","\t// Evaluate the operands.","\tvar ro, lo Value","\tvar err error","\tif ops[0].DyadicOp() { // All registerd operators have the same arity.","\t\tro, err = d.ro.Eval(a)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t}","","\t// Assignment is special: It does not evaluate the Identifier.","\tif d.op == \"←\" {","\t\t// Modified assignment contains the expr with the identifier in the left argument,","\t\t// otherwise it is the LO.","\t\tif l == nil {","\t\t\tlo, err = evalAssign(a, d.lo, nil)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t} else {","\t\t\tas, ok := l.(assignment)","\t\t\tif ok == false {","\t\t\t\treturn nil, fmt.Errorf(\"modified assignment: expected assignment target expr on the left: %T\", l)","\t\t\t}","\t\t\tvar f Function","\t\t\tif d.lo != nil {","\t\t\t\tif pf, ok := d.lo.(Function); ok {","\t\t\t\t\tf = pf","\t\t\t\t} else {","\t\t\t\t\treturn nil, fmt.Errorf(\"modifier is not a function: %T\", d.lo)","\t\t\t\t}","\t\t\t}","\t\t\tlo, err = evalAssign(a, as, f)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tl = nil","\t\t}","\t} else {","\t\tlo, err = d.lo.Eval(a)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t}","","\tfor _, op := range ops {","\t\tif LO, RO, ok := op.To(a, lo, ro); ok {","\t\t\treturn op.Derived(a, LO, RO).Call(a, l, r)","\t\t}","\t}","\treturn nil, fmt.Errorf(\"cannot handle operator %T %s %T\", lo, d.op, ro)","}","","func (d *derived) Select(a *Apl, L, R Value) (Value, error) {","\tops, ok := a.operators[d.op]","\tif ok == false || len(ops) == 0 || ops[0] == nil {","\t\treturn nil, fmt.Errorf(\"operator %s does not exist\", d.op)","\t}","","\tif ops[0].DyadicOp() \u0026\u0026 d.op != \"⍂\" {","\t\t// Scan and reduce are monadic, indexing can be used.","\t\treturn nil, fmt.Errorf(\"dyadic operators cannot be used in selective assignments\")","\t}","","\tvar RO, LO Value","\tvar err error","\tLO, err = d.lo.Eval(a)","\tif err != nil {","\t\treturn nil, err","\t}","\tif ops[0].DyadicOp() { // All registerd operators have the same arity.","\t\tRO, err = d.ro.Eval(a)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t}","","\tfor _, op := range ops {","\t\tif LO, RO, ok := op.To(a, LO, RO); ok {","\t\t\treturn op.Select(a, L, LO, RO, R)","\t\t}","\t}","\treturn nil, fmt.Errorf(\"cannot select with operator %T %T %s %T %T\", L, LO, d.op, RO, R)","}",""],"operator.go":["package domain","","import \"github.com/ktye/iv/apl\"","","// MonadicOp is used to define a monadic operator.","func MonadicOp(l SingleDomain) apl.Domain {","\treturn monop{l}","}","","type monop struct {","\tleft SingleDomain","}","","func (m monop) To(a *apl.Apl, L, R apl.Value) (apl.Value, apl.Value, bool) {","\tif m.left == nil {","\t\treturn L, R, true","\t}","\tif v, ok := m.left.To(a, L); ok {","\t\treturn v, R, true","\t}","\treturn L, R, false","}","func (m monop) DyadicOp() bool { return false }","func (m monop) String(f apl.Format) string {","\tif m.left == nil {","\t\treturn \"LO any\"","\t}","\treturn \"LO \" + m.left.String(f)","}","","// DyadicOp is used to define a dyadic operator.","func DyadicOp(child apl.Domain) apl.Domain {","\treturn dyop{child}","}","","type dyop struct {","\tchild apl.Domain","}","","func (d dyop) To(a *apl.Apl, L, R apl.Value) (apl.Value, apl.Value, bool) {","\tif L == nil {","\t\treturn L, R, false","\t}","\tif d.child == nil {","\t\treturn L, R, true","\t}","\treturn d.child.To(a, L, R)","}","func (d dyop) DyadicOp() bool { return true }","func (d dyop) String(f apl.Format) string {","\tif d.child == nil {","\t\treturn \"any\"","\t}","\treturn d.child.String(f)","}",""],"parse.go":["package apl","","import (","\t\"fmt\"","\t\"io\"","\t\"strings\"","","\t\"github.com/ktye/iv/apl/scan\"",")","","type parser struct {","\ta      *Apl","\ttokens []scan.Token","\tstack  []item","\tpos    int","}","","const (","\tnoun        class = 1 \u003c\u003c iota // array expression    (A)","\tverb                          // function expression (f)","\tadverb                        // monadic operator    (/)","\tconjunction                   // dyadic operator     (.)",")","","// Item is an element of the parse stack.","// It contains a expr with an associated class.","type item struct {","\te     expr","\tclass class","}","type class int","","func (c class) String() string {","\ts := \"Af/.\"","\tfor i := range s {","\t\tif c\u0026class(1\u003c\u003cuint(i)) != 0 {","\t\t\treturn string(s[i])","\t\t}","\t}","\treturn \"?\"","}","","// Parse parses the tokens to a program, which is a slice of expressions.","func (p *parser) parse(tokens []scan.Token) (Program, error) {","","\tvar prog Program","\tvar itm item","\tvar err error","\tfor {","\t\ttokens, err = p.nextStatement(tokens)","\t\tif err == io.EOF {","\t\t\tbreak","\t\t} else if err != nil {","\t\t\treturn nil, err","\t\t}","\t\titm, err = p.parseStatement()","\t\tif err == io.EOF {","\t\t\tbreak","\t\t} else if err != nil {","\t\t\treturn nil, err","\t\t}","\t\tprog = append(prog, itm.e)","\t}","\tif len(prog) == 0 {","\t\treturn nil, fmt.Errorf(\"empty program\")","\t}","\treturn prog, nil","}","","// nextStatement extracts the next statements from tokens and sets it to the parser.","// It returns the remaining tokens.","// Statements are separated by diamond tokens.","// Diamonds within lambda expressions are skipped.","func (p *parser) nextStatement(tokens []scan.Token) ([]scan.Token, error) {","\tif len(tokens) == 0 {","\t\treturn nil, io.EOF","\t}","\tb := 0","\tfor i, t := range tokens {","\t\tif t.T == scan.LeftBrace {","\t\t\tb++","\t\t} else if t.T == scan.RightBrace {","\t\t\tb--","\t\t\tif b \u003c 0 {","\t\t\t\treturn nil, fmt.Errorf(\"too many }\")","\t\t\t}","\t\t}","\t\tif b == 0 \u0026\u0026 t.T == scan.Diamond {","\t\t\tp.tokens = tokens[:i]","\t\t\treturn tokens[i+1:], nil","\t\t}","\t}","\tp.tokens = tokens","\treturn nil, nil","}","","// Statement parses a statement, that is a complete sentence from right to left","// and returns a single expression in tree form.","//","// It pulls the next token from the right side and converts it to a stack item.","// The item is pushed to the stack and a stack reduction step is executed.","// At the end a single item must be left on the stack, an is returned.","//","// (), [], {} with their child tokens are extracted and parsed separately.","// Their result is pushed on the stack.","//","// Only items with class A, f, / or . are passed to the stack.","//","// This is similar to the parser described in Iverson, A dictionary of APL 1987, sec I.","// With one difference:","// Instead of evaluating during reduction, the reduction assembles an expression","// and returns it's root node.","func (p *parser) parseStatement() (item, error) {","\t// The stack stores items in reverse order. Pushing appends to the end.","\tp.stack = make([]item, 0, 20)","","\tvar parseError error","\tpush := func(i item, last bool) {","\t\tp.stack = append(p.stack, i)","\t\tparseError = p.reduce(last)","\t}","","\tfor {","\t\tif parseError != nil {","\t\t\treturn item{}, parseError","\t\t}","","\t\tt := p.pull()","\t\tswitch t.T {","\t\tcase scan.Endl:","\t\t\tif len(p.stack) == 0 {","\t\t\t\treturn item{}, nil // TODO: Should this return an error?","\t\t\t}","\t\t\tif err := p.reduce(true); err != nil {","\t\t\t\treturn item{}, err","\t\t\t}","\t\t\tp.linkFuncAssign()","\t\t\treturn p.stack[0], nil","","\t\t// A symbol may be a primitive function, a dyadic or a monadic operator.","\t\tcase scan.Symbol:","","\t\t\tif _, ok := p.a.primitives[Primitive(t.S)]; ok {","\t\t\t\tpush(item{e: Primitive(t.S), class: verb}, false)","\t\t\t} else if ops, ok := p.a.operators[t.S]; ok {","\t\t\t\ti := item{e: \u0026derived{op: t.S}, class: adverb}","\t\t\t\tif ops[0].DyadicOp() == true {","\t\t\t\t\ti.class = conjunction","\t\t\t\t}","\t\t\t\tif t.S == \"∘\" {","\t\t\t\t\ti = p.specialJot(i)","\t\t\t\t}","\t\t\t\tpush(i, false)","\t\t\t} else {","\t\t\t\treturn item{}, fmt.Errorf(\"unknown symbol: %s\", t.S)","\t\t\t}","","\t\tcase scan.Number, scan.String, scan.Chars:","\t\t\te, err := p.collectArray(t)","\t\t\tif err != nil {","\t\t\t\treturn item{}, err","\t\t\t}","\t\t\tpush(item{e: e, class: noun}, false)","","\t\tcase scan.Identifier:","\t\t\ti := item{class: verb}","\t\t\tif ok, fok := isVarname(t.S); ok == false {","\t\t\t\treturn item{}, fmt.Errorf(\"illegal variable name: %s\", t.S)","\t\t\t} else if fok == false {","\t\t\t\te, err := p.collectArray(t)","\t\t\t\tif err != nil {","\t\t\t\t\treturn item{}, err","\t\t\t\t}","\t\t\t\ti.e = e","\t\t\t\ti.class = noun","\t\t\t} else {","\t\t\t\ti.e = fnVar(t.S)","\t\t\t}","\t\t\tpush(i, false)","","\t\tcase scan.Self:","\t\t\tpush(item{e: self{}, class: verb}, false)","","\t\tcase scan.LeftParen, scan.LeftBrack, scan.LeftBrace:","\t\t\treturn item{}, fmt.Errorf(\"unexpected opening %s\", t.S)","","\t\tcase scan.RightParen, scan.RightBrack, scan.RightBrace:","\t\t\ti, err := p.subStatement(t.T)","\t\t\tif err != nil {","\t\t\t\treturn item{}, fmt.Errorf(\"%s\", err)","\t\t\t}","\t\t\tpush(i, false)","","\t\tcase scan.Colon:","\t\t\treturn item{}, fmt.Errorf(\"unexpected : outside {}\")","","\t\tcase scan.Semicolon:","\t\t\treturn item{}, fmt.Errorf(\"unexpected ; outside []\")","","\t\tdefault:","\t\t\treturn item{}, fmt.Errorf(\"unknown token %s\", t.S)","\t\t}","\t}","\treturn item{}, fmt.Errorf(\"illegal parser state\") // Should not be reached.","}","","// pull returns the last from the parsers tokens and removes it from the buffer.","// If there is no token, the empty token with type scan.Endl is returned.","func (p *parser) pull() scan.Token {","\tif len(p.tokens) == 0 {","\t\treturn scan.Token{}","\t}","\tt := p.tokens[len(p.tokens)-1]","\tp.tokens = p.tokens[:len(p.tokens)-1]","\treturn t","}","","// subStatement parses a parenthesized substatement.","// Parens may be (), [] or {}.","func (p *parser) subStatement(right scan.Type) (item, error) {","","\tleft := map[scan.Type]scan.Type{","\t\tscan.RightBrace: scan.LeftBrace,","\t\tscan.RightParen: scan.LeftParen,","\t\tscan.RightBrack: scan.LeftBrack,","\t}[right]","","\t// Pull until matching left paren. The right paren is not present anymore.","\tvar tokens []scan.Token","\tl := 1","\tfor {","\t\tt := p.pull()","\t\ttokens = append(tokens, t)","\t\tswitch t.T {","\t\tcase scan.Endl:","\t\t\treturn item{}, fmt.Errorf(\"unmatched %s\", left.String())","\t\tcase right:","\t\t\tl++","\t\tcase left:","\t\t\tl--","\t\t\tif l == 0 {","\t\t\t\ttokens = tokens[:len(tokens)-1]","\t\t\t\tgoto rev","\t\t\t}","\t\t}","\t}","rev:","\tif len(tokens) == 0 {","\t\tif left == scan.LeftBrace {","\t\t\treturn item{e: \u0026lambda{}, class: verb}, nil","\t\t} else if left == scan.LeftBrack {","\t\t\t// Empty brackets are allowed in: A[]←9","\t\t\treturn item{e: idxSpec(nil), class: adverb}, nil","\t\t}","\t\treturn item{}, fmt.Errorf(\"empty: %s%s\", left.String(), right.String())","\t}","","\t// Reverse tokens.","\tfor i := 0; i \u003c len(tokens)/2; i++ {","\t\tk := len(tokens) - i - 1","\t\ttokens[i], tokens[k] = tokens[k], tokens[i]","\t}","","\t// Create a new parser for the substatement and return it's result.","\tq := \u0026parser{a: p.a, tokens: tokens}","","\tswitch left {","\tcase scan.LeftParen:","\t\tif tokens[len(tokens)-1].T == scan.Semicolon {","\t\t\treturn q.parseList()","\t\t}","\t\treturn q.parseStatement()","\tcase scan.LeftBrack:","\t\treturn q.parseBrackets()","\tcase scan.LeftBrace:","\t\treturn q.parseLambda()","\tdefault:","\t\treturn item{}, fmt.Errorf(\"unknown paranthesis type %T\", left) // This should not happen.","\t}","}","","// parseList parses a list expression, that always evaluates as a noun.","func (p *parser) parseList() (item, error) {","\tl := p.splitTokens(scan.Semicolon, []scan.Type{scan.LeftParen}, []scan.Type{scan.RightParen})","\tif len(l) \u003e 0 {","\t\t// Remove empty tail caused by trailing semicolon","\t\tl = l[:len(l)-1]","\t}","\tlst := make(list, len(l))","\tfor i := range l {","\t\tq := \u0026parser{a: p.a, tokens: l[i]}","\t\tit, err := q.parseStatement()","\t\tif err != nil {","\t\t\treturn item{}, err","\t\t}","\t\tlst[i] = it.e","\t}","\treturn item{e: lst, class: noun}, nil","}","","// ParseBrackets parses the expression within brackets [...].","// This may be an index or axis specification.","func (p *parser) parseBrackets() (item, error) {","\t//l := p.splitTokens(scan.Semicolon, scan.LeftBrack, scan.RightBrack)","\t// Allow lists in index specifications. If nested brackets are needed, splitTokens mut be modified","\t// to use multiple nesting tokens.","\tl := p.splitTokens(scan.Semicolon, []scan.Type{scan.LeftParen, scan.LeftBrack}, []scan.Type{scan.RightParen, scan.RightBrack})","\tspec := make(idxSpec, len(l))","\tfor i := range l {","\t\tq := \u0026parser{a: p.a, tokens: l[i]}","\t\tit, err := q.parseStatement()","\t\tif err != nil {","\t\t\treturn item{}, err","\t\t}","\t\tspec[i] = it.e","\t\tif spec[i] == nil {","\t\t\tspec[i] = EmptyArray{}","\t\t}","\t}","\t// A bracket parses as an adverb, that will be corrected in p.reduce.","\treturn item{e: spec, class: adverb}, nil","}","","// ParseLambda parses the lambda expression given in the parser's token list.","// A lambda expression contains a list of guarded expressions:","//\t{ guardList }","// The outer braces are not present anymore in the parsers's tokens.","// Lambdas are calles dfns in dyalog: DyaProg p. 131","func (p *parser) parseLambda() (item, error) {","\t// Entries of the guardList are separated by diamonds.","\tl := p.splitTokens(scan.Diamond, []scan.Type{scan.LeftBrace}, []scan.Type{scan.RightBrace})","\tbody := make(guardList, len(l))","\tfor i := range l {","\t\tq := \u0026parser{a: p.a, tokens: l[i]}","\t\tge, ternary, err := q.guardExpr()","\t\tif err != nil {","\t\t\treturn item{}, err","\t\t}","\t\tbody[i] = ge","\t\tif ternary != nil \u0026\u0026 i != len(l)-1 {","\t\t\treturn item{}, fmt.Errorf(\"lambda: ternary is only allowed as the last item\")","\t\t} else if ternary != nil {","\t\t\tbody = append(body, \u0026guardExpr{e: ternary})","\t\t}","\t}","\t// Remove an empty last entry, that happens if a diamond is inserted before }.","\tif len(body) \u003e 0 {","\t\tlast := body[len(body)-1]","\t\tif last.cond == nil \u0026\u0026 last.e == nil {","\t\t\tbody = body[:len(body)-1]","\t\t}","\t}","\treturn item{e: \u0026lambda{body}, class: verb}, nil","}","","// GuardExpr parses a guarded expression, which is part of a lambda expression.","//\tcond:expr","//\tcond:expr:expr2 (short ternary form, only for the last in the list).","func (p *parser) guardExpr() (*guardExpr, expr, error) {","\tl := p.splitTokens(scan.Colon, []scan.Type{scan.LeftBrace}, []scan.Type{scan.RightBrace})","\tif len(l) \u003e 3 {","\t\treturn nil, nil, fmt.Errorf(\"lambda has too many colons\")","\t}","\tge := \u0026guardExpr{}","\tfor i := range l {","\t\tq := \u0026parser{a: p.a, tokens: l[i]}","\t\titem, err := q.parseStatement()","\t\tif err != nil {","\t\t\treturn nil, nil, err","\t\t}","","\t\tif i == 0 \u0026\u0026 len(l) \u003e 1 {","\t\t\tge.cond = item.e","\t\t} else if i == 0 || i == 1 {","\t\t\tge.e = item.e","\t\t} else if i == 2 {","\t\t\treturn ge, item.e, nil","\t\t}","\t}","\treturn ge, nil, nil","}","","// collectArray pulls tokens from the parser that form an array starting with the given right end token.","//","// TODO: this is not correct: Vector binding is not stronger than right operand binding","// APL2 p 36: LO DOP A B ←→ (LO DOP A) B not LO DOP (A B)","// Check if the token left to the first number is a DOP.","func (p *parser) collectArray(right scan.Token) (expr, error) {","\t// Push back the right token.","\tp.tokens = append(p.tokens, right)","","\t// The array is collected in reverse order.","\tvar ar array","loop:","\tfor {","\t\tif len(p.tokens) == 0 {","\t\t\tbreak","\t\t}","\t\tt := p.tokens[len(p.tokens)-1]","\t\tswitch t.T {","\t\tcase scan.Number:","\t\t\tif n, err := p.a.Tower.Parse(t.S); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else {","\t\t\t\tar = append(ar, n)","\t\t\t}","","\t\tcase scan.String:","\t\t\tar = append(ar, String(t.S))","","\t\tcase scan.Chars:","\t\t\trunes := []rune(t.S)","\t\t\tif len(runes) \u003e 0 {","\t\t\t\tchars := make(array, len(runes))","\t\t\t\tfor i := range chars {","\t\t\t\t\tk := len(chars) - 1 - i","\t\t\t\t\tchars[i] = String(string(runes[k]))","\t\t\t\t}","\t\t\t\tif ar != nil \u0026\u0026 len(chars) \u003e 1 {","\t\t\t\t\treturn nil, fmt.Errorf(\"only scalars can be added to an array\")","\t\t\t\t}","\t\t\t\tar = append(ar, chars...)","\t\t\t}","","\t\tcase scan.Identifier:","\t\t\tif ok, fok := isVarname(t.S); ok == false || fok == true {","\t\t\t\tbreak loop","\t\t\t}","\t\t\tar = append(ar, numVar{t.S})","","\t\tdefault:","\t\t\tbreak loop","\t\t}","\t\tp.pull() // Remove the token that has just been processed.","\t}","","\tif ar == nil {","\t\treturn EmptyArray{}, nil","\t}","","\t// Reverse the array to the normal left to right order.","\tfor i := 0; i \u003c len(ar)/2; i++ {","\t\tn := len(ar) - i - 1","\t\tar[i], ar[n] = ar[n], ar[i]","\t}","","\t// If there is only 1 item, return it unboxed.","\tif len(ar) == 1 {","\t\treturn ar[0], nil","\t}","\treturn ar, nil","}","","// Reduce tries to reduce the partial right tail of the stack.","func (p *parser) reduce(last bool) error {","\t// in := p.shortStack()","\t// defer func() { fmt.Printf(\"reduce: %s → %s\\n\", in, p.shortStack()) }()","","\tif _, ok := p.leftItem(0).e.(idxSpec); ok {","\t\treturn nil","\t}","\tif err := p.resolveBrackets(); err != nil {","\t\treturn err","\t}","\tp.resolveOperators(last)","\tp.resolveArrays(last)","\tp.resolveFunctions(last)","","\tif last \u0026\u0026 len(p.stack) \u003e 1 {","\t\treturn fmt.Errorf(\"cannot reduce expression\")","\t}","\treturn nil","}","","// ResolveBrackets changes the order of bracket expressions.","// Brackets are parsed as idxSpec following an Identifier or as","// an axis specification following a primitive or an operator.","// IdxSpec is converted to a dyadic indexing function.","// An axis specification is converted to a dyadic operator.","func (p *parser) resolveBrackets() error {","\tif len(p.stack) \u003c 2 {","\t\treturn nil","\t}","\tif spec, ok := p.leftItem(1).e.(idxSpec); ok {","\t\tl := p.leftItem(0)","\t\tif id, ok := l.e.(numVar); ok \u0026\u0026 l.class == noun {","\t\t\tfn := \u0026function{","\t\t\t\tFunction: Primitive(\"⌷\"),","\t\t\t\tleft:     spec,","\t\t\t\tright:    id,","\t\t\t}","\t\t\tp.setLeft(1, item{e: fn, class: noun})","\t\t\tp.removeLeft(0)","\t\t\treturn nil","\t\t} else if _, ok := l.e.(Primitive); ok {","\t\t\tif len(spec) != 1 {","\t\t\t\treturn fmt.Errorf(\"axis must hold a single expression, not %d\", len(spec))","\t\t\t}","\t\t\td := derived{","\t\t\t\tlo: l.e,","\t\t\t\tro: spec[0],","\t\t\t\top: \"⍂\",","\t\t\t}","\t\t\tp.setLeft(1, item{e: \u0026d, class: verb})","\t\t\tp.removeLeft(0)","\t\t} else if _, ok := l.e.(*derived); ok {","\t\t\t// The axis specification following an operator is rewritten as a dyadic operator.","\t\t\t// The operator is called \"⍂\" and as the left operand the axis spec is inserted.","\t\t\tif len(spec) != 1 {","\t\t\t\treturn fmt.Errorf(\"axis must hold a single expression, not %d\", len(spec))","\t\t\t}","\t\t\td := derived{","\t\t\t\top: \"⍂\",","\t\t\t}","\t\t\tp.setLeft(1, item{e: \u0026d, class: conjunction})","\t\t\tp.insertLeft(1, item{e: spec[0], class: noun})","\t\t} else if l.class == noun {","\t\t\t// Axis specification follows an array or a noun expression.","\t\t\tfn := \u0026function{","\t\t\t\tFunction: Primitive(\"⌷\"),","\t\t\t\tleft:     spec,","\t\t\t\tright:    l.e,","\t\t\t}","\t\t\tp.setLeft(1, item{e: fn, class: noun})","\t\t\tp.removeLeft(0)","\t\t\treturn nil","\t\t} else {","\t\t\treturn fmt.Errorf(\"bracket expr following an %T %v\\n\", l.e, l.class)","\t\t}","\t}","\treturn nil","}","","// ResolveOperators tries to convert operators into derived functions.","//","// Operator reduction is done from the left side of the stack.","// If last==true, test if the second token is an operator:","//\t:/+\tmop(0+) reduction","//\t:.?+\tdop(0) reduction","// In any case, test if the third token is an operator.","//\t::/+\tmop(1+) reduction","//\t::.?+\tdop(1) reduction","// ?  an item of any class","// +  zero or more items of any class","// :  an item that is f or A (not an operator)","//","// The result is always of class f: a derived function.","// Repeat until no reduction can be done.","//","// Operators have long scope on the left and short scope on the right:","// \t+.+.+.+.*  ←→ ((((+.+).+).+).*)  ←≠→  (+.(+.(+.(+.*))))","// See DyaProg p 21.","func (p *parser) resolveOperators(last bool) {","\tfor {","\t\tok1, ok2, ok3, ok4 := false, false, false, false","\t\tif last {","\t\t\tok1 = p.mopReduce(0)","\t\t}","\t\tok2 = p.mopReduce(1)","\t\tif last {","\t\t\tok3 = p.dopReduce(0)","\t\t}","\t\tok4 = p.dopReduce(1)","\t\tif ok1 || ok2 || ok3 || ok4 {","\t\t\tcontinue","\t\t}","\t\treturn","\t}","}","","// mopReduction reduces a monadic operator on position i+1 from the left, i must be 0 or 1.","// If there was a reduction it continues with i+1.","// It returns true, if there was at least one reduction.","func (p *parser) mopReduce(i int) bool {","\t//  :/+\t\tmop(0) reduction","\t//  ::/+\tmop(1) reduction","\treduced := false","\tfor {","\t\top := adverb | conjunction","\t\tif len(p.stack) \u003c 2+i || p.leftItem(i+1).class != adverb {","\t\t\treturn reduced","\t\t}","\t\tc0, c1 := p.leftItem(0).class, p.leftItem(1).class","\t\tif (c0\u0026op != 0) || ((i == 1) \u0026\u0026 (c1\u0026op != 0)) {","\t\t\treturn reduced","\t\t}","\t\td := p.leftItem(i + 1).e.(*derived)","\t\tif d.lo != nil {","\t\t\tfmt.Println(\"dopReduce: overwriting LO\")","\t\t}","\t\td.lo = p.leftItem(i).e","\t\tp.setLeft(i, item{e: d, class: verb})","\t\tp.removeLeft(i + 1)","\t\treduced = true","\t\ti++","\t}","}","","// dopReduction reduces a dyadic operator on position i+1 from the left,","// i must be 0 or 1.","// It returns true, if there was a reduction.","func (p *parser) dopReduce(i int) bool {","\t//  :.?+\tdop(0) reduction","\t//  ::.?+\tdop(1) reduction","\top := adverb | conjunction","\tif len(p.stack) \u003c 3+i || p.leftItem(i+1).class != conjunction {","\t\treturn false","\t}","\tc0, c1 := p.leftItem(0).class, p.leftItem(1).class","\tif (c0\u0026op != 0) || ((i == 1) \u0026\u0026 (c1\u0026op != 0)) {","\t\treturn false","\t}","\td := p.leftItem(i + 1).e.(*derived)","\tif d.lo != nil {","\t\tfmt.Println(\"dopReduce: overwriting LO\")","\t}","\tif d.ro != nil {","\t\tfmt.Println(\"dopReduce overwriting RO\")","\t}","\td.lo = p.leftItem(i).e","\td.ro = p.leftItem(i + 2).e","\tp.setLeft(i, item{e: d, class: verb})","\tp.removeLeft(i + 1)","\tp.removeLeft(i + 1)","","\treturn true","}","","// ResolveArray resolves arrays from the right end.","//","// Arrays are reduced from the right end of the stack.","// The pattern at the right side is always reduced to class A.","// If last==true:\treduction on the tail (result is always A)","//\tfA\t\tfA","//\tAfA    \t\tAfA","// In any case:","//\t+ffA\t\tfA","//\t+/fA\t\tfA","//\t+fAfA\t\tAfA","//\t+!AAfA\t\tAfA","// +: zero or more items of any type","// !: item of type A, f or / (everything but a DOP).","//","// The reduction is repeated until no pattern is found.","func (p *parser) resolveArrays(last bool) {","\tfor {","\t\tfok := p.reducefA(last)","\t\taok := p.reduceAfA(last)","\t\tif fok == false \u0026\u0026 aok == false {","\t\t\treturn","\t\t}","\t}","}","","func (p *parser) reducefA(last bool) bool {","\t// fA","\t// +ffA","\t// +/fA","\tif len(p.stack) \u003c 2 {","\t\treturn false","\t}","\tr := p.rightItem(0)","\tf := p.rightItem(1)","\tx := conjunction","\tif len(p.stack) \u003e 2 {","\t\tx = p.rightItem(2).class","\t}","\tif last \u0026\u0026 len(p.stack) == 2 {","\t\tx = verb","\t}","\top := verb | adverb","\tif r.class == noun \u0026\u0026 f.class == verb \u0026\u0026 (x\u0026op != 0) {","\t\tfn := \u0026function{","\t\t\tFunction: f.e.(Function),","\t\t\tright:    r.e,","\t\t}","\t\tp.setRight(1, item{e: fn, class: noun})","\t\tp.removeRight(0)","\t\treturn true","\t}","\treturn false","}","","func (p *parser) reduceAfA(last bool) bool {","\t// AfA","\t// +fAfA","\t// +!AAfA","\tif len(p.stack) \u003c 3 {","\t\treturn false","\t}","\tl := p.rightItem(2)","\tf := p.rightItem(1)","\tr := p.rightItem(0)","","\tx := conjunction","\ty := noun","\tif len(p.stack) \u003e 4 {","\t\tx = p.rightItem(4).class","\t\ty = p.rightItem(3).class","\t} else if last == false {","\t\treturn false","\t}","\treduce := func() {","\t\tfn := \u0026function{","\t\t\tFunction: f.e.(Function),","\t\t\tleft:     l.e,","\t\t\tright:    r.e,","\t\t}","\t\tp.setRight(2, item{e: fn, class: noun})","\t\tp.removeRight(0)","\t\tp.removeRight(0)","\t}","","\tif !(l.class == noun \u0026\u0026 f.class == verb \u0026\u0026 r.class == noun) {","\t\treturn false","\t}","\tif last == true \u0026\u0026 len(p.stack) \u003e 2 {","\t\treduce()","\t\treturn true","\t}","\tif y == verb || (y == noun \u0026\u0026 x != conjunction) {","\t\treduce()","\t\treturn true","\t}","\treturn false","}","","// ResolveFunction resolves functions from the right end.","//","// Functions are reduced from the right end of the stack.","// Two functions on the right are combined to function trains,","// if they match this patterns:","// \t+!ff","// The reduction is called train reduction.","// It is repeated until the pattern is not found again.","// On the last call, also","//\tAf","// is reduced to a train, if f is already a train with an even length.","// This builds an Agh fork. It needs parenthesis.","func (p *parser) resolveFunctions(last bool) {","\tfor {","\t\tif p.reduceff(last) == false {","\t\t\tbreak","\t\t}","\t}","\t// Reduce Agh fork.","\tif last \u0026\u0026 len(p.stack) == 2 {","\t\tr0 := p.rightItem(0)","\t\tr1 := p.rightItem(1)","\t\tif t, ok := r0.e.(train); ok \u0026\u0026 r1.class == noun \u0026\u0026 len(t)%2 == 0 {","\t\t\tt = append(train{r1.e}, t...)","\t\t\tp.setRight(1, item{e: t, class: verb})","\t\t\tp.removeRight(0)","\t\t}","\t}","}","","func (p *parser) reduceff(last bool) bool {","\tif len(p.stack) \u003c 2 {","\t\treturn false","\t}","\t// +!ff","\tr0 := p.rightItem(0)","\tr1 := p.rightItem(1)","\tc := conjunction","\tif len(p.stack) \u003e 2 {","\t\tc = p.rightItem(2).class","\t}","\tif (r0.class == verb \u0026\u0026 r1.class == verb) \u0026\u0026 ((len(p.stack) == 2 \u0026\u0026 last) || c != conjunction) {","\t\tif t, ok := r0.e.(train); ok {","\t\t\tt = append(train{r1.e}, t...)","\t\t\tp.setRight(1, item{e: t, class: verb})","\t\t} else {","\t\t\tt = train{r1.e, r0.e}","\t\t\tp.setRight(1, item{e: t, class: verb})","\t\t}","\t\tp.removeRight(0)","\t\treturn true","\t}","\treturn false","}","","// SpecialJot converts the item from a dyadic operator to a primitive function,","// if it follows a dot.","// This special case is applied for ∘ only, which is registered as a DOP,","// but used in: ∘.×","func (p *parser) specialJot(i item) item {","\tif len(p.stack) \u003c 1 {","\t\treturn i","\t}","\tdot := p.stack[len(p.stack)-1].e","\tif d, ok := dot.(*derived); ok \u0026\u0026 d.op == \".\" {","\t\ti = item{e: Primitive(\"∘\"), class: verb}","\t}","","\treturn i","}","","// RemoveLeft removes item i from the left side of the stack.","func (p *parser) removeLeft(l int) {","\ti := len(p.stack) - 1 - l","\tcopy(p.stack[i:], p.stack[i+1:])","\tp.stack = p.stack[:len(p.stack)-1]","}","","// SetLeft overwrites the item at position i from left with the new item.","func (p *parser) setLeft(l int, i item) {","\tp.stack[len(p.stack)-1-l] = i","}","","// InsertLeft inserts an item at position i from the left.","func (p *parser) insertLeft(l int, e item) {","\ti := len(p.stack) - l - 1","\tp.stack = append(p.stack, item{})","\tcopy(p.stack[i+1:], p.stack[i:])","\tp.stack[i] = e","}","","// LeftItem returns the item number i from the left end, starting at 0.","func (p *parser) leftItem(i int) item {","\t// tokens: a b c","\t// stack: c b a","\treturn p.stack[len(p.stack)-1-i]","}","","// RightItem returns the item number i from the right end, starting at 0.","func (p *parser) rightItem(i int) item {","\treturn p.stack[i]","}","","// RemoveRight removes item i from the right side of the stack.","func (p *parser) removeRight(i int) {","\tcopy(p.stack[i:], p.stack[i+1:])","\tp.stack = p.stack[:len(p.stack)-1]","}","","// SetRight overwrites the item at position r from right with the new item.","func (p *parser) setRight(r int, i item) {","\tp.stack[r] = i","}","","// Split Tokens splits the parses's tokens at the given separator.","// It ignores sub-expressions nested by inc and dec tokens.","func (p *parser) splitTokens(at scan.Type, inc, dec []scan.Type) [][]scan.Token {","\tany := func(t scan.Type, l []scan.Type) bool {","\t\tfor i := range l {","\t\t\tif t == l[i] {","\t\t\t\treturn true","\t\t\t}","\t\t}","\t\treturn false","\t}","\tvar l [][]scan.Token","\tlv := 0","\tn := 0","\tfor i, t := range p.tokens {","\t\tif any(t.T, inc) {","\t\t\tlv++","\t\t} else if any(t.T, dec) {","\t\t\tlv--","\t\t}","\t\tif lv == 0 \u0026\u0026 t.T == at {","\t\t\tl = append(l, p.tokens[n:i])","\t\t\tn = i + 1","\t\t}","\t}","\tl = append(l, p.tokens[n:len(p.tokens)])","\treturn l","}","","// LinkFuncAssign corrects a function assignment, that was parsed as a train.","//\tf ← +","func (p *parser) linkFuncAssign() {","\tif len(p.stack) != 1 {","\t\treturn","\t}","\t// The expression was parsed as a train of two functions:","\t// 1. a derived assignment","\t// 2: the function expression","\t// It is converted to a monadic function, of the derived assignment","\t// with the second verb as the right argument.","\tif t, ok := p.stack[0].e.(train); ok \u0026\u0026 len(t) == 2 {","\t\tif d, ok := t[0].(*derived); ok \u0026\u0026 d.op == \"←\" {","\t\t\tp.stack = []item{","\t\t\t\titem{","\t\t\t\t\te: \u0026function{","\t\t\t\t\t\tFunction: d,","\t\t\t\t\t\tright:    t[1],","\t\t\t\t\t},","\t\t\t\t\tclass: verb,","\t\t\t\t},","\t\t\t}","\t\t}","\t}","}","","func (p *parser) printStack() {","\tfor k, i := range p.stack {","\t\tfmt.Printf(\"#%d: %s %s\\n\", k, i.class.String(), i.e.String(p.a.Format))","\t}","}","","func (p *parser) shortStack() string {","\tv := make([]byte, len(p.stack))","\tk := 0","\tfor i := len(p.stack) - 1; i \u003e= 0; i-- {","\t\ts := p.stack[i].class.String()","\t\tv[k] = s[0]","\t\tk++","\t}","\treturn string(v)","}","","func (p *parser) tokenString() string {","\ts := make([]string, len(p.tokens))","\tfor i, t := range p.tokens {","\t\ts[i] = t.S","\t}","\treturn strings.Join(s, \" \")","}",""],"pow.go":["package bigfloat","","import \"math/big\"","","// Pow returns a big.Float representation of z**w. Precision is the same as the one","// of the first argument. The function panics when z is negative.","func Pow(z *big.Float, w *big.Float) *big.Float {","","\tif z.Sign() \u003c 0 {","\t\tpanic(\"Pow: negative base\")","\t}","","\t// Pow(z, 0) = 1.0","\tif w.Sign() == 0 {","\t\treturn big.NewFloat(1).SetPrec(z.Prec())","\t}","","\t// Pow(z, 1) = z","\t// Pow(+Inf, n) = +Inf","\tif w.Cmp(big.NewFloat(1)) == 0 || z.IsInf() {","\t\treturn new(big.Float).Copy(z)","\t}","","\t// Pow(z, -w) = 1 / Pow(z, w)","\tif w.Sign() \u003c 0 {","\t\tx := new(big.Float)","\t\tzExt := new(big.Float).Copy(z).SetPrec(z.Prec() + 64)","\t\twNeg := new(big.Float).Neg(w)","\t\treturn x.Quo(big.NewFloat(1), Pow(zExt, wNeg)).SetPrec(z.Prec())","\t}","","\t// w integer fast path (disabled because introduces rounding","\t// errors)","\tif false \u0026\u0026 w.IsInt() {","\t\twi, _ := w.Int64()","\t\treturn powInt(z, int(wi))","\t}","","\t// compute w**z as exp(z log(w))","\tx := new(big.Float).SetPrec(z.Prec() + 64)","\tlogZ := Log(new(big.Float).Copy(z).SetPrec(z.Prec() + 64))","\tx.Mul(w, logZ)","\tx = Exp(x)","\treturn x.SetPrec(z.Prec())","","}","","// fast path for z**w when w is an integer","func powInt(z *big.Float, w int) *big.Float {","","\t// get mantissa and exponent of z","\tmant := new(big.Float)","\texp := z.MantExp(mant)","","\t// result's exponent","\texp = exp * w","","\t// result's mantissa","\tx := big.NewFloat(1).SetPrec(z.Prec())","","\t// Classic right-to-left binary exponentiation","\tfor w \u003e 0 {","\t\tif w%2 == 1 {","\t\t\tx.Mul(x, mant)","\t\t}","\t\tw \u003e\u003e= 1","\t\tmant.Mul(mant, mant)","\t}","","\treturn new(big.Float).SetMantExp(x, exp)","}",""],"power.go":["package operators","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(operator{","\t\tsymbol:  \"⍣\",","\t\tDomain:  DyadicOp(Split(Function(nil), nil)),","\t\tdoc:     \"power\",","\t\tderived: power,","\t})","}","","// TODO: should there be a limit? How to set/change it?","const powerlimit = 1000","","func power(a *apl.Apl, f, g apl.Value) apl.Function {","\tderived := func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\tf := f.(apl.Function)","\t\tgn, isgf := g.(apl.Function)","\t\tto := ToIndex(nil)","\t\tif isgf == false {","\t\t\t// RO g is not a function but an integer.","\t\t\tnv, ok := to.To(a, g)","\t\t\tif ok == false {","\t\t\t\treturn nil, fmt.Errorf(\"power: non-function RO must be an integer: %T\", g)","\t\t\t}","\t\t\tn := int(nv.(apl.Int))","\t\t\tif n \u003c 0 {","\t\t\t\treturn nil, fmt.Errorf(\"power: function inverse is not implemented\")","\t\t\t} else if n == 0 {","\t\t\t\treturn R, nil","\t\t\t}","\t\t\tvar err error","\t\t\tv := R","\t\t\tfor i := 0; i \u003c n; i++ {","\t\t\t\tv, err = f.Call(a, L, v)","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t}","\t\t\treturn v.Copy(), nil","\t\t} else {","\t\t\t// RO g is a function.","\t\t\tvar err error","\t\t\tvar fR, v apl.Value","\t\t\tr := R","\t\t\tm := 0","\t\t\tfor {","\t\t\t\tif m \u003e powerlimit {","\t\t\t\t\treturn nil, fmt.Errorf(\"power: recusion limit exceeded\")","\t\t\t\t}","\t\t\t\tm++","\t\t\t\tfR, err = f.Call(a, L, r)","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\tv, err = gn.Call(a, fR.Copy(), r)","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\tnv, ok := to.To(a, v.Copy())","\t\t\t\tif ok == false {","\t\t\t\t\treturn nil, fmt.Errorf(\"power: gY must be an integer: %T\", v)","\t\t\t\t}","\t\t\t\tn := int(nv.(apl.Int))","","\t\t\t\tr = fR.Copy()","\t\t\t\tif n == 1 {","\t\t\t\t\treturn r, nil","\t\t\t\t}","","\t\t\t}","\t\t}","\t}","\treturn function(derived)","}",""],"query.go":["package primitives","","import (","\t\"fmt\"","\t\"math/rand\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"","\t\"github.com/ktye/iv/apl/numbers\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"?\",","\t\tdoc:    \"roll, rand, randn, bi-randn\",","\t\tDomain: Monadic(nil),","\t\tfn:     roll,","\t})","\tregister(primitive{","\t\tsymbol: \"?\",","\t\tdoc:    \"deal\",","\t\tDomain: Dyadic(Split(ToScalar(ToIndex(nil)), ToScalar(ToIndex(nil)))),","\t\tfn:     deal,","\t})","}","","// roll returns a number or an array of the same shape as R.","// Values of R must be numbers","func roll(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\tif z, ok := R.(apl.Number); ok == false {","\t\t\treturn nil, fmt.Errorf(\"roll expectes a numeric array as the right argument\")","\t\t} else {","\t\t\tif n, err := rollNumber(a, z); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else {","\t\t\t\treturn n, nil","\t\t\t}","\t\t}","\t}","\tif ar.Size() == 0 {","\t\treturn apl.EmptyArray{}, nil","\t}","\tres := apl.NewMixed(apl.CopyShape(ar))","\tfor i := range res.Values {","\t\tif z, ok := ar.At(i).(apl.Number); ok == false {","\t\t\treturn nil, fmt.Errorf(\"roll: array value is not numeric\")","\t\t} else {","\t\t\tif n, err := rollNumber(a, z); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else {","\t\t\t\tres.Values[i] = n","\t\t\t}","\t\t}","\t}","\treturn a.UnifyArray(res), nil","}","","// rollNumber returns a random integer upto n, which must be integer.","// If n is 0, it returns a random float between 0 and 1.","// If n is negative it returns a random number from a normal distribution with std←|n.","// If n is complex, it returns a random number from a bivariate normal distribution","// with normal parameters given by the real an imag part.","//","// TODO: seed. Currently random numbers are not seeded (equivalent to Seed(1))","// and always return the same values.","func rollNumber(a *apl.Apl, n apl.Number) (apl.Number, error) {","\tif f, ok := n.(numbers.Float); ok \u0026\u0026 float64(f) \u003c 0 {","\t\treturn numbers.Float(float64(f) * rand.NormFloat64()), nil","\t}","\tif z, ok := n.(numbers.Complex); ok {","\t\treturn numbers.Complex(complex(real(z)*rand.NormFloat64(), imag(z)*rand.NormFloat64())), nil","\t}","\tm, ok := n.ToIndex()","\tif ok == false || m \u003c 0 {","\t\treturn numbers.Float(float64(m) * rand.NormFloat64()), nil","\t}","\tif m == 0 {","\t\t// TODO: should we exclude 0?","\t\tf := rand.Float64()","\t\treturn numbers.Float(f), nil // This only works with the default tower.","\t} else {","\t\treturn a.Tower.Import(apl.Int(rand.Intn(m) + a.Origin)), nil","\t}","}","","// deal selects L random numbers from ⍳R without repetition.","func deal(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t// TODO []RL (random link)","\tn := int(L.(apl.Int))","\tm := int(R.(apl.Int))","\tif n \u003c= 0 || m \u003c n {","\t\treturn nil, fmt.Errorf(\"deal: L must be \u003e 0 and R \u003e= L\")","\t}","\tp := rand.Perm(m)","\tp = p[:n]","\tfor i := range p {","\t\tp[i] += a.Origin","\t}","\treturn apl.IntArray{","\t\tInts: p,","\t\tDims: []int{n},","\t}, nil","}",""],"rank.go":["package operators","","import (","\t\"fmt\"","\t\"io\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(operator{","\t\tsymbol:  \"⍤\",","\t\tDomain:  DyadicOp(Split(Function(nil), ToIndexArray(nil))),","\t\tdoc:     \"rank\",","\t\tderived: rank,","\t})","}","","// rank is extended for sending subarrays over a channel:","//\t\u003c⍤3 A  send rank-3 subarray of A sequentially over the returned channel","//\t\u003c⍤3 C  read strings from input channel C, parse rank-3 subarrays and send them over a return channel","func rank(a *apl.Apl, LO, RO apl.Value) apl.Function {","\t// Cell, Frame, Conform: ISO: 9.3.3, p123","\t// Rank operator: ISO; 9.3.4, p 124","\tderived := func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\tf := LO.(apl.Function)","\t\tdoSend := false","\t\tif pf, ok := f.(apl.Primitive); ok \u0026\u0026 string(pf) == \"\u003c\" {","\t\t\tdoSend = true","\t\t}","","\t\tai := RO.(apl.IntArray)","\t\tif len(ai.Shape()) != 1 {","\t\t\treturn nil, fmt.Errorf(\"rank: RO must be a vector\")","\t\t}","","\t\t// p, q and r are the values of RO.","\t\tvar p, q, r int","\t\tif n := ai.Size(); n \u003c 1 || n \u003e 3 {","\t\t\treturn nil, fmt.Errorf(\"rank: RO vector has %d elements, must be between 1..3\", n)","\t\t} else if n == 1 {","\t\t\tp, q, r = int(ai.Ints[0]), int(ai.Ints[0]), int(ai.Ints[0])","\t\t\t// Special case: \u003c⍤R C","\t\t\tif c, ok := R.(apl.Channel); ok \u0026\u0026 doSend == true {","\t\t\t\treturn sendParseSubArray(a, r, c)","\t\t\t}","\t\t} else if n == 2 {","\t\t\tp, q, r = int(ai.Ints[1]), int(ai.Ints[0]), int(ai.Ints[1])","\t\t} else if n == 3 {","\t\t\tp, q, r = int(ai.Ints[0]), int(ai.Ints[1]), int(ai.Ints[2])","\t\t}","","\t\tar, ok := R.(apl.Array)","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"rank: right argument must be an array: %T\", R)","\t\t}","\t\trs := ar.Shape()","","\t\tvar al apl.Array","\t\tvar ls []int","\t\tif L != nil {","\t\t\tal, ok = L.(apl.Array)","\t\t\tls = al.Shape()","\t\t}","","\t\t// subcell returns the rank-subcell number i of the array x.","\t\tsubcell := func(x apl.Array, rank int, n int) (apl.Value, error) {","\t\t\tif rank == 0 {","\t\t\t\treturn x.At(n), nil","\t\t\t}","\t\t\tshape := x.Shape()","\t\t\tif rank \u003c 0 || rank \u003e len(shape) {","\t\t\t\treturn nil, fmt.Errorf(\"cannot get %d-subcell of array with rank %d\", rank, len(shape))","\t\t\t}","\t\t\tif n \u003c 0 || n \u003e shape[len(shape)-1-rank] {","\t\t\t\treturn nil, fmt.Errorf(\"cannot get %d-subcell number %d: length of axis is %d\", rank, n, shape[rank])","\t\t\t}","","\t\t\tsubshape := apl.CopyShape(x)","\t\t\tsubshape = subshape[len(subshape)-rank:]","\t\t\tcell := apl.NewMixed(subshape)","\t\t\tm := len(cell.Values)","\t\t\tfor i := range cell.Values {","\t\t\t\tcell.Values[i] = x.At(n*m + i).Copy()","\t\t\t}","\t\t\treturn a.UnifyArray(cell), nil","\t\t}","","\t\t// subcells returns the number of rank-cells of x.","\t\tsubcells := func(x apl.Array, rank int) int {","\t\t\ts := x.Shape()","\t\t\t// The number is the product of the frame of x with respect to rank.","\t\t\treturn apl.Prod(s[:len(s)-rank])","\t\t}","","\t\tvar err error","\t\tvar results []apl.Value","\t\tframe := apl.CopyShape(ar)","\t\tif al != nil {","\t\t\t// Dyadic context: q specifies rank of L.","\t\t\tif q \u003c 0 {","\t\t\t\tq += len(ls)","\t\t\t}","\t\t\tif q \u003c 0 || q \u003e len(ls) {","\t\t\t\treturn nil, fmt.Errorf(\"rank: q (%d) exceeds rank of left argument: %d\", q, len(ls))","\t\t\t}","\t\t\t// r specifies rank of R.","\t\t\tif r \u003c 0 {","\t\t\t\tr += len(rs)","\t\t\t}","\t\t\tif r \u003c 0 || r \u003e len(rs) {","\t\t\t\treturn nil, fmt.Errorf(\"rank: r (%d) exceeds rank of right argument: %d\", r, len(rs))","\t\t\t}","","\t\t\t// The number of subcells must match or any must be 0 and is repeated.","\t\t\tml := subcells(al, q)","\t\t\tmr := subcells(ar, r)","\t\t\tif ml != mr \u0026\u0026 ml \u003e 0 \u0026\u0026 mr \u003e 0 {","\t\t\t\treturn nil, fmt.Errorf(\"rank: L and R have different number of subcells\")","\t\t\t}","\t\t\tm := ml","\t\t\tif ml \u003c mr {","\t\t\t\tm = mr","\t\t\t}","","\t\t\t// Apply f successsively between sub arrays of L and R specified by q and r.","\t\t\tframe = frame[:len(frame)-r]","\t\t\tif mr == 0 {","\t\t\t\tframe = apl.CopyShape(al)","\t\t\t\tframe = frame[:len(frame)-q]","\t\t\t}","\t\t\tvar subl, subr apl.Value","\t\t\tfor i := 0; i \u003c m; i++ {","\t\t\t\tif ml == 0 {","\t\t\t\t\tsubl = al","\t\t\t\t} else {","\t\t\t\t\tsubl, err = subcell(al, q, i)","\t\t\t\t\tif err != nil {","\t\t\t\t\t\treturn nil, err","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif mr == 0 {","\t\t\t\t\tsubr = ar","\t\t\t\t} else {","\t\t\t\t\tsubr, err = subcell(ar, r, i)","\t\t\t\t\tif err != nil {","\t\t\t\t\t\treturn nil, err","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tv, err := f.Call(a, subl, subr)","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\tresults = append(results, v.Copy())","\t\t\t}","\t\t} else {","\t\t\t// Monadic context: p specifies rank of R.","\t\t\t// r specifies rank of R.","\t\t\tif p \u003c 0 {","\t\t\t\tp += len(rs)","\t\t\t}","\t\t\tif p \u003c 0 || r \u003e len(rs) {","\t\t\t\treturn nil, fmt.Errorf(\"rank: p (%d) exceeds rank of right argument: %d\", p, len(rs))","\t\t\t}","","\t\t\t// Apply f successsively to sub arrays of R specified by p.","\t\t\tframe = frame[:len(frame)-p]","\t\t\tfor i := 0; i \u003c subcells(ar, p); i++ {","\t\t\t\ts, err := subcell(ar, p, i)","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\tif doSend {","\t\t\t\t\tresults = append(results, s)","\t\t\t\t} else {","\t\t\t\t\tv, err := f.Call(a, nil, s)","\t\t\t\t\tif err != nil {","\t\t\t\t\t\treturn nil, err","\t\t\t\t\t}","\t\t\t\t\tresults = append(results, v.Copy())","\t\t\t\t}","\t\t\t}","\t\t\tif doSend {","\t\t\t\tc := apl.NewChannel()","\t\t\t\tgo c.SendAll(results)","\t\t\t\treturn c, nil","\t\t\t}","\t\t}","","\t\t// Bring all individual results to conforming shape.","\t\tvar common []int","\t\tfor i := range results {","\t\t\tif vr, ok := results[i].(apl.Array); ok {","\t\t\t\ts := vr.Shape()","\t\t\t\tif d := len(s) - len(common); d \u003e 0 {","\t\t\t\t\tcommon = append(make([]int, d), common...)","\t\t\t\t}","\t\t\t\tfor n := 0; n \u003c len(s); n++ {","\t\t\t\t\tk := len(common) - len(s) + n","\t\t\t\t\tif s[n] \u003e common[k] {","\t\t\t\t\t\tcommon[k] = s[n]","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t\tfor n := range results {","\t\t\tif vr, ok := results[n].(apl.Array); ok == false {","\t\t\t\tif len(common) \u003e 0 {","\t\t\t\t\t// Reshape scalar to common shape.","\t\t\t\t\tga := apl.NewMixed(common)","\t\t\t\t\tfor i := range ga.Values {","\t\t\t\t\t\tga.Values[i] = results[n].Copy()","\t\t\t\t\t}","\t\t\t\t\tresults[n] = a.UnifyArray(ga)","\t\t\t\t}","\t\t\t} else {","\t\t\t\t// If rank is smaller than common rank,","\t\t\t\t// fill ones at the start and reshape.","\t\t\t\tshape := apl.CopyShape(vr)","\t\t\t\tif d := len(common) - len(shape); d \u003e 0 {","\t\t\t\t\tshape = append(make([]int, d), shape...)","\t\t\t\t\tfor i := 0; i \u003c d; i++ {","\t\t\t\t\t\tshape[i] = 1","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif rs, ok := vr.(apl.Reshaper); ok {","\t\t\t\t\tvr = rs.Reshape(shape).(apl.Array)","\t\t\t\t}","","\t\t\t\t// If the shape is different from common, make a conforming","\t\t\t\t// array by: common↑vr","\t\t\t\tdiffshape := false","\t\t\t\tfor i := range common {","\t\t\t\t\tif common[i] != shape[i] {","\t\t\t\t\t\tdiffshape = true","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif diffshape {","\t\t\t\t\tidx := apl.IntArray{Dims: []int{len(common)}}","\t\t\t\t\tidx.Ints = make([]int, len(common))","\t\t\t\t\tfor i := range common {","\t\t\t\t\t\tidx.Ints[i] = int(common[i])","\t\t\t\t\t}","\t\t\t\t\tvar err error","\t\t\t\t\tvr, err = Take(a, idx, vr, nil)","\t\t\t\t\tif err != nil {","\t\t\t\t\t\treturn nil, err","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tresults[n] = vr.Copy()","\t\t\t}","\t\t}","","\t\t// The result has the shape: frame, conform","\t\tresdims := make([]int, len(frame)+len(common))","\t\tcopy(resdims, frame)","\t\tcopy(resdims[len(frame):], common)","\t\tres := apl.NewMixed(resdims)","","\t\tif len(common) == 0 {","\t\t\tif len(results) != len(res.Values) {","\t\t\t\treturn nil, fmt.Errorf(\"rank: unexpected number of scalar results %d instead of %d\", len(results), len(res.Values)) // Should not happen","\t\t\t}","\t\t\tres.Values = results","\t\t\treturn a.UnifyArray(res), nil","\t\t}","\t\tcommonsize := apl.Prod(common)","\t\toff := 0","\t\tfor i := range results {","\t\t\tif len(common) == 0 {","\t\t\t\tres.Values[i] = results[i].Copy()","\t\t\t} else {","\t\t\t\tvr := results[i].(apl.Array)","\t\t\t\tfor n := 0; n \u003c commonsize; n++ {","\t\t\t\t\tres.Values[off+n] = vr.At(n).Copy()","\t\t\t\t}","\t\t\t\toff += commonsize","\t\t\t}","\t\t}","\t\treturn a.UnifyArray(res), nil","\t}","\treturn function(derived)","}","","// sendParseSubArray assembles an array of the given rank from strings read on channel c.","// Strings are parsed to numbers or strings.","// It returns a channel and sends arrays of the rank.","func sendParseSubArray(a *apl.Apl, rank int, in apl.Channel) (apl.Value, error) {","\tout := apl.NewChannel()","\tgo func() {","\t\tdefer close(out[0])","\t\tscn := apl.RuneScanner{C: in, O: out}","\t\tfor {","\t\t\tv, err := a.ScanRankArray(\u0026scn, rank)","\t\t\tif err == io.EOF || err == io.ErrClosedPipe {","\t\t\t\treturn","\t\t\t} else if err != nil {","\t\t\t\tout[0] \u003c- apl.Error{err}","\t\t\t\treturn","\t\t\t}","\t\t\tselect {","\t\t\tcase _, ok := \u003c-in[1]:","\t\t\t\tif !ok {","\t\t\t\t\treturn","\t\t\t\t}","\t\t\tcase out[0] \u003c- v:","\t\t\t}","\t\t}","\t}()","\treturn out, nil","}","","// Take is defined and exported here, because it is used by both the rank operator and the take primitive function.","","func Take(a *apl.Apl, ai apl.IntArray, ar apl.Array, x []int) (apl.Array, error) {","\trs := ar.Shape()","","\tif x == nil {","\t\tx = make([]int, len(ai.Ints))","\t\tfor i := range x {","\t\t\tx[i] = i","\t\t}","\t}","","\tif len(ai.Ints) != len(x) {","\t\treturn nil, fmt.Errorf(\"take: length of L and axis must match\")","\t}","","\tshape := make([]int, len(rs))","\tfor i := range shape {","\t\tshape[i] = rs[i]","\t}","\tfor i, k := range x {","\t\tshape[k] = int(ai.Ints[i])","\t\tif shape[k] \u003c 0 {","\t\t\tshape[k] = -shape[k]","\t\t}","\t}","","\t// Offset for negative arguments.","\toff := make([]int, len(ar.Shape()))","\tfor i := range off {","\t\tif i \u003c len(ai.Ints) {","\t\t\tif n := ai.Ints[i]; n \u003c 0 {","\t\t\t\tk := x[i]","\t\t\t\toff[k] = rs[k] + int(n)","\t\t\t}","\t\t}","\t}","","\tres := apl.MakeArray(ar, shape)","\tvar z apl.Value","\tif u, ok := res.(apl.Uniform); ok {","\t\tz = u.Zero()","\t} else {","\t\tz = apl.Int(0)","\t}","\tidx := make([]int, len(shape))","\tic, src := apl.NewIdxConverter(ar.Shape())","\tfor i := 0; i \u003c res.Size(); i++ {","\t\tcopy(src, idx)","\t\tzero := false","\t\tfor k, n := range off {","\t\t\tsrc[k] += n","\t\t\tif src[k] \u003c 0 || src[k] \u003e= rs[k] {","\t\t\t\tzero = true","\t\t\t}","\t\t}","\t\tif zero {","\t\t\tres.Set(i, z)","\t\t} else {","\t\t\tres.Set(i, ar.At(ic.Index(src)).Copy())","\t\t}","\t\tapl.IncArrayIndex(idx, shape)","\t}","\treturn res, nil","}",""],"rat.go":["package big","","import (","\t\"fmt\"","\t\"math\"","\t\"math/big\"","\t\"strings\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/numbers\"",")","","var rat0 *big.Rat = big.NewRat(0, 1)","var rat1 *big.Rat = big.NewRat(1, 1)","","type Rat struct {","\t*big.Rat","}","","func (r Rat) Copy() apl.Value {","\tt := big.NewRat(1, 1)","\tt = t.Set(r.Rat)","\treturn Rat{t}","}","func (r Rat) String(f apl.Format) string {","\tformat, minus := getformat(f, r)","\tif format == \"\" {","\t\ts := r.Rat.String()","\t\tif minus == false {","\t\t\ts = strings.Replace(s, \"-\", \"¯\", -1)","\t\t}","\t\tif strings.HasSuffix(s, \"/1\") {","\t\t\treturn s[:len(s)-2]","\t\t}","\t\treturn strings.Replace(s, \"/\", \"r\", 1)","\t} else {","\t\tn, _ := r.Rat.Float64()","\t\ts := fmt.Sprintf(format, n)","\t\tif minus == false {","\t\t\ts = strings.Replace(s, \"-\", \"¯\", -1)","\t\t}","\t\treturn s","\t}","}","","func (r Rat) ToIndex() (int, bool) {","\tif r.Rat.IsInt() == false {","\t\treturn 0, false","\t}","\ti := r.Rat.Num()","\treturn Int{i}.ToIndex()","}","","func ParseRat(s string) (apl.Number, bool) {","\ts = strings.Replace(s, \"¯\", \"-\", -1)","\ts = strings.Replace(s, \"r\", \"/\", 1)","\tr := new(big.Rat)","\tr, ok := r.SetString(s)","\tif ok == false {","\t\treturn nil, false","\t}","\treturn Rat{r}, true","}","","func (l Rat) Equals(R apl.Value) (apl.Bool, bool) {","\treturn l.Rat.Cmp(R.(Rat).Rat) == 0, true","}","","func (l Rat) Less(R apl.Value) (apl.Bool, bool) {","\treturn l.Rat.Cmp(R.(Rat).Rat) \u003c 0, true","}","","func (l Rat) Add() (apl.Value, bool) {","\treturn l, true","}","func (l Rat) Add2(R apl.Value) (apl.Value, bool) {","\tz := new(big.Rat)","\tz = z.Add(l.Rat, R.(Rat).Rat)","\treturn Rat{z}, true","}","","func (l Rat) Sub() (apl.Value, bool) {","\tz := new(big.Rat)","\tz = z.Neg(l.Rat)","\treturn Rat{z}, true","}","func (l Rat) Sub2(R apl.Value) (apl.Value, bool) {","\tz := new(big.Rat)","\tz = z.Sub(l.Rat, R.(Rat).Rat)","\treturn Rat{z}, true","}","","func (l Rat) Mul() (apl.Value, bool) {","\treturn Int{big.NewInt(int64(l.Rat.Sign()))}, true","}","func (l Rat) Mul2(R apl.Value) (apl.Value, bool) {","\tz := new(big.Rat)","\tz = z.Mul(l.Rat, R.(Rat).Rat)","\treturn Rat{z}, true","}","","func (r Rat) Div() (apl.Value, bool) {","\tif r.Rat.Cmp(rat0) == 0 {","\t\treturn numbers.Inf, true","\t}","\tz := new(big.Rat)","\tz = z.Inv(r.Rat)","\treturn Rat{z}, true","}","func (l Rat) Div2(R apl.Value) (apl.Value, bool) {","\tL0 := false","\tR0 := false","\tif l.Rat.Cmp(rat0) == 0 {","\t\tL0 = true","\t}","\tif R.(Rat).Rat.Cmp(rat0) == 0 {","\t\tR0 = true","\t}","\tif L0 \u0026\u0026 R0 {","\t\treturn numbers.NaN, true","\t} else if L0 {","\t\treturn Int{big.NewInt(0)}, true","\t} else if R0 {","\t\treturn numbers.Inf, true","\t}","\tz := new(big.Rat)","\tz = z.Quo(l.Rat, R.(Rat).Rat)","\treturn Rat{z}, true","}","","func (r Rat) Pow() (apl.Value, bool) {","\tif r.Rat.Cmp(rat0) == 0 {","\t\treturn Int{big.NewInt(1)}, true","\t}","\treturn nil, false","}","func (l Rat) Pow2(R apl.Value) (apl.Value, bool) {","\tneg := false","\tr := R.(Rat).Rat","\tif c := r.Cmp(rat0); c == 0 {","\t\treturn Int{big.NewInt(1)}, true","\t} else if c \u003c 0 {","\t\tneg = true","\t\tr = r.Neg(r)","\t} else if l.Rat.Cmp(rat0) == 0 {","\t\treturn Int{big.NewInt(0)}, true","\t}","","\tif r.IsInt() == false {","\t\treturn nil, false","\t}","","\te := r.Num()","\ta := l.Rat.Num()","\tb := l.Rat.Denom()","\tae := new(big.Int)","\tbe := new(big.Int)","\tae = ae.Exp(a, e, nil)","\tbe = be.Exp(b, e, nil)","\tz := new(big.Rat)","\tz.SetFrac(ae, be)","\tif neg {","\t\tz = z.Inv(z)","\t}","\treturn Rat{z}, true","}","","// Log, Log2 is not defined","","func (r Rat) Abs() (apl.Value, bool) {","\tif r.Rat.Sign() \u003c 0 {","\t\treturn r.Sub()","\t}","\treturn r, true","}","","func (r Rat) Ceil() (apl.Value, bool) {","\tf, _ := r.Rat.Float64()","\treturn Rat{new(big.Rat).SetFloat64(math.Ceil(f))}, true","}","func (r Rat) Floor() (apl.Value, bool) {","\tf, _ := r.Rat.Float64()","\treturn Rat{new(big.Rat).SetFloat64(math.Floor(f))}, true","}","","func (L Rat) Gcd(R apl.Value) (apl.Value, bool) {","\tab := L.Rat","\tcd := R.(Rat).Rat","\ta := ab.Num()","\tb := ab.Denom()","\tc := cd.Num()","\td := cd.Denom()","\tad := big.NewInt(0).Mul(a, d)","\tcb := big.NewInt(0).Mul(c, b)","\tgcd := big.NewInt(0).GCD(nil, nil, ad, cb)","\tbd := big.NewInt(0).Mul(b, d)","\trat := big.NewRat(1, 1).SetFrac(gcd, bd)","\treturn Rat{rat}, true","}",""],"read.go":["package io","","import (","\t\"bufio\"","\t\"fmt\"","\t\"io\"","\t\"os\"","\tex \"os/exec\"","\t\"strings\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/domain\"","\t\"github.com/ktye/iv/apl/scan\"",")","","// Stdin is exported to be overwritable by tests.","var Stdin io.ReadCloser = os.Stdin","","// read reads from a file","func read(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tname, ok := R.(apl.String)","\tif ok == false {","\t\t// If R is 0, it reads from stdin.","\t\tif num, ok := R.(apl.Number); ok {","\t\t\tif n, ok := num.ToIndex(); ok \u0026\u0026 n == 0 {","\t\t\t\treturn apl.LineReader(Stdin), nil","\t\t\t}","\t\t}","\t\treturn nil, fmt.Errorf(\"io read: expect file name %T\", R)","\t}","\tf, err := Open(string(name))","\tif err != nil {","\t\treturn nil, err","\t}","\treturn apl.LineReader(f), nil // LineReader closes the file.","}","","// exec executes a program and sends the output through a channel.","// If called dyadically it uses R as an input, that can be a channel or a Value.","// If the program starts with a slash, it's location is looked up in the file system.","// TODO: should all arguments starting with a slash be replaced?","func exec(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tr := R","\tvar in io.Reader","\tif L != nil {","\t\tr = L","\t\tc, ok := R.(apl.Channel)","\t\tif ok {","\t\t\tin = bufio.NewReader(apl.NewChannelReader(a, c))","\t\t} else {","\t\t\tin = strings.NewReader(R.String(a.Format))","\t\t}","\t}","","\tv, ok := domain.ToStringArray(nil).To(a, r)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"io exec: argv must be strings: %T\", r)","\t}","\targv := v.(apl.StringArray).Strings","\tif len(argv) == 0 {","\t\treturn nil, fmt.Errorf(\"io exec: argv empty\")","\t}","","\t// If the command starts with a slash, we may relocate it.","\tif strings.HasPrefix(argv[0], \"/\") {","\t\tfsys, mpt, err := lookup(argv[0])","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tif f, ok := fsys.(fs); ok == false {","\t\t\treturn nil, fmt.Errorf(\"exec: %s: file system is not an os fs: %s\", argv[0], fsys.String())","\t\t} else {","\t\t\trelpath := strings.TrimPrefix(argv[0], mpt)","\t\t\targv[0] = f.path(relpath)","\t\t}","\t}","","\tcmd := ex.Command(argv[0], argv[1:]...)","\tcmd.Stdin = in","\tout, err := cmd.StdoutPipe()","\tif err != nil {","\t\treturn nil, err","\t}","\tc := apl.LineReader(out)","\tif err := cmd.Start(); err != nil {","\t\treturn nil, err","\t}","\treturn c, nil","}","","// Load reads the file R and executes it.","// It returns an error, if R is not a file.","// If L is given, the file is executed in a new environment and the resulting variables","// are copied to a package with the name of L.","func load(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\ts, ok := R.(apl.String)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"io l: argument must be a file name: %T\", R)","\t}","","\tf, err := Open(string(s))","\tif err != nil {","\t\treturn nil, err","\t}","\tdefer f.Close()","","\tif L == nil {","\t\tif err := a.EvalFile(f, string(s)); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn apl.EmptyArray{}, nil","\t}","","\tl, ok := L.(apl.String)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"io l: left argument must be a package name: %T\", L)","\t}","","\tif err := a.LoadPkg(f, string(s), string(l)); err != nil {","\t\treturn nil, err","\t}","\treturn apl.EmptyArray{}, nil","}","","func lCmd(t []scan.Token) []scan.Token {","\t// /l `/file.apl `pkg","\tif len(t) == 2 \u0026\u0026 t[0].T == scan.String \u0026\u0026 t[1].T == scan.String {","\t\treturn []scan.Token{t[1], scan.Token{T: scan.Identifier, S: \"io→l\"}, t[0]}","\t}","\tl := scan.Token{T: scan.Identifier, S: \"io→l\"}","\treturn append([]scan.Token{l}, t...)","}",""],"reduce.go":["package operators","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(operator{","\t\tsymbol:  \"/\",","\t\tDomain:  MonadicOp(Function(nil)),","\t\tdoc:     \"reduce, n-wise reduction\",","\t\tderived: reduceLast,","\t})","\tregister(operator{","\t\tsymbol:  \"⌿\",","\t\tDomain:  MonadicOp(Function(nil)),","\t\tdoc:     \"reduce first, n-wise reduction\",","\t\tderived: reduceFirst,","\t})","\tregister(operator{","\t\tsymbol:  `\\`,","\t\tDomain:  MonadicOp(Function(nil)),","\t\tdoc:     \"scan\",","\t\tderived: scanLast,","\t})","\tregister(operator{","\t\tsymbol:  `⍀`,","\t\tDomain:  MonadicOp(Function(nil)),","\t\tdoc:     \"scan first axis\",","\t\tderived: scanFirst,","\t})","\tregister(operator{","\t\tsymbol:  \"/\",","\t\tDomain:  MonadicOp(ToIndexArray(nil)),","\t\tdoc:     \"replicate, compress\",","\t\tderived: replicateLast,","\t\tselection: selectSimple(func(a *apl.Apl, LO, R apl.Value) (apl.Value, error) {","\t\t\treturn Replicate(a, LO, R, -1)","\t\t}),","\t})","\tregister(operator{","\t\tsymbol:  \"⌿\",","\t\tDomain:  MonadicOp(ToIndexArray(nil)),","\t\tdoc:     \"replicate, compress first axis\",","\t\tderived: replicateFirst,","\t})","\tregister(operator{","\t\tsymbol:  `\\`,","\t\tDomain:  MonadicOp(ToIndexArray(nil)),","\t\tdoc:     \"expand\",","\t\tderived: expandLast,","\t\tselection: selectSimple(func(a *apl.Apl, LO, R apl.Value) (apl.Value, error) {","\t\t\treturn Expand(a, LO, R, -1)","\t\t}),","\t})","\tregister(operator{","\t\tsymbol:  `⍀`,","\t\tDomain:  MonadicOp(ToIndexArray(nil)),","\t\tdoc:     \"expand first axis\",","\t\tderived: expandFirst,","\t})","}","","func reduceLast(a *apl.Apl, f, _ apl.Value) apl.Function {","\treturn reduction(a, f, -1)","}","func reduceFirst(a *apl.Apl, f, _ apl.Value) apl.Function {","\treturn reduction(a, f, 0)","}","","func scanLast(a *apl.Apl, f, _ apl.Value) apl.Function {","\treturn scanArray(a, f, -1)","}","func scanFirst(a *apl.Apl, f, _ apl.Value) apl.Function {","\treturn scanArray(a, f, 0)","}","","func replicateLast(a *apl.Apl, f, _ apl.Value) apl.Function {","\treturn replicate(a, f, -1)","}","func replicateFirst(a *apl.Apl, f, _ apl.Value) apl.Function {","\treturn replicate(a, f, 0)","}","","func expandLast(a *apl.Apl, f, _ apl.Value) apl.Function {","\treturn expand(a, f, -1)","}","func expandFirst(a *apl.Apl, f, _ apl.Value) apl.Function {","\treturn expand(a, f, 0)","}","","// Reduction returns the derived function f/ .","func reduction(a *apl.Apl, f apl.Value, axis int) apl.Function {","","\t// Special cases: left, right tack.","\tif p, ok := f.(apl.Primitive); ok {","\t\tif p == \"⊣\" {","\t\t\treturn reduceTack(true)","\t\t} else if p == \"⊢\" {","\t\t\treturn reduceTack(false)","\t\t}","\t}","\tderived := func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\treturn reduct(a, f.(apl.Function), L, R, axis)","\t}","\treturn function(derived)","}","","func reduct(a *apl.Apl, f apl.Function, l, r apl.Value, axis int) (apl.Value, error) {","","\tif c, ok := r.(apl.Channel); ok {","\t\tif axis == 0 {","\t\t\t// l f⌿ c applies f and filters empty values.","\t\t\treturn c.Apply(a, f, l, true), nil","\t\t}","\t\treturn reduceChannel(a, l, f, c)","\t}","","\tif _, ok := r.(apl.Axis); ok {","\t\tif rr, n, err := splitAxis(a, r); err != nil {","\t\t\treturn nil, err","\t\t} else {","\t\t\tr = rr","\t\t\tif len(n) != 1 {","\t\t\t\treturn nil, fmt.Errorf(\"reduce with axis: axis must be a scalar\")","\t\t\t}","\t\t\taxis = n[0]","\t\t}","\t}","","\tif _, ok := r.(apl.Table); ok {","\t\treturn reduceTable(a, f, l, r, false) // axis is ignored.","\t} else if _, ok := r.(apl.Object); ok {","\t\treturn reduceTable(a, f, l, r, false)","\t}","","\tif l != nil {","\t\treturn nwise(a, f, l, r, axis)","\t}","","\t// If R is a scalar, the operation is not applied and Z←R","\t// Single element arrays return the element.","\tar, ok := r.(apl.Array)","\tif ok == false {","\t\treturn r, nil","\t}","\tshape := ar.Shape()","\tif len(shape) == 1 \u0026\u0026 shape[0] == 1 {","\t\treturn ar.At(0).Copy(), nil // higher rank single element arrays are reduced.","\t}","","\tif len(shape) == 0 {","\t\tif id := identityItem(f.(apl.Value)); id == nil {","\t\t\treturn nil, fmt.Errorf(\"no identity item for reduce over empty array\")","\t\t} else {","\t\t\treturn id, nil","\t\t}","\t}","","\tif axis \u003c 0 {","\t\taxis = len(shape) + axis","\t}","\tif axis \u003c 0 || axis \u003e= len(shape) {","\t\treturn nil, fmt.Errorf(\"reduce: axis rank is %d but axis %d\", len(shape), axis)","\t}","","\t// n is the number of values being reduced (the length if the reduction axis).","\tn := shape[axis]","","\t// Dims is the shape of the result.","\tdims := make([]int, len(shape)-1)","\tk := 0","\tfor i := range shape {","\t\tif i != axis {","\t\t\tdims[k] = shape[i]","\t\t\tk++","\t\t}","\t}","","\t// If the length of the axis is 1, the result is a reshape.","\t// TODO: if the length of any other axis is 0, this should be triggered as well.","\tif n == 1 {","\t\tif rs, ok := ar.(apl.Reshaper); ok {","\t\t\treturn rs.Reshape(dims), nil","\t\t} else {","\t\t\treturn nil, fmt.Errorf(\"reduce with axis length 1: cannot reshape %T\", ar)","\t\t}","\t}","\tif n == 0 {","\t\t// If the axis is 0, apply an identity function, DyaRef p 169","\t\tif id := identityItem(f.(apl.Value)); id == nil {","\t\t\treturn nil, fmt.Errorf(\"reduce empty axis: cannot get identify item for %T\", f)","\t\t} else {","\t\t\tida := a.UnifyArray(apl.MixedArray{Dims: []int{1}, Values: []apl.Value{id}})","\t\t\treturn ida.(apl.Reshaper).Reshape(dims), nil","\t\t}","\t}","","\t// Reduce directly, if R is a vector.","\tif len(shape) == 1 {","\t\tvec := make([]apl.Value, shape[0])","\t\tfor i := range vec {","\t\t\tvec[i] = ar.At(i).Copy()","\t\t}","\t\tv, err := reduce(a, vec, f)","\t\treturn v, err","\t}","","\t// Create a new array with the given axis removed.","\tv := apl.NewMixed(dims)","","\tvec := make([]apl.Value, n)","\tic, sidx := apl.NewIdxConverter(shape)","\ttidx := make([]int, len(dims))","\tfor k := range v.Values {","\t\t// Copy target index over the source index,","\t\t// leaving the reduced axis unset.","\t\tcopy(sidx, tidx[:axis])","\t\tcopy(sidx[axis+1:], tidx[axis:])","\t\t// Iterate over the reduced axis","\t\tfor i := range vec {","\t\t\tsidx[axis] = i","\t\t\t// TODO: maybe this could be done more efficiently","\t\t\t// e.g. by iteration with a fixed increase.","\t\t\tvec[i] = ar.At(ic.Index(sidx)).Copy()","\t\t}","\t\tapl.IncArrayIndex(tidx, dims)","","\t\tif res, err := reduce(a, vec, f); err != nil {","\t\t\treturn nil, fmt.Errorf(\"cannot reduce: %s\", err)","\t\t} else {","\t\t\tv.Values[k] = res","\t\t}","\t}","\treturn a.UnifyArray(v), nil","}","","// ScanArray is the derived function f\\ .","func scanArray(a *apl.Apl, f apl.Value, axis int) apl.Function {","\treturn function(func(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t\treturn scanfunc(a, f.(apl.Function), L, R, axis)","\t})","}","","func scanfunc(a *apl.Apl, f apl.Function, L, R apl.Value, axis int) (apl.Value, error) {","\tif L != nil {","\t\treturn nil, fmt.Errorf(\"scan: derived function is not defined for dyadic context\")","\t}","","\tif _, ok := R.(apl.Axis); ok {","\t\tif r, n, err := splitAxis(a, R); err != nil {","\t\t\treturn nil, err","\t\t} else {","\t\t\tR = r","\t\t\tif len(n) != 1 {","\t\t\t\treturn nil, fmt.Errorf(\"scan with axis: axis must be a scalar\")","\t\t\t}","\t\t\taxis = n[0]","\t\t}","\t}","","\tif _, ok := R.(apl.Table); ok {","\t\treturn reduceTable(a, f, L, R, true) // axis is ignored.","\t} else if _, ok := R.(apl.Object); ok {","\t\treturn reduceTable(a, f, L, R, true)","\t}","\tif c, ok := R.(apl.Channel); ok {","\t\treturn scanChannel(a, f, c)","\t}","","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\t// If R is scalar, return unchanged.","\t\treturn R, nil","\t}","","\t// The result has the same shape as R.","\tdims := apl.CopyShape(ar)","\tres := apl.NewMixed(dims)","","\tif len(dims) == 0 {","\t\treturn apl.EmptyArray{}, nil","\t}","","\tif axis \u003c 0 {","\t\taxis = len(dims) + axis","\t}","\tif axis \u003c 0 || axis \u003e= len(dims) {","\t\treturn nil, fmt.Errorf(\"scan: axis rank is %d but axis %d\", len(dims), axis)","\t}","","\t// Shortcut, if R is a vector","\tif len(dims) == 1 {","\t\tvec := make([]apl.Value, dims[0])","\t\tfor i := range vec {","\t\t\tvec[i] = ar.At(i).Copy()","\t\t}","\t\tvec, err := scan(a, vec, f)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn a.UnifyArray(apl.MixedArray{","\t\t\tValues: vec,","\t\t\tDims:   []int{len(vec)},","\t\t}), nil","\t}","","\t// Loop over the indexes, with the scan axis length set to 1.","\tlidx := apl.CopyShape(ar)","\tlidx[axis] = 1","\tic, idx := apl.NewIdxConverter(dims)","\tvec := make([]apl.Value, dims[axis])","\tfor i := 0; i \u003c apl.Prod(lidx); i++ {","\t\t// Build the scan vector, by iterating over the axis.","\t\tfor k := range vec {","\t\t\tidx[axis] = k","\t\t\tvec[k] = ar.At(ic.Index(idx)).Copy()","\t\t}","\t\tvals, err := scan(a, vec, f)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","","\t\t// Assign the values to the destination indexes.","\t\tfor k := range vals {","\t\t\tidx[axis] = k","\t\t\tres.Values[ic.Index(idx)] = vals[k]","\t\t}","","\t\t// Reset the index vector and increment.","\t\tidx[axis] = 0","\t\tapl.IncArrayIndex(idx, lidx)","\t}","\treturn a.UnifyArray(res), nil","}","","func scanChannel(a *apl.Apl, f apl.Function, c apl.Channel) (apl.Value, error) {","\tvar vec []apl.Value","\tvar err error","\tvar s apl.Value","\tfor v := range c[0] {","\t\tif vec == nil {","\t\t\tvec = append(vec, v.Copy())","\t\t} else {","\t\t\ts, err = f.Call(a, vec[len(vec)-1], v)","\t\t\tif err != nil {","\t\t\t\tbreak","\t\t\t}","\t\t\tvec = append(vec, s.Copy())","\t\t}","\t}","\tc.Close()","\tif err != nil {","\t\treturn nil, err","\t} else if vec == nil {","\t\treturn apl.EmptyArray{}, nil","\t} else {","\t\treturn a.UnifyArray(apl.MixedArray{Dims: []int{len(vec)}, Values: vec}), nil","\t}","}","","// replicate, compress","// L is an index array. Only vectors are allowed.","func replicate(a *apl.Apl, L apl.Value, axis int) apl.Function {","\treturn function(func(a *apl.Apl, dummyL, R apl.Value) (apl.Value, error) {","\t\t// Replicate should not be an operator, but a dyadic function instead.","\t\t// We use LO as the left argument instead.","\t\tif dummyL != nil {","\t\t\treturn nil, fmt.Errorf(\"replicate: derived function cannot be called dyadically\")","\t\t}","\t\treturn Replicate(a, L, R, axis)","\t})","}","","// Replicate is the function L over R (L/R) where L and R are arrays.","func Replicate(a *apl.Apl, L, R apl.Value, axis int) (apl.Value, error) {","\tai, ar, ax, err := commonReplExp(a, L, R, axis)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"replicate: %s\", err)","\t}","\taxis = ax","","\trs := ar.Shape()","","\t// If L is a 1-element vector (or was a scalar), extend it to match the axis of R.","\tif ai.Dims[0] == 1 \u0026\u0026 rs[axis] \u003e 1 {","\t\tn := ai.Ints[0]","\t\tai = apl.IntArray{","\t\t\tDims: []int{rs[axis]},","\t\t}","\t\tai.Ints = make([]int, apl.Prod(ai.Dims))","\t\tfor i := range ai.Ints {","\t\t\tai.Ints[i] = n","\t\t}","\t}","\tif ai.Dims[0] != rs[axis] {","\t\treturn nil, fmt.Errorf(\"replicate: length of L must conform to length of R[axis]\")","\t}","","\tiscompress := true","\tfor i := range ai.Ints {","\t\tif ai.Ints[i] \u003c 0 || ai.Ints[i] \u003e 1 {","\t\t\tiscompress = false","\t\t\tbreak","\t\t}","\t}","\tif iscompress {","\t\treturn compress(a, ai, ar, axis)","\t}","","\t// Replicate along axis.","\tshape := apl.CopyShape(ar)","\tcount := 0","\tvar axismap []int","\tfor k, n := range ai.Ints {","\t\tif n \u003e 0 {","\t\t\tcount += n","\t\t\tfor i := 0; i \u003c n; i++ {","\t\t\t\taxismap = append(axismap, k)","\t\t\t}","\t\t} else if n \u003c 0 {","\t\t\tcount += -n","\t\t\tfor i := 0; i \u003c -n; i++ {","\t\t\t\taxismap = append(axismap, -1)","\t\t\t}","\t\t}","\t}","\tshape[axis] = int(count)","\tres := apl.MakeArray(ar, shape)","\tvar zero apl.Value = apl.Int(0)","\tif u, ok := res.(apl.Uniform); ok {","\t\tzero = u.Zero()","\t}","\tic, idx := apl.NewIdxConverter(rs)","\tdst := make([]int, len(shape))","\tfor i := 0; i \u003c res.Size(); i++ {","\t\tk := dst[axis]","\t\tif n := axismap[k]; n == -1 {","\t\t\tres.Set(i, zero)","\t\t} else {","\t\t\tcopy(idx, dst)","\t\t\tidx[axis] = int(n)","\t\t\tres.Set(i, ar.At(ic.Index(idx)).Copy())","\t\t}","\t\tapl.IncArrayIndex(dst, shape)","\t}","\treturn res, nil","}","","// expand.","// L is an index array. Only vectors are allowed.","func expand(a *apl.Apl, L apl.Value, axis int) apl.Function {","\treturn function(func(a *apl.Apl, dummyL, R apl.Value) (apl.Value, error) {","\t\t// Expand should not be an operator, but a dyadic function instead.","\t\t// We use LO as the left argument instead.","\t\tif dummyL != nil {","\t\t\treturn nil, fmt.Errorf(\"expand: derived function cannot be called dyadically\")","\t\t}","\t\treturn Expand(a, L, R, axis)","\t})","}","","// Expand is the function L\\R where L and R are arrays.","func Expand(a *apl.Apl, L, R apl.Value, axis int) (apl.Value, error) {","\t// Special case: L is empty.","\tif _, ok := L.(apl.EmptyArray); ok {","\t\tif ar, ok := R.(apl.Array); ok == false {","\t\t\treturn apl.EmptyArray{}, nil","\t\t} else {","\t\t\trs := ar.Shape()","\t\t\tax := int(axis)","\t\t\tif ax \u003c 0 {","\t\t\t\tax = len(rs) + ax","\t\t\t}","\t\t\tif ax \u003e= 0 \u0026\u0026 len(rs) \u003e= ax \u0026\u0026 rs[ax] == 0 {","\t\t\t\treturn apl.IntArray{","\t\t\t\t\tDims: apl.CopyShape(ar),","\t\t\t\t}, nil","\t\t\t}","\t\t\treturn nil, fmt.Errorf(\"expand: L is empty, R must be scalar\")","\t\t}","\t}","","\tai, ar, ax, err := commonReplExp(a, L, R, axis)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"expand: %s\", err)","\t}","\taxis = ax","","\t// Special case: R is empty. L may be 0 and is returned.","\tif _, ok := R.(apl.EmptyArray); ok {","\t\tif len(ai.Ints) == 1 \u0026\u0026 ai.Ints[0] == 0 {","\t\t\treturn ai, nil","\t\t} else {","\t\t\treturn nil, fmt.Errorf(\"exand: R is empty, but L is not 0\")","\t\t}","\t}","","\t// The shape of the result is the shape of R,","\t// with the length of the axis set to +/1⌈|L.","\tshape := apl.CopyShape(ar)","\tsum := 0","\tfor _, k := range ai.Ints {","\t\tif k \u003c 0 {","\t\t\tk = -k","\t\t}","\t\tif k \u003e 1 {","\t\t\tsum += k","\t\t} else {","\t\t\tsum++","\t\t}","\t}","\tshape[axis] = int(sum)","","\tres := apl.MakeArray(ar, shape)","\tvar zero apl.Value = apl.Int(0)","\tif u, ok := res.(apl.Uniform); ok {","\t\tzero = u.Zero()","\t}","","\tshort := apl.CopyShape(res)","\tshort[axis] = 1","","\tic, idx := apl.NewIdxConverter(ar.Shape())","\tdic, dst := apl.NewIdxConverter(shape)","\tfor i := 0; i \u003c res.Size()/shape[axis]; i++ {","\t\tcopy(idx, dst)","\t\td := 0","\t\tj := 0 // Count positive indexes in L.","\t\tfor _, k := range ai.Ints {","\t\t\tif k \u003e 0 {","\t\t\t\tidx[axis] = j","\t\t\t\tj++","\t\t\t\tfor m := 0; m \u003c int(k); m++ {","\t\t\t\t\tdst[axis] = d","\t\t\t\t\td++","\t\t\t\t\tres.Set(dic.Index(dst), ar.At(ic.Index(idx)).Copy())","\t\t\t\t}","\t\t\t} else if k == 0 {","\t\t\t\tdst[axis] = d","\t\t\t\td++","\t\t\t\tres.Set(dic.Index(dst), zero)","\t\t\t} else if k \u003c 0 {","\t\t\t\tfor m := 0; m \u003c int(-k); m++ {","\t\t\t\t\tdst[axis] = d","\t\t\t\t\td++","\t\t\t\t\tres.Set(dic.Index(dst), zero)","\t\t\t\t}","\t\t\t}","\t\t}","\t\tdst[axis] = 0","\t\tapl.IncArrayIndex(dst, short)","\t}","\treturn res, nil","}","","// commonReplExp is the common input preprocessing for replicate and expand.","func commonReplExp(a *apl.Apl, L, R apl.Value, axis int) (apl.IntArray, apl.Array, int, error) {","\tai := L.(apl.IntArray)","\tif len(ai.Dims) != 1 {","\t\treturn ai, nil, axis, fmt.Errorf(\"LO must be a vector\")","\t}","","\t// R may contain an axis from a bracket expression, which overwrites axis.","\tif r, n, err := splitAxis(a, R); err != nil {","\t\treturn ai, nil, axis, err","\t} else {","\t\tR = r","\t\tif len(n) == 1 {","\t\t\taxis = n[0]","\t\t} else if len(n) \u003e 1 {","\t\t\treturn ai, nil, axis, fmt.Errorf(\"compress/replicate: axis must be a scalar\")","\t\t}","\t}","","\t// If R is scalar or a single-element array, convert it to (⍴L)⍴B","\t// If R is a scalar, convert it to a single element array.","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\tr := apl.MixedArray{","\t\t\tDims:   []int{1},","\t\t\tValues: []apl.Value{R.Copy()},","\t\t}","\t\tar = a.UnifyArray(r)","\t}","\trs := ar.Shape()","","\t// Special case for empty R.","\tif len(rs) == 0 {","\t\treturn ai, ar, 0, nil","\t}","\tif axis \u003c 0 {","\t\taxis = len(rs) + axis","\t}","\tif axis \u003c 0 {","\t\treturn ai, nil, axis, fmt.Errorf(\"axis is negative\")","\t}","","\t// If R has size 1 along the selected axis and L is larger, extend R.","\tif rs[axis] == 1 \u0026\u0026 len(ai.Ints) \u003e 1 {","\t\tshape := apl.CopyShape(ar)","\t\tshape[axis] = len(ai.Ints)","\t\tr := apl.MakeArray(ar, shape)","\t\tic, idx := apl.NewIdxConverter(rs)","\t\tdst := make([]int, len(shape))","\t\tfor i := 0; i \u003c r.Size(); i++ {","\t\t\tcopy(idx, dst)","\t\t\tidx[axis] = 0","\t\t\tr.Set(i, ar.At(ic.Index(idx)).Copy())","\t\t\tapl.IncArrayIndex(dst, shape)","\t\t}","\t\tar = r","\t\trs = ar.Shape()","\t}","","\tif axis \u003c 0 || axis \u003e= len(rs) {","\t\treturn ai, nil, axis, fmt.Errorf(\"replicate: axis out of range: %d\", axis)","\t}","\treturn ai, ar, axis, nil","}","","// L is an index vector with boolean values.","// R is an array.","func compress(a *apl.Apl, L, R apl.Value, axis int) (apl.Value, error) {","\tai := L.(apl.IntArray)","\tar := R.(apl.Array)","\trs := ar.Shape()","","\tshape := apl.CopyShape(ar)","\tcount := 0","\tfor _, b := range ai.Ints {","\t\tcount += int(b)","\t}","\tshape[axis] = count","","\tres := apl.MakeArray(ar, shape)","\tridx := make([]int, len(rs))","\tn := 0","\tfor i := 0; i \u003c ar.Size(); i++ {","\t\tif b := ridx[axis]; ai.Ints[b] == 1 {","\t\t\tres.Set(n, ar.At(i).Copy())","\t\t\tn++","\t\t}","\t\tapl.IncArrayIndex(ridx, rs)","\t}","\treturn res, nil","}","","func reduce(a *apl.Apl, vec []apl.Value, d apl.Function) (apl.Value, error) {","\tvar err error","\tv := vec[len(vec)-1].Copy()","\tfor i := len(vec) - 2; i \u003e= 0; i-- {","\t\tv, err = d.Call(a, vec[i].Copy(), v.Copy())","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t}","\treturn v.Copy(), nil","}","","func reduceChannel(a *apl.Apl, L apl.Value, f apl.Function, c apl.Channel) (apl.Value, error) {","\tif L != nil {","\t\treturn nil, fmt.Errorf(\"TODO: n-wise channel reduction\")","\t}","\tvar res apl.Value","\tvar err error","\tfor v := range c[0] {","\t\tif res == nil {","\t\t\tres = v.Copy()","\t\t} else {","\t\t\tres, err = f.Call(a, res, v.Copy())","\t\t\tif err != nil {","\t\t\t\tbreak","\t\t\t}","\t\t}","\t}","\tc.Close()","\tif err != nil {","\t\treturn nil, err","\t} else if res == nil {","\t\treturn apl.EmptyArray{}, nil","\t} else {","\t\treturn res, nil","\t}","}","","// reduceTable applies to tables or objects/dicts.","// It always uses the same axis.","// It is used from both reduce and scan.","func reduceTable(a *apl.Apl, f apl.Function, L, R apl.Value, scan bool) (apl.Value, error) {","\tvar o apl.Object","\tistable := false","\tif t, ok := R.(apl.Table); ok {","\t\tistable = true","\t\to = t.Dict","\t} else {","\t\to = R.(apl.Object)","\t}","\tkeys := o.Keys()","\td := apl.Dict{K: make([]apl.Value, len(keys)), M: make(map[apl.Value]apl.Value)}","\tvar err error","\tfor i, k := range keys {","\t\tcol := o.At(k)","\t\tvar ar apl.Array","\t\tif v, ok := col.(apl.Array); ok {","\t\t\tar = v","\t\t} else {","\t\t\tar = a.UnifyArray(apl.MixedArray{Dims: []int{1}, Values: []apl.Value{col}})","\t\t}","\t\tvar v apl.Value","\t\tif scan {","\t\t\tv, err = scanfunc(a, f, L, ar, -1)","\t\t} else {","\t\t\tv, err = reduct(a, f, L, ar, -1)","\t\t}","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tif _, ok := v.(apl.Array); ok == false \u0026\u0026 istable {","\t\t\t// Tables never contain scalars. Values must be enlisted.","\t\t\tv = apl.List{v}","\t\t}","\t\td.K[i] = k.Copy()","\t\td.M[k.Copy()] = v.Copy()","\t}","\tif istable {","\t\treturn dict2table(a, \u0026d)","\t}","\treturn \u0026d, nil","}","","// copy from primitives/table.go","func dict2table(a *apl.Apl, d *apl.Dict) (apl.Table, error) {","\trows := 0","\tif len(d.K) \u003e 0 {","\t\tv := d.At(d.K[0])","\t\tif ar, ok := v.(apl.Array); ok {","\t\t\tshape := ar.Shape()","\t\t\tif len(shape) == 1 {","\t\t\t\trows = shape[0]","\t\t\t}","\t\t}","\t}","\treturn apl.Table{Dict: d, Rows: rows}, nil","}","","func scan(a *apl.Apl, vec []apl.Value, d apl.Function) ([]apl.Value, error) {","\t// The ith element of the result is: d/I↑V","\tres := make([]apl.Value, len(vec))","\tres[0] = vec[0] // TODO: copy?","\tfor i := 1; i \u003c len(res); i++ {","\t\tif v, err := reduce(a, vec[:i+1], d); err != nil {","\t\t\treturn nil, err","\t\t} else {","\t\t\tres[i] = v.Copy()","\t\t}","\t}","\treturn res, nil","}","","// Nwise is the function handle for n-wise recution.","// l must be a scalar (integer) or a 1 element vector.","func nwise(a *apl.Apl, f apl.Function, L, R apl.Value, axis int) (apl.Value, error) {","","\tvar n int","\tneg := false","\tto := ToScalar(ToIndex(nil))","\tif idx, ok := to.To(a, L); ok == false {","\t\treturn nil, fmt.Errorf(\"nwise reduction: left argument must be a scalar integer: %T\", L)","\t} else {","\t\tn = int(idx.(apl.Int))","\t\tif n \u003c 0 {","\t\t\tn = -n","\t\t\tneg = true","\t\t}","\t}","","\tif _, ok := R.(apl.Table); ok {","\t\treturn nil, fmt.Errorf(\"n-wise reduction over table should not happen\")","\t}","\tif _, ok := R.(apl.Object); ok {","\t\treturn nil, fmt.Errorf(\"n-wise reduction over object should not happen\")","\t}","","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"n-wise reduction: right argument must be an array\")","\t}","\trs := ar.Shape()","","\tif _, ok := R.(apl.EmptyArray); ok {","\t\tif n == 0 {","\t\t\treturn apl.IntArray{Dims: []int{1}, Ints: []int{0}}, nil","\t\t} else if n == 1 {","\t\t\treturn apl.EmptyArray{}, nil","\t\t} else {","\t\t\treturn nil, fmt.Errorf(\"n-wise reduction: length error\")","\t\t}","\t}","","\tif axis == -1 {","\t\taxis = len(rs) + axis","\t}","\tif axis \u003c 0 || axis \u003e= len(rs) {","\t\treturn nil, fmt.Errorf(\"n-wise reduction: axis out of range\")","\t}","","\tshape := apl.CopyShape(ar)","\tshape[axis] -= n - 1","\tif n-rs[axis] \u003e 2 {","\t\treturn nil, fmt.Errorf(\"n-wise reduction: length error\")","\t}","","\tres := apl.NewMixed(shape)","\tif len(res.Values) == 0 {","\t\treturn res, nil","\t}","","\tif n == 0 {","\t\tvar id apl.Value","\t\tif p, ok := f.(apl.Primitive); ok {","\t\t\tid = identityItem(p)","\t\t}","\t\tif id == nil {","\t\t\treturn nil, fmt.Errorf(\"n-wise reduction: unknown identify function\")","\t\t}","\t\tfor i := range res.Values {","\t\t\tres.Values[i] = id","\t\t}","\t\treturn a.UnifyArray(res), nil","\t}","","\t// Fast accumulative algorithm for +/ and ×/","\tvar inv apl.Function","\tif p, ok := f.(apl.Primitive); ok {","\t\tif p == \"+\" {","\t\t\tinv = apl.Primitive(\"-\")","\t\t} else if p == \"×\" {","\t\t\tinv = apl.Primitive(\"÷\")","\t\t}","\t}","","\t// Iterate over all items, except for the reduction axis.","\taxlen := rs[axis]","\tvec := make([]apl.Value, axlen)","\txs := apl.CopyShape(ar)","\txs[axis] = 1","\touter := apl.Prod(xs)","\tic, idx := apl.NewIdxConverter(rs)","\tdc, dst := apl.NewIdxConverter(res.Dims)","\tfor i := 0; i \u003c outer; i++ {","\t\tfor k := range vec {","\t\t\tj := k","\t\t\tif neg {","\t\t\t\tj = axlen - 1 - k","\t\t\t}","\t\t\tidx[axis] = j","\t\t\tvec[k] = ar.At(ic.Index(idx)).Copy()","\t\t}","\t\tif err := applyNwise(a, vec, n, f, inv); err != nil {","\t\t\treturn nil, err","\t\t}","\t\tcopy(dst, idx)","\t\tfor k := 0; k \u003c axlen-n+1; k++ {","\t\t\tj := k","\t\t\tif neg {","\t\t\t\tj = axlen - n - k","\t\t\t}","\t\t\tdst[axis] = j","\t\t\tres.Values[dc.Index(dst)] = vec[k]","\t\t}","","\t\tidx[axis] = 0","\t\tapl.IncArrayIndex(idx, xs)","\t}","","\treturn a.UnifyArray(res), nil","}","","func applyNwise(a *apl.Apl, vec []apl.Value, n int, f, g apl.Function) error {","\tvar err error","\treduce := func(x []apl.Value) apl.Value {","\t\tr := x[len(x)-1]","\t\tfor i := len(x) - 2; i \u003e= 0; i-- {","\t\t\tr, err = f.Call(a, x[i], r)","\t\t\tif err != nil {","\t\t\t\treturn nil","\t\t\t}","\t\t}","\t\treturn r","\t}","","\t// Fast path: Moving window with accumulator.","\tif g != nil \u0026\u0026 n \u003e 3 {","\t\tvar acc apl.Value","\t\twindow := make([]apl.Value, n)","\t\tp := 0","\t\treduce = func(x []apl.Value) apl.Value {","\t\t\t// Initial call: fill the window.","\t\t\tif acc == nil {","\t\t\t\tfor i, v := range x {","\t\t\t\t\twindow[i] = v","\t\t\t\t}","\t\t\t\tacc = x[0]","\t\t\t\tfor _, v := range x[1:] {","\t\t\t\t\tacc, err = f.Call(a, acc, v)","\t\t\t\t\tif err != nil {","\t\t\t\t\t\treturn nil","\t\t\t\t\t}","\t\t\t\t}","\t\t\t} else {","\t\t\t\txnew := x[len(x)-1]","\t\t\t\tacc, err = g.Call(a, acc, window[p])","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil","\t\t\t\t}","\t\t\t\twindow[p] = xnew","\t\t\t\tacc, err = f.Call(a, acc, xnew)","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil","\t\t\t\t}","\t\t\t\tp++","\t\t\t\tif p == len(window) {","\t\t\t\t\tp = 0","\t\t\t\t}","\t\t\t}","\t\t\treturn acc","\t\t}","\t}","","\tfor i := 0; i \u003c len(vec)-n+1; i++ {","\t\tvec[i] = reduce(vec[i : i+n])","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","// reduceTack is the derived function from ⊣/ or ⊢/ .","type reduceTack bool","","func (first reduceTack) Call(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tif L != nil {","\t\treturn nil, fmt.Errorf(\"tack-reduce can only be applied monadically\")","\t}","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\treturn R, nil","\t}","\tshape := ar.Shape()","\tif len(shape) == 0 {","\t\treturn R, nil","\t}","","\t// Reduce a vector to a scalar.","\tif len(shape) == 1 {","\t\tif shape[0] \u003c= 0 {","\t\t\treturn apl.EmptyArray{}, nil","\t\t}","\t\tvar v apl.Value","\t\tif first {","\t\t\tv = ar.At(0)","\t\t} else {","\t\t\tv = ar.At(shape[0] - 1)","\t\t}","\t\treturn v.Copy(), nil","\t}","","\t// Create a new array","\tinner := shape[len(shape)-1]","\tnewshape := apl.CopyShape(ar)","\tnewshape = newshape[:len(newshape)-1]","\tres := apl.MakeArray(ar, newshape)","\ti := 0","\tn := 0 // index over inner axis.","\tfor k := 0; k \u003c ar.Size(); k++ {","\t\tif first \u0026\u0026 n == 0 {","\t\t\tres.Set(i, ar.At(k).Copy())","\t\t\ti++","\t\t} else if first == false \u0026\u0026 n == inner-1 {","\t\t\tres.Set(i, ar.At(k).Copy())","\t\t\ti++","\t\t}","\t\tn++","\t\tif n == inner {","\t\t\tn = 0","\t\t}","\t}","\treturn res, nil","}",""],"register.go":["package xgo","","import (","\t\"fmt\"","\t\"reflect\"","\t\"strings\"","","\t\"github.com/ktye/iv/apl\"",")","","func Register(a *apl.Apl, name string) {","\tif name == \"\" {","\t\tname = \"go\"","\t}","\tpkg := map[string]apl.Value{","\t\t\"t\":      New(reflect.TypeOf(T{})),","\t\t\"s\":      New(reflect.TypeOf(S{})),","\t\t\"i\":      New(reflect.TypeOf(I(0))),","\t\t\"source\": source{},","\t\t\"echo\":   echo{},","\t}","\ta.RegisterPackage(\"go\", pkg)","}","","type I int","","// T is an example struct with methods with pointer receivers.","type T struct {","\tA string","\tI int","\tF float64","\tC complex128","\tV []string","\tS S","}","","func (t *T) Inc() {","\tt.I++","}","","func (t *T) Join(sep string) (int, string) {","\ts := strings.Join(t.V, sep)","\treturn len(t.V), s","}","","// S is an example struct with a method without pointer receiver.","type S struct {","\tA int","\tB int","\tV []int","}","","func (s S) Sum() int {","\treturn s.A + s.B","}","","// source returns a Channel to pull numbers from.","// It stops if the max value is reached or the channel is closed.","// It is used for demonstrating apl.Channel.","type source struct{}","","func (_ source) String(f apl.Format) string {","\treturn \"source\"","}","func (s source) Copy() apl.Value { return s }","","func (s source) Call(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tnum, ok := R.(apl.Number)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"source: r must be a number\")","\t}","\tn, ok := num.ToIndex()","\tif ok == false || n \u003c= 0 {","\t\treturn nil, fmt.Errorf(\"source: R must be a positive integer\")","\t}","\tc := apl.NewChannel()","\tgo func(c apl.Channel) {","\t\tfor i := 0; i \u003c n; i++ {","\t\t\tselect {","\t\t\tcase \u003c-c[1]:","\t\t\t\tclose(c[0])","\t\t\t\treturn","\t\t\tdefault:","\t\t\t\tc[0] \u003c- apl.Int(i)","\t\t\t}","\t\t}","\t\tclose(c[0])","\t}(c)","\treturn c, nil","}","","// echo returns a Channel which echos what was send to it.","type echo struct{}","","func (_ echo) String(f apl.Format) string {","\treturn \"echo\"","}","func (e echo) Copy() apl.Value { return e }","","func (_ echo) Call(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tp := \"\"","\tif s, ok := R.(apl.String); ok == false || len(s) == 0 {","\t\treturn nil, fmt.Errorf(\"echo: R must be a non-empty string\")","\t} else {","\t\tp = string(s)","\t}","\tc := apl.NewChannel()","\tgo func(c apl.Channel) {","\t\tvar buf []apl.Value","\t\ts := \"empty stack\"","\t\tfor {","\t\t\tselect {","\t\t\tcase r, ok := \u003c-c[1]:","\t\t\t\tif ok == false {","\t\t\t\t\tclose(c[0])","\t\t\t\t\treturn","\t\t\t\t}","\t\t\t\tbuf = append(buf, r)","\t\t\t\tif len(buf) == 1 {","\t\t\t\t\ts = p + r.String(a.Format)","\t\t\t\t}","\t\t\tcase c[0] \u003c- apl.String(s):","\t\t\t\tif len(buf) \u003e 1 {","\t\t\t\t\tcopy(buf, buf[1:])","\t\t\t\t\tbuf = buf[:len(buf)-1]","\t\t\t\t\tif len(buf) \u003e 0 {","\t\t\t\t\t\ts = p + buf[0].String(a.Format)","\t\t\t\t\t}","\t\t\t\t} else if len(buf) == 1 {","\t\t\t\t\tbuf = buf[:0]","\t\t\t\t\ts = p + \"empty stack\"","\t\t\t\t}","\t\t\t}","\t\t}","\t\tclose(c[0])","\t}(c)","\treturn c, nil","}",""],"reverse.go":["package primitives","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"⌽\",","\t\tdoc:    \"reverse\",","\t\tDomain: Monadic(nil),","\t\tfn:     revLast,","\t\tsel:    selection(revLast),","\t})","\tregister(primitive{","\t\tsymbol: \"⊖\",","\t\tdoc:    \"reverse first\",","\t\tDomain: Monadic(nil),","\t\tfn:     revFirst,","\t\tsel:    selection(revFirst),","\t})","\t// TODO reverse with axis","","\tregister(primitive{","\t\tsymbol: \"⌽\",","\t\tdoc:    \"rotate\",","\t\tDomain: Dyadic(Split(ToIndexArray(nil), nil)),","\t\tfn:     rotLast,","\t\tsel:    selection(rotLast),","\t})","\tregister(primitive{","\t\tsymbol: \"⊖\",","\t\tdoc:    \"rotate first\",","\t\tDomain: Dyadic(Split(ToIndexArray(nil), nil)),","\t\tfn:     rotFirst,","\t\tsel:    selection(rotFirst),","\t})","\t// TODO rotate with axis","}","","func revLast(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\treturn reverse(a, R, -1)","}","func revFirst(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\treturn reverse(a, R, 0)","}","func reverse(a *apl.Apl, R apl.Value, axis int) (apl.Value, error) {","\tif _, ok := R.(apl.Axis); ok {","\t\tif r, n, err := splitAxis(a, R); err != nil {","\t\t\treturn nil, err","\t\t} else {","\t\t\tR = r","\t\t\tif len(n) != 1 {","\t\t\t\treturn nil, fmt.Errorf(\"reverse with axis: axis must be a scalar or length 1\")","\t\t\t}","\t\t\taxis = n[0]","\t\t}","\t}","","\tar, ok := R.(apl.Array)","","\t// Scalar values are returned as scalars.","\tif ok == false {","\t\treturn R, nil","\t}","","\tshape := ar.Shape()","\tif axis \u003c 0 {","\t\taxis = len(shape) + axis","\t}","\tif axis \u003c 0 || axis \u003e= len(shape) {","\t\treturn nil, fmt.Errorf(\"reverse: axis out of range: %d  (rank %d)\", axis, len(shape))","\t}","","\tres := apl.MakeArray(ar, nil)","\tic, src := apl.NewIdxConverter(shape)","\tdst := make([]int, len(shape)) // dst index vector","\tfor i := 0; i \u003c res.Size(); i++ {","\t\tcopy(src, dst) // sic: copy dst over src","\t\tsrc[axis] = shape[axis] - src[axis] - 1","\t\tres.Set(i, ar.At(ic.Index(src)).Copy())","\t\tapl.IncArrayIndex(dst, shape)","\t}","\treturn res, nil","}","","func rotLast(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\treturn rotate(a, L, R, -1)","}","func rotFirst(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\treturn rotate(a, L, R, 0)","}","","// rotate R around axis by L.","// L is a Vector which should be convertable to index.","// It must have the shape of R, with the axis removed.","// It it is a single element array, it is repeated to conform.","func rotate(a *apl.Apl, L, R apl.Value, axis int) (apl.Value, error) {","\tif _, ok := R.(apl.Axis); ok {","\t\tif r, n, err := splitAxis(a, R); err != nil {","\t\t\treturn nil, err","\t\t} else {","\t\t\tR = r","\t\t\tif len(n) != 1 {","\t\t\t\treturn nil, fmt.Errorf(\"rotate with axis: axis must be a scalar or length 1\")","\t\t\t}","\t\t\taxis = n[0]","\t\t}","\t}","","\tar, ok := R.(apl.Array)","","\t// Scalar R are returned as scalars.","\tif ok == false {","\t\treturn R, nil","\t}","","\tshape := ar.Shape()","","\tal := L.(apl.IntArray)","\tlshape := al.Shape()","","\trot := func(i, n, size int) int {","\t\tk := (i + n) % size","\t\tif k \u003c 0 {","\t\t\tk = size + k","\t\t}","\t\treturn k","\t}","","\t// If R is a vector, shortcut.","\tif len(shape) == 1 {","\t\tif len(lshape) != 1 || lshape[0] != 1 {","\t\t\treturn nil, fmt.Errorf(\"rotate: wrong shape of L for vector R: %v\", lshape)","\t\t}","\t\tn := int(al.At(0).(apl.Int))","\t\tsize := shape[0]","","\t\tres := apl.MakeArray(ar, []int{shape[0]})","\t\tfor i := 0; i \u003c size; i++ {","\t\t\tres.Set(i, ar.At(rot(i, n, size)).Copy())","\t\t}","\t\treturn res, nil","\t}","","\tif axis \u003c 0 {","\t\taxis = len(shape) + axis","\t}","\tif axis \u003c 0 || axis \u003e= len(shape) {","\t\treturn nil, fmt.Errorf(\"rotate: illeal axis: %d (rank: %d)\", axis, len(shape))","\t}","","\t// Extend L to conform, if it is a single element array.","\tif len(lshape) == 1 \u0026\u0026 len(shape) \u003e 2 {","\t\tnewshape := make([]int, len(shape)-1)","\t\tfor i := range newshape {","\t\t\tnewshape[i] = lshape[0]","\t\t}","\t\tif rs, ok := L.(apl.Reshaper); ok {","\t\t\tnewl := rs.Reshape(newshape)","\t\t\tal = newl.(apl.IntArray)","\t\t\tlshape = al.Shape()","\t\t} else {","\t\t\treturn nil, fmt.Errorf(\"rotate: cannot reshape L\") // this should not happen","\t\t}","\t}","","\tif len(lshape) != len(shape)-1 {","\t\treturn nil, fmt.Errorf(\"rotate L: has wrong rank: %d (R: %d)\", len(lshape), len(shape))","\t}","\tfor i := range lshape {","\t\tk := i","\t\tif i \u003e= axis {","\t\t\tk = i + 1","\t\t}","\t\tif shape[k] != lshape[i] {","\t\t\treturn nil, fmt.Errorf(\"rotate L: has wrong shape: %v (R: %v)\", lshape, shape)","\t\t}","\t}","","\tres := apl.MakeArray(ar, nil)","\tlic, idx := apl.NewIdxConverter(lshape)","\tric, src := apl.NewIdxConverter(shape)","\tdst := make([]int, len(shape))","\taxsize := shape[axis]","\tfor i := 0; i \u003c res.Size(); i++ {","\t\t// Calculate the rotation number n.","\t\t// Copy dst over idx, omitting axis","\t\tcopy(idx, dst[:axis])","\t\tcopy(idx[axis:], dst[axis+1:])","\t\tn := int(al.At(lic.Index(idx)).(apl.Int))","\t\tcopy(src, dst)                        // sic: copy dst over src","\t\tsrc[axis] = rot(dst[axis], n, axsize) // replace the axis by it's rotation","\t\tres.Set(i, ar.At(ric.Index(src)).Copy())","\t\tapl.IncArrayIndex(dst, shape)","\t}","\treturn res, nil","}",""],"rho.go":["package primitives","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"⍴\",","\t\tdoc:    \"shape\",","\t\tDomain: Monadic(nil),","\t\tfn:     rho1,","\t})","\tregister(primitive{","\t\tsymbol: \"⍴\",","\t\tdoc:    \"reshape\",","\t\tDomain: Dyadic(Split(ToVector(ToIndexArray(nil)), ToArray(nil))),","\t\tfn:     rho2,","\t\tsel:    selection(rho2),","\t})","\tregister(primitive{","\t\tsymbol: \"⍴\",","\t\tdoc:    \"reshape channel\",","\t\tDomain: Dyadic(Split(ToVector(ToIndexArray(nil)), IsChannel(nil))),","\t\tfn:     rhoChannel,","\t})","}","","// Rho1 returns the shape of R.","func rho1(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\t// Report a table as a two dimensional array.","\tif t, ok := R.(apl.Table); ok == true {","\t\treturn apl.IntArray{","\t\t\tDims: []int{2},","\t\t\tInts: []int{t.Rows, len(t.K)},","\t\t}, nil","\t}","\t// An object returns the number of keys.","\tif o, ok := R.(apl.Object); ok == true {","\t\tn := len(o.Keys())","\t\treturn apl.IntArray{Dims: []int{1}, Ints: []int{n}}, nil","\t}","","\tif _, ok := R.(apl.Array); ok == false {","\t\treturn apl.EmptyArray{}, nil","\t}","\t// Shape of an empty array is 0, rank is 1","\tif _, ok := R.(apl.EmptyArray); ok {","\t\treturn apl.IntArray{Ints: []int{0}, Dims: []int{1}}, nil","\t}","\tar := R.(apl.Array)","\tshape := ar.Shape()","\tret := apl.IntArray{","\t\tInts: make([]int, len(shape)),","\t\tDims: []int{len(shape)},","\t}","\tcopy(ret.Ints, shape)","\treturn ret, nil","}","","// Rho2 is dyadic reshape, L is empty or index array, R is array.","func rho2(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t// L is empty, returns empty.","\tif L.(apl.Array).Size() == 0 {","\t\treturn apl.EmptyArray{}, nil","\t}","","\tif _, ok := R.(apl.Object); ok {","\t\treturn nil, fmt.Errorf(\"cannot reshape %T\", R)","\t}","","\tl := L.(apl.IntArray)","\tshape := make([]int, len(l.Ints))","\tcopy(shape, l.Ints)","\tif rs, ok := R.(apl.Reshaper); ok {","\t\treturn rs.Reshape(shape), nil","\t}","\treturn nil, fmt.Errorf(\"cannot reshape %T\", R)","}","","// rhoChannel returns a channel and sends arrays with the shape of L.","// Values are read from a channel R.","func rhoChannel(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tif L.(apl.Array).Size() == 0 {","\t\treturn R, nil","\t}","\tal := L.(apl.IntArray)","\tsize := apl.Prod(al.Ints)","\tnewarray := func() apl.MixedArray {","\t\ts := make([]int, len(al.Ints))","\t\tcopy(s, al.Ints)","\t\treturn apl.NewMixed(s)","\t}","\tres := newarray()","","\tin := R.(apl.Channel)","\tout := apl.NewChannel()","\tgo func() {","\t\tp := 0","\t\tdefer close(out[0])","\t\tpush := func(v apl.Value) {","\t\t\tres.Values[p] = v","\t\t\tp++","\t\t\tif p == size {","\t\t\t\tselect {","\t\t\t\tcase _, ok := \u003c-out[1]:","\t\t\t\t\tif ok == false {","\t\t\t\t\t\tclose(in[1])","\t\t\t\t\t\treturn","\t\t\t\t\t}","\t\t\t\tcase out[0] \u003c- res:","\t\t\t\t\tres = newarray()","\t\t\t\t\tp = 0","\t\t\t\t}","\t\t\t}","\t\t}","\t\tfor {","\t\t\tselect {","\t\t\tcase _, ok := \u003c-out[1]:","\t\t\t\tif ok == false {","\t\t\t\t\tclose(in[1])","\t\t\t\t\treturn","\t\t\t\t}","\t\t\tcase v, ok := \u003c-in[0]:","\t\t\t\tif ok == false {","\t\t\t\t\treturn","\t\t\t\t}","\t\t\t\tif ar, ok := v.(apl.Array); ok {","\t\t\t\t\tfor i := 0; i \u003c ar.Size(); i++ {","\t\t\t\t\t\tpush(ar.At(i))","\t\t\t\t\t}","\t\t\t\t} else {","\t\t\t\t\tpush(v)","\t\t\t\t}","\t\t\t}","\t\t}","\t}()","\treturn out, nil","}",""],"rpc.go":["// Package rpc adds remove procedure calls to APL.","package rpc","","import (","\t\"encoding/gob\"","\t\"fmt\"","\t\"net\"","","\t\"github.com/ktye/iv/apl\"",")","","func Dial(address string) (Conn, error) {","\tc, err := net.Dial(\"tcp\", address)","\tif err != nil {","\t\treturn Conn{}, err","\t}","\treturn Conn{Conn: c}, nil","}","","type Conn struct {","\tnet.Conn","}","","func (c Conn) String(f apl.Format) string {","\tremote := c.RemoteAddr()","\tif remote == nil {","\t\treturn fmt.Sprintf(\"rpc→conn not connected\")","\t}","\treturn fmt.Sprintf(\"rpc→conn to %s\", remote.String())","}","func (c Conn) Copy() apl.Value { return c }","","func (c Conn) Close() (apl.Value, error) {","\tif c.Conn == nil {","\t\treturn nil, fmt.Errorf(\"not connected\")","\t}","\tif err := c.Conn.Close(); err != nil {","\t\treturn nil, err","\t}","\treturn apl.Int(1), nil","}","","func (c Conn) Call(f string, L, R apl.Value) (apl.Value, error) {","\treq := Request{Fn: f, L: L, R: R}","\tif err := gob.NewEncoder(c.Conn).Encode(req); err != nil {","\t\tc.Conn.Close()","\t\treturn nil, err","\t}","\tvar res Response","\tif err := gob.NewDecoder(c.Conn).Decode(\u0026res); err != nil {","\t\tc.Conn.Close()","\t\treturn nil, err","\t}","\tif res.Err != \"\" {","\t\treturn nil, fmt.Errorf(\"%s\", res.Err)","\t} else if res.V == nil {","\t\treturn nil, fmt.Errorf(\"empty result\")","\t}","\treturn res.V, nil","}",""],"runtime.go":["package a","","import (","\t\"reflect\"","\t\"runtime\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/xgo\"",")","","// Memstats returns runtime.MemStats as an object.","func Memstats(p *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tvar m runtime.MemStats","\truntime.ReadMemStats(\u0026m)","\treturn xgo.Convert(reflect.ValueOf(m))","}","","func cpus(p *apl.Apl, _, R apl.Value) (apl.Value, error) {","\treturn apl.Int(runtime.NumCPU()), nil","}","","func goroutines(p *apl.Apl, _, R apl.Value) (apl.Value, error) {","\treturn apl.Int(runtime.NumGoroutine()), nil","}","","func goversion(p *apl.Apl, _, R apl.Value) (apl.Value, error) {","\treturn apl.String(runtime.Version()), nil","}",""],"scalar.go":["package domain","","import \"github.com/ktye/iv/apl\"","","// ToScalar accepts scalars and converts single element arrays to scalars.","func ToScalar(child SingleDomain) SingleDomain {","\treturn scalar{child, true}","}","","// IsScalar accepts values that are not arrays.","func IsScalar(child SingleDomain) SingleDomain {","\treturn scalar{child, false}","}","","type scalar struct {","\tchild   SingleDomain","\tconvert bool","}","","func (s scalar) To(a *apl.Apl, V apl.Value) (apl.Value, bool) {","\tv := V","\tif ar, ok := V.(apl.Array); ok {","\t\tif s.convert == false {","\t\t\treturn V, false","\t\t}","\t\tif n := ar.Size(); n != 1 {","\t\t\treturn V, false","\t\t}","\t\tv = ar.At(0)","\t}","\treturn propagate(a, v, s.child)","}","func (s scalar) String(f apl.Format) string {","\tname := \"scalar\"","\tif s.convert {","\t\tname = \"toscalar\"","\t}","\tif s.child == nil {","\t\treturn name","\t}","\treturn name + \" \" + s.child.String(f)","}",""],"scan.go":["// Package scan contains the tokenizer for iv/apl","package scan","","import (","\t\"fmt\"","\t\"io\"","\t\"sort\"","\t\"strconv\"","\t\"strings\"","\t\"unicode\"","\t\"unicode/utf8\"",")","","type Token struct {","\tT   Type","\tS   string","\tPos int","}","","type Type int","","const (","\tEndl       Type = iota","\tSymbol          // single rune APL symbol","\tNumber          // 1 1.23 1.234E12 -1.234 1.234J2","\tString          // \"quoted text\", \"escape \"\" with double quotes\" `alpha","\tChars           // 'rune vector' in single quotes","\tIdentifier      // alpha_3","\tLeftParen       // (","\tRightParen      // )","\tLeftBrack       // ]","\tRightBrack      // ]","\tLeftBrace       // {","\tRightBrace      // }","\tColon           // :","\tSemicolon       // ;","\tSelf            // ∇","\tDiamond         // ⋄",")","","// Scanner can split APL input into tokens.","// SetSymbols must be called before using the scanner.","type Scanner struct {","\tinput    string","\ttokens   []Token","\tsymbols  map[rune]string","\tcommands map[string]Command","\tpos      int","\twidth    int","}","","// SetSymbols initializes the Scanner to recognize the given APL symbols.","// In the map, both the rune and the string are the same letter.","func (s *Scanner) SetSymbols(symbols map[rune]string) {","\ts.symbols = symbols","}","","// AddCommands sets token rewrite commands.","func (s *Scanner) AddCommands(commands map[string]Command) {","\tif s.commands == nil {","\t\ts.commands = make(map[string]Command)","\t}","\tfor name, cmd := range commands {","\t\ts.commands[name] = cmd","\t}","}","","// Commands returns a list of commands.","func (s *Scanner) Commands() []string {","\tl := make([]string, len(s.commands))","\ti := 0","\tfor c := range s.commands {","\t\tl[i] = c","\t\ti++","\t}","\tsort.Strings(l)","\treturn l","}","","// A command is a function that rewrites a token list.","// It is recognized by a leading / or \\.","// The identifier following is the command name.","// Commands are set by registering package a.","type Command interface {","\tRewrite(l []Token) []Token","}","","// Scan returns the tokens from one line of APL input.","func (s *Scanner) Scan(line string) ([]Token, error) {","\ts.input = line","\ts.pos = 0","\ts.width = 0","\ts.tokens = nil","\tfor {","\t\tpos := s.pos","\t\tif t, err := s.nextToken(); err != nil {","\t\t\treturn nil, err","\t\t} else if t.T == Endl {","\t\t\tbreak","\t\t} else {","\t\t\tt.Pos = pos","\t\t\ts.tokens = append(s.tokens, t)","\t\t}","\t}","\treturn s.applyCmds(s.tokens), nil","}","","func (t Type) String() string {","\tvar s string","\tswitch t {","\tcase LeftParen:","\t\ts = \"(\"","\tcase RightParen:","\t\ts = \")\"","\tcase LeftBrack:","\t\ts = \"[\"","\tcase RightBrack:","\t\ts = \"]\"","\tcase LeftBrace:","\t\ts = \"{\"","\tcase RightBrace:","\t\ts = \"}\"","\tdefault:","\t\t// The other type are not printed.","\t\ts = \"?\"","\t}","\treturn s","}","","func (t Token) String() string {","\tvar s string","\tswitch t.T {","\tcase Symbol:","\t\ts = \"X\"","\tcase Number:","\t\ts = \"N\"","\tcase String:","\t\ts = \"S\"","\tcase Chars:","\t\ts = \"c\"","\tcase Identifier:","\t\ts = \"I\"","\tcase LeftParen, RightParen, LeftBrack, RightBrack, LeftBrace, RightBrace:","\t\ts = \"P\"","\tcase Colon:","\t\ts = \":\"","\tcase Semicolon:","\t\ts = \";\"","\tcase Self:","\t\ts = \"∇\"","\tcase Diamond:","\t\ts = \"⋄\"","\tcase Endl:","\t\ts = \"NULL\"","\tdefault:","\t\tpanic(\"no stringer for token type \" + strconv.Itoa(int(t.T)))","\t}","\treturn s + \"(\" + t.S + \")\"","}","","func PrintTokens(t []Token) string {","\tif len(t) == 0 {","\t\treturn \"[]\"","\t}","\tv := make([]string, len(t))","\tfor i := range t {","\t\tv[i] = t[i].String()","\t}","\treturn \"[\" + strings.Join(v, \",\") + \"]\"","}","","func (s *Scanner) ReadRune() (rune, int, error) {","\tr, w := s.nextRune()","\tif r == -1 {","\t\treturn -1, 0, io.EOF","\t}","\treturn r, w, nil","}","","func (s *Scanner) UnreadRune() error {","\ts.unreadRune()","\treturn nil","}","","func (s *Scanner) nextRune() (rune, int) {","\tif s.pos \u003e= len(s.input) {","\t\treturn -1, 0","\t}","\tr, w := utf8.DecodeRuneInString(s.input[s.pos:])","\ts.pos += w","\ts.width = w","\treturn r, w","}","","// unreadRune can be called once to set the position to the last state.","func (s *Scanner) unreadRune() {","\ts.pos -= s.width","\ts.width = 0","}","","// Peek is like nextRune, but does not advance the position.","func (s *Scanner) peek() rune {","\tif s.pos \u003e= len(s.input) {","\t\treturn -1","\t}","\tr, _ := utf8.DecodeRuneInString(s.input[s.pos:])","\treturn r","}","","func (s *Scanner) nextToken() (Token, error) {","\tfor {","\t\tr, _ := s.nextRune()","\t\tif r == -1 {","\t\t\treturn Token{T: Endl}, nil","\t\t}","","\t\tif r == '\"' || r == '\\'' || r == '`' {","\t\t\treturn s.scanString(r)","\t\t}","","\t\t// A number starts with [0-9] or \".\" or \"¯\".","\t\tif (r \u003e= '0' \u0026\u0026 r \u003c= '9') || r == '.' || r == '¯' {","\t\t\tif r == '.' {","\t\t\t\t// If it start with . a digit must follow,","\t\t\t\t// otherwise it could be the dot operator.","\t\t\t\tif n := s.peek(); n \u003e= '0' \u0026\u0026 n \u003c= '9' {","\t\t\t\t\ts.unreadRune()","\t\t\t\t\treturn s.scanNumber()","\t\t\t\t}","\t\t\t} else {","\t\t\t\ts.unreadRune()","\t\t\t\treturn s.scanNumber()","\t\t\t}","\t\t}","","\t\t// Registered APL symbols.","\t\tif r, ok := s.symbols[r]; ok {","\t\t\treturn Token{T: Symbol, S: r}, nil","\t\t}","","\t\tif AllowedInVarname(r, true) {","\t\t\ts.unreadRune()","\t\t\treturn s.scanIdentifier()","\t\t}","","\t\tswitch r {","\t\tcase '(':","\t\t\treturn Token{T: LeftParen, S: \"(\"}, nil","\t\tcase ')':","\t\t\treturn Token{T: RightParen, S: \")\"}, nil","\t\tcase '[':","\t\t\treturn Token{T: LeftBrack, S: \"[\"}, nil","\t\tcase ']':","\t\t\treturn Token{T: RightBrack, S: \"]\"}, nil","\t\tcase '{':","\t\t\treturn Token{T: LeftBrace, S: \"{\"}, nil","\t\tcase '}':","\t\t\treturn Token{T: RightBrace, S: \"}\"}, nil","\t\tcase ':':","\t\t\treturn Token{T: Colon, S: \":\"}, nil","\t\tcase ';':","\t\t\treturn Token{T: Semicolon, S: \";\"}, nil","\t\tcase '∇':","\t\t\treturn Token{T: Self, S: \"∇\"}, nil","\t\tcase '⋄':","\t\t\treturn Token{T: Diamond, S: \"⋄\"}, nil","\t\tcase ' ', '\\r', '\\t':","\t\t\tcontinue // ignore whitespace, newline should not be present.","\t\tcase '⍝':","\t\t\treturn Token{T: Endl}, nil","\t\tdefault:","\t\t\treturn Token{}, fmt.Errorf(\"unexpected rune: %U (%d %c)\", r, r, r)","\t\t}","\t}","\treturn Token{T: Endl}, nil","}","","// ScanNumber scans the next number.","// It starts with a digit, ¯ or dot","// and stops before a character is not digit, a-zA-Z, dot or ¯.","// Valid number formats are not known to the scanner.","// Parsing is done by the parser with the current numerical tower.","func (s *Scanner) scanNumber() (Token, error) {","\tnum, err := ScanNumber(s)","\tif err != nil {","\t\treturn Token{}, err","\t}","\treturn Token{T: Number, S: num}, nil","}","","// ScanNumber reads the next number from s.","// The string is not parsed and may not be a valid number.","func ScanNumber(s io.RuneScanner) (string, error) {","\tvar buf strings.Builder","\tfor {","\t\tr, _, err := s.ReadRune()","\t\tif err == io.EOF {","\t\t\treturn buf.String(), nil","\t\t} else if err != nil {","\t\t\treturn \"\", err","\t\t} else if r \u003e= '0' \u0026\u0026 r \u003c= '9' {","\t\t\tbuf.WriteRune(r)","\t\t} else if r \u003e= 'a' \u0026\u0026 r \u003c= 'z' {","\t\t\tbuf.WriteRune(r)","\t\t} else if r \u003e= 'A' \u0026\u0026 r \u003c= 'Z' {","\t\t\tbuf.WriteRune(r)","\t\t} else if r == '.' {","\t\t\tbuf.WriteRune(r)","\t\t} else if r == '¯' {","\t\t\tbuf.WriteRune(r)","\t\t} else {","\t\t\ts.UnreadRune()","\t\t\treturn buf.String(), nil","\t\t}","\t}","}","","// ScanString returns the next token as charstr or chars depending on the quoteChar.","// \" scans the string as charstr and ' as chars.","// There is currently no way to escape newlines etc.","func (s *Scanner) scanString(quoteChar rune) (Token, error) {","\ts.unreadRune()","\tstr, err := ReadString(s)","\tif err != nil {","\t\treturn Token{}, err","\t}","\tif quoteChar == '\\'' {","\t\treturn Token{T: Chars, S: str}, nil","\t}","\treturn Token{T: String, S: str}, nil","}","","// An identifier may start with _ or a unicode letter.","// Later characters may also be digits.","// A → may be present within an identifier.","func (s *Scanner) scanIdentifier() (Token, error) {","\tvar buf strings.Builder","\tfirst := true","\tarrow := false","\tfor {","\t\tr, _ := s.nextRune()","\t\tif AllowedInVarname(r, first) {","\t\t\tbuf.WriteRune(r)","\t\t} else if r == '→' \u0026\u0026 arrow == false {","\t\t\tbuf.WriteRune(r)","\t\t\tarrow = true","\t\t} else {","\t\t\tif r != -1 {","\t\t\t\ts.unreadRune()","\t\t\t}","\t\t\tif first {","\t\t\t\treturn Token{}, fmt.Errorf(\"cannot scan empty identifier\")","\t\t\t} else {","\t\t\t\treturn Token{T: Identifier, S: buf.String()}, nil","\t\t\t}","\t\t}","\t\tfirst = false","\t}","}","","// AllowedinVarname returns true if the rune is allowed in a variable name.","func AllowedInVarname(r rune, first bool) bool {","\tif first \u0026\u0026 strings.IndexRune(\"⎕⍺⍵\", r) != -1 {","\t\treturn true","\t}","\tif first == false \u0026\u0026 unicode.IsNumber(r) {","\t\treturn true","\t}","\treturn r == '_' || unicode.IsLetter(r)","}","","// applyCmds applyes rewrite rules recursively.","// In /e/h* first /h is applyd to * then /e on the result.","func (s *Scanner) applyCmds(t []Token) []Token {","\tif s.commands == nil {","\t\treturn t","\t}","\tif len(t) \u003e 1 \u0026\u0026 t[0].T == Symbol \u0026\u0026 (t[0].S == \"/\" || t[0].S == `\\`) \u0026\u0026 t[1].T == Identifier {","\t\tcmd, ok := s.commands[string(t[1].S)]","\t\tif ok {","\t\t\tt = s.applyCmds(t[2:])","\t\t\treturn cmd.Rewrite(t)","\t\t}","\t}","\treturn t","}","","// ReadString parses the next string from the Reader.","// The first rune must be \", ' or `.","// Double quote parses a quoted string in the format of strconv.Quote.","// Single quote parses verbatim until the next single quote, that is not followed by another single quote.","// Two single quotes are interpreted as one. APL splits single-quoted strings them into a rune array.","// Backtick parses verbatim until the next `}])⋄# or a unicode whitespace rune.","func ReadString(s io.RuneScanner) (string, error) {","\tr, _, err := s.ReadRune()","\tif err != nil {","\t\treturn \"\", err","\t}","\tif strings.ContainsRune(\"`'\\\"\", r) == false {","\t\treturn \"\", fmt.Errorf(\"not a string\")","\t}","\tquoteChar := r","","\tvar str strings.Builder","\tif quoteChar == '`' {","\tloop:","\t\tfor {","\t\t\tr, _, err := s.ReadRune()","\t\t\tif err == io.EOF {","\t\t\t\tbreak loop","\t\t\t} else if err != nil {","\t\t\t\treturn \"\", err","\t\t\t}","\t\t\tif unicode.IsSpace(r) {","\t\t\t\ts.UnreadRune()","\t\t\t\tbreak loop","\t\t\t}","\t\t\tswitch r {","\t\t\tcase '`', '}', ']', ')', '⋄', '#', ';':","\t\t\t\ts.UnreadRune()","\t\t\t\tbreak loop","\t\t\tdefault:","\t\t\t\tstr.WriteRune(r)","\t\t\t}","\t\t}","\t\treturn str.String(), nil","\t} else if quoteChar == '\\'' {","\t\tfor {","\t\t\tr, _, err := s.ReadRune()","\t\t\tif err == io.EOF {","\t\t\t\treturn \"\", fmt.Errorf(\"unquoted string: %q\", str.String())","\t\t\t} else if err != nil {","\t\t\t\treturn \"\", err","\t\t\t}","\t\t\tif r == quoteChar {","\t\t\t\t// Two quotes escapes a single one.","\t\t\t\tr, _, err := s.ReadRune()","\t\t\t\tif err == io.EOF {","\t\t\t\t\treturn str.String(), nil","\t\t\t\t}","\t\t\t\tif err == nil \u0026\u0026 r == quoteChar {","\t\t\t\t\tstr.WriteRune(r)","\t\t\t\t\tcontinue","\t\t\t\t} else {","\t\t\t\t\ts.UnreadRune()","\t\t\t\t\treturn str.String(), nil","\t\t\t\t}","\t\t\t}","\t\t\tstr.WriteRune(r)","\t\t}","\t} else {","\t\tquoted := false","\t\tstr.WriteRune('\"')","\t\tfor {","\t\t\tr, _, err := s.ReadRune()","\t\t\tif err == io.EOF {","\t\t\t\treturn \"\", fmt.Errorf(\"unquoted string: %q\", str.String())","\t\t\t} else if err != nil {","\t\t\t\treturn \"\", err","\t\t\t}","\t\t\tstr.WriteRune(r)","\t\t\tif quoted \u0026\u0026 r != '\\\\' {","\t\t\t\tquoted = false","\t\t\t\tif r == '\"' {","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t} else if r == '\\\\' {","\t\t\t\tquoted = !quoted","\t\t\t}","\t\t\tif quoted == false \u0026\u0026 r == '\"' {","\t\t\t\tq, err := strconv.Unquote(str.String())","\t\t\t\tif err != nil {","\t\t\t\t\treturn \"\", fmt.Errorf(\"%q: %s\", str.String(), err)","\t\t\t\t}","\t\t\t\treturn q, nil","\t\t\t}","\t\t}","\t}","}",""],"select.go":["package operators","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","// selection returns a derived selection function, given an operator function that creates a derived function.","func selection(op func(*apl.Apl, apl.Value, apl.Value) apl.Function) func(*apl.Apl, apl.Value, apl.Value, apl.Value, apl.Value) (apl.IntArray, error) {","\tderived := func(a *apl.Apl, L, LO, RO, R apl.Value) (apl.IntArray, error) {","","\t\t// Create the derived function.","\t\tdf := op(a, LO, RO)","","\t\t// Create an index array with the shape of R.","\t\tvar ai apl.IntArray","\t\tar, ok := R.(apl.Array)","\t\tif ok == false {","\t\t\treturn ai, fmt.Errorf(\"cannot select from %T\", R)","\t\t}","\t\tai.Dims = apl.CopyShape(ar)","\t\tai.Ints = make([]int, apl.Prod(ai.Dims))","\t\tfor i := range ai.Ints {","\t\t\tai.Ints[i] = i + 1","\t\t}","","\t\t// Apply the selection function to the index array.","\t\tv, err := df.Call(a, L, ai)","\t\tif err != nil {","\t\t\treturn ai, err","\t\t}","","\t\tto := ToIndexArray(nil)","\t\tif av, ok := to.To(a, v); ok == false {","\t\t\treturn ai, fmt.Errorf(\"could not convert selection to index array: %T\", v)","\t\t} else {","\t\t\tai = av.(apl.IntArray)","\t\t\tfor i := range ai.Ints {","\t\t\t\tai.Ints[i]--","\t\t\t}","\t\t\treturn ai, nil","\t\t}","\t}","\treturn derived","}","","// selectSimple returns a general selection function for selective assignment.","// It creates an index array of the same shape of R and applies f to it.","// It is used by replicate and expand which behave like primitive functions instead of operators.","// They take only 2 arguments.","func selectSimple(f func(*apl.Apl, apl.Value, apl.Value) (apl.Value, error)) func(*apl.Apl, apl.Value, apl.Value, apl.Value, apl.Value) (apl.IntArray, error) {","\treturn func(a *apl.Apl, dummyL, L apl.Value, dummyRO, R apl.Value) (apl.IntArray, error) {","","\t\t// Create an index array with the shape of R.","\t\tvar ai apl.IntArray","\t\tar, ok := R.(apl.Array)","\t\tif ok == false {","\t\t\treturn ai, fmt.Errorf(\"cannot select from %T\", R)","\t\t}","\t\tai.Dims = apl.CopyShape(ar)","\t\tai.Ints = make([]int, apl.Prod(ai.Dims))","\t\tfor i := range ai.Ints {","\t\t\tai.Ints[i] = i + 1","\t\t}","","\t\t// Apply the selection function to it.","\t\tv, err := f(a, L, ai)","\t\tif err != nil {","\t\t\treturn ai, err","\t\t}","","\t\tto := ToIndexArray(nil)","\t\tif av, ok := to.To(a, v); ok == false {","\t\t\treturn ai, fmt.Errorf(\"could not convert selection to index array: %T\", v)","\t\t} else {","\t\t\t// Fill elements will be reported as ¯1, which the assignment should ignore.","\t\t\tai = av.(apl.IntArray)","\t\t\tfor i := range ai.Ints {","\t\t\t\tai.Ints[i]--","\t\t\t}","\t\t\treturn ai, nil","\t\t}","\t}","}",""],"selection.go":["package primitives","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t\"github.com/ktye/iv/apl/domain\"",")","","// Selection returns a general selection function for selective assignment.","// It creates an index array of the same shape of R and applies f to it.","func selection(f func(*apl.Apl, apl.Value, apl.Value) (apl.Value, error)) func(*apl.Apl, apl.Value, apl.Value) (apl.IntArray, error) {","\treturn func(a *apl.Apl, L apl.Value, R apl.Value) (apl.IntArray, error) {","\t\t// Create an index array with the shape of R.","\t\tvar ai apl.IntArray","\t\tar, ok := R.(apl.Array)","\t\tif ok == false {","\t\t\treturn ai, fmt.Errorf(\"cannot select from %T\", R)","\t\t}","\t\tai.Dims = apl.CopyShape(ar)","\t\tai.Ints = make([]int, ar.Size())","\t\tfor i := range ai.Ints {","\t\t\tai.Ints[i] = i","\t\t}","","\t\t// Apply the selection function to it.","\t\tv, err := f(a, L, ai)","\t\tif err != nil {","\t\t\treturn ai, err","\t\t}","","\t\tto := domain.ToIndexArray(nil)","\t\tif av, ok := to.To(a, v); ok == false {","\t\t\treturn ai, fmt.Errorf(\"could not convert selection to index array: %T\", v)","\t\t} else {","\t\t\treturn av.(apl.IntArray), nil","\t\t}","\t}","}",""],"server.go":["package rpc","","import (","\t\"encoding/gob\"","\t\"fmt\"","\t\"log\"","\t\"net\"","","\t\"github.com/ktye/iv/apl\"",")","","// ListenAndServe puts APL into server mode.","// It accepts a single connection at a time from anyone.","func ListenAndServe(a *apl.Apl, addr string) {","\tln, err := net.Listen(\"tcp\", addr)","\tif err != nil {","\t\tlog.Fatal(err)","\t}","\tdefer ln.Close()","","\tlog.Print(\"listen on \", addr)","\tfor {","\t\tconn, err := ln.Accept()","\t\tif err != nil {","\t\t\tlog.Print(err)","\t\t} else {","\t\t\thandle(a, conn)","\t\t}","\t}","}","","type Request struct {","\tFn   string","\tL, R apl.Value","}","","type Response struct {","\tErr string","\tV   apl.Value","}","","func handle(a *apl.Apl, cn net.Conn) {","\tlog.Print(\"conn \", cn.RemoteAddr())","\tvar req Request","\tfor {","\t\tvar res Response","\t\tif err := gob.NewDecoder(cn).Decode(\u0026req); err != nil {","\t\t\tres.Err = err.Error()","\t\t} else {","\t\t\tif v, err := exec(a, req); err != nil {","\t\t\t\tres.Err = err.Error()","\t\t\t} else {","\t\t\t\tres.V = v","\t\t\t}","\t\t}","\t\tif err := gob.NewEncoder(cn).Encode(res); err != nil {","\t\t\tlog.Print(err)","\t\t\tcn.Close()","\t\t\treturn","\t\t}","\t}","}","","func exec(a *apl.Apl, req Request) (apl.Value, error) {","\tif req.R == nil {","\t\treturn nil, fmt.Errorf(\"right argument is nil\")","\t}","\tif p, err := a.Parse(req.Fn); err != nil {","\t\treturn nil, err","\t} else if len(p) != 1 {","\t\treturn nil, fmt.Errorf(\"expected a single function expression: got %d\", len(p))","\t} else if v, err := p[0].Eval(a); err != nil {","\t\treturn nil, err","\t} else if f, ok := v.(apl.Function); ok == false {","\t\treturn nil, fmt.Errorf(\"expr is not a function\")","\t} else {","\t\treturn f.Call(a, req.L, req.R)","\t}","}",""],"sqrt.go":["// Package bigfloat provides the implementation of a few additional operations for the","// standard library big.Float type.","package bigfloat","","import (","\t\"math\"","\t\"math/big\"",")","","// Sqrt returns a big.Float representation of the square root of","// z. Precision is the same as the one of the argument. The function","// panics if z is negative, returns ±0 when z = ±0, and +Inf when z =","// +Inf.","func Sqrt(z *big.Float) *big.Float {","","\t// panic on negative z","\tif z.Sign() == -1 {","\t\tpanic(\"Sqrt: argument is negative\")","\t}","","\t// √±0 = ±0","\tif z.Sign() == 0 {","\t\treturn big.NewFloat(float64(z.Sign()))","\t}","","\t// √+Inf  = +Inf","\tif z.IsInf() {","\t\treturn big.NewFloat(math.Inf(+1))","\t}","","\t// Compute √(a·2**b) as","\t//   √(a)·2**b/2       if b is even","\t//   √(2a)·2**b/2      if b \u003e 0 is odd","\t//   √(0.5a)·2**b/2    if b \u003c 0 is odd","\t//","\t// The difference in the odd exponent case is due to the fact that","\t// exp/2 is rounded in different directions when exp is negative.","\tmant := new(big.Float)","\texp := z.MantExp(mant)","\tswitch exp % 2 {","\tcase 1:","\t\tmant.Mul(big.NewFloat(2), mant)","\tcase -1:","\t\tmant.Mul(big.NewFloat(0.5), mant)","\t}","","\t// Solving x² - z = 0 directly requires a Quo call, but it's","\t// faster for small precisions.","\t//","\t// Solving 1/x² - z = 0 avoids the Quo call and is much faster for","\t// high precisions.","\t//","\t// Use sqrtDirect for prec \u003c= 128 and sqrtInverse for prec \u003e 128.","\tvar x *big.Float","\tif z.Prec() \u003c= 128 {","\t\tx = sqrtDirect(mant)","\t} else {","\t\tx = sqrtInverse(mant)","\t}","","\t// re-attach the exponent and return","\treturn x.SetMantExp(x, exp/2)","","}","","// compute √z using newton to solve","// t² - z = 0 for t","func sqrtDirect(z *big.Float) *big.Float {","\t// f(t)/f'(t) = 0.5(t² - z)/t","\thalf := big.NewFloat(0.5)","\tf := func(t *big.Float) *big.Float {","\t\tx := new(big.Float).Mul(t, t) // x = t²","\t\tx.Sub(x, z)                   // x = t² - z","\t\tx.Mul(half, x)                // x = 0.5(t² - z)","\t\treturn x.Quo(x, t)            // return x = 0.5(t² - z)/t","\t}","","\t// initial guess","\tzf, _ := z.Float64()","\tguess := big.NewFloat(math.Sqrt(zf))","","\treturn newton(f, guess, z.Prec())","}","","// compute √z using newton to solve","// 1/t² - z = 0 for x and then inverting.","func sqrtInverse(z *big.Float) *big.Float {","\t// f(t)/f'(t) = -0.5t(1 - zt²)","\tnhalf := big.NewFloat(-0.5)","\tone := big.NewFloat(1)","\tf := func(t *big.Float) *big.Float {","\t\tu := new(big.Float)","\t\tu.Mul(t, t)                     // u = t²","\t\tu.Mul(u, z)                     // u = zt²","\t\tu.Sub(one, u)                   // u = 1 - zt²","\t\tu.Mul(u, nhalf)                 // u = -0.5(1 - zt²)","\t\treturn new(big.Float).Mul(t, u) // x = -0.5t(1 - zt²)","\t}","","\t// initial guess","\tzf, _ := z.Float64()","\tguess := big.NewFloat(1 / math.Sqrt(zf))","","\t// There's another operation after newton,","\t// so we need to force it to return at least","\t// a few guard digits. Use 32.","\tx := newton(f, guess, z.Prec()+32)","\treturn x.Mul(z, x).SetPrec(z.Prec())","}",""],"stencil.go":["package operators","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(operator{","\t\tsymbol:  \"⌺\",","\t\tDomain:  DyadicOp(Split(Function(nil), ToIndexArray(nil))),","\t\tdoc:     \"stencil\",","\t\tderived: stencil,","\t})","}","","// stencil: f is a function, RO an index array and R an array.","func stencil(a *apl.Apl, f, RO apl.Value) apl.Function {","\tderived := func(a *apl.Apl, dummyL, R apl.Value) (apl.Value, error) {","\t\t// Stencil derived function must be called monadically.","\t\tif dummyL != nil {","\t\t\treturn nil, fmt.Errorf(\"stencil: derived function cannot be called dyadically\")","\t\t}","","\t\t// f is a Function","\t\tf := f.(apl.Function)","","\t\t// RO is a 2 x rank R index array with rows that indicate stencil shape and movement.","\t\tvar ai apl.IntArray","\t\tif _, ok := RO.(apl.EmptyArray); ok {","\t\t\tai = apl.IntArray{}","\t\t} else {","\t\t\tai = RO.(apl.IntArray)","\t\t}","\t\tis := ai.Shape()","\t\tif len(is) \u003e 2 {","\t\t\treturn nil, fmt.Errorf(\"stencil: rank of RO is \u003e 2: %d\", len(is))","\t\t}","","\t\t// R is an array.","\t\tar, ok := R.(apl.Array)","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"stencil: right argument must be an array: %T\", R)","\t\t}","\t\trs := ar.Shape()","\t\tif len(is) \u003e 0 \u0026\u0026 is[len(is)-1] \u003e len(rs) {","\t\t\treturn nil, fmt.Errorf(\"stencil: shape of RO is too large: %v, max: [2 %d]\", is, len(rs))","\t\t}","","\t\t// Default RO matrix.","\t\tdef := apl.IntArray{Dims: []int{2, len(rs)}}","\t\tdef.Ints = make([]int, 2*len(rs))","\t\tfor i := range def.Ints {","\t\t\tdef.Ints[i] = 1","\t\t}","\t\t// Overwrite default matrix with given values and swap.","\t\tif len(is) == 1 {","\t\t\tis = append([]int{1}, is[0])","\t\t}","\t\tic, idx := apl.NewIdxConverter(is)","\t\tfor i := 0; i \u003c ai.Size(); i++ {","\t\t\tdef.Ints[ic.Index(idx)] = int(ai.At(i).(apl.Int))","\t\t\tapl.IncArrayIndex(idx, is)","\t\t}","\t\tai = def","\t\tis = ai.Shape()","","\t\t// The result has the same shape as R.","\t\tres := apl.NewMixed(apl.CopyShape(ar))","","\t\t// The temporary array has the requested stencil shape, the first row of RO.","\t\ttmp := apl.NewMixed(ai.Ints[:len(ai.Ints)/2])","\t\tif tmp.Size() == 0 {","\t\t\treturn nil, fmt.Errorf(\"stencil: stencil size is 0\")","\t\t}","","\t\t// lvec is the left vector for the stencil function application,","\t\t// which indicates the number of fill elements per axis.","\t\tlvec := apl.IntArray{Dims: []int{len(rs)}}","\t\tvec := make([]int, len(rs))","\t\tlvec.Ints = vec","","\t\t// Apply the stencil to all elements of R.","\t\tic, idx = apl.NewIdxConverter(rs)","\t\tsdx := make([]int, len(tmp.Dims))","\t\tdst := make([]int, len(idx))","\t\tfor i := 0; i \u003c len(res.Values); i++ {","","\t\t\t// Center the stencil on idx.","\t\t\tic.Indexes(i, idx)","\t\t\tcopy(dst, idx)","\t\t\tfor k := range vec {","\t\t\t\tvec[k] = 0","\t\t\t}","\t\t\tfor k := range tmp.Values {","\t\t\t\tout := false","\t\t\t\tfor d := range tmp.Dims {","\t\t\t\t\tdst[d] = idx[d] + sdx[d] - tmp.Dims[d]/2","\t\t\t\t\tif dst[d] \u003c 0 || dst[d] \u003e= res.Dims[d] {","\t\t\t\t\t\tout = true","\t\t\t\t\t}","\t\t\t\t\tif v := dst[d]; v \u003c 0 \u0026\u0026 -v \u003e vec[d] {","\t\t\t\t\t\t// Positive lvec value indicates the padding preceeds the array.","\t\t\t\t\t\tvec[d] = -v","\t\t\t\t\t} else if v = dst[d] + 1 - tmp.Dims[d]; v \u003e 0 \u0026\u0026 -v \u003c vec[d] {","\t\t\t\t\t\t// Negative lvec value indicates padding follows the array values.","\t\t\t\t\t\tvec[d] = -v","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif out {","\t\t\t\t\ttmp.Values[k] = apl.Int(0)","\t\t\t\t} else {","\t\t\t\t\ttmp.Values[k] = ar.At(ic.Index(dst)).Copy()","\t\t\t\t}","\t\t\t\tapl.IncArrayIndex(sdx, tmp.Dims)","\t\t\t}","","\t\t\t// Apply the stencil and set the result.","\t\t\tv, err := f.Call(a, lvec, tmp)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\t// We only accept scalar results. Is that ok?","\t\t\tif _, ok := v.(apl.Array); ok {","\t\t\t\treturn nil, fmt.Errorf(\"stencil function must return a scalar, not an array\")","\t\t\t}","\t\t\tres.Values[i] = v.Copy()","","\t\t\tapl.IncArrayIndex(idx, rs)","\t\t}","\t\treturn a.UnifyArray(res), nil","\t}","\treturn function(derived)","}",""],"string.go":["package apl","","import (","\t\"fmt\"","\t\"io\"","\t\"io/ioutil\"","\t\"reflect\"",")","","type String string","","// String prints a string.","func (s String) String(f Format) string {","\tfs := f.Fmt[reflect.TypeOf(s)]","\tif fs == \"\" {","\t\tif f.PP \u003c 0 {","\t\t\tfs = \"%q\"","\t\t}","\t}","\tif fs == \"\" {","\t\treturn string(s)","\t}","\treturn fmt.Sprintf(fs, string(s))","}","","func (s String) Copy() Value {","\treturn s","}","","func (s String) Eval(a *Apl) (Value, error) {","\treturn s, nil","}","","func (s String) ReadFrom(a *Apl, r io.Reader) (Value, error) {","\tb, err := ioutil.ReadAll(r)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn String(b), nil","}","","// Less implements primitives.lesser to be used for comparison and sorting.","func (s String) Less(r Value) (Bool, bool) {","\tb, ok := r.(String)","\tif ok == false {","\t\treturn false, false","\t}","\treturn s \u003c b, true","}","","func (s String) Export() reflect.Value {","\treturn reflect.ValueOf(string(s))","}","","// StringArray is a uniform array of strings.","type StringArray struct {","\tDims    []int","\tStrings []string","}","","func (s StringArray) String(f Format) string {","\treturn ArrayString(f, s)","}","","func (s StringArray) Copy() Value {","\tr := StringArray{Dims: CopyShape(s), Strings: make([]string, len(s.Strings))}","\tcopy(r.Strings, s.Strings)","\treturn r","}","","func (s StringArray) At(i int) Value {","\treturn String(s.Strings[i])","}","","func (s StringArray) Shape() []int {","\treturn s.Dims","}","","func (s StringArray) Size() int {","\treturn len(s.Strings)","}","","func (s StringArray) Zero() Value {","\treturn String(\"\")","}","","func (s StringArray) Set(i int, v Value) error {","\tif i \u003c 0 || i \u003e len(s.Strings) {","\t\treturn fmt.Errorf(\"index out of range\")","\t}","\tif c, ok := v.(String); ok {","\t\ts.Strings[i] = string(c)","\t\treturn nil","\t}","\treturn fmt.Errorf(\"cannot assign %T to StringArray\", v)","}","","func (s StringArray) Make(shape []int) Uniform {","\treturn StringArray{","\t\tDims:    shape,","\t\tStrings: make([]string, Prod(shape)),","\t}","}","","func makeStringArray(v []Value) StringArray {","\tstr := make([]string, len(v))","\tfor i, e := range v {","\t\tstr[i] = string(e.(String))","\t}","\treturn StringArray{","\t\tDims:    []int{len(v)},","\t\tStrings: str,","\t}","}","","func (s StringArray) Reshape(shape []int) Value {","\tres := StringArray{","\t\tDims:    shape,","\t\tStrings: make([]string, Prod(shape)),","\t}","\tk := 0","\tfor i := range res.Strings {","\t\tres.Strings[i] = s.Strings[k]","\t\tk++","\t\tif k == len(s.Strings) {","\t\t\tk = 0","\t\t}","\t}","\treturn res","}",""],"table.go":["package apl","","import (","\t\"bytes\"","\t\"encoding/csv\"","\t\"fmt\"","\t\"io\"","\t\"reflect\"","\t\"strings\"","\t\"text/tabwriter\"",")","","// A Table is a transposed dictionary where each value is a vector","// with the same number of elements and unique type.","// Tables are constructed by transposing dictionaries T←⍉D","//","// Indexing tables selects rows:","//\tT[⍳5]","// returns a table with the first 5 rows.","// Right arrow indexing selects columns, just like a dict.","//\tT→Col1 // TODO update","// Sorting by column","//\tT[⍋T→Time] // TODO update","// Selecting rows","//\tT[⍸T→Qty\u003e5] // TODO update","type Table struct {","\t*Dict","\tRows int","}","","// String formats a table using a tabwriter.","// Each value is printed using by it's String method, same as ⍕V.","func (t Table) String(f Format) string {","\tif f.PP == -2 || f.PP == -3 {","\t\treturn t.Dict.String(f)","\t}","\tvar b bytes.Buffer","\tif err := t.WriteFormatted(f, nil, \u0026b); err != nil {","\t\treturn \"\"","\t}","\treturn string(b.Bytes())","}","func (t Table) Copy() Value {","\tr := Table{Rows: t.Rows}","\tif t.Dict != nil {","\t\tr.Dict = t.Dict.Copy().(*Dict)","\t}","\treturn r","}","","// Csv writes a table in csv format.","// If L is nil, it uses ⍕V on each value.","// If L is a dict with conforming keys, it uses the values as left arguments to format (L[Key])⍕V","// for columns of the corresponding keys.","func (t Table) Csv(f Format, L Object, w io.Writer) error {","\tcw := csv.NewWriter(w)","\tif err := t.write(f, L, csvTable{cw}); err != nil {","\t\treturn err","\t}","\tcw.Flush()","\treturn nil","}","","// WriteFormatted writes the table with a tablwriter.","// The format of the values is given by L in the same way as for Csv.","func (t Table) WriteFormatted(f Format, L Object, w io.Writer) error {","\ttw := tabwriter.NewWriter(w, 1, 0, 1, ' ', 0)","\tif err := t.write(f, L, wsTable{tw}); err != nil {","\t\treturn err","\t}","\treturn tw.Flush()","}","","func (t Table) write(af Format, L Object, rw rowWriter) error {","\tkeys := t.Keys()","\tif len(keys) == 0 {","\t\treturn nil","\t}","","\tvar colfmt map[Value]string","\tif L != nil {","\t\tcolfmt = make(map[Value]string)","\t\tfor _, k := range L.Keys() {","\t\t\tv := L.At(k)","\t\t\tif s, ok := v.(String); ok {","\t\t\t\tcolfmt[k.Copy()] = string(s)","\t\t\t}","\t\t}","\t}","","\tf := Format{","\t\tPP:  af.PP,","\t\tFmt: make(map[reflect.Type]string),","\t}","\tfor k, v := range af.Fmt {","\t\tf.Fmt[k] = v","\t}","","\tr := make([]string, len(keys))","\tfor i := range r {","\t\tr[i] = keys[i].String(f) // The header is always formatted with String.","\t}","\tif err := rw.writeRow(r); err != nil {","\t\treturn err","\t}","","\tfor n := 0; n \u003c t.Rows; n++ {","\t\tfor i, k := range keys {","\t\t\tcustom := \"\"","\t\t\tif colfmt != nil {","\t\t\t\tif s, ok := colfmt[k]; ok {","\t\t\t\t\tcustom = s","\t\t\t\t}","\t\t\t}","\t\t\tv := t.At(k).(Array).At(n)","\t\t\tt := reflect.TypeOf(v)","\t\t\tif custom == \"\" {","\t\t\t\tdelete(f.Fmt, t)","\t\t\t} else {","\t\t\t\tf.Fmt[t] = custom","\t\t\t}","\t\t\tif ar, ok := v.(Array); ok {","\t\t\t\tsize := ar.Size()","\t\t\t\tvec := make([]string, size)","\t\t\t\tfor j := 0; j \u003c size; j++ {","\t\t\t\t\te := ar.At(j)","\t\t\t\t\tvec[j] = e.String(f)","\t\t\t\t}","\t\t\t\tr[i] = strings.Join(vec, \" \")","\t\t\t\tif f.PP \u003c 0 {","\t\t\t\t\tr[i] = \"[\" + r[i] + \"]\"","\t\t\t\t}","\t\t\t} else {","\t\t\t\tr[i] = v.String(f)","\t\t\t}","\t\t}","\t\tif err := rw.writeRow(r); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","type rowWriter interface {","\twriteRow([]string) error","}","","type csvTable struct {","\t*csv.Writer","}","","func (c csvTable) writeRow(records []string) error { return c.Writer.Write(records) }","","type wsTable struct {","\t*tabwriter.Writer","}","","func (w wsTable) writeRow(records []string) error {","\t_, err := fmt.Fprintln(w, strings.Join(records, \"\\t\"))","\treturn err","}","","func (a *Apl) ParseTable(prototype Value, s string) (Table, error) {","\tif prototype != nil {","\t\t_, ok := prototype.(Table)","\t\tif ok == false {","\t\t\treturn Table{}, fmt.Errorf(\"ParseTable: prototype is not a table: %T\", prototype)","\t\t}","\t}","\treturn Table{}, fmt.Errorf(\"TODO ParseTable\")","}",""],"tack.go":["package primitives","","import (","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"⊣\",","\t\tdoc:    \"left tack, same\",","\t\tDomain: Monadic(nil),","\t\tfn:     same,","\t})","\tregister(primitive{","\t\tsymbol: \"⊢\",","\t\tdoc:    \"right tack, same\",","\t\tDomain: Monadic(nil),","\t\tfn:     same,","\t})","\tregister(primitive{","\t\tsymbol: \"⊣\",","\t\tdoc:    \"left tack, left argument\",","\t\tDomain: Dyadic(nil),","\t\tfn:     left,","\t})","\tregister(primitive{","\t\tsymbol: \"⊢\",","\t\tdoc:    \"right tack, right argument\",","\t\tDomain: Dyadic(nil),","\t\tfn:     right,","\t})","}","","func same(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\treturn R, nil","}","func left(a *apl.Apl, L, _ apl.Value) (apl.Value, error) {","\treturn L, nil","}","func right(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\treturn R, nil","}",""],"take.go":["package primitives","","import (","\t\"fmt\"","\t\"sort\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"","\t\"github.com/ktye/iv/apl/operators\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"↑\",","\t\tdoc:    \"take\",","\t\tDomain: Dyadic(Split(ToIndexArray(nil), nil)),","\t\tfn:     take,","\t\tsel:    takeSelection,","\t})","\tregister(primitive{","\t\tsymbol: \"↑\",","\t\tdoc:    \"take from channel\",","\t\tDomain: Dyadic(Split(ToIndexArray(nil), IsChannel(nil))),","\t\tfn:     takeChannel2,","\t})","\tregister(primitive{","\t\tsymbol: \"↑\",","\t\tdoc:    \"take one from channel\",","\t\tDomain: Monadic(IsChannel(nil)),","\t\tfn:     takeChannel1,","\t})","\tregister(primitive{","\t\tsymbol: \"↓\",","\t\tdoc:    \"drop\",","\t\tDomain: Dyadic(Split(ToIndexArray(nil), nil)),","\t\tfn:     drop,","\t\tsel:    dropSelection,","\t})","\tregister(primitive{","\t\tsymbol: \"↓\",","\t\tdoc:    \"drop to channel\",","\t\tDomain: Dyadic(Split(IsChannel(nil), nil)),","\t\tfn:     sendChannel,","\t})","\tregister(primitive{","\t\tsymbol: \"↓\",","\t\tdoc:    \"close channel\",","\t\tDomain: Monadic(IsChannel(nil)),","\t\tfn:     closeChannel,","\t})","\tregister(primitive{","\t\tsymbol: \"↓\",","\t\tdoc:    \"cut\",","\t\tDomain: Dyadic(Split(ToIndexArray(nil), IsList(nil))),","\t\tfn:     cut,","\t})","}","","func take(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\treturn takedrop(a, L, R, true)","}","func drop(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\treturn takedrop(a, L, R, false)","}","","func takeSelection(a *apl.Apl, L, R apl.Value) (apl.IntArray, error) {","\tv, err := takeDropSelection(a, L, R, true)","\treturn v, err","}","func dropSelection(a *apl.Apl, L, R apl.Value) (apl.IntArray, error) {","\treturn takeDropSelection(a, L, R, false)","}","","// takedrop does the preprocessing, that is common to both take and drop.","func takedrop(a *apl.Apl, L, R apl.Value, take bool) (apl.Value, error) {","\t// Special case, L is the empty array, return R.","\tif _, ok := L.(apl.EmptyArray); ok {","\t\treturn R, nil","\t}","","\tvar x []int","\tvar err error","\tR, x, err = splitAxis(a, R)","\tif err != nil {","\t\treturn nil, err","\t}","","\tai := L.(apl.IntArray)","\tif len(ai.Dims) \u003e 1 {","\t\treturn nil, fmt.Errorf(\"take/drop: L must be a vector\")","\t}","","\t// If R is an empty array, return 0s of the size of |L.","\tif _, ok := R.(apl.EmptyArray); ok {","\t\tif len(ai.Ints) == 1 {","\t\t\tn := ai.Ints[0]","\t\t\tif n \u003c 0 {","\t\t\t\tn = -n","\t\t\t}","\t\t\treturn apl.IntArray{","\t\t\t\tInts: make([]int, n),","\t\t\t\tDims: []int{n},","\t\t\t}, nil","\t\t}","\t}","","\t// If R is a scalar, set it's shape to (⍴,L)⍴1.","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\tr := apl.MixedArray{Values: []apl.Value{R.Copy()}}","\t\tr.Dims = make([]int, len(ai.Ints))","\t\tfor i := range r.Dims {","\t\t\tr.Dims[i] = 1","\t\t}","\t\tar = a.UnifyArray(r)","\t}","\trs := ar.Shape()","","\t// The default axis is the shape list of R: L↑R ←→ L↑[⍳⍴⍴R]R, same for drop.","\t// Shorter axis are filled with the missing default items.","\t// Elements may not repeat.","\tif len(x) \u003e len(rs) {","\t\treturn nil, fmt.Errorf(\"axis is too long\")","\t}","\tm := make(map[int]int)","\tfor i := range rs {","\t\tm[i] = i","\t}","\taxis := make([]int, len(rs))","\tfor i, n := range x {","\t\tif k, ok := m[n]; ok == false {","\t\t\treturn nil, fmt.Errorf(\"axis does not conform\")","\t\t} else {","\t\t\taxis[i] = k","\t\t\tdelete(m, k)","\t\t}","\t}","\ttail := make([]int, len(m))","\ti := 0","\tfor _, n := range m {","\t\ttail[i] = n","\t\ti++","\t}","\tsort.Ints(tail)","\tcopy(axis[len(x):], tail)","\tx = axis","","\t// Missing items in L default to values of ⍴R[x] for take and 0 for drop.","\tif len(ai.Ints) \u003e len(rs) {","\t\treturn nil, fmt.Errorf(\"take/drop: length of L is too large\")","\t} else if len(ai.Ints) \u003c len(rs) {","\t\tn := make([]int, len(rs))","\t\tcopy(n, ai.Ints)","\t\tif take {","\t\t\tfor i := len(ai.Ints); i \u003c len(rs); i++ {","\t\t\t\tn[i] = rs[x[i]]","\t\t\t}","\t\t}","\t\tai.Ints = n","\t\tai.Dims[0] = len(n)","\t}","","\tif take == false {","\t\t// Convert L to the left argument of an equivalent call to take.","\t\tfor i, n := range ai.Ints {","\t\t\tm := rs[x[i]]","\t\t\tif n \u003e= m || -n \u003e= m { // over drop","\t\t\t\tai.Ints[i] = 0","\t\t\t} else if n \u003e 0 {","\t\t\t\tai.Ints[i] = n - m","\t\t\t} else {","\t\t\t\tai.Ints[i] = n + m","\t\t\t}","\t\t}","\t}","\t// Take is defined in opearators/rank.go","\treturn operators.Take(a, ai, ar, x)","}","","func takeDropSelection(a *apl.Apl, L, R apl.Value, take bool) (apl.IntArray, error) {","\tvar x []int","\tvar err error","\tR, x, err = splitAxis(a, R)","\tif err != nil {","\t\treturn apl.IntArray{}, err","\t}","","\tar, ok := R.(apl.Array)","\tif ok == false {","\t\treturn apl.IntArray{}, fmt.Errorf(\"cannot select from non-array: %T\", R)","\t}","","\t// Take/drop from an index array instead of R of the same shape.","\t// Take/drop fills with zeros, so count with origin 1 temporarily.","\tr := apl.IntArray{Dims: apl.CopyShape(ar)}","\tr.Ints = make([]int, ar.Size())","\tfor i := range r.Ints {","\t\tr.Ints[i] = i + 1","\t}","","\tR = r","\tif x != nil {","\t\tfor i := range x {","\t\t\tx[i] += a.Origin","\t\t}","\t\tR = apl.Axis{R: r, A: apl.IntArray{Dims: []int{len(x)}, Ints: x}}","\t}","","\tvar ai apl.IntArray","\tres, err := takedrop(a, L, R, take)","\tif err != nil {","\t\treturn ai, err","\t}","","\tto := ToIndexArray(nil)","\tif v, ok := to.To(a, res); ok == false {","\t\treturn ai, fmt.Errorf(\"could not convert selection to index array: %T\", res)","\t} else {","\t\tai = v.(apl.IntArray)","\t}","","\tfor i := range ai.Ints {","\t\tai.Ints[i]--","","\t\t// TODO: Elements \u003c 0 are the result of overtake.","\t\t// These elements should be removed.","\t\tif ai.Ints[i] \u003c 0 {","\t\t\treturn ai, fmt.Errorf(\"TODO: overtake/drop with selection\")","\t\t}","\t}","\treturn ai, nil","}","","// Cut list R at indexes L.","// This is similar to _ in q.","// Indexes may be negative.","func cut(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tai := L.(apl.IntArray)","\tr := R.(apl.List)","\tif len(ai.Shape()) != 1 {","\t\treturn nil, fmt.Errorf(\"cut: left argument must be an index vector\")","\t}","\tidx := make([]int, len(ai.Ints))","\tfor i := range idx {","\t\tidx[i] = ai.Ints[i] - a.Origin","\t\tif idx[i] \u003c 0 {","\t\t\tidx[i] = len(r) + idx[i]","\t\t}","\t\tif i \u003e 0 \u0026\u0026 idx[i] \u003c= idx[i-1] {","\t\t\treturn nil, fmt.Errorf(\"cut: indexes may not decrease\")","\t\t}","\t\tif idx[i] \u003c 0 || idx[i] \u003e= len(r) {","\t\t\treturn nil, fmt.Errorf(\"cut: indexes out of range\")","\t\t}","\t}","\tif len(idx) == 1 {","\t\treturn r[idx[0]:].Copy(), nil","\t}","\tres := make(apl.List, len(idx))","\tfor i := range res {","\t\tstp := len(r)","\t\tif i \u003c len(idx)-1 {","\t\t\tstp = idx[i+1]","\t\t}","\t\tres[i] = r[idx[i]:stp].Copy()","\t}","\treturn res, nil","}","","func takeChannel1(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tc := R.(apl.Channel)","\tv, ok := \u003c-c[0]","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"channel is closed\")","\t}","\treturn v, nil","}","","// takeChannel2 takes multiple values from channel R and reshapes according to L.","func takeChannel2(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tai := L.(apl.IntArray)","\tif len(ai.Shape()) != 1 {","\t\treturn nil, fmt.Errorf(\"take channel: L must be an index vector\")","\t}","\tfor _, n := range ai.Ints {","\t\tif n \u003c= 0 {","\t\t\treturn nil, fmt.Errorf(\"take channel: values in L must be positive\")","\t\t}","\t}","\tshape := make([]int, len(ai.Ints))","\tcopy(shape, ai.Ints)","\tres := apl.NewMixed(shape)","","\tc := R.(apl.Channel)","\tfor i := range res.Values {","\t\tv, ok := \u003c-c[0]","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"not enough data in channel\")","\t\t}","\t\tres.Values[i] = v","\t}","\treturn res, nil","}","","// sendChannel sends the value R to the channel L and returns R.","func sendChannel(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tc := L.(apl.Channel)","\tc[1] \u003c- R.Copy()","\treturn R, nil","}","","// closeChannel closes the channel R and returns 1.","func closeChannel(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tR.(apl.Channel).Close()","\treturn apl.Int(1), nil","}",""],"testing.go":["package cmd","","import (","\t\"bufio\"","\t\"bytes\"","\t\"fmt\"","\t\"io\"","\t\"io/ioutil\"","\t\"os\"","\t\"strings\"","","\t\"github.com/ktye/iv/apl\"",")","","// AplTest is run from go test in cmd/apl and cmd/lui.","func AplTest(newapl func() *apl.Apl) error {","\td, err := os.Open(\".\")","\tif err != nil {","\t\treturn err","\t}","\tdefer d.Close()","","\tfiles, err := d.Readdirnames(-1)","\tif err != nil {","\t\treturn err","\t}","","\tfor _, file := range files {","\t\tif strings.HasSuffix(file, \".apl\") == false {","\t\t\tcontinue","\t\t}","\t\tif err := testAplFile(newapl, file); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","// IvTest is run from go test in cmd/iv and cmd/lui.","func IvTest(newapl func(io.ReadCloser) *apl.Apl) error {","\td, err := os.Open(\".\")","\tif err != nil {","\t\treturn err","\t}","\tdefer d.Close()","","\tfiles, err := d.Readdirnames(-1)","\tif err != nil {","\t\treturn err","\t}","","\tfor _, file := range files {","\t\tif strings.HasSuffix(file, \".iv\") == false {","\t\t\tcontinue","\t\t}","\t\tif err := testIvFile(newapl, file[:len(file)-3]); err != nil {","\t\t\treturn fmt.Errorf(\"%s: %s\", file, err)","\t\t}","\t}","\treturn nil","}","","func testAplFile(newapl func() *apl.Apl, file string) error {","\tvar out bytes.Buffer","\ta := newapl()","\ta.SetOutput(\u0026out)","\tif err := Apl(a, nil, []string{file}); err != nil {","\t\treturn compareError(err, file)","\t}","\treturn compareOut(out.Bytes(), file[:len(file)-4])","}","func testIvFile(newapl func(io.ReadCloser) *apl.Apl, file string) error {","\tf, err := os.Open(file + \".iv\")","\tif err != nil {","\t\treturn err","\t}","\tdefer f.Close()","","\t// First line in each iv test file is the program with a comment.","\tr := bufio.NewReader(f)","\tprog, err := readline(r)","\tif err != nil {","\t\treturn err","\t}","","\tvar out bytes.Buffer","\tif err := Iv(newapl(ioutil.NopCloser(r)), prog[1:], \u0026out); err != nil {","\t\treturn err","\t}","\treturn compareOut(out.Bytes(), file)","}","","func readline(s io.RuneScanner) (string, error) {","\tvar b strings.Builder","\tfor {","\t\tif r, _, err := s.ReadRune(); err != nil {","\t\t\treturn \"\", err","\t\t} else {","\t\t\tif r == '\\n' {","\t\t\t\treturn b.String(), nil","\t\t\t}","\t\t\tb.WriteRune(r)","\t\t}","\t}","}","","func compareError(got error, file string) error {","\tname := file[:len(file)-4] + \".err\"","\twant, err := ioutil.ReadFile(name)","\tif err != nil {","\t\treturn fmt.Errorf(\"%s: failed but (%s)\\n%s\", file, err, got)","\t}","\tif got := got.Error() + \"\\n\"; got != string(want) {","\t\treturn fmt.Errorf(\"%s: expected:\\n%sgot:\\n%s\", file, want, got)","\t}","\treturn nil","}","","func compareOut(got []byte, file string) error {","\tname := file + \".out\"","\twant, err := ioutil.ReadFile(name)","\tif err != nil {","\t\treturn fmt.Errorf(\"%s: should have failed, but: %s\", file, err)","\t}","","\tat := -1","\tmax := len(want)","\tif len(got) \u003c max {","\t\tmax = len(got)","\t}","\tif len(want) != len(got) {","\t\tat = max","\t}","","\tline := 1","\tfor i := 0; i \u003c max; i++ {","\t\tif want[i] == '\\n' {","\t\t\tline++","\t\t}","\t\tif got[i] != want[i] {","\t\t\tat = i","\t\t\tbreak","\t\t}","\t}","","\tif at \u003c 0 {","\t\treturn nil","\t}","\treturn fmt.Errorf(\"%s:%d differs (byte %d). Got:\\n%s\\nWant:\\n%s\", name, line, at+1, string(got), string(want))","}",""],"time.go":["package numbers","","import (","\t\"fmt\"","\t\"strings\"","\t\"time\"","","\t\"github.com/ktye/iv/apl\"",")","","var y0, y1k time.Time","","func init() {","\ty1k, _ = time.Parse(\"2006.01.02\", \"1000.01.01\")","\ty0, _ = time.Parse(\"15h04\", \"00h00\")","}","","// Time holds both a time stamp and a duration in a single number type.","// Durations are identified as time stamps before year 1000 (y1k).","// The parser accepts both, durations and time stamps.","// When times and other number types are mixed, the other number types","// are identified as seconds and upgraded.","type Time time.Time","","func ParseTime(s string) (apl.Number, bool) {","\ts = strings.Replace(s, \"¯\", \"-\", -1)","\tfor _, layout := range layouts {","\t\tif t, err := time.Parse(layout, s); err == nil {","\t\t\treturn Time(t), true","\t\t}","\t}","\tif d, err := time.ParseDuration(s); err == nil {","\t\treturn Time(y0.Add(d)), true","\t}","","\treturn nil, false","}","","// We cannot separate with colons.","// Mon Jan 2 15:04:05 -0700 MST 2006","var layouts = []string{","\t\"2006.01.02\",","\t\"2006.01.02T15.04\",","\t\"2006.01.02T15.04\",","\t\"2006.01.02T15.04.05\", // This accepts also fractional seconds.","}","","func (t Time) String(f apl.Format) string {","\tformat, minus := getformat(f, t)","\tif t1 := time.Time(t); t1.Before(y1k) {","\t\ts := t1.Sub(y0).String()","\t\tif minus == false {","\t\t\ts = strings.Replace(s, \"-\", \"¯\", -1)","\t\t\treturn s","\t\t}","\t}","","\tif format == \"W\" {","\t\tyear, wk := time.Time(t).ISOWeek()","\t\treturn fmt.Sprintf(\"%04dw%02d\", year, wk)","\t} else if format == \"Q\" {","\t\t_, year, quarter := roundQuarter(time.Time(t))","\t\treturn fmt.Sprintf(\"%04dQ%d\", year, quarter)","\t}","","\tif format == \"\" {","\t\tformat = \"2006.01.02T15.04.05.000\"","\t}","","\treturn time.Time(t).Format(format)","}","func (t Time) Copy() apl.Value { return t }","","func (t Time) ToIndex() (int, bool) {","\treturn 0, false","}","","func (t Time) Less(R apl.Value) (apl.Bool, bool) {","\treturn apl.Bool(time.Time(t).Before(time.Time(R.(Time)))), true","}","","func (t Time) Add() (apl.Value, bool) {","\treturn t, true","}","","// Add2 adds two times.","// At least one of the times must be a duration (before y1k).","func (t Time) Add2(R apl.Value) (apl.Value, bool) {","\tt0 := time.Time(t)","\tt1 := time.Time(R.(Time))","\tif t0.After(y1k) \u0026\u0026 t1.After(y1k) {","\t\treturn nil, false","\t} else if t0.After(y1k) {","\t\treturn Time(t0.Add(t1.Sub(y0))), true","\t} else {","\t\treturn Time(t1.Add(t0.Sub(y0))), true","\t}","}","","func (t Time) Sub() (apl.Value, bool) {","\tif t0 := time.Time(t); t0.Before(y1k) {","\t\td := t0.Sub(y0)","\t\treturn Time(y0.Add(-d)), true","\t}","\treturn nil, false","}","","// Sub2 returns a duration depending on it's arguments:","// If both are a duration, it is the difference.","// If both are a time, it is the difference.","// If the first is a time and the second a duration, it's a time before.","// If the first is a duration and the second a time, it is not accepted.","func (t Time) Sub2(R apl.Value) (apl.Value, bool) {","\tt0 := time.Time(t)","\tt1 := time.Time(R.(Time))","\tif t0.After(y1k) \u0026\u0026 t1.After(y1k) {","\t\treturn Time(y0.Add(t0.Sub(t1))), true","\t} else if t0.Before(y1k) \u0026\u0026 t1.Before(y1k) {","\t\treturn Time(y0.Add(t0.Sub(y0)).Add(-t1.Sub(y0))), true","\t} else if t0.After(y1k) \u0026\u0026 t1.Before(y1k) {","\t\treturn Time(t0.Add(-t1.Sub(y0))), true","\t}","\treturn nil, false","}","","// Duration returns if the time value is a duration and it's value.","func (t Time) Duration() (time.Duration, bool) {","\tif time.Time(t).Before(y1k) {","\t\treturn time.Time(t).Sub(y0), true","\t}","\treturn time.Duration(0), false","}","","func (t Time) Mul() (apl.Value, bool) {","\tif t0 := time.Time(t); t0.Before(y0) {","\t\treturn apl.Int(-1), true","\t} else if t0.After(y0) {","\t\treturn apl.Int(1), true","\t}","\treturn apl.Int(0), true","}","","// Multiplication is allowed for durations only and applied to seconds.","func (t Time) Mul2(R apl.Value) (apl.Value, bool) {","\tt0 := time.Time(t)","\tt1 := time.Time(R.(Time))","\tif t0.After(y1k) || t1.After(y1k) {","\t\treturn nil, false","\t}","\ts0 := t0.Sub(y0).Seconds()","\ts1 := t1.Sub(y0).Seconds()","\treturn Time(y0.Add(time.Duration(int64(1e9 * (s0 * s1))))), true","}","","/* Does Div make any sense?","func (t Time) Div() (apl.Value, bool) {","\tif t0 := time.Time(t); t0.Before(y1k) {","\t\ts0 := t0.Sub(y0).Seconds()","\t\treturn Time(y0.Add(time.Duration(int64(1e9 / s0)))), true","\t}","\treturn nil, false","}","*/","","// Division is allowed for durations only and applied to seconds.","func (t Time) Div2(R apl.Value) (apl.Value, bool) {","\tt0 := time.Time(t)","\tt1 := time.Time(R.(Time))","\tif t0.After(y1k) || t1.After(y1k) {","\t\treturn nil, false","\t}","\ts0 := t0.Sub(y0).Seconds()","\ts1 := t1.Sub(y0).Seconds()","\treturn Time(y0.Add(time.Duration(int64(1e9 * (s0 / s1))))), true","}","","func (t Time) Abs() (apl.Value, bool) {","\tif t0 := time.Time(t); t0.Before(y0) {","\t\treturn Time(y0.Add(-t0.Sub(y0))), true","\t}","\treturn t, true","}","","func (t Time) Floor() (apl.Value, bool) {","\treturn Time(time.Time(t).Truncate(time.Second)), true","}","","func (t Time) Ceil() (apl.Value, bool) {","\treturn Time(time.Time(t).Add(500 * time.Millisecond).Truncate(time.Second)), true","}","","func (t Time) Floor2() (apl.Value, bool) {","\treturn Time(time.Time(t).Truncate(time.Second)), true","}","","func (t Time) Ceil2() (apl.Value, bool) {","\treturn Time(time.Time(t).Add(500 * time.Millisecond).Truncate(time.Second)), true","}","","func (t Time) Round(period string) (Time, error) {","\tif d, ok := t.Duration(); ok {","\t\treturn roundDuration(d, period)","\t}","\tt1 := time.Time(t)","\tY, M, D := t1.Date()","\th := t1.Hour()","\tm := t1.Minute()","\ts := t1.Second()","\tswitch period {","\tcase \"Y\":","\t\treturn Time(time.Date(Y, 1, 1, 0, 0, 0, 0, time.UTC)), nil","\tcase \"M\":","\t\treturn Time(time.Date(Y, M, 1, 0, 0, 0, 0, time.UTC)), nil","\tcase \"D\":","\t\treturn Time(time.Date(Y, M, D, 0, 0, 0, 0, time.UTC)), nil","\tcase \"h\":","\t\treturn Time(time.Date(Y, M, D, h, 0, 0, 0, time.UTC)), nil","\tcase \"m\":","\t\treturn Time(time.Date(Y, M, D, h, m, 0, 0, time.UTC)), nil","\tcase \"s\":","\t\treturn Time(time.Date(Y, M, D, h, m, s, 0, time.UTC)), nil","\tcase \"Q\":","\t\trt, _, _ := roundQuarter(t1)","\t\treturn Time(rt), nil","\tcase \"W\":","\t\tyear, wk := t1.ISOWeek()","\t\treturn Time(roundWeek(year, wk, time.UTC)), nil","\tdefault:","\t\treturn t, fmt.Errorf(\"cannot round time to %s\", period)","\t}","","\treturn t, fmt.Errorf(\"TODO: round time\")","}","","func roundQuarter(t time.Time) (time.Time, int, int) {","\tY, _, _ := t.Date()","\tif t.Before(time.Date(Y, time.April, 1, 0, 0, 0, 0, time.UTC)) {","\t\treturn time.Date(Y, time.January, 1, 0, 0, 0, 0, time.UTC), Y, 1","\t} else if t.Before(time.Date(Y, time.July, 1, 0, 0, 0, 0, time.UTC)) {","\t\treturn time.Date(Y, time.April, 1, 0, 0, 0, 0, time.UTC), Y, 2","\t} else if t.Before(time.Date(Y, time.October, 1, 0, 0, 0, 0, time.UTC)) {","\t\treturn time.Date(Y, time.July, 1, 0, 0, 0, 0, time.UTC), Y, 3","\t}","\treturn time.Date(Y, time.October, 1, 0, 0, 0, 0, time.UTC), Y, 4","}","","func roundWeek(year int, week int, timezone *time.Location) time.Time {","\tdate := time.Date(year, 0, 0, 0, 0, 0, 0, timezone)","\tisoYear, isoWeek := date.ISOWeek()","\tfor date.Weekday() != time.Monday {","\t\tdate = date.AddDate(0, 0, -1)","\t\tisoYear, isoWeek = date.ISOWeek()","\t}","\tfor isoYear \u003c year {","\t\tdate = date.AddDate(0, 0, 1)","\t\tisoYear, isoWeek = date.ISOWeek()","\t}","\tfor isoWeek \u003c week {","\t\tdate = date.AddDate(0, 0, 1)","\t\tisoYear, isoWeek = date.ISOWeek()","\t}","\treturn date","}","","func roundDuration(t time.Duration, s string) (Time, error) {","\tvar d time.Duration","\tswitch s {","\tcase \"h\":","\t\td = time.Hour","\tcase \"m\":","\t\td = time.Minute","\tcase \"s\":","\t\td = time.Second","\tcase \"ms\":","\t\td = time.Millisecond","\tcase \"us\", \"μs\":","\t\td = time.Microsecond","\tcase \"ns\":","\t\td = time.Nanosecond","\tdefault:","\t\treturn Time(y0), fmt.Errorf(\"round duration: not supported: %s\", s)","\t}","\treturn Time(y0.Add(t.Round(d))), nil","}","","// Not supported by elementary arithmetics on time numbers:","// - Add non-constant intervals to time, e.g. 2016.01.01 + 1 year (go: time.AddDate)","//\tCurrently we can only do:","//      \t2015.01.01 + 365×24h","//\t2016.12.31T00.00.00.000","//\t       2015.01.01 + 365×24h","//\t2016.01.01T00.00.00.000 // This does not take leap years into account","// - Intervals: Year, Month, Quarter, Calendar week","// \t2015Q3, 2015W12",""],"times.go":["package numbers","","import (","\t\"fmt\"","\t\"time\"","","\t\"github.com/ktye/iv/apl\"",")","","// TimeArray is a uniform array of time.Time.","type TimeArray struct {","\tDims  []int","\tTimes []time.Time","}","","func (t TimeArray) String(f apl.Format) string {","\treturn apl.ArrayString(f, t)","}","","func (t TimeArray) Copy() apl.Value {","\tr := TimeArray{Dims: apl.CopyShape(t), Times: make([]time.Time, len(t.Times))}","\tcopy(r.Times, t.Times)","\treturn r","}","","func (t TimeArray) At(i int) apl.Value {","\treturn Time(t.Times[i])","}","","func (t TimeArray) Shape() []int {","\treturn t.Dims","}","","func (t TimeArray) Size() int {","\treturn len(t.Times)","}","","func (t TimeArray) Zero() apl.Value {","\treturn Time(y0)","}","","func (t TimeArray) Set(i int, v apl.Value) error {","\tif i \u003c 0 || i \u003e len(t.Times) {","\t\treturn fmt.Errorf(\"index out of range\")","\t}","\tif c, ok := v.(Time); ok {","\t\tt.Times[i] = time.Time(c)","\t\treturn nil","\t}","\treturn fmt.Errorf(\"cannot assign %T to TimeArray\", v)","}","","func (t TimeArray) Reshape(shape []int) apl.Value {","\tres := TimeArray{","\t\tDims:  shape,","\t\tTimes: make([]time.Time, prod(shape)),","\t}","\tk := 0","\tfor i := range res.Times {","\t\tres.Times[i] = t.Times[k]","\t\tk++","\t\tif k == len(t.Times) {","\t\t\tk = 0","\t\t}","\t}","\treturn res","}","","func (t TimeArray) Make(shape []int) apl.Uniform {","\treturn TimeArray{","\t\tDims:  shape,","\t\tTimes: make([]time.Time, prod(shape)),","\t}","}","","func makeTimeArray(v []apl.Value) TimeArray {","\tt := make([]time.Time, len(v))","\tfor i, e := range v {","\t\tt[i] = time.Time(e.(Time))","\t}","\treturn TimeArray{","\t\tDims:  []int{len(v)},","\t\tTimes: t,","\t}","}",""],"tower.go":["package apl","","import (","\t\"fmt\"","\t\"reflect\"",")","","type Tower struct {","\tNumbers map[reflect.Type]*Numeric","\tImport  func(v Number) Number       // Import Bool or Int","\tUniform func([]Value) (Value, bool) // Values must already be uniform.","\tidx     []*Numeric","}","","// SetTower sets the numerical tower.","// The default tower can be set by calling numbers.Register(a).","func (a *Apl) SetTower(t Tower) error {","\tt.idx = make([]*Numeric, len(t.Numbers))","\tfor i := 0; i \u003c len(t.Numbers); i++ {","\t\tfor _, n := range t.Numbers {","\t\t\tif n.Class == i {","\t\t\t\tm := n","\t\t\t\tt.idx[i] = m","\t\t\t}","\t\t}","\t}","\tfor c, p := range t.idx {","\t\tif p == nil {","\t\t\treturn fmt.Errorf(\"not a valid tower: class %d is missing\", c)","\t\t}","\t}","\ta.Tower = t","\treturn nil","}","","// Parse tries to parse a string as a Number, starting with the lowest number type.","func (t Tower) Parse(s string) (NumExpr, error) {","","\t// Bool and Index can be parsed directly.","\tswitch s {","\tcase \"1b\":","\t\treturn NumExpr{Bool(true)}, nil","\tcase \"0b\":","\t\treturn NumExpr{Bool(false)}, nil","\tdefault:","\t\tif n, ok := ParseInt(s); ok {","\t\t\treturn NumExpr{n}, nil","\t\t}","\t}","","\tif t.Numbers == nil || len(t.idx) != len(t.Numbers) {","\t\treturn NumExpr{}, fmt.Errorf(\"numeric tower is not initialized\")","\t}","\tfor _, num := range t.idx {","\t\tif num.Parse == nil {","\t\t\tcontinue","\t\t}","\t\tif n, ok := num.Parse(s); ok {","\t\t\treturn NumExpr{n}, nil","\t\t}","\t}","\treturn NumExpr{}, fmt.Errorf(\"cannot parse number: %s\", s)","}","","// SameType returns the two numbers with the same type.","// It uptypes the lower number type.","func (t Tower) SameType(a, b Number) (Number, Number, error) {","\tat := reflect.TypeOf(a)","\tbt := reflect.TypeOf(b)","\tif at == bt {","\t\treturn a, b, nil","\t}","","\t// Handle Bool and Index.","\tif ab, ok := a.(Bool); ok {","\t\tif _, ok := b.(Int); ok {","\t\t\treturn bool2int(ab), b, nil","\t\t}","\t\ta = t.Import(a)","\t\tat = reflect.TypeOf(a)","\t}","\tif bb, ok := b.(Bool); ok {","\t\tif _, ok := a.(Int); ok {","\t\t\treturn a, bool2int(bb), nil","\t\t}","\t\tb = t.Import(b)","\t\tbt = reflect.TypeOf(b)","\t}","\tif _, ok := a.(Int); ok {","\t\ta = t.Import(a)","\t\tat = reflect.TypeOf(a)","\t}","\tif _, ok := b.(Int); ok {","\t\tb = t.Import(b)","\t\tbt = reflect.TypeOf(b)","\t}","","\tna, ok := t.Numbers[at]","\tif ok == false {","\t\treturn nil, nil, fmt.Errorf(\"numeric tower: unknown number type %T\", a)","\t}","\tnb, ok := t.Numbers[bt]","\tif ok == false {","\t\treturn nil, nil, fmt.Errorf(\"numeric tower: unknown number type %T\", b)","\t}","\tfor i := na.Class; i \u003c nb.Class; i++ {","\t\ta, ok = na.Uptype(a)","\t\tif ok == false {","\t\t\t// Uptype should return the original number if it fails.","\t\t\treturn nil, nil, fmt.Errorf(\"cannot uptype %T\", a)","\t\t}","\t\tna = t.idx[i+1]","\t}","\tfor i := nb.Class; i \u003c na.Class; i++ {","\t\tb, ok = nb.Uptype(b)","\t\tif ok == false {","\t\t\t// Uptype should return the original number if it fails.","\t\t\treturn nil, nil, fmt.Errorf(\"cannot uptype %T\", b)","\t\t}","\t\tnb = t.idx[i+1]","\t}","\treturn a, b, nil","}","","func bool2int(b Bool) Int {","\tif b {","\t\treturn Int(1)","\t}","\treturn Int(0)","}","","func (a *Apl) IsZero(n Number) bool {","\tb, ok := a.Tower.ToBool(n)","\tif ok == false {","\t\treturn false","\t}","\treturn b == false","}","","func (t *Tower) ToBool(n Number) (Bool, bool) {","\tif idx, ok := n.ToIndex(); ok == false {","\t\treturn false, false","\t} else if idx \u003c 0 || idx \u003e 1 {","\t\treturn false, false","\t} else if idx == 0 {","\t\treturn false, true","\t} else {","\t\treturn true, true","\t}","}","","func (t *Tower) ToNumeric(v Number) *Numeric {","\tif _, ok := v.(Bool); ok {","\t\treturn \u0026Numeric{","\t\t\tClass: -2,","\t\t\tUptype: func(n Number) (Number, bool) {","\t\t\t\tif b := n.(Bool); b {","\t\t\t\t\treturn Int(1), true","\t\t\t\t}","\t\t\t\treturn Int(0), true","\t\t\t},","\t\t}","\t}","\tif _, ok := v.(Int); ok {","\t\treturn \u0026Numeric{","\t\t\tClass: -1,","\t\t\tUptype: func(n Number) (Number, bool) {","\t\t\t\treturn t.Import(n), true","\t\t\t},","\t\t}","\t}","\tif num, ok := t.Numbers[reflect.TypeOf(v)]; ok {","\t\treturn num","\t}","\treturn nil","}","","// Numeric is a member of the tower.","// Uptype converts a Number to the next higher class.","type Numeric struct {","\tClass  int","\tParse  func(string) (Number, bool)","\tUptype func(Number) (Number, bool)","}","","// Number is the interface that a numeric type must implement.","// It's a scalar numeric value that can be part of the current tower.","type Number interface {","\tValue","\tToIndex() (int, bool)","}","","// NumExpr wraps a Number to be used as an expression by the parser.","type NumExpr struct {","\tNumber","}","","func (num NumExpr) Eval(a *Apl) (Value, error) {","\treturn num.Number, nil","}",""],"train.go":["package apl","","import (","\t\"fmt\"","\t\"strings\"",")","","// Train is a function train expression.","// It does not contain it's arguments like a Primitive or a fnVar.","// See DyaProg p 25.","type train []expr","","func (t train) Eval(a *Apl) (Value, error) {","\treturn t, nil","}","","func (t train) String(f Format) string {","\tv := make([]string, len(t))","\tfor i := range t {","\t\tv[i] = t[i].String(f)","\t}","\treturn \"(\" + strings.Join(v, \", \") + \")\"","}","func (t train) Copy() Value { return t }","","func (t train) Call(a *Apl, L, R Value) (Value, error) {","\tif len(t) \u003c 2 {","\t\treturn nil, fmt.Errorf(\"cannot call short train, length %d\", len(t))","\t} else if len(t)%2 == 0 {","\t\t// even number: f g h i j k → f(g h(i j k)) ⍝ atop(fork(fork))","\t\tf := atop{}","\t\tend := 1","\t\tif len(t) == 2 {","\t\t\tend = 2","\t\t}","\t\tfor i, e := range t[:end] {","\t\t\tif v, err := e.Eval(a); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else {","\t\t\t\tf[i] = v","\t\t\t}","\t\t}","\t\tif len(t) \u003e 3 {","\t\t\tf[1] = train(t[1:])","\t\t}","\t\treturn f.Call(a, L, R)","\t} else {","\t\t// odd number: e f g h i j k → e f(g h(i j k)) ⍝ fork(fork(fork))","\t\tf := fork{}","\t\tend := 2","\t\tif len(t) == 3 {","\t\t\tend = 3","\t\t}","\t\tfor i, e := range t[:end] {","\t\t\tif v, err := e.Eval(a); err != nil {","\t\t\t\treturn nil, err","\t\t\t} else {","\t\t\t\tf[i] = v","\t\t\t}","\t\t}","\t\tif len(t) \u003e 3 {","\t\t\tf[2] = train(t[2:])","\t\t}","\t\treturn f.Call(a, L, R)","\t}","}","","type atop [2]Value","","func (t atop) String(f Format) string {","\treturn fmt.Sprintf(\"(%s %s)\", t[0].String(f), t[1].String(f))","}","","func (t atop) Call(a *Apl, L, R Value) (Value, error) {","\tg, ok := t[0].(Function)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"atop: expected function g: %T\", t[0])","\t}","\th, ok := t[1].(Function)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"atop: expected function h: %T\", t[1])","\t}","","\t// L may be nil.","\tv, err := h.Call(a, L, R)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn g.Call(a, nil, v)","}","","type fork [3]Value","","func (fk fork) String(f Format) string {","\treturn fmt.Sprintf(\"(%s %s %s)\", fk[0].String(f), fk[1].String(f), fk[2].String(f))","}","","func (fk fork) Call(a *Apl, L, R Value) (Value, error) {","\tf, fok := fk[0].(Function)","","\tg, ok := fk[1].(Function)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"fork: expected function g: %T\", fk[1])","\t}","\th, ok := fk[2].(Function)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"fork: expected function h: %T\", fk[2])","\t}","","\t// Agh fork if f is not a function.","\tvar l Value","\tl = fk[0]","\tif fok {","\t\tif v, err := f.Call(a, L, R); err != nil { // TODO copy?","\t\t\treturn nil, err","\t\t} else {","\t\t\tl = v","\t\t}","\t}","\tr, err := h.Call(a, L, R) // TODO copy?","\tif err != nil {","\t\treturn nil, err","\t}","\treturn g.Call(a, l, r)","}",""],"transpose.go":["package primitives","","import (","\t\"fmt\"","","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"⍉\",","\t\tdoc:    \"cant, transpose, reverse axes\",","\t\tDomain: Monadic(IsArray(nil)),","\t\tfn:     transpose,","\t\tsel:    selection(transpose),","\t})","\tregister(primitive{","\t\tsymbol: \"⍉\",","\t\tdoc:    \"table from object, transpose, flip\",","\t\tDomain: Monadic(IsObject(nil)),","\t\tfn:     transposeObject,","\t})","\tregister(primitive{","\t\tsymbol: \"⍉\",","\t\tdoc:    \"dict from table, transpose, flip\",","\t\tDomain: Monadic(IsTable(nil)),","\t\tfn:     transposeTable,","\t})","\tregister(primitive{","\t\tsymbol: \"⍉\",","\t\tdoc:    \"cant, transpose, general transpose\",","\t\tDomain: Dyadic(Split(IsArray(nil), IsNumber(nil))), // This matches (⍳0)⍉5","\t\tfn:     transpose,","\t\tsel:    selection(transpose),","\t})","\tregister(primitive{","\t\tsymbol: \"⍉\",","\t\tdoc:    \"cant, transpose, general transpose\",","\t\tDomain: Dyadic(Split(ToIndexArray(nil), IsArray(nil))),","\t\tfn:     transpose,","\t\tsel:    selection(transpose),","\t})","}","","func transpose(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\t// Special case: L is the empty array and R is scalar: return R.","\tif _, ok := L.(apl.EmptyArray); ok {","\t\tif _, ok := R.(apl.Array); ok == false {","\t\t\treturn R, nil","\t\t} else {","\t\t\treturn nil, fmt.Errorf(\"transpose: L is empty, R not scalar\")","\t\t}","\t}","","\tidx, shape, err := transposeIndexes(a, L, R)","\tif err != nil {","\t\treturn nil, err","\t}","","\tar := R.(apl.Array)","\tres := apl.MakeArray(ar, shape)","\tfor i, k := range idx {","\t\tres.Set(i, ar.At(k).Copy())","\t}","\treturn res, nil","}","","func transposeIndexes(a *apl.Apl, L, R apl.Value) ([]int, []int, error) {","\tar := R.(apl.Array)","\trs := ar.Shape()","","\t// Monadic transpose: reverse axis.","\tif L == nil {","\t\tl := apl.IntArray{","\t\t\tDims: []int{len(rs)},","\t\t\tInts: make([]int, len(rs)),","\t\t}","\t\tn := len(l.Ints)","\t\tfor i := range l.Ints {","\t\t\tl.Ints[i] = n - i - 1 + a.Origin","\t\t}","\t\tL = l","\t}","\tal := L.(apl.IntArray)","\tls := al.Shape()","","\tif len(ls) != 1 {","\t\treturn nil, nil, fmt.Errorf(\"transpose: L must be a vector or a scalar\")","\t}","\tif ls[0] != len(rs) {","\t\treturn nil, nil, fmt.Errorf(\"transpose: length of L must be the rank of R\")","\t}","","\t// Add 1 to L, if Origin is 0.","\tif a.Origin == 0 {","\t\tfor i := range al.Ints {","\t\t\tal.Ints[i] += 1","\t\t}","\t}","","\t// All values of ⍳⌈/L must be included in L.","\t// Iso requires both: ^/L∊⍳⌈/0,L and ^/(⍳⌈/0,L)∊L to evaluate to 1.","\tmax := -1","\tm := make(map[int]bool)","\tfor _, v := range al.Ints {","\t\tif v \u003c 1 {","\t\t\treturn nil, nil, fmt.Errorf(\"transpose: value in L out of range: %d\", v)","\t\t}","\t\tif v \u003e max {","\t\t\tmax = v","\t\t}","\t\tm[v] = true","\t}","\tfor i := 1; i \u003c= max; i++ {","\t\tif m[i] == false {","\t\t\treturn nil, nil, fmt.Errorf(\"transpose: all of ⍳⌈/L must be included in L: %d is missing\", i)","\t\t}","\t}","","\tmaxRS := 0","\tfor _, i := range rs {","\t\tif i \u003e maxRS {","\t\t\tmaxRS = i","\t\t}","\t}","","\t// Element i of shape is ⌊/(L=i)/⍴R.","\tshape := make([]int, max)","\tfor i := range shape {","\t\tmin := maxRS","\t\tfor k := range rs {","\t\t\tif al.Ints[k] == i+1 {","\t\t\t\tif rs[k] \u003c min {","\t\t\t\t\tmin = rs[k]","\t\t\t\t}","\t\t\t}","\t\t}","\t\tshape[i] = min","\t}","","\t// The index list of the result is for item i is: 1+(⍴R)⊥((shape)⊤i)[L]","\tflat := make([]int, apl.Prod(shape))","\tics, sidx := apl.NewIdxConverter(shape)","\ticr, ridx := apl.NewIdxConverter(rs)","\tfor i := range flat {","\t\tics.Indexes(i, sidx) // sidx ← (shape)⊤i","\t\tfor k, n := range al.Ints {","\t\t\tridx[k] = sidx[n-1] // ridx ← ((shape)⊤i)[L]","\t\t}","\t\tflat[i] = icr.Index(ridx) // 1+(⍴R)⊥((shape)⊤i)[L]","\t}","\treturn flat, shape, nil","}","","// transposeObject returns a Table by transposing an object.","func transposeObject(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\to := R.(apl.Object)","\ttab := apl.Table{Dict: \u0026apl.Dict{}}","\tkeys := o.Keys()","\tn := 0","\tfor i, k := range keys {","\t\tcol := o.At(k).Copy()","\t\tif col == nil {","\t\t\treturn nil, fmt.Errorf(\"table: column %s does not exist\", k.String(apl.Format{}))","\t\t}","\t\tif _, ok := col.(apl.Object); ok {","\t\t\treturn nil, fmt.Errorf(\"table: contains an object: %s\", k.String(apl.Format{}))","\t\t}","\t\tif _, ok := col.(apl.Array); ok == false {","\t\t\tcol = apl.MixedArray{Dims: []int{1}, Values: []apl.Value{col}}","\t\t}","","\t\tsize := 1","\t\tar := col.(apl.Array)","\t\tif shape := ar.Shape(); len(shape) != 1 {","\t\t\treturn nil, fmt.Errorf(\"table: column %s has rank != 1\", k.String(apl.Format{}))","\t\t} else {","\t\t\tsize = shape[0]","\t\t}","\t\tu, ok := a.Unify(ar, true)","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"table: cannot unify column %s (mixed types)\", k.String(apl.Format{}))","\t\t}","","\t\tif i == 0 {","\t\t\tn = size","\t\t} else if size != n {","\t\t\treturn nil, fmt.Errorf(\"table: columns have different sizes\")","\t\t}","\t\ttab.K = append(tab.K, k.Copy())","\t\tif tab.Dict.M == nil {","\t\t\ttab.Dict.M = make(map[apl.Value]apl.Value)","\t\t}","\t\ttab.M[k] = u // already copied","\t}","\ttab.Rows = n","\treturn tab, nil","}","","// transposeTable returns a Dict by transposing a table.","func transposeTable(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\treturn R.(apl.Table).Dict.Copy(), nil","}",""],"type.go":["package xgo","","import (","\t\"fmt\"","\t\"reflect\"","\t\"strings\"","\t\"text/tabwriter\"","\t\"unicode\"","","\t\"github.com/ktye/iv/apl\"",")","","// New returns an initialization function for the given type.","func New(t reflect.Type) create {","\treturn create{t}","}","","type Value reflect.Value","","// xgo values are copied by reference.","func (v Value) Copy() apl.Value {","\treturn v","}","","func (v Value) String(f apl.Format) string {","\tkeys := v.Keys()","\tif keys == nil {","\t\treturn fmt.Sprintf(\"xgo.Value (not a struct) %T\", v)","\t}","\tvar buf strings.Builder","\ttw := tabwriter.NewWriter(\u0026buf, 1, 0, 1, ' ', 0)","\tfor _, k := range keys {","\t\tval := v.At(k)","\t\ts := \"\"","\t\tif val == nil {","\t\t\ts = \"?\"","\t\t} else {","\t\t\ts = val.String(f)","\t\t}","\t\tfmt.Fprintf(tw, \"%s:\\t%s\\n\", k.String(f), s)","\t}","\ttw.Flush()","\ts := buf.String()","\tif len(s) \u003e 0 \u0026\u0026 s[len(s)-1] == '\\n' {","\t\treturn s[:len(s)-1]","\t}","\treturn s","}","","// Keys returns the field names, if the value is a struct.","// It does not return the method names.","// It returns nil, if the Value is not a struct.","func (v Value) Keys() []apl.Value {","\tval := reflect.Value(v)","\tif val.Kind() == reflect.Ptr {","\t\tval = val.Elem()","\t}","\tif val.Kind() != reflect.Struct {","\t\treturn nil","\t}","\tt := val.Type()","\tn := t.NumField()","\tres := make([]apl.Value, n)","\tfor i := 0; i \u003c n; i++ {","\t\tres[i] = apl.String(t.Field(i).Name)","\t}","\treturn res","}","","func (v Value) Methods() []string {","\tval := reflect.Value(v)","\tt := val.Type()","\tn := t.NumMethod()","\tres := make([]string, n)","\tfor i := range res {","\t\tres[i] = lower(t.Method(i).Name)","\t}","\treturn res","}","","// Field returns the value of a field or a method with the given name.","func (v Value) At(key apl.Value) apl.Value {","\tname, ok := key.(apl.String)","\tif ok == false {","\t\treturn nil","\t}","\tval := reflect.Value(v)","\tvar zero reflect.Value","\tName := upper(string(name))","\tm := val.MethodByName(Name)","\tif m != zero {","\t\treturn Function{Name: Name, Fn: m}","\t}","\tif val.Kind() == reflect.Ptr {","\t\tval = val.Elem()","\t}","\tif val.Kind() != reflect.Struct {","\t\treturn nil","\t}","\tsf := val.FieldByName(Name)","\tif sf == zero {","\t\treturn nil","\t}","\trv, err := Convert(sf)","\tif err != nil {","\t\treturn nil","\t}","\treturn rv","}","","func (v Value) Set(key apl.Value, fv apl.Value) error {","\tfield, ok := key.(apl.String)","\tif ok == false {","\t\treturn fmt.Errorf(\"key must be a string\")","\t}","\tval := reflect.Value(v).Elem()","\tif val.Kind() != reflect.Struct {","\t\treturn fmt.Errorf(\"not a struct: cannot set field\")","\t}","\tsf := val.FieldByName(string(field))","\tvar zero reflect.Value","\tif sf == zero {","\t\treturn fmt.Errorf(\"%v: field does not exist: %s\", val.Type(), field)","\t}","\tsv, err := export(fv, sf.Type())","\tif err != nil {","\t\treturn err","\t}","\tsf.Set(sv)","\treturn nil","}","","type create struct {","\treflect.Type","}","","func (t create) String(f apl.Format) string {","\treturn fmt.Sprintf(\"new %v\", t.Type)","}","func (t create) Copy() apl.Value {","\treturn t","}","","func (t create) Call(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tv := reflect.New(t.Type)","\treturn Value(v), nil","}","","func upper(s string) string {","\treturn firstrune(s, unicode.ToUpper)","}","","func lower(s string) string {","\treturn firstrune(s, unicode.ToLower)","}","","func firstrune(s string, f func(r rune) rune) string {","\tvar buf strings.Builder","\tfor i, r := range s {","\t\tif i == 0 {","\t\t\tbuf.WriteRune(f(r))","\t\t} else {","\t\t\tbuf.WriteRune(r)","\t\t}","\t}","\treturn buf.String()","}",""],"uniform.go":["package apl","","import (","\t\"fmt\"","\t\"reflect\"",")","","// Unify tries to convert the array to a uniform array, if possible.","// If uptype is true, it uptypes numeric values, if that helps.","func (a *Apl) Unify(A Array, uptype bool) (resultarray Array, resultok bool) {","\tif _, ok := A.(EmptyArray); ok {","\t\treturn A, false // An empty array is defined to be not uniform.","\t}","\tif _, ok := A.(Uniform); ok {","\t\treturn A, true","\t}","","\tnoNumber := -10","\tboolType := reflect.TypeOf(Bool(false))","\tindexType := reflect.TypeOf(Int(0))","\tclass := func(t reflect.Type) int {","\t\tn, ok := a.Tower.Numbers[t]","\t\tif ok == false {","\t\t\tif t == indexType {","\t\t\t\treturn -1","\t\t\t} else if t == boolType {","\t\t\t\treturn -2","\t\t\t}","\t\t\treturn noNumber","\t\t}","\t\treturn n.Class","\t}","","\t// If all values of the array are the same type, it is uniform.","\t// This includes a List who's primary values are lists as well.","\tsize := A.Size()","\tif size \u003c 1 {","\t\treturn A, true","\t}","\tv0 := A.At(0)","\tt0 := reflect.TypeOf(v0)","\tmax := class(t0)","\tvar maxnumber Number","\tif max != noNumber {","\t\tmaxnumber = v0.(Number)","\t}","\tsametype := true","\tfor i := 1; i \u003c size; i++ {","\t\tv := A.At(i)","\t\tt := reflect.TypeOf(v)","\t\tif t != t0 {","\t\t\tsametype = false","\t\t\tif uptype == false {","\t\t\t\treturn A, false","\t\t\t}","\t\t}","\t\tif max != noNumber {","\t\t\tif c := class(t); c == noNumber {","\t\t\t\tmax = noNumber","\t\t\t} else if c \u003e max {","\t\t\t\tmax = c","\t\t\t\tmaxnumber = v.(Number)","\t\t\t}","\t\t}","\t}","","\t// All values have the same type.","\t// Try to convert them to a compact uniform type.","\tif sametype {","\t\t// Some uniform types are defined in the numeric implementation.","\t\t// E.g. numbers/{FloatArray;ComplexArray;TimeArray}.","\t\tif max != noNumber {","\t\t\tvar values []Value","\t\t\tswitch v := A.(type) {","\t\t\tcase MixedArray:","\t\t\t\tvalues = v.Values","\t\t\tcase List:","\t\t\t\tvalues = []Value(v)","\t\t\tdefault:","\t\t\t\treturn A, true","\t\t\t}","\t\t\tif u, ok := a.Tower.Uniform(values); ok == false {","\t\t\t\treturn A, true","\t\t\t} else if rs, ok := u.(Reshaper); ok {","\t\t\t\treturn rs.Reshape(CopyShape(A)).(Array), true","\t\t\t}","\t\t}","\t\t// Some uniform types are defined in array.go.","\t\tif t0 == reflect.TypeOf(String(\"\")) {","\t\t\tar := StringArray{}.Make(CopyShape(A))","\t\t\tfor i := 0; i \u003c A.Size(); i++ {","\t\t\t\tv := A.At(i)","\t\t\t\tar.(StringArray).Strings[i] = string(v.(String))","\t\t\t}","\t\t\treturn ar, true","\t\t} else if t0 == reflect.TypeOf(Bool(false)) {","\t\t\tar := BoolArray{}.Make(CopyShape(A))","\t\t\tfor i := 0; i \u003c A.Size(); i++ {","\t\t\t\tv := A.At(i)","\t\t\t\tar.(BoolArray).Bools[i] = bool(v.(Bool))","\t\t\t}","\t\t\treturn ar, true","\t\t} else if t0 == reflect.TypeOf(Int(0)) {","\t\t\tar := IntArray{}.Make(CopyShape(A))","\t\t\tfor i := 0; i \u003c A.Size(); i++ {","\t\t\t\tv := A.At(i)","\t\t\t\tar.(IntArray).Ints[i] = int(v.(Int))","\t\t\t}","\t\t\treturn ar, true","\t\t}","\t\t// Unknown uniform type is returnd as it is.","\t\treturn A, true","\t} else if max == noNumber {","\t\t// If values are not of the same type, and not identified by","\t\t// the current tower, there is no chance to make them equal.","\t\treturn A, false","\t}","","\t// Try to uptype all values to the same number type.","\tvalues := make([]Value, size)","\tvar err error","\tfor i := 0; i \u003c size; i++ {","\t\tv := A.At(i)","\t\tvalues[i], _, err = a.Tower.SameType(v.(Number), maxnumber)","\t\tif err != nil {","\t\t\tfmt.Println(err)","\t\t\treturn A, false","\t\t}","\t}","\tif u, ok := a.Tower.Uniform(values); ok {","\t\tif rs, ok := u.(Reshaper); ok {","\t\t\treturn rs.Reshape(CopyShape(A)).(Array), true","\t\t}","\t}","\treturn A, false","}","","// UnifyArray tries to unify the input array without uptyping.","func (a *Apl) UnifyArray(A Array) Array {","\tu, _ := a.Unify(A, false)","\treturn u","}",""],"unique.go":["package primitives","","import (","\t\"github.com/ktye/iv/apl\"","\t. \"github.com/ktye/iv/apl/domain\"",")","","func init() {","\tregister(primitive{","\t\tsymbol: \"∪\",","\t\tdoc:    \"unique\",","\t\tDomain: Monadic(ToVector(nil)),","\t\tfn:     unique,","\t})","\tregister(primitive{","\t\tsymbol: \"∪\",","\t\tdoc:    \"union\",","\t\tDomain: Dyadic(Split(ToVector(nil), ToVector(nil))),","\t\tfn:     union,","\t})","}","","// unique: R is a vector.","// DyRef gives an example of an array: ∪3 4 5⍴⍳20","// which fails in tryapl.","// ISO also allows only vectors.","func unique(a *apl.Apl, _, R apl.Value) (apl.Value, error) {","\tar := R.(apl.Array)","","\tvar values []apl.Value","\tfor i := 0; i \u003c ar.Size(); i++ {","\t\tv := ar.At(i)","\t\tu := true","\t\tfor k := range values {","\t\t\tif isEqual(a, v, values[k]) {","\t\t\t\tu = false","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif u {","\t\t\tvalues = append(values, v.Copy())","\t\t}","\t}","\treturn a.UnifyArray(apl.MixedArray{Values: values, Dims: []int{len(values)}}), nil","}","","// union of L and R, both are vectors.","func union(a *apl.Apl, L, R apl.Value) (apl.Value, error) {","\tif _, ok := L.(apl.EmptyArray); ok {","\t\treturn R, nil","\t}","\tif _, ok := R.(apl.EmptyArray); ok {","\t\treturn L, nil","\t}","\tal := L.(apl.Array)","\tar := R.(apl.Array)","","\tvar values []apl.Value","\tappendvec := func(vec apl.Array) error {","\t\tfor i := 0; i \u003c vec.Size(); i++ {","\t\t\tv := vec.At(i)","\t\t\tu := true","\t\t\tfor k := range values {","\t\t\t\tif isEqual(a, v, values[k]) == true {","\t\t\t\t\tu = false","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","\t\t\tif u {","\t\t\t\tvalues = append(values, v.Copy())","\t\t\t}","\t\t}","\t\treturn nil","\t}","\tif err := appendvec(al); err != nil {","\t\treturn nil, err","\t}","\tif err := appendvec(ar); err != nil {","\t\treturn nil, err","\t}","\treturn a.UnifyArray(apl.MixedArray{Dims: []int{len(values)}, Values: values}), nil","}",""],"value.go":["package apl","","import \"io\"","","// Value is the result of an evaluation.","// Any type that implements the interface is a valid type for apl.","//","// The String method is used to display the value.","// It does not need to be unique or represent the input syntax.","// Mosty types have no input respresentation at all.","// They are the result of a computation.","//","// A Value may implement further interfaces such as Array, Uniform or Function.","type Value interface {","\tString(Format) string","\tCopy() Value","}","","// VarReader is implemented by Values that are able to parse from a Reader.","// The ReadFrom method must return a new value of the same type.","// The function should be able to parse the format of it's String method.","// It is used by varfs in package io.","type VarReader interface {","\tReadFrom(*Apl, io.Reader) (Value, error)","}",""],"var.go":["package apl","","import (","\t\"fmt\"","\t\"sort\"","\t\"strings\"","\t\"unicode\"","","\t\"github.com/ktye/iv/apl/scan\"",")","","// Identifier is a the Value of a variable identifier.","// It evaluates to itself, not the stored Value.","type Identifier string","","func (id Identifier) String(f Format) string {","\treturn string(id)","}","","func (id Identifier) Copy() Value {","\treturn id","}","","func (id Identifier) Eval(a *Apl) (Value, error) {","\treturn id, nil","}","","// Assign assigns a value to a variable with the given name.","func (a *Apl) Assign(name string, v Value) error {","\treturn a.AssignEnv(name, v, nil)","}","","// AssignEnv assigns a variable in the given environment.","func (a *Apl) AssignEnv(name string, v Value, env *env) error {","\tok, isfunc := isVarname(name)","\tif ok == false {","\t\treturn fmt.Errorf(\"variable name is not allowed: %s\", name)","\t}","","\tif strings.ContainsRune(name, '→') {","\t\treturn fmt.Errorf(\"cannot assign to a package variable\")","\t}","","\t// Assignment to the special variable ⎕ prints the value.","\tif name == \"⎕\" {","\t\tfmt.Fprintf(a.stdout, \"%s\\n\", v.String(a.Format))","\t\treturn nil","\t} else if name == \"⎕IO\" {","\t\tif n, ok := v.(Number); ok {","\t\t\tif b, ok := a.Tower.ToBool(n); ok {","\t\t\t\ta.Origin = 0","\t\t\t\tif b {","\t\t\t\t\ta.Origin = 1","\t\t\t\t}","\t\t\t\treturn nil","\t\t\t}","\t\t}","\t\treturn fmt.Errorf(\"cannot set index origin: %T\", v)","\t} else if name == \"⎕PP\" {","\t\treturn a.SetPP(v)","\t}","","\tif _, ok := v.(Function); ok \u0026\u0026 isfunc != true {","\t\treturn fmt.Errorf(\"cannot assign a function to an uppercase variable\")","\t} else if ok == false \u0026\u0026 isfunc == true {","\t\treturn fmt.Errorf(\"only functions can be assigned to lowercase variables\")","\t}","","\tif env == nil {","\t\tenv = a.env","\t}","","\t// Special case: Default left argument in lambda expressions:","\t// Do not overwrite the given argument.","\tif name == \"⍺\" \u0026\u0026 env.vars[\"⍺\"] != nil {","\t\treturn nil","\t}","","\tenv.vars[name] = v","\treturn nil","}","","// Lookup returns the value stored under the given variable name.","// It returns nil, if the variable does not exist.","// Variables are lexically scoped.","func (a *Apl) Lookup(name string) Value {","\tv, _ := a.LookupEnv(name)","\treturn v","}","","// LookupEnv returns the value of a variable and a pointer to the environment,","// where it was found.","func (a *Apl) LookupEnv(name string) (Value, *env) {","\tif name == \"⎕IO\" {","\t\treturn Int(a.Origin), nil","\t} else if name == \"⎕PP\" {","\t\treturn Int(a.Format.PP), nil","\t}","","\tif idx := strings.Index(name, \"→\"); idx != -1 {","\t\tprefix := name[:idx]","\t\tif strings.ToLower(prefix) == prefix {","\t\t\treturn a.packageVar(name), nil","\t\t} else {","\t\t\treturn nil, nil","\t\t}","\t}","","\te := a.env","\tfor {","\t\tv, ok := e.vars[name]","\t\tif ok {","\t\t\treturn v, e","\t\t}","\t\tif e.parent == nil {","\t\t\tbreak","\t\t}","\t\te = e.parent","\t}","\treturn nil, nil","}","","// Vars returns a list of variable names in a package.","// If pkg is empty, the variables the root environment are returned,","// and a list of packages ending with \"/\".","func (a *Apl) Vars(pkg string) ([]string, error) {","\tvar l []string","\tvar e *env","\tif pkg == \"\" {","\t\tfor n := range a.pkg {","\t\t\tl = append(l, n+\"/\")","\t\t}","\t\te = a.env","\t} else {","\t\tvar ok bool","\t\te, ok = a.pkg[pkg]","\t\tif ok == false {","\t\t\treturn nil, fmt.Errorf(\"package %s is not registered\", pkg)","\t\t}","\t}","\tfor n := range e.vars {","\t\tl = append(l, n)","\t}","\tsort.Strings(l)","\treturn l, nil","}","","func (a *Apl) packageVar(name string) Value {","\tidx := strings.Index(name, \"→\")","\tif idx == -1 {","\t\treturn nil","\t}","\tpkgname := name[:idx]","\tvarname := name[idx+len(\"→\"):]","\tpkg, ok := a.pkg[pkgname]","\tif ok == false {","\t\treturn nil","\t}","\treturn pkg.vars[varname]","}","","// NumVar contains the identifier to a value.","// The name is upper case and does not evaluate to a function.","// NumVar evaluates to the stored value or to an Identifier if it is undeclared.","type numVar struct {","\tname string","}","","func (v numVar) String(f Format) string {","\treturn v.name","}","","func (v numVar) Eval(a *Apl) (Value, error) {","\tx := a.Lookup(v.name)","\tif x == nil {","\t\treturn Identifier(v.name), nil","\t}","\treturn x, nil","}","","// FnValue contains the identifier to a function value.","// It's name is lowercase.","// FnVar evaluates to the stored value or to an Identifier if it is undeclared.","type fnVar string","","func (f fnVar) String(af Format) string {","\treturn string(f)","}","func (f fnVar) Copy() Value { return f }","","func (f fnVar) Eval(a *Apl) (Value, error) {","\treturn f, nil","}","","func (f fnVar) Call(a *Apl, l, r Value) (Value, error) {","\tx := a.Lookup(string(f))","\tif x == nil {","\t\treturn Identifier(f), nil","\t}","\tfn, ok := x.(Function)","\tif ok == false {","\t\treturn nil, fmt.Errorf(\"value in function variable is not a function: %T\", x)","\t}","\tif fn == nil {","\t\treturn nil, fmt.Errorf(\"value in function variable %s is nil\", string(f))","\t}","\treturn fn.Call(a, l, r)","}","","// isVarname returns if the string is allowed as a variable name and","// referes to a number or function value.","func isVarname(s string) (ok, isfunc bool) {","\tif s == \"\" {","\t\treturn false, false","\t}","\tif n := strings.Index(s, \"→\"); n != -1 {","\t\ts = s[n+len(\"→\"):]","\t}","\tupper := false","\tfor i, r := range s {","\t\tif scan.AllowedInVarname(r, i == 0) == false {","\t\t\treturn false, false","\t\t}","\t\tif i == 0 \u0026\u0026 unicode.IsUpper(r) || strings.IndexRune(\"⎕⍺⍵\", r) != -1 {","\t\t\tupper = true","\t\t}","\t}","\treturn true, upper == false","}",""]}
