<!KDOCTYPE html>
<head><meta charset="utf-8">
<link rel="icon" type="image/png" sizes="32x32" href="db/kelas32.png">
<link rel="icon" type="image/png" sizes="16x16" href="db/kelas16.png">
<title>kdoc</title>
<style>
*{font-family:monospace;margin:0}
.q{color:green}.q:hover{cursor:pointer}
.l{color:blue}.l:hover{cursor:pointer}
.n{display:none}
.h{font-weight:bold}
.hidden{display:none}
body{display:flex;flex-direction:column;height:100vh;overflow:hidden}
a{text-decoration:none}
#ref{display:inline-block;background:#ffe}
#tty{display:inline-block;background:#004687;color:white;width:100%;margin-left:0.5em;margin-right:0.5em;outline:none;overflow:hidden}
#top{display:flex}
#doc{overflow:auto;outline:none;margin:0}
#mono{position:absolute;left:100;top:100;visibility:hidden}
</style>
</head>
<body onload="init()">

<script>
function ge(x){return document.getElementById(x)}
function ce(x){return document.createElement(x)}
function ct(x){return document.createTextNode(x)}
function tc(x,y){x.textContent=y;return x}
function ac(x,y){x.appendChild(y);return y}
function id(x,y){x.id=y;return x}
function fe(u,f){fetch(u).then(r=>r.text()).then(f)}
function rm(p){while(p.firstChild)p.removeChild(p.firstChild);return p}
const td_=new TextDecoder("utf-8"),su=x=>td_.decode(x),te_=new TextEncoder("utf-8"),us=x=>te_.encode(x)
let cur=null
function callers(x,y){rm(y);
 let c=Array.from(document.querySelectorAll("a")).filter(a=>a.id.startsWith("c:")&&a.getAttribute("href")=="#"+x.textContent)
 tc(y,"\ncallers("+(c.length)+")\n")
 c.forEach(a=>{let d=ce("a");d.href="#"+a.id;d.textContent="│"+a.parentElement.id;ac(y,d);ac(y,ct(": "+linestr(a)+"\n"))})
}
function linestr(a){let r=a.textContent,x=a;while(1){x=x.nextSibling;let s=x.textContent,i=s.indexOf("\n");if(i>=0){r+=s.slice(0,1+i);break};r+=s};x=a;while(1){x=x.previousSibling;let s=x.textContent,i=s.lastIndexOf("\n");if(i>=0){r=s.slice(i)+r;break};r=s+r};return r.trim()}
function init(){
 Array.from(document.getElementsByClassName("q")).forEach(x=>x.onclick=function(){let y=ge("c:"+x.textContent);callers(x,y);y.classList.toggle("n")})
 kinit();ge("tty").onclick=end;ge("tty").onkeydown=key
}
//function goto(x){let s=ge("fn:"+x);s.scrollIntoView();s.classList.add("h")}
function ttysize(){let mono=ge("mono");let n=mono.textContent.length;return[Math.floor(ge("tty").clientHeight/mono.clientHeight),Math.floor(n*ge("tty").clientWidth/mono.clientWidth)]}
function end(){let b=ge("tty"),s=window.getSelection();s.removeAllRanges();let r=document.createRange();r.selectNodeContents(b);r.collapse(false);s.addRange(r);b.focus()}
function key(e){if(e.key!="Enter")return;e.preventDefault();let s=ge("tty").textContent.split("\n").slice(-1)+"\n";O("\n");try{K.repl(KC(s.startsWith(" ")?s.slice(1):s));O(" ");end()}catch(e){kinit()}}
window.onhashchange=e=>{if(cur)cur.classList.remove("h");cur=ge(window.location.hash.slice(1));console.log("cur",cur);if(cur==null)return;cur.classList.add("h");cur.scrollIntoView()}



let /*there be*/ K
let C=()=>new Int8Array(K.memory.buffer),I=()=>new Int32Array(K.memory.buffer),J=()=>new BigInt64Array(K.memory.buffer),F=()=>new Float64Array(K.memory.buffer),lo=x=>Number(BigInt.asUintN(32,x))
let kenv={env:{ 
 Exit:  function(x      ){},
 Args:  function(       ){return 0},
 Arg:   function(x,y    ){return 0},
 Read:  function(a,b,c  ){return -1},
 Write: function(a,b,c,d){O(su(new Uint8Array(K.memory.buffer,c,d)));return 0},
 ReadIn:function(x,y    ){return 0},
 Native:function(x,y    ){let i=lo(x);K.dx(x);return xcal[i](K.Atx(4n,y))}}}
function O(s){let o=ge("tty");console.log("kout", s);o.textContent=(o.textContent+s).split("\n").slice(-25).join("\n")}
function kinit(){let s,sz=x=>{s=x.byteLength;return x}
 fetch("k.wasm").then(r=>r.arrayBuffer()).then(r=>WebAssembly.instantiate(sz(r),kenv)).then(r=>{
 K=r.instance.exports
 K.kinit()
 let[rows,cols]=ttysize();K.dx(K.Asn(Ks("l."),K.Atx(Ks("lxy"),K.Val(KC((cols-2)+" 50")))))
 O("ktye/k "+s+"\n ");end()})
}
let
KC=x=>{let r=K.mk(18,x.length  );C().set(("string"===typeof x)?us(x):x,lo(r));return r},
Ks=x=>K.sc(KC(x))


let full=s=>{let a=[" ▲ "," ▼ "];ge("top").style.display=(s.textContent==a[0])?"none":"flex";s.textContent=a[1-a.indexOf(s.textContent)]}
</script>

<div id="top">
<pre id="ref">ktye/k ktye.github.io/kdoc.htm
+ <a href="#Flp">flp</a> <a href="#Add">add</a>  '  ech     both bin
- <a href="#Neg">neg</a> <a href="#Sub">sub</a>  /  ovr/fix echright
* <a href="#Fst">fst</a> <a href="#Mul">mul</a>  \  scn/fix eachleft
% <a href="#Sqr">sqr</a> <a href="#Div">div</a>      / join   decode
! <a href="#Til">til</a> <a href="#Key">key</a>  mod \ split  encode
& <a href="#Wer">wer</a> <a href="#Min">min</a>  $[a;b;...]     cond
| <a href="#Rev">rev</a> <a href="#Max">max</a>  while[c;a;b;d;e;..]
< <a href="#Asc">asc</a> <a href="#Les">les</a>  f:{x+y}   [bl;o;ck]
> <a href="#Dsc">dsc</a> <a href="#Mor">mor</a>              "abc" c
= <a href="#Grp">grp</a> <a href="#Eql">eql</a>  01234567   1 2 3  i
~ <a href="#Not">not</a> <a href="#Mtc">mtc</a>   :+-*%&|   4 5 6. f
, <a href="#Enl">enl</a> <a href="#Cat">cat</a>  <>=~!,^#   2a300  z
^ <a href="#Srt">srt</a> <a href="#Cut">cut</a>  _$?@.     (1;2 3) L
# <a href="#Cnt">cnt</a> <a href="#Tak">tak</a>           `a`b!5 6 D
_ <a href="#Flr">flr</a> <a href="#Drp">drp</a>  t,d t,t t,'t   join
$ <a href="#Str">str</a> <a href="#Cst">cst</a>           k!t    key
? <a href="#Unq">unq</a> <a href="#Fnd">fnd</a>  in       k?t  group
@ <a href="#Typ">typ</a> <a href="#Atx">atx</a>  @[x;i;+;y]    amend
. <a href="#Val">val</a> <a href="#Cal">cal</a>  .[x;i;+;y]    dmend
                              
<a href="#Abs">abs</a> <a href="#Sin">sin</a> <a href="#Cos">cos</a> <a href="#Exp">exp</a> <a href="#Log">log</a> <a href="#Find">find</a> <a href="#Angle">angle</a>
<a href="#Imag">imag</a> <a href="#Conj">conj</a>  <a href="#types">types</a>:cisfzLDTvcdlx
?n(uniform) ?-n(normal) ?z(bi)
n?n(with)   random   -n?n(w/o)
</pre>
<pre id="tty" contenteditable spellcheck="false"></pre>
<pre id="toc"><a href="#kinit">kinit</a> . . . . . . . . . . .<a href="#z.k">z.k</a>

<a href="#intro">intro</a>                   <a href="#invoke">invoke</a> 

<a href="#types">types</a> <a href="#literals">literals</a>    <a href="#allocator">memory/alloc</a>

adverb            <a href="#control">control-flow</a>

examples algebra stats queries

html/js/wasm         embedding





implementation
types        <a href="#heap">heap</a>    allocator
<a href="#symtab">symbols</a>    variables     scope
exec    <a href="#kvm">kvm</a>       <a href="#kvm">instructions</a>
compilers boot   <a href="#extend">extend/native</a>
            f77 c go wasm wasi
<a href="#ir">ir</a>  <a href="#mach">abstract-machine</a>  <a href="#syscalls">syscalls</a>
</pre>
</div>
<pre id="doc"><span class="l" onclick="full(this)" style="position:sticky;float:right;top:0"> ▲ </span><span id="init">
func <span class='q'>init</span>() {<span id='c:init' class='n'>
</span>
	<a href="#Memory" id='c:0'>Memory</a>(1)
	<a href="#Memory2" id='c:1'>Memory2</a>(1)
	<a href="#Data" id='c:2'>Data</a>(132, &#34;\x00\x01@\x01\x01\x01\x01\t\x10`\x01\x01\x01\x01\x01\t\xc4\xc4\xc4\xc4\xc4\xc4\xc4\xc4\xc4\xc4\x01 \x01\x01\x01\x01\x01BBBBBBBBBBBBBBBBBBBBBBBBBB\x10\t`\x01\x01\x00\xc2\xc2\xc2\xc2\xc2\xc2BBBBBBBBBBBBBBBBBBBB\x10\x01`\x01&#34;) // k_test.go: TestClass
	<a href="#Data" id='c:3'>Data</a>(227, &#34;:+-*%&amp;|&lt;&gt;=~!,^#_$?@.&#39;:/:\\:vbcisfzldtmdplx00BCISFZLDT0&#34;)
	<a href="#Export" id='c:4'>Export</a>(<a href="#main" id='c:5'>main</a>, <a href="#Asn" id='c:6'>Asn</a>, <a href="#Atx" id='c:7'>Atx</a>, <a href="#Cal" id='c:8'>Cal</a>, <a href="#cs" id='c:9'>cs</a>, <a href="#dx" id='c:10'>dx</a>, <a href="#Kc" id='c:11'>Kc</a>, <a href="#Kf" id='c:12'>Kf</a>, <a href="#Ki" id='c:13'>Ki</a>, <a href="#kinit" id='c:14'>kinit</a>, <a href="#l2" id='c:15'>l2</a>, <a href="#mk" id='c:16'>mk</a>, <a href="#nn" id='c:17'>nn</a>, <a href="#repl" id='c:18'>repl</a>, <a href="#rx" id='c:19'>rx</a>, <a href="#sc" id='c:20'>sc</a>, <a href="#src" id='c:21'>src</a>, <a href="#tp" id='c:22'>tp</a>, <a href="#trap" id='c:23'>trap</a>, <a href="#Val" id='c:24'>Val</a>)

	//            0    :    +    -    *    %    &amp;    |    &lt;    &gt;    =10   ~    !    ,    ^    #    _    $    ?    @    .20  &#39;    &#39;:   /    /:   \    \:                  30                       35                       40                       45
	<a href="#Functions" id='c:25'>Functions</a>(00, <a href="#nul" id='c:26'>nul</a>, <a href="#Idy" id='c:27'>Idy</a>, <a href="#Flp" id='c:28'>Flp</a>, <a href="#Neg" id='c:29'>Neg</a>, <a href="#Fst" id='c:30'>Fst</a>, <a href="#Sqr" id='c:31'>Sqr</a>, <a href="#Wer" id='c:32'>Wer</a>, <a href="#Rev" id='c:33'>Rev</a>, <a href="#Asc" id='c:34'>Asc</a>, <a href="#Dsc" id='c:35'>Dsc</a>, <a href="#Grp" id='c:36'>Grp</a>, <a href="#Not" id='c:37'>Not</a>, <a href="#Til" id='c:38'>Til</a>, <a href="#Enl" id='c:39'>Enl</a>, <a href="#Srt" id='c:40'>Srt</a>, <a href="#Cnt" id='c:41'>Cnt</a>, <a href="#Flr" id='c:42'>Flr</a>, <a href="#Str" id='c:43'>Str</a>, <a href="#Unq" id='c:44'>Unq</a>, <a href="#Typ" id='c:45'>Typ</a>, <a href="#Val" id='c:46'>Val</a>, <a href="#ech" id='c:47'>ech</a>, <a href="#nyi" id='c:48'>nyi</a>, <a href="#rdc" id='c:49'>rdc</a>, <a href="#nyi" id='c:50'>nyi</a>, <a href="#scn" id='c:51'>scn</a>, <a href="#nyi" id='c:52'>nyi</a>, <a href="#lst" id='c:53'>lst</a>, <a href="#Kst" id='c:54'>Kst</a>, <a href="#Out" id='c:55'>Out</a>, <a href="#nyi" id='c:56'>nyi</a>, <a href="#nyi" id='c:57'>nyi</a>, <a href="#Abs" id='c:58'>Abs</a>, <a href="#Img" id='c:59'>Img</a>, <a href="#Cnj" id='c:60'>Cnj</a>, <a href="#Ang" id='c:61'>Ang</a>, <a href="#nyi" id='c:62'>nyi</a>, <a href="#Uqs" id='c:63'>Uqs</a>, <a href="#nyi" id='c:64'>nyi</a>, <a href="#Tok" id='c:65'>Tok</a>, <a href="#Fwh" id='c:66'>Fwh</a>, <a href="#Las" id='c:67'>Las</a>, <a href="#Exp" id='c:68'>Exp</a>, <a href="#Log" id='c:69'>Log</a>, <a href="#Sin" id='c:70'>Sin</a>, <a href="#Cos" id='c:71'>Cos</a>, <a href="#Prs" id='c:72'>Prs</a>)
	<a href="#Functions" id='c:73'>Functions</a>(64, <a href="#Asn" id='c:74'>Asn</a>, <a href="#Dex" id='c:75'>Dex</a>, <a href="#Add" id='c:76'>Add</a>, <a href="#Sub" id='c:77'>Sub</a>, <a href="#Mul" id='c:78'>Mul</a>, <a href="#Div" id='c:79'>Div</a>, <a href="#Min" id='c:80'>Min</a>, <a href="#Max" id='c:81'>Max</a>, <a href="#Les" id='c:82'>Les</a>, <a href="#Mor" id='c:83'>Mor</a>, <a href="#Eql" id='c:84'>Eql</a>, <a href="#Mtc" id='c:85'>Mtc</a>, <a href="#Key" id='c:86'>Key</a>, <a href="#Cat" id='c:87'>Cat</a>, <a href="#Cut" id='c:88'>Cut</a>, <a href="#Tak" id='c:89'>Tak</a>, <a href="#Drp" id='c:90'>Drp</a>, <a href="#Cst" id='c:91'>Cst</a>, <a href="#Fnd" id='c:92'>Fnd</a>, <a href="#Atx" id='c:93'>Atx</a>, <a href="#Cal" id='c:94'>Cal</a>, <a href="#Ech" id='c:95'>Ech</a>, <a href="#nyi" id='c:96'>nyi</a>, <a href="#Rdc" id='c:97'>Rdc</a>, <a href="#nyi" id='c:98'>nyi</a>, <a href="#Scn" id='c:99'>Scn</a>, <a href="#nyi" id='c:100'>nyi</a>, <a href="#com" id='c:101'>com</a>, <a href="#prj" id='c:102'>prj</a>, <a href="#Otu" id='c:103'>Otu</a>, <a href="#In" id='c:104'>In</a>, <a href="#Find" id='c:105'>Find</a>, <a href="#Hyp" id='c:106'>Hyp</a>, <a href="#Cpx" id='c:107'>Cpx</a>, <a href="#fdl" id='c:108'>fdl</a>, <a href="#Rot" id='c:109'>Rot</a>, <a href="#Enc" id='c:110'>Enc</a>, <a href="#Dec" id='c:111'>Dec</a>, <a href="#nyi" id='c:112'>nyi</a>, <a href="#nyi" id='c:113'>nyi</a>, <a href="#Bin" id='c:114'>Bin</a>, <a href="#Mod" id='c:115'>Mod</a>, <a href="#Pow" id='c:116'>Pow</a>, <a href="#Lgn" id='c:117'>Lgn</a>)
	<a href="#Functions" id='c:118'>Functions</a>(193, <a href="#tchr" id='c:119'>tchr</a>, <a href="#tnms" id='c:120'>tnms</a>, <a href="#tvrb" id='c:121'>tvrb</a>, <a href="#tpct" id='c:122'>tpct</a>, <a href="#tvar" id='c:123'>tvar</a>, <a href="#tsym" id='c:124'>tsym</a>, <a href="#pop" id='c:125'>pop</a>)
	<a href="#Functions" id='c:126'>Functions</a>(211, <a href="#Amd" id='c:127'>Amd</a>, <a href="#Dmd" id='c:128'>Dmd</a>)

	<a href="#Functions" id='c:129'>Functions</a>(220, <a href="#negi" id='c:130'>negi</a>, <a href="#negf" id='c:131'>negf</a>, <a href="#negz" id='c:132'>negz</a>)
	<a href="#Functions" id='c:133'>Functions</a>(223, <a href="#absi" id='c:134'>absi</a>, <a href="#absf" id='c:135'>absf</a>, <a href="#nyi" id='c:136'>nyi</a>)
	<a href="#Functions" id='c:137'>Functions</a>(226, <a href="#addi" id='c:138'>addi</a>, <a href="#addf" id='c:139'>addf</a>, <a href="#addz" id='c:140'>addz</a>)
	<a href="#Functions" id='c:141'>Functions</a>(229, <a href="#subi" id='c:142'>subi</a>, <a href="#subf" id='c:143'>subf</a>, <a href="#subz" id='c:144'>subz</a>)
	<a href="#Functions" id='c:145'>Functions</a>(232, <a href="#muli" id='c:146'>muli</a>, <a href="#mulf" id='c:147'>mulf</a>, <a href="#mulz" id='c:148'>mulz</a>)
	<a href="#Functions" id='c:149'>Functions</a>(235, <a href="#divi" id='c:150'>divi</a>, <a href="#divf" id='c:151'>divf</a>, <a href="#divz" id='c:152'>divz</a>)
	<a href="#Functions" id='c:153'>Functions</a>(238, <a href="#mini" id='c:154'>mini</a>, <a href="#minf" id='c:155'>minf</a>, <a href="#minz" id='c:156'>minz</a>)
	<a href="#Functions" id='c:157'>Functions</a>(241, <a href="#maxi" id='c:158'>maxi</a>, <a href="#maxf" id='c:159'>maxf</a>, <a href="#maxz" id='c:160'>maxz</a>)
	<a href="#Functions" id='c:161'>Functions</a>(244, <a href="#modi" id='c:162'>modi</a>, <a href="#sqrf" id='c:163'>sqrf</a>, <a href="#nyi" id='c:164'>nyi</a>)

	<a href="#Functions" id='c:165'>Functions</a>(247, <a href="#cmi" id='c:166'>cmi</a>, <a href="#cmi" id='c:167'>cmi</a>, <a href="#cmi" id='c:168'>cmi</a>, <a href="#cmF" id='c:169'>cmF</a>, <a href="#cmZ" id='c:170'>cmZ</a>, <a href="#cmC" id='c:171'>cmC</a>, <a href="#cmI" id='c:172'>cmI</a>, <a href="#cmI" id='c:173'>cmI</a>, <a href="#cmF" id='c:174'>cmF</a>, <a href="#cmZ" id='c:175'>cmZ</a>, <a href="#cmL" id='c:176'>cmL</a>)
	<a href="#Functions" id='c:177'>Functions</a>(258, <a href="#sum" id='c:178'>sum</a>, <a href="#rd0" id='c:179'>rd0</a>, <a href="#prd" id='c:180'>prd</a>, <a href="#rd0" id='c:181'>rd0</a>, <a href="#min" id='c:182'>min</a>, <a href="#max" id='c:183'>max</a>)
	<a href="#Functions" id='c:184'>Functions</a>(264, <a href="#mtC" id='c:185'>mtC</a>, <a href="#mtC" id='c:186'>mtC</a>, <a href="#mtC" id='c:187'>mtC</a>, <a href="#mtF" id='c:188'>mtF</a>, <a href="#mtF" id='c:189'>mtF</a>, <a href="#mtL" id='c:190'>mtL</a>)
	<a href="#Functions" id='c:191'>Functions</a>(270, <a href="#inC" id='c:192'>inC</a>, <a href="#inI" id='c:193'>inI</a>, <a href="#inI" id='c:194'>inI</a>, <a href="#inF" id='c:195'>inF</a>, <a href="#inZ" id='c:196'>inZ</a>)
	<a href="#Functions" id='c:197'>Functions</a>(275, <a href="#exp1" id='c:198'>exp1</a>, <a href="#log1" id='c:199'>log1</a>, <a href="#sin1" id='c:200'>sin1</a>, <a href="#cos1" id='c:201'>cos1</a>, <a href="#pow2" id='c:202'>pow2</a>)
}</span>
<span id="trap">
func <span class='q'>trap</span>() {<span id='c:trap' class='n'>
</span>
	s := <a href="#src" id='c:203'>src</a>()
	if srcp == 0 {
		<a href="#write" id='c:204'>write</a>(<a href="#Ku" id='c:205'>Ku</a>(2608)) // 0\n
	} else {
		a := <a href="#maxi" id='c:206'>maxi</a>(srcp-30, 0)
		b := <a href="#mini" id='c:207'>mini</a>(<a href="#nn" id='c:208'>nn</a>(s), srcp+30)
		for i := a; i &lt; b; i++ {
			if <a href="#I8" id='c:209'>I8</a>(<a href="#int32" id='c:210'>int32</a>(s)+i) == 10 {
				if i &lt; srcp {
					a = 1 + i
				} else {
					b = i
				}
			}
		}
		<a href="#Write" id='c:211'>Write</a>(0, 0, <a href="#int32" id='c:212'>int32</a>(s)+a, b-a)
		if srcp &gt; a {
			<a href="#write" id='c:213'>write</a>(<a href="#Cat" id='c:214'>Cat</a>(<a href="#Kc" id='c:215'>Kc</a>(10), <a href="#ntake" id='c:216'>ntake</a>(srcp-a-1, <a href="#Kc" id='c:217'>Kc</a>(32))))
		}
	}
	<a href="#write" id='c:218'>write</a>(<a href="#Ku" id='c:219'>Ku</a>(2654)) // ^\n
	<a href="#panic" id='c:220'>panic</a>(srcp)
}</span>
const nai int32 = -2147483648 // 0N
var loc, xyz K
var na, inf float64
var pp, pe, sp, srcp, rand_ int32 //parse position/end, stack position, src pointer

//   0....7  key
//   8...15  val
//  16...19  src(int32)
//  20..127  free list
// 128..131  memsize log2
// 132..226  char map (starts at 100)    -+
// 227..252  :+-*%!&amp;|&lt;&gt;=~,^#_$?@.&#39;:/:\:   | text
// 253..279  vbcisfzldtcdpl000BCISFZLDT   | section
// 280.....  z.k                         -+
// 2k....4k  stack
<span id="kinit">
func <span class='q'>kinit</span>() {<span id='c:kinit' class='n'>
</span>
	<a href="#minit" id='c:221'>minit</a>(12, 16) //4k..64k
	sp = 2048
	<a href="#SetI32" id='c:222'>SetI32</a>(16, <a href="#int32" id='c:223'>int32</a>(<a href="#mk" id='c:224'>mk</a>(Ct, 0))) //<a href="#SetI64" id='c:225'>SetI64</a>(512, <a href="#int64" id='c:226'>int64</a>(<a href="#mk" id='c:227'>mk</a>(Ct, 0))) //src
	na = <a href="#F64reinterpret_i64" id='c:228'>F64reinterpret_i64</a>(<a href="#uint64" id='c:229'>uint64</a>(0x7FF8000000000001))
	inf = <a href="#F64reinterpret_i64" id='c:230'>F64reinterpret_i64</a>(<a href="#uint64" id='c:231'>uint64</a>(0x7FF0000000000000))
	rand_ = 1592653589
	<a href="#SetI64" id='c:232'>SetI64</a>(0, <a href="#int64" id='c:233'>int64</a>(<a href="#mk" id='c:234'>mk</a>(Lt, 0)))
	<a href="#SetI64" id='c:235'>SetI64</a>(8, <a href="#int64" id='c:236'>int64</a>(<a href="#mk" id='c:237'>mk</a>(Lt, 0)))
	xyz = <a href="#Ech" id='c:238'>Ech</a>(17, <a href="#l2" id='c:239'>l2</a>(<a href="#sc" id='c:240'>sc</a>(<a href="#Ku" id='c:241'>Ku</a>(0)), <a href="#Ku" id='c:242'>Ku</a>(8026488))) //`$&#39;&#34;xyz&#34;: `x`y`z -&gt; 8 16 24
	<a href="#zk" id='c:243'>zk</a>()
}</span>

type K uint64
type T int32

// typeof(x K): t=x&gt;&gt;59
// isatom:      t&lt;16
// isvector:    t&gt;16
// isflat:      t&lt;22
// basetype:    t&amp;15  0..9
// istagged:    t&lt;5
// haspointers: t&gt;5   (recursive unref)
// elementsize: $[t&lt;19;1;t&lt;21;4;8]
const ( //base t&amp;15          bytes  atom  vector
	ct T = 2 // char    1      2     18
	it T = 3 // int     4      3     19
	st T = 4 // symbol  4      4     20
	ft T = 5 // float   8      5     21
	zt T = 6 // complex(8)     6     22

	cf T = 10 // comp   (8)    10
	df T = 11 // derived(8)    11
	pf T = 12 // proj   (8)    12
	lf T = 13 // lambda (8)    13
	xf T = 14 // native (8)    14
	Ct T = 18
	It T = 19
	St T = 20
	Ft T = 21
	Zt T = 22
	Lt T = 23 // list
	Dt T = 24 // dict
	Tt T = 25 // table
)

// func t=0
// basic x &lt; 64 (triadic/tetradic)
// composition .. f2 f1 f0
// derived     func    symb
// projection  func    arglist  emptylist
// lambda      code    string	locals
// native      ptr(Ct) string

// ptr: int32(x)
//  p-12    p-4 p
// [length][rc][data]
<span id="ti">
func <span class='q'>ti</span>(t T, i int32) K { return <a href="#K" id='c:244'>K</a>(t)&lt;&lt;59 | <a href="#K" id='c:245'>K</a>(<a href="#uint32" id='c:246'>uint32</a>(i)) }<span id='c:ti' class='n'>
</span></span><span id="Kc">
func <span class='q'>Kc</span>(x int32) K      { return <a href="#ti" id='c:247'>ti</a>(ct, x) }<span id='c:Kc' class='n'>
</span></span><span id="Ki">
func <span class='q'>Ki</span>(x int32) K      { return <a href="#ti" id='c:248'>ti</a>(it, x) }<span id='c:Ki' class='n'>
</span></span><span id="Ks">
func <span class='q'>Ks</span>(x int32) K      { return <a href="#ti" id='c:249'>ti</a>(st, x) }<span id='c:Ks' class='n'>
</span></span><span id="Kf">
func <span class='q'>Kf</span>(x float64) K {<span id='c:Kf' class='n'>
</span>
	r := <a href="#mk" id='c:250'>mk</a>(Ft, 1)
	<a href="#SetF64" id='c:251'>SetF64</a>(<a href="#int32" id='c:252'>int32</a>(r), x)
	return <a href="#ti" id='c:253'>ti</a>(ft, <a href="#int32" id='c:254'>int32</a>(r))
}</span><span id="Kz">
func <span class='q'>Kz</span>(x, y float64) K {<span id='c:Kz' class='n'>
</span>
	r := <a href="#mk" id='c:255'>mk</a>(Zt, 1)
	rp := <a href="#int32" id='c:256'>int32</a>(r)
	<a href="#SetF64" id='c:257'>SetF64</a>(rp, x)
	<a href="#SetF64" id='c:258'>SetF64</a>(rp+8, y)
	return <a href="#ti" id='c:259'>ti</a>(zt, rp)
}</span><span id="l1">
func <span class='q'>l1</span>(x K) K {<span id='c:l1' class='n'>
</span>
	r := <a href="#mk" id='c:260'>mk</a>(Lt, 1)
	<a href="#SetI64" id='c:261'>SetI64</a>(<a href="#int32" id='c:262'>int32</a>(r), <a href="#int64" id='c:263'>int64</a>(x))
	return r
}</span><span id="l2">
func <span class='q'>l2</span>(x, y K) K {<span id='c:l2' class='n'>
</span>
	r := <a href="#mk" id='c:264'>mk</a>(Lt, 2)
	rp := <a href="#int32" id='c:265'>int32</a>(r)
	<a href="#SetI64" id='c:266'>SetI64</a>(rp, <a href="#int64" id='c:267'>int64</a>(x))
	<a href="#SetI64" id='c:268'>SetI64</a>(8+rp, <a href="#int64" id='c:269'>int64</a>(y))
	return r
}</span><span id="l3">
func <span class='q'>l3</span>(x, y, z K) K { return <a href="#cat1" id='c:270'>cat1</a>(<a href="#l2" id='c:271'>l2</a>(x, y), z) }<span id='c:l3' class='n'>
</span></span><span id="r0">
func <span class='q'>r0</span>(x K) K       { r := <a href="#x0" id='c:272'>x0</a>(x); <a href="#dx" id='c:273'>dx</a>(x); return r }<span id='c:r0' class='n'>
</span></span><span id="r1">
func <span class='q'>r1</span>(x K) K       { r := <a href="#x1" id='c:274'>x1</a>(x); <a href="#dx" id='c:275'>dx</a>(x); return r }<span id='c:r1' class='n'>
</span></span><span id="x0">
func <span class='q'>x0</span>(x K) K       { return <a href="#rx" id='c:276'>rx</a>(<a href="#K" id='c:277'>K</a>(<a href="#I64" id='c:278'>I64</a>(<a href="#int32" id='c:279'>int32</a>(x)))) }<span id='c:x0' class='n'>
</span></span><span id="x1">
func <span class='q'>x1</span>(x K) K       { return <a href="#x0" id='c:280'>x0</a>(x + 8) }<span id='c:x1' class='n'>
</span></span><span id="x2">
func <span class='q'>x2</span>(x K) K       { return <a href="#x0" id='c:281'>x0</a>(x + 16) }<span id='c:x2' class='n'>
</span></span><span id="Ku">
func <span class='q'>Ku</span>(x uint64) K { // Ct<span id='c:Ku' class='n'>
</span>
	r := <a href="#mk" id='c:282'>mk</a>(Ct, 0)
	p := <a href="#int32" id='c:283'>int32</a>(r)
	for x != 0 {
		<a href="#SetI8" id='c:284'>SetI8</a>(p, <a href="#int32" id='c:285'>int32</a>(x))
		x &gt;&gt;= <a href="#uint64" id='c:286'>uint64</a>(8)
		p++
	}
	<a href="#SetI32" id='c:287'>SetI32</a>(<a href="#int32" id='c:288'>int32</a>(r)-12, p-<a href="#int32" id='c:289'>int32</a>(r))
	return r
}</span>

/* encode bytes for Ku(..) with: https://play.golang.org/p/4ethx6OEVCR<span id="enc">
func <span class='q'>enc</span>(x []byte) uint64 {<span id='c:enc' class='n'>
</span>
	r := <a href="#uint32" id='c:290'>uint32</a>(0)
	var o uint64 = 1
	for _, b := range x {
		r += o * <a href="#uint64" id='c:291'>uint64</a>(b)
		o &lt;&lt;= 8
	}
	return r
}</span>
*/
<span id="kx">
func <span class='q'>kx</span>(u int32, x K) K { return <a href="#cal" id='c:292'>cal</a>(<a href="#Val" id='c:293'>Val</a>(<a href="#Ks" id='c:294'>Ks</a>(u)), <a href="#l1" id='c:295'>l1</a>(x)) } //call k func from z.k<span id='c:kx' class='n'>
</span></span><span id="sc">
func <span class='q'>sc</span>(c K) K { //symbol from chars<span id='c:sc' class='n'>
</span>
	s := <a href="#K" id='c:296'>K</a>(<a href="#I64" id='c:297'>I64</a>(0))
	sp := <a href="#int32" id='c:298'>int32</a>(s)
	sn := <a href="#nn" id='c:299'>nn</a>(s)
	for i := <a href="#int32" id='c:300'>int32</a>(0); i &lt; sn; i++ {
		if <a href="#match" id='c:301'>match</a>(c, <a href="#K" id='c:302'>K</a>(<a href="#I64" id='c:303'>I64</a>(sp))) != 0 {
			<a href="#dx" id='c:304'>dx</a>(c)
			return <a href="#ti" id='c:305'>ti</a>(st, sp-<a href="#int32" id='c:306'>int32</a>(s))
		}
		sp += 8
	}
	<a href="#SetI64" id='c:307'>SetI64</a>(0, <a href="#int64" id='c:308'>int64</a>(<a href="#cat1" id='c:309'>cat1</a>(s, c)))
	<a href="#SetI64" id='c:310'>SetI64</a>(8, <a href="#int64" id='c:311'>int64</a>(<a href="#cat1" id='c:312'>cat1</a>(<a href="#K" id='c:313'>K</a>(<a href="#I64" id='c:314'>I64</a>(8)), 0)))
	return <a href="#ti" id='c:315'>ti</a>(st, 8*sn)
}</span><span id="cs">
func <span class='q'>cs</span>(x K) K { return <a href="#x0" id='c:316'>x0</a>(<a href="#K" id='c:317'>K</a>(<a href="#I32" id='c:318'>I32</a>(0)) + x) } //chars from symbol<span id='c:cs' class='n'>
</span></span><span id="missing">
func <span class='q'>missing</span>(t T) K {<span id='c:missing' class='n'>
</span>
	switch t - 2 {
	case 0: // ct
		return <a href="#Kc" id='c:319'>Kc</a>(32)
	case 1: // it
		return <a href="#Ki" id='c:320'>Ki</a>(nai)
	case 2: // st
		return <a href="#Ks" id='c:321'>Ks</a>(0)
	case 3: // ft
		return <a href="#Kf" id='c:322'>Kf</a>(na)
	case 4: // zt
		return <a href="#Kz" id='c:323'>Kz</a>(na, na)
	default: // lt
		return <a href="#mk" id='c:324'>mk</a>(Ct, 0) //<a href="#Kb" id='c:325'>Kb</a>(0)
	}
}</span>
type rdf = func(int32, T, int32) K
type scf = func(K, int32, T, int32) K
<span id="ech">
func <span class='q'>ech</span>(x K) K { return <a href="#ti" id='c:326'>ti</a>(df, <a href="#int32" id='c:327'>int32</a>(<a href="#l2" id='c:328'>l2</a>(x, 0))) } // &#39;<span id='c:ech' class='n'>
</span></span><span id="rdc">
func <span class='q'>rdc</span>(x K) K { return <a href="#ti" id='c:329'>ti</a>(df, <a href="#int32" id='c:330'>int32</a>(<a href="#l2" id='c:331'>l2</a>(x, 2))) } // /<span id='c:rdc' class='n'>
</span></span><span id="scn">
func <span class='q'>scn</span>(x K) K { return <a href="#ti" id='c:332'>ti</a>(df, <a href="#int32" id='c:333'>int32</a>(<a href="#l2" id='c:334'>l2</a>(x, 4))) } // \<span id='c:scn' class='n'>
</span></span>
<span id="Ech">
func <span class='q'>Ech</span>(f, x K) K {<span id='c:Ech' class='n'>
</span>
	var r K
	t := <a href="#tp" id='c:335'>tp</a>(f)
	if <a href="#isfunc" id='c:336'>isfunc</a>(t) == 0 {
		return <a href="#Bin" id='c:337'>Bin</a>(f, <a href="#Fst" id='c:338'>Fst</a>(x))
	}
	if <a href="#nn" id='c:339'>nn</a>(x) == 1 {
		x = <a href="#Fst" id='c:340'>Fst</a>(x)
	} else {
		return <a href="#ecn" id='c:341'>ecn</a>(f, x)
	}
	if <a href="#tp" id='c:342'>tp</a>(x) &lt; 16 {
		<a href="#trap" id='c:343'>trap</a>() //type
	}
	xt := <a href="#tp" id='c:344'>tp</a>(x)
	if xt == Dt {
		r = <a href="#x0" id='c:345'>x0</a>(x)
		return <a href="#Key" id='c:346'>Key</a>(r, <a href="#Ech" id='c:347'>Ech</a>(f, <a href="#l1" id='c:348'>l1</a>(<a href="#r1" id='c:349'>r1</a>(x))))
	}
	if xt == Tt {
		x = <a href="#explode" id='c:350'>explode</a>(x)
	}
	xn := <a href="#nn" id='c:351'>nn</a>(x)
	r = <a href="#mk" id='c:352'>mk</a>(Lt, xn)
	rp := <a href="#int32" id='c:353'>int32</a>(r)
	for i := <a href="#int32" id='c:354'>int32</a>(0); i &lt; xn; i++ {
		<a href="#SetI64" id='c:355'>SetI64</a>(rp, <a href="#int64" id='c:356'>int64</a>(<a href="#Atx" id='c:357'>Atx</a>(<a href="#rx" id='c:358'>rx</a>(f), <a href="#ati" id='c:359'>ati</a>(<a href="#rx" id='c:360'>rx</a>(x), i))))
		rp += 8
	}
	<a href="#dxy" id='c:361'>dxy</a>(f, x)
	return <a href="#uf" id='c:362'>uf</a>(r)
}</span><span id="ecn">
func <span class='q'>ecn</span>(f, x K) K {<span id='c:ecn' class='n'>
</span>
	if <a href="#nn" id='c:363'>nn</a>(x) == 2 {
		r := <a href="#x0" id='c:364'>x0</a>(x)
		x = <a href="#r1" id='c:365'>r1</a>(x)
		//if r == 0 { project?
		//	return <a href="#Ech" id='c:366'>Ech</a>(f, <a href="#l1" id='c:367'>l1</a>(x))
		//}
		if <a href="#tp" id='c:368'>tp</a>(f) == 0 &amp;&amp; <a href="#int32" id='c:369'>int32</a>(f) == 13 {
			if <a href="#tp" id='c:370'>tp</a>(r) == Tt &amp;&amp; <a href="#tp" id='c:371'>tp</a>(x) == Tt { // T,&#39;T (horcat)
				if <a href="#nn" id='c:372'>nn</a>(r) != <a href="#nn" id='c:373'>nn</a>(x) {
					<a href="#trap" id='c:374'>trap</a>() //length
				}
				f = <a href="#Cat" id='c:375'>Cat</a>(<a href="#x0" id='c:376'>x0</a>(r), <a href="#x0" id='c:377'>x0</a>(x))
				return <a href="#key" id='c:378'>key</a>(f, <a href="#Cat" id='c:379'>Cat</a>(<a href="#r1" id='c:380'>r1</a>(r), <a href="#r1" id='c:381'>r1</a>(x)), Tt)
			}
		}
		return <a href="#ec2" id='c:382'>ec2</a>(f, r, x)
	}
	return <a href="#Ech" id='c:383'>Ech</a>(20, <a href="#l2" id='c:384'>l2</a>(f, <a href="#Flp" id='c:385'>Flp</a>(x)))
}</span><span id="ec2">
func <span class='q'>ec2</span>(f, x, y K) K {<span id='c:ec2' class='n'>
</span>
	var r K
	t := <a href="#dtypes" id='c:386'>dtypes</a>(x, y)
	if t &gt; Lt {
		r = <a href="#dkeys" id='c:387'>dkeys</a>(x, y)
		return <a href="#key" id='c:388'>key</a>(r, <a href="#ec2" id='c:389'>ec2</a>(f, <a href="#dvals" id='c:390'>dvals</a>(x), <a href="#dvals" id='c:391'>dvals</a>(y)), t)
	}
	n := <a href="#conform" id='c:392'>conform</a>(x, y)
	switch n {
	case 0: // a-a
		return <a href="#Cal" id='c:393'>Cal</a>(f, <a href="#l2" id='c:394'>l2</a>(x, y))
	case 1: // a-v
		n = <a href="#nn" id='c:395'>nn</a>(y)
	default: // v-a, v-v
		n = <a href="#nn" id='c:396'>nn</a>(x)
	}
	r = <a href="#mk" id='c:397'>mk</a>(Lt, n)
	rp := <a href="#int32" id='c:398'>int32</a>(r)
	for i := <a href="#int32" id='c:399'>int32</a>(0); i &lt; n; i++ {
		<a href="#SetI64" id='c:400'>SetI64</a>(rp, <a href="#int64" id='c:401'>int64</a>(<a href="#Cal" id='c:402'>Cal</a>(<a href="#rx" id='c:403'>rx</a>(f), <a href="#l2" id='c:404'>l2</a>(<a href="#ati" id='c:405'>ati</a>(<a href="#rx" id='c:406'>rx</a>(x), i), <a href="#ati" id='c:407'>ati</a>(<a href="#rx" id='c:408'>rx</a>(y), i)))))
		rp += 8
	}
	<a href="#dx" id='c:409'>dx</a>(f)
	<a href="#dxy" id='c:410'>dxy</a>(x, y)
	return <a href="#uf" id='c:411'>uf</a>(r)
}</span>
<span id="Rdc">
func <span class='q'>Rdc</span>(f, x K) K { // x f/y   (x=0):f/y<span id='c:Rdc' class='n'>
</span>
	t := <a href="#tp" id='c:412'>tp</a>(f)
	if <a href="#isfunc" id='c:413'>isfunc</a>(t) == 0 {
		if <a href="#nn" id='c:414'>nn</a>(x) == 2 {
			<a href="#trap" id='c:415'>trap</a>() //nyi state machine
		}
		x = <a href="#Fst" id='c:416'>Fst</a>(x)
		if t&amp;15 == ct {
			return <a href="#join" id='c:417'>join</a>(f, x)
		} else {
			return <a href="#Dec" id='c:418'>Dec</a>(f, x)
		}
	}
	a := <a href="#arity" id='c:419'>arity</a>(f)
	if a != 2 {
		if a &gt; 2 {
			return <a href="#rdn" id='c:420'>rdn</a>(f, x, 0)
		} else {
			return <a href="#fix" id='c:421'>fix</a>(f, <a href="#Fst" id='c:422'>Fst</a>(x), 0)
		}
	}

	if <a href="#nn" id='c:423'>nn</a>(x) == 2 {
		return <a href="#Ecr" id='c:424'>Ecr</a>(f, x)
	}
	x = <a href="#Fst" id='c:425'>Fst</a>(x)
	xt := <a href="#tp" id='c:426'>tp</a>(x)
	if xt == Dt {
		x = <a href="#Val" id='c:427'>Val</a>(x)
		xt = <a href="#tp" id='c:428'>tp</a>(x)
	}
	if xt &lt; 16 {
		<a href="#dx" id='c:429'>dx</a>(f)
		return x
	}
	xn := <a href="#nn" id='c:430'>nn</a>(x)
	if t == 0 {
		fp := <a href="#int32" id='c:431'>int32</a>(f)
		if fp &gt; 1 &amp;&amp; fp &lt; 8 { // sum,prd,min,max (reduce.go)
			if xt == Tt {
				return <a href="#Ech" id='c:432'>Ech</a>(<a href="#rdc" id='c:433'>rdc</a>(f), <a href="#l1" id='c:434'>l1</a>(<a href="#Flp" id='c:435'>Flp</a>(x)))
			}
			r := Func[256+fp].(rdf)(<a href="#int32" id='c:436'>int32</a>(x), xt, <a href="#ep" id='c:437'>ep</a>(x)) //365
			if r != 0 {
				<a href="#dx" id='c:438'>dx</a>(x)
				return r
			}
		}
		if fp == 13 { // ,/
			if xt &lt; Lt {
				return x
			}
		}
	}
	if xn == 0 {
		<a href="#dxy" id='c:439'>dxy</a>(f, x)
		return <a href="#missing" id='c:440'>missing</a>(xt)
	}
	i := <a href="#int32" id='c:441'>int32</a>(1)
	x0 := <a href="#ati" id='c:442'>ati</a>(<a href="#rx" id='c:443'>rx</a>(x), 0)
	for i &lt; xn {
		x0 = <a href="#cal" id='c:444'>cal</a>(<a href="#rx" id='c:445'>rx</a>(f), <a href="#l2" id='c:446'>l2</a>(x0, <a href="#ati" id='c:447'>ati</a>(<a href="#rx" id='c:448'>rx</a>(x), i)))
		i++
	}
	<a href="#dxy" id='c:449'>dxy</a>(x, f)
	return x0
}</span><span id="rdn">
func <span class='q'>rdn</span>(f, x, l K) K { // {x+y*z}/x  {x+y*z}\x<span id='c:rdn' class='n'>
</span>
	r := <a href="#Fst" id='c:450'>Fst</a>(<a href="#rx" id='c:451'>rx</a>(x))
	x = <a href="#Flp" id='c:452'>Flp</a>(<a href="#ndrop" id='c:453'>ndrop</a>(1, x))
	n := <a href="#nn" id='c:454'>nn</a>(x)
	for i := <a href="#int32" id='c:455'>int32</a>(0); i &lt; n; i++ {
		r = <a href="#Cal" id='c:456'>Cal</a>(<a href="#rx" id='c:457'>rx</a>(f), <a href="#Cat" id='c:458'>Cat</a>(<a href="#l1" id='c:459'>l1</a>(r), <a href="#ati" id='c:460'>ati</a>(<a href="#rx" id='c:461'>rx</a>(x), i)))
		if l != 0 {
			l = <a href="#cat1" id='c:462'>cat1</a>(l, <a href="#rx" id='c:463'>rx</a>(r))
		}
	}
	<a href="#dxy" id='c:464'>dxy</a>(f, x)
	if l != 0 {
		<a href="#dx" id='c:465'>dx</a>(r)
		return <a href="#uf" id='c:466'>uf</a>(l)
	}
	return r
}</span>
<span id="Ecr">
func <span class='q'>Ecr</span>(f, x K) K { //x f/y<span id='c:Ecr' class='n'>
</span>
	var r K
	y := <a href="#x1" id='c:467'>x1</a>(x)
	x = <a href="#r0" id='c:468'>r0</a>(x)
	yt := <a href="#tp" id='c:469'>tp</a>(y)
	if yt &lt; 16 {
		return <a href="#cal" id='c:470'>cal</a>(f, <a href="#l2" id='c:471'>l2</a>(x, y))
	}
	if yt &gt; Lt {
		t := <a href="#dtypes" id='c:472'>dtypes</a>(x, y)
		r = <a href="#dkeys" id='c:473'>dkeys</a>(x, y)
		return <a href="#key" id='c:474'>key</a>(r, <a href="#Ecr" id='c:475'>Ecr</a>(f, <a href="#l2" id='c:476'>l2</a>(<a href="#dvals" id='c:477'>dvals</a>(x), <a href="#dvals" id='c:478'>dvals</a>(y))), t)
	}
	yn := <a href="#nn" id='c:479'>nn</a>(y)
	r = <a href="#mk" id='c:480'>mk</a>(Lt, yn)
	rp := <a href="#int32" id='c:481'>int32</a>(r)
	for i := <a href="#int32" id='c:482'>int32</a>(0); i &lt; yn; i++ {
		<a href="#SetI64" id='c:483'>SetI64</a>(rp, <a href="#int64" id='c:484'>int64</a>(<a href="#cal" id='c:485'>cal</a>(<a href="#rx" id='c:486'>rx</a>(f), <a href="#l2" id='c:487'>l2</a>(<a href="#rx" id='c:488'>rx</a>(x), <a href="#ati" id='c:489'>ati</a>(<a href="#rx" id='c:490'>rx</a>(y), i)))))
		rp += 8
	}
	<a href="#dx" id='c:491'>dx</a>(f)
	<a href="#dxy" id='c:492'>dxy</a>(x, y)
	return <a href="#uf" id='c:493'>uf</a>(r)
}</span><span id="fix">
func <span class='q'>fix</span>(f, x, l K) K {<span id='c:fix' class='n'>
</span>
	r := <a href="#K" id='c:494'>K</a>(0)
	y := <a href="#rx" id='c:495'>rx</a>(x)
	for {
		r = <a href="#Atx" id='c:496'>Atx</a>(<a href="#rx" id='c:497'>rx</a>(f), <a href="#rx" id='c:498'>rx</a>(x))
		if <a href="#match" id='c:499'>match</a>(r, x) != 0 {
			break
		}
		if <a href="#match" id='c:500'>match</a>(r, y) != 0 {
			break
		}
		<a href="#dx" id='c:501'>dx</a>(x)
		x = r
		if l != 0 {
			l = <a href="#cat1" id='c:502'>cat1</a>(l, <a href="#rx" id='c:503'>rx</a>(x))
		}
	}
	<a href="#dx" id='c:504'>dx</a>(f)
	<a href="#dxy" id='c:505'>dxy</a>(r, y)
	if l != 0 {
		<a href="#dx" id='c:506'>dx</a>(x)
		return l
	}
	return x
}</span><span id="Scn">
func <span class='q'>Scn</span>(f, x K) K {<span id='c:Scn' class='n'>
</span>
	var r K
	t := <a href="#tp" id='c:507'>tp</a>(f)
	if <a href="#isfunc" id='c:508'>isfunc</a>(t) == 0 {
		if <a href="#nn" id='c:509'>nn</a>(x) != 1 {
			<a href="#trap" id='c:510'>trap</a>() //rank
		}
		x = <a href="#Fst" id='c:511'>Fst</a>(x)
		if t&amp;15 == ct {
			return <a href="#split" id='c:512'>split</a>(f, x)
		} else {
			return <a href="#Enc" id='c:513'>Enc</a>(f, x)
		}
	}
	a := <a href="#arity" id='c:514'>arity</a>(f)
	if a != 2 {
		if a &gt; 2 {
			return <a href="#rdn" id='c:515'>rdn</a>(f, x, <a href="#mk" id='c:516'>mk</a>(Lt, 0))
		} else {
			x = <a href="#rx" id='c:517'>rx</a>(<a href="#Fst" id='c:518'>Fst</a>(x))
			return <a href="#fix" id='c:519'>fix</a>(f, x, <a href="#Enl" id='c:520'>Enl</a>(x))
		}
	}
	if <a href="#nn" id='c:521'>nn</a>(x) == 2 {
		return <a href="#Ecl" id='c:522'>Ecl</a>(f, x)
	}
	x = <a href="#Fst" id='c:523'>Fst</a>(x)
	xt := <a href="#tp" id='c:524'>tp</a>(x)
	if xt &lt; 16 {
		<a href="#dx" id='c:525'>dx</a>(f)
		return x
	}
	xn := <a href="#nn" id='c:526'>nn</a>(x)
	if xn == 0 {
		<a href="#dx" id='c:527'>dx</a>(f)
		return x
	}
	if xt == Dt {
		r = <a href="#x0" id='c:528'>x0</a>(x)
		return <a href="#Key" id='c:529'>Key</a>(r, <a href="#Scn" id='c:530'>Scn</a>(f, <a href="#l1" id='c:531'>l1</a>(<a href="#r1" id='c:532'>r1</a>(x))))
	}
	r = <a href="#mk" id='c:533'>mk</a>(Lt, xn)
	rp := <a href="#int32" id='c:534'>int32</a>(r)
	i := <a href="#int32" id='c:535'>int32</a>(1)
	z := <a href="#ati" id='c:536'>ati</a>(<a href="#rx" id='c:537'>rx</a>(x), 0)
	<a href="#SetI64" id='c:538'>SetI64</a>(rp, <a href="#int64" id='c:539'>int64</a>(<a href="#rx" id='c:540'>rx</a>(z)))
	rp += 8
	for i &lt; xn {
		z = <a href="#cal" id='c:541'>cal</a>(<a href="#rx" id='c:542'>rx</a>(f), <a href="#l2" id='c:543'>l2</a>(z, <a href="#ati" id='c:544'>ati</a>(<a href="#rx" id='c:545'>rx</a>(x), i)))
		<a href="#SetI64" id='c:546'>SetI64</a>(rp, <a href="#int64" id='c:547'>int64</a>(<a href="#rx" id='c:548'>rx</a>(z)))
		rp += 8
		i++
	}
	<a href="#dx" id='c:549'>dx</a>(z)
	<a href="#dxy" id='c:550'>dxy</a>(x, f)
	return <a href="#uf" id='c:551'>uf</a>(r)
}</span><span id="Ecl">
func <span class='q'>Ecl</span>(f, x K) K { // x f\y<span id='c:Ecl' class='n'>
</span>
	y := <a href="#x1" id='c:552'>x1</a>(x)
	x = <a href="#r0" id='c:553'>r0</a>(x)
	if <a href="#tp" id='c:554'>tp</a>(x) &lt; 16 {
		return <a href="#cal" id='c:555'>cal</a>(f, <a href="#l2" id='c:556'>l2</a>(x, y))
	}
	xn := <a href="#nn" id='c:557'>nn</a>(x)
	r := <a href="#mk" id='c:558'>mk</a>(Lt, xn)
	rp := <a href="#int32" id='c:559'>int32</a>(r)
	for i := <a href="#int32" id='c:560'>int32</a>(0); i &lt; xn; i++ {
		<a href="#SetI64" id='c:561'>SetI64</a>(rp, <a href="#int64" id='c:562'>int64</a>(<a href="#cal" id='c:563'>cal</a>(<a href="#rx" id='c:564'>rx</a>(f), <a href="#l2" id='c:565'>l2</a>(<a href="#ati" id='c:566'>ati</a>(<a href="#rx" id='c:567'>rx</a>(x), i), <a href="#rx" id='c:568'>rx</a>(y)))))
		rp += 8
	}
	<a href="#dx" id='c:569'>dx</a>(f)
	<a href="#dxy" id='c:570'>dxy</a>(x, y)
	return <a href="#uf" id='c:571'>uf</a>(r)
}</span>
<span id="uf">
func <span class='q'>uf</span>(x K) K {<span id='c:uf' class='n'>
</span>
	rt := <a href="#T" id='c:572'>T</a>(0)
	xn := <a href="#nn" id='c:573'>nn</a>(x)
	xp := <a href="#int32" id='c:574'>int32</a>(x)
	for i := <a href="#int32" id='c:575'>int32</a>(0); i &lt; xn; i++ {
		t := <a href="#tp" id='c:576'>tp</a>(<a href="#K" id='c:577'>K</a>(<a href="#I64" id='c:578'>I64</a>(xp)))
		if i == 0 {
			rt = t
		} else if t != rt {
			return x
		}
		xp += 8
	}
	if rt == Dt {
		r := <a href="#Til" id='c:579'>Til</a>(<a href="#x0" id='c:580'>x0</a>(x))
		if <a href="#tp" id='c:581'>tp</a>(r) != St {
			<a href="#dx" id='c:582'>dx</a>(r)
			return x
		}
		xp = <a href="#int32" id='c:583'>int32</a>(x)
		for xn &gt; 0 {
			xn--
			if <a href="#match" id='c:584'>match</a>(r, <a href="#K" id='c:585'>K</a>(<a href="#I64" id='c:586'>I64</a>(<a href="#int32" id='c:587'>int32</a>(<a href="#I64" id='c:588'>I64</a>(xp))))) == 0 {
				<a href="#dx" id='c:589'>dx</a>(r)
				return x
			}
			xp += 8
		}
		return <a href="#key" id='c:590'>key</a>(r, <a href="#Flp" id='c:591'>Flp</a>(<a href="#Ech" id='c:592'>Ech</a>(20, <a href="#l1" id='c:593'>l1</a>(x))), Tt)
	}
	if rt == 0 || rt &gt; zt {
		return x
	}
	r := <a href="#mk" id='c:594'>mk</a>(rt+16, xn)
	for xn &gt; 0 {
		xn--
		r = <a href="#sti" id='c:595'>sti</a>(r, xn, <a href="#ati" id='c:596'>ati</a>(<a href="#rx" id='c:597'>rx</a>(x), xn))
	}
	<a href="#dx" id='c:598'>dx</a>(x)
	return r
}</span><span id="minit">
func <span class='q'>minit</span>(a, b int32) {<span id='c:minit' class='n'>
</span>
	p := <a href="#int32" id='c:599'>int32</a>(1 &lt;&lt; a)
	for a &lt; b {
		<a href="#SetI32" id='c:600'>SetI32</a>(4*a, p)
		<a href="#SetI32" id='c:601'>SetI32</a>(p, 0)
		p *= 2
		a++
	}
	<a href="#SetI32" id='c:602'>SetI32</a>(128, b)
}</span><span id="alloc">
func <span class='q'>alloc</span>(n, s int32) int32 {<span id='c:alloc' class='n'>
</span>
	size := n * s
	t := <a href="#bucket" id='c:603'>bucket</a>(size)
	if <a href="#int64" id='c:604'>int64</a>(n)*<a href="#int64" id='c:605'>int64</a>(s) &gt; 2147483647 /*|| t &gt; 31*/ {
		<a href="#trap" id='c:606'>trap</a>() //grow (oom)
	}
	i := 4 * t
	m := 4 * <a href="#I32" id='c:607'>I32</a>(128)
	for <a href="#I32" id='c:608'>I32</a>(i) == 0 {
		if i &gt;= m {
			m = 4 * <a href="#grow" id='c:609'>grow</a>(i)
		} else {
			i += 4
		}
	}
	a := <a href="#I32" id='c:610'>I32</a>(i)
	<a href="#SetI32" id='c:611'>SetI32</a>(i, <a href="#I32" id='c:612'>I32</a>(a))
	for j := i - 4; j &gt;= 4*t; j -= 4 {
		u := a + <a href="#int32" id='c:613'>int32</a>(1)&lt;&lt;(j&gt;&gt;2)
		<a href="#SetI32" id='c:614'>SetI32</a>(u, <a href="#I32" id='c:615'>I32</a>(j))
		<a href="#SetI32" id='c:616'>SetI32</a>(j, u)
	}
	if a&amp;31 != 0 {
		<a href="#trap" id='c:617'>trap</a>() //memory corruption
	}
	return a
}</span><span id="grow">
func <span class='q'>grow</span>(p int32) int32 {<span id='c:grow' class='n'>
</span>
	n := 1 + (p &gt;&gt; 2)                   // required total mem (log2)
	g := (1 &lt;&lt; (n - 16)) - <a href="#Memorysize" id='c:618'>Memorysize</a>() // grow by 64k blocks
	if g &gt; 0 {
		if <a href="#Memorygrow" id='c:619'>Memorygrow</a>(g) &lt; 0 {
			<a href="#trap" id='c:620'>trap</a>() //grow
		}
	}
	<a href="#minit" id='c:621'>minit</a>(<a href="#I32" id='c:622'>I32</a>(128), n)
	return n
}</span><span id="mfree">
func <span class='q'>mfree</span>(x, bs int32) {<span id='c:mfree' class='n'>
</span>
	if x&amp;31 != 0 {
		<a href="#trap" id='c:623'>trap</a>() //memory corruption
	}
	t := 4 * bs
	<a href="#SetI32" id='c:624'>SetI32</a>(x, <a href="#I32" id='c:625'>I32</a>(t))
	<a href="#SetI32" id='c:626'>SetI32</a>(t, x)
}</span><span id="bucket">
func <span class='q'>bucket</span>(size int32) int32 { return <a href="#maxi" id='c:627'>maxi</a>(5, <a href="#int32" id='c:628'>int32</a>(32)-<a href="#I32clz" id='c:629'>I32clz</a>(15+size)) }<span id='c:bucket' class='n'>
</span></span><span id="mk">
func <span class='q'>mk</span>(t T, n int32) K {<span id='c:mk' class='n'>
</span>
	if t &lt; 17 {
		<a href="#trap" id='c:630'>trap</a>() //type
	}
	x := <a href="#alloc" id='c:631'>alloc</a>(n, <a href="#sz" id='c:632'>sz</a>(t))
	<a href="#SetI32" id='c:633'>SetI32</a>(x+12, 1) //rc
	<a href="#SetI32" id='c:634'>SetI32</a>(x+4, n)
	return <a href="#ti" id='c:635'>ti</a>(t, x+16)
}</span><span id="tp">
func <span class='q'>tp</span>(x K) T     { return <a href="#T" id='c:636'>T</a>(<a href="#uint64" id='c:637'>uint64</a>(x) &gt;&gt; 59) }<span id='c:tp' class='n'>
</span></span><span id="nn">
func <span class='q'>nn</span>(x K) int32 { return <a href="#I32" id='c:638'>I32</a>(<a href="#int32" id='c:639'>int32</a>(x) - 12) }<span id='c:nn' class='n'>
</span></span><span id="ep">
func <span class='q'>ep</span>(x K) int32 { return <a href="#int32" id='c:640'>int32</a>(x) + <a href="#sz" id='c:641'>sz</a>(<a href="#tp" id='c:642'>tp</a>(x))*<a href="#nn" id='c:643'>nn</a>(x) }<span id='c:ep' class='n'>
</span></span><span id="sz">
func <span class='q'>sz</span>(t T) int32 {<span id='c:sz' class='n'>
</span>
	if t &lt; 16 {
		return 8
	} else if t &lt; 19 {
		return 1
	} else if t &lt; 21 {
		return 4
	} else if t == Zt {
		return 16
	}
	return 8
}</span><span id="rx">
func <span class='q'>rx</span>(x K) K {<span id='c:rx' class='n'>
</span>
	if <a href="#tp" id='c:644'>tp</a>(x) &gt; 4 {
		p := <a href="#int32" id='c:645'>int32</a>(x) - 4
		<a href="#SetI32" id='c:646'>SetI32</a>(p, 1+<a href="#I32" id='c:647'>I32</a>(p))
	}
	return x
}</span><span id="dx">
func <span class='q'>dx</span>(x K) {<span id='c:dx' class='n'>
</span>
	t := <a href="#tp" id='c:648'>tp</a>(x)
	if t &lt; 5 {
		return
	}
	p := <a href="#int32" id='c:649'>int32</a>(x) - 16
	rc := <a href="#I32" id='c:650'>I32</a>(p + 12)
	<a href="#SetI32" id='c:651'>SetI32</a>(p+12, rc-1)
	if rc == 0 {
		<a href="#trap" id='c:652'>trap</a>() //unref
	}
	if rc == 1 {
		n := <a href="#nn" id='c:653'>nn</a>(x)
		if t&amp;15 &gt; 6 {
			if t == 14 || t == 24 || t == 25 {
				n = 2 // nat | D | T
			} else if t == 12 || t == 13 {
				n = 3 // prj | lam
			}
			p := <a href="#int32" id='c:654'>int32</a>(x)
			e := p + 8*n
			for p &lt; e {
				<a href="#dx" id='c:655'>dx</a>(<a href="#K" id='c:656'>K</a>(<a href="#I64" id='c:657'>I64</a>(p)))
				p += 8
			}
		}
		<a href="#mfree" id='c:658'>mfree</a>(p, <a href="#bucket" id='c:659'>bucket</a>(<a href="#sz" id='c:660'>sz</a>(t)*n))
	}
}</span><span id="dxy">
func <span class='q'>dxy</span>(x, y K) { <a href="#dx" id='c:661'>dx</a>(x); <a href="#dx" id='c:662'>dx</a>(y) }<span id='c:dxy' class='n'>
</span></span><span id="rl">
func <span class='q'>rl</span>(x K) { // ref list elements<span id='c:rl' class='n'>
</span>
	e := <a href="#ep" id='c:663'>ep</a>(x)
	p := <a href="#int32" id='c:664'>int32</a>(x)
	for e &gt; p {
		e -= 8
		<a href="#rx" id='c:665'>rx</a>(<a href="#K" id='c:666'>K</a>(<a href="#I64" id='c:667'>I64</a>(e)))
	}
}</span><span id="Cal">
func <span class='q'>Cal</span>(x, y K) K {<span id='c:Cal' class='n'>
</span>
	y = <a href="#explode" id='c:668'>explode</a>(y)
	if <a href="#isfunc" id='c:669'>isfunc</a>(<a href="#tp" id='c:670'>tp</a>(x)) != 0 {
		return <a href="#cal" id='c:671'>cal</a>(x, y)
	}
	return <a href="#atdepth" id='c:672'>atdepth</a>(x, y)
}</span><span id="isfunc">
func <span class='q'>isfunc</span>(t T) int32 { return <a href="#I32B" id='c:673'>I32B</a>(t == 0 || <a href="#uint32" id='c:674'>uint32</a>(t-10) &lt; 5) }<span id='c:isfunc' class='n'>
</span></span>
<span id="cal">
func <span class='q'>cal</span>(f, x K) K {<span id='c:cal' class='n'>
</span>
	r := <a href="#K" id='c:675'>K</a>(0)
	z := <a href="#K" id='c:676'>K</a>(0)
	y := <a href="#K" id='c:677'>K</a>(0)
	t := <a href="#tp" id='c:678'>tp</a>(f)
	fp := <a href="#int32" id='c:679'>int32</a>(f)
	xn := <a href="#nn" id='c:680'>nn</a>(x)
	if t &lt; df {
		switch xn - 1 {
		case 0:
			x = <a href="#Fst" id='c:681'>Fst</a>(x)
		case 1:
			r = <a href="#x1" id='c:682'>x1</a>(x)
			x = <a href="#r0" id='c:683'>r0</a>(x)
		default:
			r = <a href="#x1" id='c:684'>x1</a>(x)
			z = <a href="#x2" id='c:685'>x2</a>(x)
			if xn == 4 {
				y = <a href="#x0" id='c:686'>x0</a>(x + 24)
			}
			x = <a href="#r0" id='c:687'>r0</a>(x)
		}
	}
	if t != 0 {
		t -= 9
	}
	switch t {
	case 0: // basic
		switch xn - 1 {
		case 0:
			r = Func[<a href="#int32" id='c:688'>int32</a>(f)].(f1)(x)
		case 1:
			r = Func[fp+64].(f2)(x, r)
		case 2:
			r = Func[fp+192].(f4)(x, r, 1, z)
		case 3:
			r = Func[fp+192].(f4)(x, r, z, y)
		default:
			<a href="#trap" id='c:689'>trap</a>() //rank
			r = 0
		}
		r = r
	case 1: // cf
		switch xn - 1 {
		case 0:
			r = <a href="#calltrain" id='c:690'>calltrain</a>(f, <a href="#l1" id='c:691'>l1</a>(x))
		case 1:
			r = <a href="#calltrain" id='c:692'>calltrain</a>(f, <a href="#l2" id='c:693'>l2</a>(x, r))
		default:
			<a href="#trap" id='c:694'>trap</a>() //rank
			r = 0
		}
		r = r
	case 2: // df
		d := <a href="#x0" id='c:695'>x0</a>(f)
		a := 85 + <a href="#int32" id='c:696'>int32</a>(<a href="#I64" id='c:697'>I64</a>(fp+8))
		r = Func[a].(f2)(d, x)
	case 3: // pf
		r = <a href="#callprj" id='c:698'>callprj</a>(f, x)
	case 4: // lf
		r = <a href="#lambda" id='c:699'>lambda</a>(f, x)
	case 5: // xf
		r = <a href="#native" id='c:700'>native</a>(f, x)
	default:
		<a href="#trap" id='c:701'>trap</a>() //type
		r = 0
	}
	<a href="#dx" id='c:702'>dx</a>(f)
	return r
}</span><span id="calltrain">
func <span class='q'>calltrain</span>(f, x K) K { return <a href="#cal" id='c:703'>cal</a>(<a href="#x0" id='c:704'>x0</a>(f+8), <a href="#l1" id='c:705'>l1</a>(<a href="#cal" id='c:706'>cal</a>(<a href="#x0" id='c:707'>x0</a>(f), x))) }<span id='c:calltrain' class='n'>
</span></span><span id="callprj">
func <span class='q'>callprj</span>(f, x K) K {<span id='c:callprj' class='n'>
</span>
	n := <a href="#nn" id='c:708'>nn</a>(x)
	fn := <a href="#nn" id='c:709'>nn</a>(f)
	if fn != n {
		if n &lt; fn {
			<a href="#rx" id='c:710'>rx</a>(f)
			return <a href="#prj" id='c:711'>prj</a>(f, x)
		}
		<a href="#trap" id='c:712'>trap</a>() //rank
	}
	return <a href="#Cal" id='c:713'>Cal</a>(<a href="#x0" id='c:714'>x0</a>(f), <a href="#stv" id='c:715'>stv</a>(<a href="#x1" id='c:716'>x1</a>(f), <a href="#x2" id='c:717'>x2</a>(f), x))
}</span><span id="native">
func <span class='q'>native</span>(f K, x K) K {<span id='c:native' class='n'>
</span>
	fn := <a href="#nn" id='c:718'>nn</a>(f)
	xn := <a href="#nn" id='c:719'>nn</a>(x)
	if xn != fn {
		if xn &lt; fn {
			<a href="#rx" id='c:720'>rx</a>(f)
			return <a href="#prj" id='c:721'>prj</a>(f, x)
		}
		<a href="#trap" id='c:722'>trap</a>() //rank
	}
	return <a href="#K" id='c:723'>K</a>(<a href="#Native" id='c:724'>Native</a>(<a href="#int64" id='c:725'>int64</a>(<a href="#x0" id='c:726'>x0</a>(f)), <a href="#int64" id='c:727'>int64</a>(x))) // +/api: KR
}</span><span id="lambda">
func <span class='q'>lambda</span>(f, x K) K {<span id='c:lambda' class='n'>
</span>
	fn := <a href="#nn" id='c:728'>nn</a>(f)
	xn := <a href="#nn" id='c:729'>nn</a>(x)
	if xn &lt; fn {
		<a href="#rx" id='c:730'>rx</a>(f)
		return <a href="#prj" id='c:731'>prj</a>(f, x)
	}
	if xn != fn {
		<a href="#trap" id='c:732'>trap</a>() //rank
	}
	//store vars
	lo := <a href="#K" id='c:733'>K</a>(<a href="#I64" id='c:734'>I64</a>(<a href="#int32" id='c:735'>int32</a>(f) + 16))
	n := <a href="#nn" id='c:736'>nn</a>(lo)
	a := <a href="#nn" id='c:737'>nn</a>(f)
	z := <a href="#mk" id='c:738'>mk</a>(Zt, n) //use a complex vector to store symbols+values w/o refcounting
	zp := <a href="#int32" id='c:739'>int32</a>(z)
	xp := <a href="#ep" id='c:740'>ep</a>(x)
	vp := <a href="#I32" id='c:741'>I32</a>(8)
	for n &gt; 0 {
		n -= 1
		p := <a href="#I32" id='c:742'>I32</a>(<a href="#int32" id='c:743'>int32</a>(lo) + 4*n)
		<a href="#SetI32" id='c:744'>SetI32</a>(zp, p)
		p += vp
		<a href="#SetI64" id='c:745'>SetI64</a>(zp+8, <a href="#I64" id='c:746'>I64</a>(p))
		if n &lt; a { //args
			xp -= 8
			<a href="#SetI64" id='c:747'>SetI64</a>(p, <a href="#I64" id='c:748'>I64</a>(xp))
		} else { //locals
			<a href="#SetI64" id='c:749'>SetI64</a>(p, 0)
		}
		zp += 16
	}
	<a href="#rl" id='c:750'>rl</a>(x)
	<a href="#dx" id='c:751'>dx</a>(x)
	x = <a href="#exec" id='c:752'>exec</a>(<a href="#x0" id='c:753'>x0</a>(f)) //execute lambda code
	//restore vars
	zp = <a href="#int32" id='c:754'>int32</a>(z)
	e := <a href="#ep" id='c:755'>ep</a>(z)
	for zp &lt; e {
		p := <a href="#I32" id='c:756'>I32</a>(8) + <a href="#I32" id='c:757'>I32</a>(zp)
		<a href="#dx" id='c:758'>dx</a>(<a href="#K" id='c:759'>K</a>(<a href="#I64" id='c:760'>I64</a>(p)))
		<a href="#SetI64" id='c:761'>SetI64</a>(p, <a href="#I64" id='c:762'>I64</a>(zp+8))
		zp += 16
	}
	<a href="#dx" id='c:763'>dx</a>(z)
	return x
}</span><span id="com">
func <span class='q'>com</span>(x, y K) K { return <a href="#ti" id='c:764'>ti</a>(cf, <a href="#int32" id='c:765'>int32</a>(<a href="#l2" id='c:766'>l2</a>(y, x))) } // compose<span id='c:com' class='n'>
</span></span><span id="prj">
func <span class='q'>prj</span>(f, x K) K { // project<span id='c:prj' class='n'>
</span>
	var r K
	if <a href="#isfunc" id='c:767'>isfunc</a>(<a href="#tp" id='c:768'>tp</a>(f)) == 0 {
		return <a href="#atdepth" id='c:769'>atdepth</a>(f, x)
	}
	xn := <a href="#nn" id='c:770'>nn</a>(x)
	xp := <a href="#int32" id='c:771'>int32</a>(x)
	a := <a href="#mk" id='c:772'>mk</a>(It, 0)
	for i := <a href="#int32" id='c:773'>int32</a>(0); i &lt; xn; i++ {
		if <a href="#I64" id='c:774'>I64</a>(xp) == 0 {
			a = <a href="#cat1" id='c:775'>cat1</a>(a, <a href="#Ki" id='c:776'>Ki</a>(i))
		}
		xp += 8
	}
	ar := <a href="#arity" id='c:777'>arity</a>(f)
	for i := xn; i &lt; ar; i++ {
		a = <a href="#cat1" id='c:778'>cat1</a>(a, <a href="#Ki" id='c:779'>Ki</a>(i))
		x = <a href="#cat1" id='c:780'>cat1</a>(x, 0)
	}
	an := <a href="#nn" id='c:781'>nn</a>(a)
	if <a href="#tp" id='c:782'>tp</a>(f) == pf { // collapse
		r = <a href="#x1" id='c:783'>x1</a>(f)
		y := <a href="#x2" id='c:784'>x2</a>(f)
		f = <a href="#r0" id='c:785'>r0</a>(f)
		x = <a href="#stv" id='c:786'>stv</a>(r, <a href="#rx" id='c:787'>rx</a>(y), x)
		a = <a href="#Drp" id='c:788'>Drp</a>(a, y)
	}
	r = <a href="#l3" id='c:789'>l3</a>(f, x, a)
	<a href="#SetI32" id='c:790'>SetI32</a>(<a href="#int32" id='c:791'>int32</a>(r)-12, an)
	return <a href="#ti" id='c:792'>ti</a>(pf, <a href="#int32" id='c:793'>int32</a>(r))
}</span><span id="arity">
func <span class='q'>arity</span>(f K) int32 {<span id='c:arity' class='n'>
</span>
	if <a href="#tp" id='c:794'>tp</a>(f) &gt; df {
		return <a href="#nn" id='c:795'>nn</a>(f)
	}
	return 2
}</span><span id="Cat">
func <span class='q'>Cat</span>(x, y K) K {<span id='c:Cat' class='n'>
</span>
	xt, yt := <a href="#tp" id='c:796'>tp</a>(x), <a href="#tp" id='c:797'>tp</a>(y)
	if xt == Tt &amp;&amp; yt == Dt {
		return <a href="#dcat" id='c:798'>dcat</a>(x, y)
	}
	if xt&amp;15 == yt&amp;15 {
		if xt &lt; 16 {
			x = <a href="#Enl" id='c:799'>Enl</a>(x)
		}
		if yt &lt; 16 {
			return <a href="#cat1" id='c:800'>cat1</a>(x, y)
		} else {
			return <a href="#ucat" id='c:801'>ucat</a>(x, y)
		}
	} else if xt == Lt &amp;&amp; yt &lt; 16 {
		if <a href="#nn" id='c:802'>nn</a>(x) &gt; 0 {
			return <a href="#cat1" id='c:803'>cat1</a>(x, y)
		}
	}
	x = <a href="#uf" id='c:804'>uf</a>(<a href="#Cat" id='c:805'>Cat</a>(<a href="#explode" id='c:806'>explode</a>(x), <a href="#explode" id='c:807'>explode</a>(y)))
	if <a href="#nn" id='c:808'>nn</a>(x) == 0 {
		<a href="#dx" id='c:809'>dx</a>(x)
		return <a href="#mk" id='c:810'>mk</a>(xt|16, 0)
	}
	return x
}</span><span id="Enl">
func <span class='q'>Enl</span>(x K) K { return <a href="#uf" id='c:811'>uf</a>(<a href="#l1" id='c:812'>l1</a>(x)) }<span id='c:Enl' class='n'>
</span></span><span id="explode">
func <span class='q'>explode</span>(x K) K {<span id='c:explode' class='n'>
</span>
	var r K
	xt := <a href="#tp" id='c:813'>tp</a>(x)
	if xt &lt; 16 || xt == Dt {
		return <a href="#l1" id='c:814'>l1</a>(x)
	} else if xt &lt; Lt {
		xn := <a href="#nn" id='c:815'>nn</a>(x)
		r = <a href="#mk" id='c:816'>mk</a>(Lt, <a href="#nn" id='c:817'>nn</a>(x))
		rp := <a href="#int32" id='c:818'>int32</a>(r)
		for i := <a href="#int32" id='c:819'>int32</a>(0); i &lt; xn; i++ {
			<a href="#SetI64" id='c:820'>SetI64</a>(rp+8*i, <a href="#int64" id='c:821'>int64</a>(<a href="#ati" id='c:822'>ati</a>(<a href="#rx" id='c:823'>rx</a>(x), i)))
		}
		<a href="#dx" id='c:824'>dx</a>(x)
		return r
	} else if xt == Tt { // Tt
		xn := <a href="#nn" id='c:825'>nn</a>(x)
		k := <a href="#x0" id='c:826'>x0</a>(x)
		x = <a href="#Flp" id='c:827'>Flp</a>(<a href="#r1" id='c:828'>r1</a>(x))
		r = <a href="#mk" id='c:829'>mk</a>(Lt, 0)
		for i := <a href="#int32" id='c:830'>int32</a>(0); i &lt; xn; i++ {
			r = <a href="#cat1" id='c:831'>cat1</a>(r, <a href="#Key" id='c:832'>Key</a>(<a href="#rx" id='c:833'>rx</a>(k), <a href="#ati" id='c:834'>ati</a>(<a href="#rx" id='c:835'>rx</a>(x), i)))
		}
		<a href="#dxy" id='c:836'>dxy</a>(x, k)
		return r
	}
	return x
}</span><span id="ucat">
func <span class='q'>ucat</span>(x, y K) K { // Bt,Bt .. Tt,Tt<span id='c:ucat' class='n'>
</span>
	xt := <a href="#tp" id='c:837'>tp</a>(x)
	if xt &gt; Lt {
		return <a href="#dcat" id='c:838'>dcat</a>(x, y)
	}
	xn := <a href="#nn" id='c:839'>nn</a>(x)
	yn := <a href="#nn" id='c:840'>nn</a>(y)
	r := <a href="#uspc" id='c:841'>uspc</a>(x, xt, yn)
	s := <a href="#sz" id='c:842'>sz</a>(xt)
	if xt == Lt {
		<a href="#rl" id='c:843'>rl</a>(y)
	}
	<a href="#Memorycopy" id='c:844'>Memorycopy</a>(<a href="#int32" id='c:845'>int32</a>(r)+s*xn, <a href="#int32" id='c:846'>int32</a>(y), s*yn)
	<a href="#dx" id='c:847'>dx</a>(y)
	return r
}</span><span id="dcat">
func <span class='q'>dcat</span>(x, y K) K { // d,d  t,t<span id='c:dcat' class='n'>
</span>
	t := <a href="#tp" id='c:848'>tp</a>(x)
	if t == Tt {
		if <a href="#match" id='c:849'>match</a>(<a href="#K" id='c:850'>K</a>(<a href="#I64" id='c:851'>I64</a>(<a href="#int32" id='c:852'>int32</a>(x))), <a href="#K" id='c:853'>K</a>(<a href="#I64" id='c:854'>I64</a>(<a href="#int32" id='c:855'>int32</a>(y)))) == 0 {
			return <a href="#ucat" id='c:856'>ucat</a>(<a href="#explode" id='c:857'>explode</a>(x), <a href="#explode" id='c:858'>explode</a>(y))
		}
	}
	r := <a href="#x0" id='c:859'>x0</a>(x)
	x = <a href="#r1" id='c:860'>r1</a>(x)
	q := <a href="#x0" id='c:861'>x0</a>(y)
	y = <a href="#r1" id='c:862'>r1</a>(y)
	if t == Dt {
		r = <a href="#Cat" id='c:863'>Cat</a>(r, q)
		return <a href="#Key" id='c:864'>Key</a>(r, <a href="#Cat" id='c:865'>Cat</a>(x, y))
	} else {
		<a href="#dx" id='c:866'>dx</a>(q)
		x = <a href="#Ech" id='c:867'>Ech</a>(13, <a href="#l2" id='c:868'>l2</a>(x, y))
		return <a href="#key" id='c:869'>key</a>(r, x, t)
	}
}</span><span id="ucat1">
func <span class='q'>ucat1</span>(x, y, z K) K { return <a href="#cat1" id='c:870'>cat1</a>(<a href="#ucat" id='c:871'>ucat</a>(x, y), z) }<span id='c:ucat1' class='n'>
</span></span><span id="cat1">
func <span class='q'>cat1</span>(x, y K) K {<span id='c:cat1' class='n'>
</span>
	t := <a href="#tp" id='c:872'>tp</a>(x)
	x = <a href="#uspc" id='c:873'>uspc</a>(x, t, 1)
	if t == Lt {
		y = <a href="#l1" id='c:874'>l1</a>(<a href="#rx" id='c:875'>rx</a>(y))
		x = <a href="#ti" id='c:876'>ti</a>(Ft, <a href="#int32" id='c:877'>int32</a>(x))
	}
	return <a href="#ti" id='c:878'>ti</a>(t, <a href="#int32" id='c:879'>int32</a>(<a href="#sti" id='c:880'>sti</a>(x, <a href="#nn" id='c:881'>nn</a>(x)-1, y)))
}</span><span id="uspc">
func <span class='q'>uspc</span>(x K, xt T, ny int32) K {<span id='c:uspc' class='n'>
</span>
	r := <a href="#K" id='c:882'>K</a>(0)
	nx := <a href="#nn" id='c:883'>nn</a>(x)
	s := <a href="#sz" id='c:884'>sz</a>(xt)
	if <a href="#I32" id='c:885'>I32</a>(<a href="#int32" id='c:886'>int32</a>(x)-4) == 1 &amp;&amp; <a href="#bucket" id='c:887'>bucket</a>(s*nx) == <a href="#bucket" id='c:888'>bucket</a>(s*(nx+ny)) {
		r = x
	} else {
		r = <a href="#mk" id='c:889'>mk</a>(xt, nx+ny)
		<a href="#Memorycopy" id='c:890'>Memorycopy</a>(<a href="#int32" id='c:891'>int32</a>(r), <a href="#int32" id='c:892'>int32</a>(x), s*nx)
		if xt == Lt {
			<a href="#rl" id='c:893'>rl</a>(x)
		}
		<a href="#dx" id='c:894'>dx</a>(x)
	}
	<a href="#SetI32" id='c:895'>SetI32</a>(<a href="#int32" id='c:896'>int32</a>(r)-12, nx+ny)
	return r
}</span>
type f1 = func(K) K
type f2 = func(K, K) K
type f3 = func(K, K, K) K
type f4 = func(K, K, K, K) K
<span id="quoted">
func <span class='q'>quoted</span>(x K) int32 { return <a href="#I32B" id='c:897'>I32B</a>(<a href="#int32" id='c:898'>int32</a>(x) &gt;= 448 &amp;&amp; <a href="#tp" id='c:899'>tp</a>(x) == 0) }<span id='c:quoted' class='n'>
</span></span><span id="quote">
func <span class='q'>quote</span>(x K) K      { return x + 448 }<span id='c:quote' class='n'>
</span></span><span id="unquote">
func <span class='q'>unquote</span>(x K) K    { return x - 448 }<span id='c:unquote' class='n'>
</span></span>
<span id="exec">
func <span class='q'>exec</span>(x K) K {<span id='c:exec' class='n'>
</span>
	var b, c K
	srcp = 0
	a := <a href="#K" id='c:900'>K</a>(0) // accumulator
	xn := <a href="#nn" id='c:901'>nn</a>(x)
	if xn == 0 {
		<a href="#dx" id='c:902'>dx</a>(x)
		return 0
	}
	p := <a href="#int32" id='c:903'>int32</a>(x)
	e := p + 8*xn
	for p &lt; e {
		u := <a href="#K" id='c:904'>K</a>(<a href="#I64" id='c:905'>I64</a>(p))
		if <a href="#tp" id='c:906'>tp</a>(u) != 0 {
			<a href="#push" id='c:907'>push</a>(a)
			a = <a href="#rx" id='c:908'>rx</a>(u)
		} else {
			switch <a href="#int32" id='c:909'>int32</a>(u) &gt;&gt; 6 {
			case 0: //   0..63   monadic
				a = Func[<a href="#marksrc" id='c:910'>marksrc</a>(u)].(f1)(a)
			case 1: //  64..127  dyadic
				a = Func[<a href="#marksrc" id='c:911'>marksrc</a>(u)].(f2)(a, <a href="#pop" id='c:912'>pop</a>())
			case 2: // 128       dyadic indirect
				<a href="#marksrc" id='c:913'>marksrc</a>(a)
				b = <a href="#pop" id='c:914'>pop</a>()
				a = <a href="#Cal" id='c:915'>Cal</a>(a, <a href="#l2" id='c:916'>l2</a>(b, <a href="#pop" id='c:917'>pop</a>()))
			case 3: // 192..255  tetradic
				b = <a href="#pop" id='c:918'>pop</a>()
				c = <a href="#pop" id='c:919'>pop</a>()
				a = Func[<a href="#marksrc" id='c:920'>marksrc</a>(u)].(f4)(a, b, c, <a href="#pop" id='c:921'>pop</a>())
			case 4: // 256       drop
				<a href="#dx" id='c:922'>dx</a>(a)
				a = <a href="#pop" id='c:923'>pop</a>()
			case 5: // 320       jump
				p = p + <a href="#int32" id='c:924'>int32</a>(a)
				a = <a href="#pop" id='c:925'>pop</a>()
			case 6: // 384       jump if not
				u = <a href="#pop" id='c:926'>pop</a>()
				p += <a href="#int32" id='c:927'>int32</a>(a) * <a href="#I32B" id='c:928'>I32B</a>(<a href="#int32" id='c:929'>int32</a>(u) == 0)
				<a href="#dx" id='c:930'>dx</a>(u)
				a = <a href="#pop" id='c:931'>pop</a>()
			default: //448..     quoted verb
				<a href="#push" id='c:932'>push</a>(a)
				a = <a href="#rx" id='c:933'>rx</a>(u - 448)
			}
		}
		p += 8
		continue
	}
	<a href="#pop" id='c:934'>pop</a>() //0
	<a href="#dx" id='c:935'>dx</a>(x)
	return a
}</span><span id="marksrc">
func <span class='q'>marksrc</span>(x K) int32 {<span id='c:marksrc' class='n'>
</span>
	if p := <a href="#h48" id='c:936'>h48</a>(x); p != 0 {
		srcp = p
	}
	return <a href="#int32" id='c:937'>int32</a>(x)
}</span><span id="push">
func <span class='q'>push</span>(x K) {<span id='c:push' class='n'>
</span>
	<a href="#SetI64" id='c:938'>SetI64</a>(sp, <a href="#int64" id='c:939'>int64</a>(x))
	sp += 8
	if sp == 4096 { //512 {
		<a href="#trap" id='c:940'>trap</a>() //stack overflow
	}
}</span><span id="pop">
func <span class='q'>pop</span>() K {<span id='c:pop' class='n'>
</span>
	sp -= 8
	if sp &lt; 2048 {
		<a href="#trap" id='c:941'>trap</a>() //stack underflow
	}
	return <a href="#K" id='c:942'>K</a>(<a href="#I64" id='c:943'>I64</a>(sp))
}</span><span id="lst">
func <span class='q'>lst</span>(n K) K {<span id='c:lst' class='n'>
</span>
	r := <a href="#mk" id='c:944'>mk</a>(Lt, <a href="#int32" id='c:945'>int32</a>(n))
	rp := <a href="#int32" id='c:946'>int32</a>(r)
	e := <a href="#ep" id='c:947'>ep</a>(r)
	for rp &lt; e {
		<a href="#SetI64" id='c:948'>SetI64</a>(rp, <a href="#int64" id='c:949'>int64</a>(<a href="#pop" id='c:950'>pop</a>()))
		rp += 8
	}
	return <a href="#uf" id='c:951'>uf</a>(r)
}</span><span id="nul">
func <span class='q'>nul</span>(x K) K { <a href="#push" id='c:952'>push</a>(x); return 0 }<span id='c:nul' class='n'>
</span></span><span id="lup">
func <span class='q'>lup</span>(x K) K {<span id='c:lup' class='n'>
</span>
	vp := <a href="#I32" id='c:953'>I32</a>(8) + <a href="#int32" id='c:954'>int32</a>(x)
	return <a href="#x0" id='c:955'>x0</a>(<a href="#K" id='c:956'>K</a>(vp))
}</span><span id="Asn">
func <span class='q'>Asn</span>(x, y K) K {<span id='c:Asn' class='n'>
</span>
	if <a href="#tp" id='c:957'>tp</a>(x) != st {
		<a href="#trap" id='c:958'>trap</a>() //type
	}
	vp := <a href="#I32" id='c:959'>I32</a>(8) + <a href="#int32" id='c:960'>int32</a>(x)
	<a href="#dx" id='c:961'>dx</a>(<a href="#K" id='c:962'>K</a>(<a href="#I64" id='c:963'>I64</a>(vp)))
	<a href="#SetI64" id='c:964'>SetI64</a>(vp, <a href="#int64" id='c:965'>int64</a>(<a href="#rx" id='c:966'>rx</a>(y)))
	return y
}</span><span id="Amd">
func <span class='q'>Amd</span>(x, i, v, y K) K {<span id='c:Amd' class='n'>
</span>
	xt := <a href="#tp" id='c:967'>tp</a>(x)
	if xt == st {
		return <a href="#Asn" id='c:968'>Asn</a>(x, <a href="#Amd" id='c:969'>Amd</a>(<a href="#lup" id='c:970'>lup</a>(x), i, v, y))
	}
	if xt &lt; 16 {
		<a href="#trap" id='c:971'>trap</a>() //type
	}
	if <a href="#tp" id='c:972'>tp</a>(i) == Lt { // @[;;v;]/[x;y;i]
		n := <a href="#nn" id='c:973'>nn</a>(i)
		for j := <a href="#int32" id='c:974'>int32</a>(0); j &lt; n; j++ {
			x = <a href="#Amd" id='c:975'>Amd</a>(x, <a href="#ati" id='c:976'>ati</a>(<a href="#rx" id='c:977'>rx</a>(i), j), <a href="#rx" id='c:978'>rx</a>(v), <a href="#ati" id='c:979'>ati</a>(<a href="#rx" id='c:980'>rx</a>(y), j))
		}
		<a href="#dx" id='c:981'>dx</a>(i)
		<a href="#dxy" id='c:982'>dxy</a>(v, y)
		return x
	}
	if xt &gt; Lt {
		r := <a href="#x0" id='c:983'>x0</a>(x)
		x = <a href="#r1" id='c:984'>r1</a>(x)
		if xt == Tt &amp;&amp; <a href="#tp" id='c:985'>tp</a>(i)&amp;15 == it { // table-assign-rows
			if <a href="#tp" id='c:986'>tp</a>(y) &gt; Lt {
				y = <a href="#Val" id='c:987'>Val</a>(y)
			}
			return <a href="#key" id='c:988'>key</a>(r, <a href="#Dmd" id='c:989'>Dmd</a>(x, <a href="#l2" id='c:990'>l2</a>(0, i), v, y), xt)
		}
		r = <a href="#Unq" id='c:991'>Unq</a>(<a href="#Cat" id='c:992'>Cat</a>(r, <a href="#rx" id='c:993'>rx</a>(i)))
		return <a href="#key" id='c:994'>key</a>(r, <a href="#Amd" id='c:995'>Amd</a>(<a href="#ntake" id='c:996'>ntake</a>(<a href="#nn" id='c:997'>nn</a>(r), x), <a href="#Fnd" id='c:998'>Fnd</a>(<a href="#rx" id='c:999'>rx</a>(r), i), v, y), xt)
	}
	if i == 0 {
		if v == 1 {
			if <a href="#tp" id='c:1000'>tp</a>(y) &lt; 16 {
				y = <a href="#ntake" id='c:1001'>ntake</a>(<a href="#nn" id='c:1002'>nn</a>(x), y)
			}
			<a href="#dx" id='c:1003'>dx</a>(x)
			return y
		}
		return <a href="#Cal" id='c:1004'>Cal</a>(v, <a href="#l2" id='c:1005'>l2</a>(x, y))
	}
	if <a href="#tp" id='c:1006'>tp</a>(v) != 0 || v != 1 {
		y = <a href="#cal" id='c:1007'>cal</a>(v, <a href="#l2" id='c:1008'>l2</a>(<a href="#Atx" id='c:1009'>Atx</a>(<a href="#rx" id='c:1010'>rx</a>(x), <a href="#rx" id='c:1011'>rx</a>(i)), y))
	}
	ti, yt := <a href="#tp" id='c:1012'>tp</a>(i), <a href="#tp" id='c:1013'>tp</a>(y)
	if xt&amp;15 != yt&amp;15 {
		x, xt = <a href="#explode" id='c:1014'>explode</a>(x), Lt
	}
	if ti == it {
		if xt != yt+16 {
			x = <a href="#explode" id='c:1015'>explode</a>(x)
		}
		return <a href="#sti" id='c:1016'>sti</a>(<a href="#use" id='c:1017'>use</a>(x), <a href="#int32" id='c:1018'>int32</a>(i), y)
	}
	if yt &lt; 16 {
		y = <a href="#ntake" id='c:1019'>ntake</a>(<a href="#nn" id='c:1020'>nn</a>(i), y)
		yt = <a href="#tp" id='c:1021'>tp</a>(y)
	}
	if xt == Lt {
		y = <a href="#explode" id='c:1022'>explode</a>(y)
	}
	return <a href="#stv" id='c:1023'>stv</a>(x, i, y)
}</span><span id="Dmd">
func <span class='q'>Dmd</span>(x, i, v, y K) K {<span id='c:Dmd' class='n'>
</span>
	if <a href="#tp" id='c:1024'>tp</a>(x) == st {
		return <a href="#Asn" id='c:1025'>Asn</a>(x, <a href="#Dmd" id='c:1026'>Dmd</a>(<a href="#lup" id='c:1027'>lup</a>(x), i, v, y))
	}
	i = <a href="#explode" id='c:1028'>explode</a>(i)
	f := <a href="#Fst" id='c:1029'>Fst</a>(<a href="#rx" id='c:1030'>rx</a>(i))
	if <a href="#nn" id='c:1031'>nn</a>(i) == 1 {
		<a href="#dx" id='c:1032'>dx</a>(i)
		return <a href="#Amd" id='c:1033'>Amd</a>(x, f, v, y)
	}
	if f == 0 {
		f = <a href="#seq" id='c:1034'>seq</a>(<a href="#nn" id='c:1035'>nn</a>(x))
	}
	i = <a href="#ndrop" id='c:1036'>ndrop</a>(1, i)
	if <a href="#tp" id='c:1037'>tp</a>(f) &gt; 16 { // matrix-assign
		n := <a href="#nn" id='c:1038'>nn</a>(f)
		if <a href="#nn" id='c:1039'>nn</a>(i) != 1 {
			<a href="#trap" id='c:1040'>trap</a>() //rank
		}
		i = <a href="#Fst" id='c:1041'>Fst</a>(i)
		if <a href="#tp" id='c:1042'>tp</a>(f) == It &amp;&amp; <a href="#tp" id='c:1043'>tp</a>(x) == Tt {
			t := <a href="#rx" id='c:1044'>rx</a>(<a href="#x0" id='c:1045'>x0</a>(x))
			return <a href="#key" id='c:1046'>key</a>(t, <a href="#Dmd" id='c:1047'>Dmd</a>(<a href="#r1" id='c:1048'>r1</a>(x), <a href="#l2" id='c:1049'>l2</a>(<a href="#Fnd" id='c:1050'>Fnd</a>(t, i), f), v, y), Tt)
		}
		if <a href="#tp" id='c:1051'>tp</a>(f) != It || <a href="#tp" id='c:1052'>tp</a>(x) != Lt {
			<a href="#trap" id='c:1053'>trap</a>() // nyi Dt
		}
		x = <a href="#use" id='c:1054'>use</a>(x)
		for j := <a href="#int32" id='c:1055'>int32</a>(0); j &lt; n; j++ {
			rj := <a href="#int32" id='c:1056'>int32</a>(x) + 8*<a href="#I32" id='c:1057'>I32</a>(<a href="#int32" id='c:1058'>int32</a>(f)+4*j)
			<a href="#SetI64" id='c:1059'>SetI64</a>(rj, <a href="#int64" id='c:1060'>int64</a>(<a href="#Amd" id='c:1061'>Amd</a>(<a href="#K" id='c:1062'>K</a>(<a href="#I64" id='c:1063'>I64</a>(rj)), <a href="#rx" id='c:1064'>rx</a>(i), <a href="#rx" id='c:1065'>rx</a>(v), <a href="#ati" id='c:1066'>ati</a>(<a href="#rx" id='c:1067'>rx</a>(y), j))))
		}
		<a href="#dxy" id='c:1068'>dxy</a>(f, i)
		<a href="#dxy" id='c:1069'>dxy</a>(v, y)
		return x
	}
	return <a href="#Amd" id='c:1070'>Amd</a>(x, f, 1, <a href="#Dmd" id='c:1071'>Dmd</a>(<a href="#Atx" id='c:1072'>Atx</a>(<a href="#rx" id='c:1073'>rx</a>(x), f), i, v, y))
}</span>
type f3i = func(int32, int32, int32) int32
<span id="Fnd">
func <span class='q'>Fnd</span>(x, y K) K { // x?y<span id='c:Fnd' class='n'>
</span>
	var r K
	xt, yt := <a href="#tp" id='c:1074'>tp</a>(x), <a href="#tp" id='c:1075'>tp</a>(y)
	if xt &lt; 16 {
		if yt == Tt { // s?T
			r = <a href="#Drp" id='c:1076'>Drp</a>(<a href="#rx" id='c:1077'>rx</a>(x), <a href="#rx" id='c:1078'>rx</a>(y))
			return <a href="#Atx" id='c:1079'>Atx</a>(r, <a href="#Grp" id='c:1080'>Grp</a>(<a href="#Atx" id='c:1081'>Atx</a>(y, x)))
		} else {
			return <a href="#deal" id='c:1082'>deal</a>(x, y)
		}
	}
	if xt &gt; Lt {
		if xt == Tt {
			<a href="#trap" id='c:1083'>trap</a>() //nyi t?..
		}
		r = <a href="#x0" id='c:1084'>x0</a>(x)
		return <a href="#Atx" id='c:1085'>Atx</a>(r, <a href="#Fnd" id='c:1086'>Fnd</a>(<a href="#r1" id='c:1087'>r1</a>(x), y))
	} else if xt == yt {
		return <a href="#Ecr" id='c:1088'>Ecr</a>(18+16*<a href="#K" id='c:1089'>K</a>(<a href="#I32B" id='c:1090'>I32B</a>(yt == Lt)), <a href="#l2" id='c:1091'>l2</a>(x, y))
	} else if xt == yt+16 {
		r = <a href="#Ki" id='c:1092'>Ki</a>(<a href="#fnd" id='c:1093'>fnd</a>(x, y, yt))
	} else if xt == Lt {
		return <a href="#fdl" id='c:1094'>fdl</a>(x, y)
	} else if yt == Lt {
		return <a href="#Ecr" id='c:1095'>Ecr</a>(18, <a href="#l2" id='c:1096'>l2</a>(x, y))
	} else {
		<a href="#trap" id='c:1097'>trap</a>() //type
	}
	<a href="#dxy" id='c:1098'>dxy</a>(x, y)
	return r
}</span><span id="fnd">
func <span class='q'>fnd</span>(x, y K, t T) int32 {<span id='c:fnd' class='n'>
</span>
	if <a href="#nn" id='c:1099'>nn</a>(x) == 0 {
		return nai
	}
	xp := <a href="#int32" id='c:1100'>int32</a>(x)
	r := Func[268+t].(f3i)(<a href="#int32" id='c:1101'>int32</a>(y), xp, <a href="#ep" id='c:1102'>ep</a>(x))
	if r == 0 {
		return nai
	}
	return (r - xp) &gt;&gt; (31 - <a href="#I32clz" id='c:1103'>I32clz</a>(<a href="#sz" id='c:1104'>sz</a>(16+t)))
}</span><span id="fdl">
func <span class='q'>fdl</span>(x, y K) K {<span id='c:fdl' class='n'>
</span>
	xp := <a href="#int32" id='c:1105'>int32</a>(x)
	<a href="#dxy" id='c:1106'>dxy</a>(x, y)
	e := <a href="#ep" id='c:1107'>ep</a>(x)
	for xp &lt; e {
		if <a href="#match" id='c:1108'>match</a>(<a href="#K" id='c:1109'>K</a>(<a href="#I64" id='c:1110'>I64</a>(xp)), y) != 0 {
			return <a href="#Ki" id='c:1111'>Ki</a>((xp - <a href="#int32" id='c:1112'>int32</a>(x)) &gt;&gt; 3)
		}
		xp += 8
	}
	return <a href="#Ki" id='c:1113'>Ki</a>(nai)
}</span><span id="idx">
func <span class='q'>idx</span>(x, a, b int32) int32 {<span id='c:idx' class='n'>
</span>
	for i := a; i &lt; b; i++ {
		if x == <a href="#I8" id='c:1114'>I8</a>(i) {
			return i - a
		}
	}
	return -1
}</span>
<span id="Find">
func <span class='q'>Find</span>(x, y K) K { // find[pattern;string] returns all matches (It)<span id='c:Find' class='n'>
</span>
	if <a href="#tp" id='c:1115'>tp</a>(x) != Ct || <a href="#tp" id='c:1116'>tp</a>(y) != Ct {
		<a href="#trap" id='c:1117'>trap</a>()
	}
	xn, yn := <a href="#nn" id='c:1118'>nn</a>(x), <a href="#nn" id='c:1119'>nn</a>(y)
	if xn*yn == 0 {
		<a href="#dxy" id='c:1120'>dxy</a>(x, y)
		return <a href="#mk" id='c:1121'>mk</a>(It, 0)
	}
	r := <a href="#mk" id='c:1122'>mk</a>(It, 0)
	yp := <a href="#int32" id='c:1123'>int32</a>(y)
	e := yp + yn + 1 - xn
	for yp &lt; e { // todo rabin-karp / knuth-morris / boyes-moore..
		if <a href="#findat" id='c:1124'>findat</a>(<a href="#int32" id='c:1125'>int32</a>(x), yp, xn) != 0 {
			r = <a href="#cat1" id='c:1126'>cat1</a>(r, <a href="#Ki" id='c:1127'>Ki</a>(yp-<a href="#int32" id='c:1128'>int32</a>(y)))
			yp += xn
		} else {
			yp++
		}
		continue
	}
	<a href="#dxy" id='c:1129'>dxy</a>(x, y)
	return r
}</span><span id="findat">
func <span class='q'>findat</span>(xp, yp, n int32) int32 {<span id='c:findat' class='n'>
</span>
	for i := <a href="#int32" id='c:1130'>int32</a>(0); i &lt; n; i++ {
		if <a href="#I8" id='c:1131'>I8</a>(xp+i) != <a href="#I8" id='c:1132'>I8</a>(yp+i) {
			return 0
		}
	}
	return 1
}</span>
<span id="Mtc">
func <span class='q'>Mtc</span>(x, y K) K {<span id='c:Mtc' class='n'>
</span>
	<a href="#dxy" id='c:1133'>dxy</a>(x, y)
	return <a href="#Ki" id='c:1134'>Ki</a>(<a href="#match" id='c:1135'>match</a>(x, y))
}</span><span id="match">
func <span class='q'>match</span>(x, y K) int32 {<span id='c:match' class='n'>
</span>
	if x == y {
		return 1
	}
	xt := <a href="#tp" id='c:1136'>tp</a>(x)
	if xt != <a href="#tp" id='c:1137'>tp</a>(y) {
		return 0
	}
	if xt &gt; 16 {
		n := <a href="#nn" id='c:1138'>nn</a>(x)
		if n != <a href="#nn" id='c:1139'>nn</a>(y) {
			return 0
		}
		if n == 0 {
			return 1
		}
		xp, yp := <a href="#int32" id='c:1140'>int32</a>(x), <a href="#int32" id='c:1141'>int32</a>(y)
		if xt &lt; Dt {
			return Func[246+xt].(f3i)(xp, yp, <a href="#ep" id='c:1142'>ep</a>(y))
		} else {
			if <a href="#match" id='c:1143'>match</a>(<a href="#K" id='c:1144'>K</a>(<a href="#I64" id='c:1145'>I64</a>(xp)), <a href="#K" id='c:1146'>K</a>(<a href="#I64" id='c:1147'>I64</a>(yp))) != 0 {
				return <a href="#match" id='c:1148'>match</a>(<a href="#K" id='c:1149'>K</a>(<a href="#I64" id='c:1150'>I64</a>(xp+8)), <a href="#K" id='c:1151'>K</a>(<a href="#I64" id='c:1152'>I64</a>(yp+8)))
			}
			return 0
		}
	}
	yn := <a href="#int32" id='c:1153'>int32</a>(0)
	xp, yp := <a href="#int32" id='c:1154'>int32</a>(x), <a href="#int32" id='c:1155'>int32</a>(y)
	if xt &lt; ft {
		return <a href="#I32B" id='c:1156'>I32B</a>(xp == yp)
	}
	switch <a href="#int32" id='c:1157'>int32</a>(xt-ft) - 3*<a href="#I32B" id='c:1158'>I32B</a>(xt &gt; 9) {
	case 0: // ft
		return <a href="#I32B" id='c:1159'>I32B</a>(0 == <a href="#cmF" id='c:1160'>cmF</a>(xp, yp))
	case 1: // zt
		return <a href="#I32B" id='c:1161'>I32B</a>(0 == <a href="#cmZ" id='c:1162'>cmZ</a>(xp, yp))
	case 2: // composition
		yn = 8 * <a href="#nn" id='c:1163'>nn</a>(y)
	case 3: // derived
		yn = 16
	case 4: // projection
		yn = 24
	case 5: // lambda
		return <a href="#match" id='c:1164'>match</a>(<a href="#K" id='c:1165'>K</a>(<a href="#I64" id='c:1166'>I64</a>(xp+8)), <a href="#K" id='c:1167'>K</a>(<a href="#I64" id='c:1168'>I64</a>(yp+8))) // compare strings
	default: // xf
		return <a href="#I32B" id='c:1169'>I32B</a>(<a href="#I64" id='c:1170'>I64</a>(xp) == <a href="#I64" id='c:1171'>I64</a>(yp))
	}
	for yn &gt; 0 { // composition, derived, projection
		yn -= 8
		if <a href="#match" id='c:1172'>match</a>(<a href="#K" id='c:1173'>K</a>(<a href="#I64" id='c:1174'>I64</a>(xp+yn)), <a href="#K" id='c:1175'>K</a>(<a href="#I64" id='c:1176'>I64</a>(yp+yn))) == 0 {
			return 0
		}
	}
	return 1
}</span><span id="mtC">
func <span class='q'>mtC</span>(xp, yp, e int32) int32 {<span id='c:mtC' class='n'>
</span>
	ve := e &amp;^ 7
	for yp &lt; ve {
		if <a href="#I64" id='c:1177'>I64</a>(xp) != <a href="#I64" id='c:1178'>I64</a>(yp) {
			return 0
		}
		xp += 8
		yp += 8
	}
	for yp &lt; e {
		if <a href="#I8" id='c:1179'>I8</a>(xp) != <a href="#I8" id='c:1180'>I8</a>(yp) {
			return 0
		}
		xp++
		yp++
	}
	return 1
}</span><span id="mtF">
func <span class='q'>mtF</span>(xp, yp, e int32) int32 {<span id='c:mtF' class='n'>
</span>
	for yp &lt; e {
		if <a href="#cmF" id='c:1181'>cmF</a>(xp, yp) != 0 {
			return 0
		}
		xp += 8
		yp += 8
		continue
	}
	return 1
}</span><span id="mtL">
func <span class='q'>mtL</span>(xp, yp, e int32) int32 {<span id='c:mtL' class='n'>
</span>
	for yp &lt; e {
		if <a href="#match" id='c:1182'>match</a>(<a href="#K" id='c:1183'>K</a>(<a href="#I64" id='c:1184'>I64</a>(xp)), <a href="#K" id='c:1185'>K</a>(<a href="#I64" id='c:1186'>I64</a>(yp))) == 0 {
			return 0
		}
		xp += 8
		yp += 8
		continue
	}
	return 1
}</span><span id="In">
func <span class='q'>In</span>(x, y K) K {<span id='c:In' class='n'>
</span>
	xt, yt := <a href="#tp" id='c:1187'>tp</a>(x), <a href="#tp" id='c:1188'>tp</a>(y)
	if xt == yt &amp;&amp; xt &gt; 16 {
		return <a href="#Ecl" id='c:1189'>Ecl</a>(30, <a href="#l2" id='c:1190'>l2</a>(x, y))
	} else if xt+16 != yt {
		<a href="#trap" id='c:1191'>trap</a>() //type
	}
	<a href="#dxy" id='c:1192'>dxy</a>(x, y)
	return <a href="#Ki" id='c:1193'>Ki</a>(<a href="#I32B" id='c:1194'>I32B</a>(Func[268+xt].(f3i)(<a href="#int32" id='c:1195'>int32</a>(x), <a href="#int32" id='c:1196'>int32</a>(y), <a href="#ep" id='c:1197'>ep</a>(y)) != 0))
}</span><span id="inC">
func <span class='q'>inC</span>(x, yp, e int32) int32 {<span id='c:inC' class='n'>
</span>
	for yp &lt; e { // maybe splat x to int64
		if x == <a href="#I8" id='c:1198'>I8</a>(yp) {
			return yp
		}
		yp++
	}
	return 0
}</span><span id="inI">
func <span class='q'>inI</span>(x, yp, e int32) int32 {<span id='c:inI' class='n'>
</span>
	for yp &lt; e {
		if x == <a href="#I32" id='c:1199'>I32</a>(yp) {
			return yp
		}
		yp += 4
	}
	return 0
}</span><span id="inF">
func <span class='q'>inF</span>(xp, yp, e int32) int32 {<span id='c:inF' class='n'>
</span>
	for yp &lt; e {
		if <a href="#cmF" id='c:1200'>cmF</a>(xp, yp) == 0 {
			return yp
		}
		yp += 8
	}
	return 0
}</span><span id="inZ">
func <span class='q'>inZ</span>(xp, yp, e int32) int32 {<span id='c:inZ' class='n'>
</span>
	for yp &lt; e {
		if <a href="#cmZ" id='c:1201'>cmZ</a>(xp, yp) == 0 {
			return yp
		}
		yp += 16
	}
	return 0
}</span><span id="Atx">
func <span class='q'>Atx</span>(x, y K) K { // x@y<span id='c:Atx' class='n'>
</span>
	var r K
	xt, yt := <a href="#tp" id='c:1202'>tp</a>(x), <a href="#tp" id='c:1203'>tp</a>(y)
	xp := <a href="#int32" id='c:1204'>int32</a>(x)
	if xt &lt; 16 {
		if xt == 0 || xt &gt; 9 {
			return <a href="#cal" id='c:1205'>cal</a>(x, <a href="#l1" id='c:1206'>l1</a>(y))
		}
		if xt == st {
			if xp == 0 {
				if yt == it { // `123 (quoted verb)
					return <a href="#K" id='c:1207'>K</a>(<a href="#int32" id='c:1208'>int32</a>(y))
				}
			}
			xt = <a href="#ts" id='c:1209'>ts</a>(x) + 16
			if <a href="#uint32" id='c:1210'>uint32</a>(xt-18) &lt; 5 { // `c@ .. `z@
				return <a href="#rtp" id='c:1211'>rtp</a>(xt, y)
			} else {
				return <a href="#cal" id='c:1212'>cal</a>(<a href="#Val" id='c:1213'>Val</a>(<a href="#sc" id='c:1214'>sc</a>(<a href="#cat1" id='c:1215'>cat1</a>(<a href="#cs" id='c:1216'>cs</a>(x), <a href="#Kc" id='c:1217'>Kc</a>(&#39;.&#39;)))), <a href="#l1" id='c:1218'>l1</a>(y))
			}
		}
	}
	if xt &gt; Lt &amp;&amp; yt &lt; Lt {
		r = <a href="#x0" id='c:1219'>x0</a>(x)
		x = <a href="#r1" id='c:1220'>r1</a>(x)
		if xt == Tt {
			if yt&amp;15 == it {
				return <a href="#key" id='c:1221'>key</a>(r, <a href="#Ecl" id='c:1222'>Ecl</a>(19, <a href="#l2" id='c:1223'>l2</a>(x, y)), Dt+<a href="#T" id='c:1224'>T</a>(<a href="#I32B" id='c:1225'>I32B</a>(yt == It)))
			}
		}
		return <a href="#Atx" id='c:1226'>Atx</a>(x, <a href="#Fnd" id='c:1227'>Fnd</a>(r, y))
	}
	if yt&amp;15 == ft {
		return <a href="#Rot" id='c:1228'>Rot</a>(x, y)
	}
	if yt &lt; It {
		y = <a href="#uptype" id='c:1229'>uptype</a>(y, it)
		yt = <a href="#tp" id='c:1230'>tp</a>(y)
	}
	if yt == It {
		return <a href="#atv" id='c:1231'>atv</a>(x, y)
	}
	if yt == it {
		return <a href="#ati" id='c:1232'>ati</a>(x, <a href="#int32" id='c:1233'>int32</a>(y))
	}
	if yt == Lt {
		return <a href="#Ecr" id='c:1234'>Ecr</a>(19, <a href="#l2" id='c:1235'>l2</a>(x, y))
	}
	if yt == Dt {
		r = <a href="#x0" id='c:1236'>x0</a>(y)
		return <a href="#Key" id='c:1237'>Key</a>(r, <a href="#Atx" id='c:1238'>Atx</a>(x, <a href="#r1" id='c:1239'>r1</a>(y)))
	}
	<a href="#trap" id='c:1240'>trap</a>() //type f@
	return 0
}</span><span id="ati">
func <span class='q'>ati</span>(x K, i int32) K { // x CT..LT<span id='c:ati' class='n'>
</span>
	r := <a href="#K" id='c:1241'>K</a>(0)
	t := <a href="#tp" id='c:1242'>tp</a>(x)
	if t &lt; 16 {
		return x
	}
	if t &gt; Lt {
		return <a href="#Atx" id='c:1243'>Atx</a>(x, <a href="#Ki" id='c:1244'>Ki</a>(i))
	}
	if i &lt; 0 || i &gt;= <a href="#nn" id='c:1245'>nn</a>(x) {
		<a href="#dx" id='c:1246'>dx</a>(x)
		return <a href="#missing" id='c:1247'>missing</a>(t - 16)
	}
	s := <a href="#sz" id='c:1248'>sz</a>(t)
	p := <a href="#int32" id='c:1249'>int32</a>(x) + i*s
	switch s &gt;&gt; 2 {
	case 0:
		r = <a href="#K" id='c:1250'>K</a>(<a href="#uint32" id='c:1251'>uint32</a>(<a href="#I8" id='c:1252'>I8</a>(p)))
	case 1:
		r = <a href="#K" id='c:1253'>K</a>(<a href="#uint32" id='c:1254'>uint32</a>(<a href="#I32" id='c:1255'>I32</a>(p)))
	case 2:
		r = <a href="#K" id='c:1256'>K</a>(<a href="#uint64" id='c:1257'>uint64</a>(<a href="#I64" id='c:1258'>I64</a>(p)))
	default:
		<a href="#dx" id='c:1259'>dx</a>(x)
		return <a href="#Kz" id='c:1260'>Kz</a>(<a href="#F64" id='c:1261'>F64</a>(p), <a href="#F64" id='c:1262'>F64</a>(p+8))
	}
	if t == Ft {
		r = <a href="#Kf" id='c:1263'>Kf</a>(<a href="#F64reinterpret_i64" id='c:1264'>F64reinterpret_i64</a>(<a href="#uint64" id='c:1265'>uint64</a>(r)))
	} else if t == Lt {
		r = <a href="#rx" id='c:1266'>rx</a>(r)
		<a href="#dx" id='c:1267'>dx</a>(x)
		return r
	}
	<a href="#dx" id='c:1268'>dx</a>(x)
	return <a href="#ti" id='c:1269'>ti</a>(t-16, <a href="#int32" id='c:1270'>int32</a>(r))
}</span><span id="atv">
func <span class='q'>atv</span>(x, y K) K { // x CT..LT<span id='c:atv' class='n'>
</span>
	t := <a href="#tp" id='c:1271'>tp</a>(x)
	if t == Tt {
		return <a href="#Atx" id='c:1272'>Atx</a>(x, y)
	}
	yn := <a href="#nn" id='c:1273'>nn</a>(y)
	if t &lt; 16 {
		<a href="#dx" id='c:1274'>dx</a>(y)
		return <a href="#ntake" id='c:1275'>ntake</a>(yn, x)
	}
	xn := <a href="#nn" id='c:1276'>nn</a>(x)
	r := <a href="#mk" id='c:1277'>mk</a>(t, yn)
	s := <a href="#sz" id='c:1278'>sz</a>(t)
	rp := <a href="#int32" id='c:1279'>int32</a>(r)
	xp := <a href="#int32" id='c:1280'>int32</a>(x)
	yp := <a href="#int32" id='c:1281'>int32</a>(y)
	e := <a href="#ep" id='c:1282'>ep</a>(y)

	na := <a href="#missing" id='c:1283'>missing</a>(t - 16)
	switch s &gt;&gt; 2 {
	case 0:
		for yp &lt; e {
			xi := <a href="#I32" id='c:1284'>I32</a>(yp)
			if <a href="#uint32" id='c:1285'>uint32</a>(xi) &gt;= <a href="#uint32" id='c:1286'>uint32</a>(xn) {
				<a href="#SetI8" id='c:1287'>SetI8</a>(rp, <a href="#int32" id='c:1288'>int32</a>(na))
			} else {
				<a href="#SetI8" id='c:1289'>SetI8</a>(rp, <a href="#I8" id='c:1290'>I8</a>(xp+xi))
			}
			rp++
			yp += 4
		}
	case 1:
		for yp &lt; e {
			xi := <a href="#I32" id='c:1291'>I32</a>(yp)
			if <a href="#uint32" id='c:1292'>uint32</a>(xi) &gt;= <a href="#uint32" id='c:1293'>uint32</a>(xn) {
				<a href="#SetI32" id='c:1294'>SetI32</a>(rp, <a href="#int32" id='c:1295'>int32</a>(na))
			} else {
				<a href="#SetI32" id='c:1296'>SetI32</a>(rp, <a href="#I32" id='c:1297'>I32</a>(xp+4*xi))
			}
			rp += 4
			yp += 4
		}
	case 2:
		for yp &lt; e {
			xi := <a href="#I32" id='c:1298'>I32</a>(yp)
			if <a href="#uint32" id='c:1299'>uint32</a>(xi) &gt;= <a href="#uint32" id='c:1300'>uint32</a>(xn) {
				if t == Lt {
					<a href="#SetI64" id='c:1301'>SetI64</a>(rp, <a href="#int64" id='c:1302'>int64</a>(na))
				} else {
					<a href="#SetI64" id='c:1303'>SetI64</a>(rp, <a href="#I64" id='c:1304'>I64</a>(<a href="#int32" id='c:1305'>int32</a>(na)))
				}
			} else {
				<a href="#SetI64" id='c:1306'>SetI64</a>(rp, <a href="#I64" id='c:1307'>I64</a>(xp+8*xi))
			}
			rp += 8
			yp += 4
		}
	default:
		for yp &lt; e {
			xi := <a href="#I32" id='c:1308'>I32</a>(yp)
			if <a href="#uint32" id='c:1309'>uint32</a>(xi) &gt;= <a href="#uint32" id='c:1310'>uint32</a>(xn) {
				<a href="#SetI64" id='c:1311'>SetI64</a>(rp, <a href="#I64" id='c:1312'>I64</a>(<a href="#int32" id='c:1313'>int32</a>(na)))
				<a href="#SetI64" id='c:1314'>SetI64</a>(rp+8, <a href="#I64" id='c:1315'>I64</a>(<a href="#int32" id='c:1316'>int32</a>(na)))
			} else {
				xi *= 16
				<a href="#SetI64" id='c:1317'>SetI64</a>(rp, <a href="#I64" id='c:1318'>I64</a>(xp+xi))
				<a href="#SetI64" id='c:1319'>SetI64</a>(rp+8, <a href="#I64" id='c:1320'>I64</a>(8+xp+xi))
			}
			rp += 16
			yp += 4
		}
	}
	if t == Lt {
		<a href="#rl" id='c:1321'>rl</a>(r)
		r = <a href="#uf" id='c:1322'>uf</a>(r)
	}
	<a href="#dx" id='c:1323'>dx</a>(na)
	<a href="#dxy" id='c:1324'>dxy</a>(x, y)
	return r
}</span><span id="stv">
func <span class='q'>stv</span>(x, i, y K) K {<span id='c:stv' class='n'>
</span>
	if It != <a href="#tp" id='c:1325'>tp</a>(i) {
		<a href="#trap" id='c:1326'>trap</a>() //type
	}
	n := <a href="#nn" id='c:1327'>nn</a>(i)
	if n == 0 {
		<a href="#dxy" id='c:1328'>dxy</a>(y, i)
		return x
	}
	if n != <a href="#nn" id='c:1329'>nn</a>(y) {
		<a href="#trap" id='c:1330'>trap</a>() //length
	}
	x = <a href="#use" id='c:1331'>use</a>(x)
	xt := <a href="#tp" id='c:1332'>tp</a>(x)
	xn := <a href="#nn" id='c:1333'>nn</a>(x)
	s := <a href="#sz" id='c:1334'>sz</a>(xt)
	xp := <a href="#int32" id='c:1335'>int32</a>(x)
	yp := <a href="#int32" id='c:1336'>int32</a>(y)
	ip := <a href="#int32" id='c:1337'>int32</a>(i)
	e := <a href="#ep" id='c:1338'>ep</a>(y)
	for j := <a href="#int32" id='c:1339'>int32</a>(0); j &lt; n; j++ {
		xi := <a href="#uint32" id='c:1340'>uint32</a>(<a href="#I32" id='c:1341'>I32</a>(ip + 4*j))
		if xi &gt;= <a href="#uint32" id='c:1342'>uint32</a>(xn) {
			<a href="#trap" id='c:1343'>trap</a>() //index
		}
	}
	switch s &gt;&gt; 2 {
	case 0:
		for yp &lt; e {
			<a href="#SetI8" id='c:1344'>SetI8</a>(xp+<a href="#I32" id='c:1345'>I32</a>(ip), <a href="#I8" id='c:1346'>I8</a>(yp))
			ip += 4
			yp++
		}
	case 1:
		for yp &lt; e {
			<a href="#SetI32" id='c:1347'>SetI32</a>(xp+4*<a href="#I32" id='c:1348'>I32</a>(ip), <a href="#I32" id='c:1349'>I32</a>(yp))
			ip += 4
			yp += 4
		}
	case 2:
		if xt == Lt {
			<a href="#rl" id='c:1350'>rl</a>(y)
			for j := <a href="#int32" id='c:1351'>int32</a>(0); j &lt; n; j++ {
				<a href="#dx" id='c:1352'>dx</a>(<a href="#K" id='c:1353'>K</a>(<a href="#I64" id='c:1354'>I64</a>(xp + 8*<a href="#I32" id='c:1355'>I32</a>(ip))))
				ip += 4
			}
			ip = <a href="#int32" id='c:1356'>int32</a>(i)
		}
		for yp &lt; e {
			<a href="#SetI64" id='c:1357'>SetI64</a>(xp+8*<a href="#I32" id='c:1358'>I32</a>(ip), <a href="#I64" id='c:1359'>I64</a>(yp))
			ip += 4
			yp += 8
		}
		if xt == Lt {
			x = <a href="#uf" id='c:1360'>uf</a>(x)
		}
	default:
		for yp &lt; e {
			xp = <a href="#int32" id='c:1361'>int32</a>(x) + 16*<a href="#I32" id='c:1362'>I32</a>(ip)
			<a href="#SetI64" id='c:1363'>SetI64</a>(xp, <a href="#I64" id='c:1364'>I64</a>(yp))
			<a href="#SetI64" id='c:1365'>SetI64</a>(xp+8, <a href="#I64" id='c:1366'>I64</a>(yp+8))
			ip += 4
			yp += 16
		}
	}
	<a href="#dxy" id='c:1367'>dxy</a>(i, y)
	return x
}</span><span id="sti">
func <span class='q'>sti</span>(x K, i int32, y K) K {<span id='c:sti' class='n'>
</span>
	xt := <a href="#tp" id='c:1368'>tp</a>(x)
	if <a href="#uint32" id='c:1369'>uint32</a>(i) &gt;= <a href="#uint32" id='c:1370'>uint32</a>(<a href="#nn" id='c:1371'>nn</a>(x)) {
		<a href="#trap" id='c:1372'>trap</a>() //index
	}
	s := <a href="#sz" id='c:1373'>sz</a>(xt)
	xp := <a href="#int32" id='c:1374'>int32</a>(x)
	yp := <a href="#int32" id='c:1375'>int32</a>(y)
	switch s &gt;&gt; 2 {
	case 0:
		<a href="#SetI8" id='c:1376'>SetI8</a>(xp+i, yp)
	case 1:
		<a href="#SetI32" id='c:1377'>SetI32</a>(xp+4*i, yp)
	case 2:
		xp += 8 * i
		if xt == Lt {
			<a href="#dx" id='c:1378'>dx</a>(<a href="#K" id='c:1379'>K</a>(<a href="#I64" id='c:1380'>I64</a>(xp)))
			<a href="#SetI64" id='c:1381'>SetI64</a>(xp, <a href="#int64" id='c:1382'>int64</a>(<a href="#rx" id='c:1383'>rx</a>(y)))
			x = <a href="#uf" id='c:1384'>uf</a>(x)
		} else {
			<a href="#SetI64" id='c:1385'>SetI64</a>(xp, <a href="#I64" id='c:1386'>I64</a>(yp))
		}
	default:
		xp += 16 * i
		<a href="#SetI64" id='c:1387'>SetI64</a>(xp, <a href="#I64" id='c:1388'>I64</a>(yp))
		<a href="#SetI64" id='c:1389'>SetI64</a>(xp+8, <a href="#I64" id='c:1390'>I64</a>(yp+8))
	}
	<a href="#dx" id='c:1391'>dx</a>(y)
	return x
}</span>
<span id="atdepth">
func <span class='q'>atdepth</span>(x, y K) K {<span id='c:atdepth' class='n'>
</span>
	xt := <a href="#tp" id='c:1392'>tp</a>(x)
	if xt &lt; 16 {
		<a href="#trap" id='c:1393'>trap</a>() //type
	}
	f := <a href="#Fst" id='c:1394'>Fst</a>(<a href="#rx" id='c:1395'>rx</a>(y))
	if f == 0 {
		f = <a href="#seq" id='c:1396'>seq</a>(<a href="#nn" id='c:1397'>nn</a>(x))
	}
	x = <a href="#Atx" id='c:1398'>Atx</a>(x, f)
	if <a href="#nn" id='c:1399'>nn</a>(y) == 1 {
		<a href="#dx" id='c:1400'>dx</a>(y)
		return x
	}
	y = <a href="#ndrop" id='c:1401'>ndrop</a>(1, y)
	if <a href="#tp" id='c:1402'>tp</a>(f) &gt; 16 {
		if <a href="#nn" id='c:1403'>nn</a>(y) == 1 &amp;&amp; xt == Tt {
			return <a href="#Atx" id='c:1404'>Atx</a>(x, <a href="#Fst" id='c:1405'>Fst</a>(y))
		}
		return <a href="#Ecl" id='c:1406'>Ecl</a>(20, <a href="#l2" id='c:1407'>l2</a>(x, y))
	}
	return <a href="#atdepth" id='c:1408'>atdepth</a>(x, y)
}</span>
//go:build !small
<span id="main">
func <span class='q'>main</span>() { // _start<span id='c:main' class='n'>
</span>
	<a href="#kinit" id='c:1409'>kinit</a>()
	<a href="#doargs" id='c:1410'>doargs</a>()
	<a href="#write" id='c:1411'>write</a>(<a href="#Ku" id='c:1412'>Ku</a>(2932601077199979)) // &#34;ktye/k\n&#34;
	<a href="#store" id='c:1413'>store</a>()
	for {
		<a href="#write" id='c:1414'>write</a>(<a href="#Ku" id='c:1415'>Ku</a>(32))
		x := <a href="#readfile" id='c:1416'>readfile</a>(<a href="#mk" id='c:1417'>mk</a>(Ct, 0))
		<a href="#try" id='c:1418'>try</a>(x)
	}
}</span>
<span id="store">
func <span class='q'>store</span>() {<span id='c:store' class='n'>
</span>
	g := (1 &lt;&lt; (<a href="#I32" id='c:1419'>I32</a>(128) - 16)) - <a href="#Memorysize2" id='c:1420'>Memorysize2</a>()
	if g &gt; 0 {
		<a href="#Memorygrow2" id='c:1421'>Memorygrow2</a>(g)
	}
	<a href="#Memorycopy2" id='c:1422'>Memorycopy2</a>(0, 0, <a href="#int32" id='c:1423'>int32</a>(1)&lt;&lt;<a href="#I32" id='c:1424'>I32</a>(128))
}</span><span id="catch">
func <span class='q'>catch</span>() {<span id='c:catch' class='n'>
</span>
	<a href="#Memorycopy3" id='c:1425'>Memorycopy3</a>(0, 0, <a href="#int32" id='c:1426'>int32</a>(65536)*<a href="#Memorysize2" id='c:1427'>Memorysize2</a>())
}</span><span id="try">
func <span class='q'>try</span>(x K) {<span id='c:try' class='n'>
</span>
	defer <a href="#Catch" id='c:1428'>Catch</a>(catch)
	<a href="#repl" id='c:1429'>repl</a>(x)
	<a href="#store" id='c:1430'>store</a>()
}</span>
<span id="doargs">
func <span class='q'>doargs</span>() {<span id='c:doargs' class='n'>
</span>
	a := <a href="#ndrop" id='c:1431'>ndrop</a>(1, <a href="#getargv" id='c:1432'>getargv</a>())
	an := <a href="#nn" id='c:1433'>nn</a>(a)
	ee := <a href="#Ku" id='c:1434'>Ku</a>(25901) // -e
	for i := <a href="#int32" id='c:1435'>int32</a>(0); i &lt; an; i++ {
		x := <a href="#x0" id='c:1436'>x0</a>(a)
		if <a href="#match" id='c:1437'>match</a>(x, ee) != 0 { // -e (exit)
			if i &lt; an-1 {
				<a href="#dx" id='c:1438'>dx</a>(x)
				x = <a href="#x1" id='c:1439'>x1</a>(a)
				<a href="#dx" id='c:1440'>dx</a>(ee)
				<a href="#repl" id='c:1441'>repl</a>(x)
			}
			<a href="#Exit" id='c:1442'>Exit</a>(0)
		}
		<a href="#dofile" id='c:1443'>dofile</a>(x, <a href="#readfile" id='c:1444'>readfile</a>(<a href="#rx" id='c:1445'>rx</a>(x)))
		a += 8
	}
	<a href="#dx" id='c:1446'>dx</a>(ee)
}</span><span id="dofile">
func <span class='q'>dofile</span>(x K, c K) {<span id='c:dofile' class='n'>
</span>
	kk := <a href="#Ku" id='c:1447'>Ku</a>(27438) // .k
	tt := <a href="#Ku" id='c:1448'>Ku</a>(29742) // .t
	xe := <a href="#ntake" id='c:1449'>ntake</a>(-2, <a href="#rx" id='c:1450'>rx</a>(x))
	if <a href="#match" id='c:1451'>match</a>(xe, kk) != 0 { // file.k (execute)
		<a href="#dx" id='c:1452'>dx</a>(<a href="#val" id='c:1453'>val</a>(c))
	} else if <a href="#match" id='c:1454'>match</a>(xe, tt) != 0 { // file.t (test)
		<a href="#test" id='c:1455'>test</a>(c)
	} else { // file (assign file:bytes..)
		<a href="#dx" id='c:1456'>dx</a>(<a href="#Asn" id='c:1457'>Asn</a>(<a href="#sc" id='c:1458'>sc</a>(<a href="#rx" id='c:1459'>rx</a>(x)), c))
	}
	<a href="#dxy" id='c:1460'>dxy</a>(xe, x)
	<a href="#dxy" id='c:1461'>dxy</a>(tt, kk)
}</span><span id="getargv">
func <span class='q'>getargv</span>() K {<span id='c:getargv' class='n'>
</span>
	n := <a href="#Args" id='c:1462'>Args</a>()
	r := <a href="#mk" id='c:1463'>mk</a>(Lt, n)
	rp := <a href="#int32" id='c:1464'>int32</a>(r)
	for i := <a href="#int32" id='c:1465'>int32</a>(0); i &lt; n; i++ {
		s := <a href="#mk" id='c:1466'>mk</a>(Ct, <a href="#Arg" id='c:1467'>Arg</a>(i, 0))
		<a href="#Arg" id='c:1468'>Arg</a>(i, <a href="#int32" id='c:1469'>int32</a>(s))
		<a href="#SetI64" id='c:1470'>SetI64</a>(rp, <a href="#int64" id='c:1471'>int64</a>(s))
		rp += 8
	}
	return r
}</span>
// softfloat implementation of cosin_ atan2 log exp pow frexp is 2464 b

const pi float64 = 3.141592653589793
const maxfloat float64 = 1.797693134862315708145274237317043567981e+308
<span id="hypot">
func <span class='q'>hypot</span>(p, q float64) float64 {<span id='c:hypot' class='n'>
</span>
	p, q = <a href="#F64abs" id='c:1472'>F64abs</a>(p), <a href="#F64abs" id='c:1473'>F64abs</a>(q)
	if p &lt; q {
		t := p
		p = q
		q = t
	}
	if p == 0.0 {
		return 0.0
	}
	q = q / p
	return p * <a href="#F64sqrt" id='c:1474'>F64sqrt</a>(1+q*q)
}</span><span id="cosin">
func <span class='q'>cosin</span>(deg float64, rp int32) {<span id='c:cosin' class='n'>
</span>
	c, s := 0.0, 0.0
	if deg == 0 {
		c = 1.0
	} else if deg == 90 {
		s = 1.0
	} else if deg == 180 {
		c = -1.0
	} else if deg == 270 {
		s = -1.0
	} else {
		<a href="#cosin_" id='c:1475'>cosin_</a>(deg*0.017453292519943295, rp, 0)
		return
	}
	<a href="#SetF64" id='c:1476'>SetF64</a>(rp, c)
	<a href="#SetF64" id='c:1477'>SetF64</a>(rp+8, s)
}</span><span id="ang2">
func <span class='q'>ang2</span>(y, x float64) float64 {<span id='c:ang2' class='n'>
</span>
	if y == 0 {
		if x &lt; 0 {
			return 180.0
		}
		return 0.
	}
	if x == 0 {
		if y &lt; 0 {
			return 270.0
		}
		return 90.0
	}
	deg := 57.29577951308232 * <a href="#atan2" id='c:1478'>atan2</a>(y, x)
	if deg &lt; 0 {
		deg += 360.0
	}
	return deg
}</span><span id="exp1">
func <span class='q'>exp1</span>(xp, yp, rp int32) { <a href="#SetF64" id='c:1479'>SetF64</a>(rp, <a href="#exp" id='c:1480'>exp</a>(<a href="#F64" id='c:1481'>F64</a>(xp))) }<span id='c:exp1' class='n'>
</span></span><span id="log1">
func <span class='q'>log1</span>(xp, yp, rp int32) { <a href="#SetF64" id='c:1482'>SetF64</a>(rp, <a href="#log" id='c:1483'>log</a>(<a href="#F64" id='c:1484'>F64</a>(xp))) }<span id='c:log1' class='n'>
</span></span><span id="pow2">
func <span class='q'>pow2</span>(xp, yp, rp int32) { <a href="#SetF64" id='c:1485'>SetF64</a>(rp, <a href="#pow" id='c:1486'>pow</a>(<a href="#F64" id='c:1487'>F64</a>(xp), <a href="#F64" id='c:1488'>F64</a>(yp))) }<span id='c:pow2' class='n'>
</span></span><span id="sin1">
func <span class='q'>sin1</span>(xp, yp, rp int32) { <a href="#cosin_" id='c:1489'>cosin_</a>(<a href="#F64" id='c:1490'>F64</a>(xp), rp, 1) }<span id='c:sin1' class='n'>
</span></span><span id="cos1">
func <span class='q'>cos1</span>(xp, yp, rp int32) { <a href="#cosin_" id='c:1491'>cosin_</a>(<a href="#F64" id='c:1492'>F64</a>(xp), rp, 2) }<span id='c:cos1' class='n'>
</span></span><span id="cosin_">
func <span class='q'>cosin_</span>(x float64, rp int32, csonly int32) {<span id='c:cosin_' class='n'>
</span>
	c, s, ss, cs := 0.0, 0.0, <a href="#int32" id='c:1493'>int32</a>(0), <a href="#int32" id='c:1494'>int32</a>(0)
	if x &lt; 0 {
		x = -x
		ss = 1
	}
	j := <a href="#int64" id='c:1495'>int64</a>(x * 1.2732395447351628) // *4/pi
	y := <a href="#float64" id='c:1496'>float64</a>(j)
	if j&amp;1 == 1 {
		j++
		y++
	}
	j &amp;= 7
	z := ((x - y*7.85398125648498535156e-1) - y*3.77489470793079817668e-8) - y*2.69515142907905952645e-15
	if j &gt; 3 {
		j -= 4
		//ss, cs = !ss, !cs
		ss, cs = 1-ss, 1-cs
	}
	if j &gt; 1 {
		cs = 1 - cs
	}
	zz := z * z
	c = 1.0 - 0.5*zz + zz*zz*((((((-1.13585365213876817300e-11*zz)+2.08757008419747316778e-9)*zz+-2.75573141792967388112e-7)*zz+2.48015872888517045348e-5)*zz+-1.38888888888730564116e-3)*zz+4.16666666666665929218e-2)
	s = z + z*zz*((((((1.58962301576546568060e-10*zz)+-2.50507477628578072866e-8)*zz+2.75573136213857245213e-6)*zz+-1.98412698295895385996e-4)*zz+8.33333333332211858878e-3)*zz+-1.66666666666666307295e-1)
	if j == 1 || j == 2 {
		x = c
		c = s
		s = x
	}
	if cs != 0 {
		c = -c
	}
	if ss != 0 {
		s = -s
	}
	<a href="#SetF64" id='c:1497'>SetF64</a>(rp, c)
	if csonly == 0 {
		<a href="#SetF64" id='c:1498'>SetF64</a>(rp+8, s)
	} else if csonly == 1 {
		<a href="#SetF64" id='c:1499'>SetF64</a>(rp, s)
	}
}</span><span id="atan2">
func <span class='q'>atan2</span>(y, x float64) float64 {<span id='c:atan2' class='n'>
</span>
	// todo nan/inf
	q := <a href="#atan" id='c:1500'>atan</a>(y / x)
	if x &lt; 0 {
		if q &lt;= 0 {
			return q + pi
		}
		return q - pi
	}
	return q
}</span><span id="atan">
func <span class='q'>atan</span>(x float64) float64 {<span id='c:atan' class='n'>
</span>
	if x &gt; 0 {
		return <a href="#satan" id='c:1501'>satan</a>(x)
	} else {
		return -<a href="#satan" id='c:1502'>satan</a>(-x)
	}
}</span><span id="satan">
func <span class='q'>satan</span>(x float64) float64 {<span id='c:satan' class='n'>
</span>
	if x &lt;= 0.66 {
		return <a href="#xatan" id='c:1503'>xatan</a>(x)
	}
	if x &gt; 2.41421356237309504880 {
		return 1.5707963267948966 - <a href="#xatan" id='c:1504'>xatan</a>(1.0/x) + 6.123233995736765886130e-17
	}
	return 0.7853981633974483 + <a href="#xatan" id='c:1505'>xatan</a>((x-1)/(x+1)) + 0.5*6.123233995736765886130e-17
}</span><span id="xatan">
func <span class='q'>xatan</span>(x float64) float64 {<span id='c:xatan' class='n'>
</span>
	z := x * x
	z = z * ((((-8.750608600031904122785e-01*z+-1.615753718733365076637e+01)*z+-7.500855792314704667340e+01)*z+-1.228866684490136173410e+02)*z + -6.485021904942025371773e+01) / (((((z+2.485846490142306297962e+01)*z+1.650270098316988542046e+02)*z+4.328810604912902668951e+02)*z+4.853903996359136964868e+02)*z + 1.945506571482613964425e+02)
	z = x*z + x
	return z
}</span><span id="exp">
func <span class='q'>exp</span>(x float64) float64 {<span id='c:exp' class='n'>
</span>
	var k int64
	if x != x {
		return x
	}
	if x &gt; 7.09782712893383973096e+02 {
		return inf
	}
	if x &lt; -7.45133219101941108420e+02 {
		return 0.0
	}
	if -3.725290298461914e-09 &lt; x &amp;&amp; x &lt; 3.725290298461914e-09 {
		return 1.0 + x
	}
	if x &lt; 0 {
		k = <a href="#int64" id='c:1506'>int64</a>(1.44269504088896338700*x - 0.5)
	} else {
		k = <a href="#int64" id='c:1507'>int64</a>(1.44269504088896338700*x + 0.5)
	}
	hi := x - <a href="#float64" id='c:1508'>float64</a>(k)*6.93147180369123816490e-01
	lo := <a href="#float64" id='c:1509'>float64</a>(k) * 1.90821492927058770002e-10
	return <a href="#expmulti" id='c:1510'>expmulti</a>(hi, lo, k)
}</span><span id="expmulti">
func <span class='q'>expmulti</span>(hi, lo float64, k int64) float64 {<span id='c:expmulti' class='n'>
</span>
	r := hi - lo
	t := r * r
	c := r - t*(1.66666666666666657415e-01+t*(-2.77777777770155933842e-03+t*(6.61375632143793436117e-05+t*(-1.65339022054652515390e-06+t*4.13813679705723846039e-08))))
	y := 1 - ((lo - (r*c)/(2-c)) - hi)
	return <a href="#ldexp" id='c:1511'>ldexp</a>(y, k)
}</span><span id="ldexp">
func <span class='q'>ldexp</span>(frac float64, exp int64) float64 {<span id='c:ldexp' class='n'>
</span>
	if frac == 0 || frac &gt; maxfloat || frac &lt; -maxfloat || (frac != frac) {
		return frac
	}
	nf := <a href="#normalize" id='c:1512'>normalize</a>(frac)
	if nf != frac {
		exp -= 52
		frac = nf
	}
	x := <a href="#uint64" id='c:1513'>uint64</a>(<a href="#I64reinterpret_f64" id='c:1514'>I64reinterpret_f64</a>(frac))
	exp += <a href="#int64" id='c:1515'>int64</a>(x&gt;&gt;52)&amp;2047 - 1023
	if exp &lt; <a href="#int64" id='c:1516'>int64</a>(-1075) {
		return <a href="#F64copysign" id='c:1517'>F64copysign</a>(0, frac)
	}
	if exp &gt; <a href="#int64" id='c:1518'>int64</a>(1023) {
		if frac &lt; 0 {
			return -inf
		}
		return inf
	}
	m := 1.0
	if exp &lt; <a href="#int64" id='c:1519'>int64</a>(-1022) {
		exp += 53
		m = 1.1102230246251565e-16
	}
	x &amp;^= 9218868437227405312
	x |= <a href="#uint64" id='c:1520'>uint64</a>(exp+1023) &lt;&lt; 52
	return m * <a href="#F64reinterpret_i64" id='c:1521'>F64reinterpret_i64</a>(<a href="#uint64" id='c:1522'>uint64</a>(x))
}</span><span id="frexp1">
func <span class='q'>frexp1</span>(f float64) int32 {<span id='c:frexp1' class='n'>
</span>
	if f == 0.0 {
		return 0
	}
	if f &lt; -maxfloat || f &gt; maxfloat || (f != f) {
		return 0
	}
	return 1
}</span><span id="frexp2">
func <span class='q'>frexp2</span>(f float64) float64 {<span id='c:frexp2' class='n'>
</span>
	f = <a href="#normalize" id='c:1523'>normalize</a>(f)
	x := <a href="#I64reinterpret_f64" id='c:1524'>I64reinterpret_f64</a>(f)
	x &amp;^= 9218868437227405312
	x |= 4602678819172646912
	return <a href="#F64reinterpret_i64" id='c:1525'>F64reinterpret_i64</a>(x)
}</span><span id="frexp3">
func <span class='q'>frexp3</span>(f float64) int64 {<span id='c:frexp3' class='n'>
</span>
	exp := <a href="#int64" id='c:1526'>int64</a>(0)
	nf := <a href="#normalize" id='c:1527'>normalize</a>(f)
	if nf != f {
		exp = <a href="#int64" id='c:1528'>int64</a>(-52)
		f = nf
	}
	x := <a href="#I64reinterpret_f64" id='c:1529'>I64reinterpret_f64</a>(f)
	return exp + <a href="#int64" id='c:1530'>int64</a>((x&gt;&gt;52)&amp;2047) - 1022
}</span><span id="normalize">
func <span class='q'>normalize</span>(x float64) float64 {<span id='c:normalize' class='n'>
</span>
	if <a href="#F64abs" id='c:1531'>F64abs</a>(x) &lt; 2.2250738585072014e-308 {
		return x * 4.503599627370496e+15
	}
	return x
}</span><span id="log">
func <span class='q'>log</span>(x float64) float64 {<span id='c:log' class='n'>
</span>
	if (x != x) || x &gt; maxfloat {
		return x
	}
	if x &lt; 0 {
		return na
	}
	if x == 0 {
		return -inf
	}
	f1 := x
	ki := <a href="#int64" id='c:1532'>int64</a>(0)
	if <a href="#frexp1" id='c:1533'>frexp1</a>(x) != 0 {
		f1 = <a href="#frexp2" id='c:1534'>frexp2</a>(x)
		ki = <a href="#frexp3" id='c:1535'>frexp3</a>(x)
	}
	if f1 &lt; 0.7071067811865476 {
		f1 *= 2
		ki--
	}
	f := f1 - 1
	k := <a href="#float64" id='c:1536'>float64</a>(ki)
	s := f / (2 + f)
	s2 := s * s
	s4 := s2 * s2
	t1 := s2 * (6.666666666666735130e-01 + s4*(2.857142874366239149e-01+s4*(1.818357216161805012e-01+s4*1.479819860511658591e-01)))
	t2 := s4 * (3.999999999940941908e-01 + s4*(2.222219843214978396e-01+s4*1.531383769920937332e-01))
	R := t1 + t2
	hfsq := 0.5 * f * f
	return k*6.93147180369123816490e-01 - ((hfsq - (s*(hfsq+R) + k*1.90821492927058770002e-10)) - f)
}</span><span id="modabsfi">
func <span class='q'>modabsfi</span>(f float64) float64 {<span id='c:modabsfi' class='n'>
</span>
	if f &lt; 1.0 { // simplified for f &gt; 0
		return 0
	}
	x := <a href="#I64reinterpret_f64" id='c:1537'>I64reinterpret_f64</a>(f)
	e := (x&gt;&gt;52)&amp;2047 - 1023
	if e &lt; 52 {
		x &amp;^= <a href="#uint64" id='c:1538'>uint64</a>(1)&lt;&lt;(52-e) - <a href="#uint64" id='c:1539'>uint64</a>(1)
	}
	return <a href="#F64reinterpret_i64" id='c:1540'>F64reinterpret_i64</a>(x)
}</span><span id="pow">
func <span class='q'>pow</span>(x, y float64) float64 {<span id='c:pow' class='n'>
</span>
	if y == 0.0 || x == 1.0 {
		return 1.0
	}
	if y == 1.0 {
		return x
	}
	if (x != x) || (y != y) || y &gt; maxfloat || y &lt; -maxfloat { // simplified
		return na
	}
	if x == 0 { // simplified
		if y &lt; 0 {
			return inf
		} else {
			return 0.0
		}
	}
	if y == 0.5 {
		return <a href="#F64sqrt" id='c:1541'>F64sqrt</a>(x)
	}
	if y == -0.5 {
		return 1.0 / <a href="#F64sqrt" id='c:1542'>F64sqrt</a>(x)
	}

	yf := <a href="#F64abs" id='c:1543'>F64abs</a>(y)
	yi := <a href="#modabsfi" id='c:1544'>modabsfi</a>(yf)
	yf -= yi
	if yf != 0.0 &amp;&amp; x &lt; 0.0 {
		return na
	}
	if yi &gt;= 9.223372036854776e+18 {
		if x == -1.0 {
			return 1.0
		} else if (<a href="#F64abs" id='c:1545'>F64abs</a>(x) &lt; 1.0) == (y &gt; 0.0) {
			return 0.0
		} else {
			return inf
		}
	}
	a1 := 1.0
	ae := <a href="#int64" id='c:1546'>int64</a>(0)
	if yf != 0 {
		if yf &gt; 0.5 {
			yf -= 1.0
			yi += 1.0
		}
		a1 = <a href="#exp" id='c:1547'>exp</a>(yf * <a href="#log" id='c:1548'>log</a>(x))
	}
	x1 := x
	xe := <a href="#int64" id='c:1549'>int64</a>(0)
	if <a href="#frexp1" id='c:1550'>frexp1</a>(x) != 0 {
		x1 = <a href="#frexp2" id='c:1551'>frexp2</a>(x)
		xe = <a href="#frexp3" id='c:1552'>frexp3</a>(x)
	}
	for i := <a href="#int64" id='c:1553'>int64</a>(yi); i != 0; i &gt;&gt;= <a href="#int64" id='c:1554'>int64</a>(1) {
		if xe &lt; <a href="#int64" id='c:1555'>int64</a>(-4096) || 4096 &lt; xe {
			ae += xe
			break
		}
		if i&amp;1 == 1 {
			a1 *= x1
			ae += xe
		}
		x1 *= x1
		xe &lt;&lt;= <a href="#int64" id='c:1556'>int64</a>(1)
		if x1 &lt; 0.5 {
			x1 += x1
			xe--
		}
	}
	if y &lt; 0.0 {
		a1 = 1.0 / a1
		ae = -ae
	}
	return <a href="#ldexp" id='c:1557'>ldexp</a>(a1, ae)
}</span><span id="ipow">
func <span class='q'>ipow</span>(x K, y int32) K {<span id='c:ipow' class='n'>
</span>
	if <a href="#tp" id='c:1558'>tp</a>(x) == It {
		return <a href="#Ecr" id='c:1559'>Ecr</a>(42, <a href="#l2" id='c:1560'>l2</a>(<a href="#Ki" id='c:1561'>Ki</a>(y), x))
	} else {
		return <a href="#Ki" id='c:1562'>Ki</a>(<a href="#iipow" id='c:1563'>iipow</a>(<a href="#int32" id='c:1564'>int32</a>(x), y))
	}
}</span><span id="iipow">
func <span class='q'>iipow</span>(x, y int32) int32 {<span id='c:iipow' class='n'>
</span>
	r := <a href="#int32" id='c:1565'>int32</a>(1)
	for {
		if y&amp;1 == 1 {
			r *= x
		}
		y &gt;&gt;= 1
		if y == 0 {
			break
		}
		x *= x
	}
	return r
}</span>
//go:build small
<span id="main">
func <span class='q'>main</span>() {}<span id='c:main' class='n'>
</span></span>
var ps int32
<span id="Prs">
func <span class='q'>Prs</span>(x K) K { return <a href="#parse" id='c:1566'>parse</a>(<a href="#Tok" id='c:1567'>Tok</a>(x)) } // `p&#34;src&#34;  `<a href="#p" id='c:1568'>p</a>(token list)<span id='c:Prs' class='n'>
</span></span><span id="parse">
func <span class='q'>parse</span>(x K) K {<span id='c:parse' class='n'>
</span>
	if <a href="#tp" id='c:1569'>tp</a>(x) != Lt {
		<a href="#trap" id='c:1570'>trap</a>() //type
	}
	pp = <a href="#int32" id='c:1571'>int32</a>(x)
	n := 8 * <a href="#nn" id='c:1572'>nn</a>(x)
	pe = n + pp
	r := <a href="#es" id='c:1573'>es</a>()
	if pp != pe {
		<a href="#trap" id='c:1574'>trap</a>() //parse
	}
	<a href="#mfree" id='c:1575'>mfree</a>(<a href="#int32" id='c:1576'>int32</a>(x)-16, <a href="#bucket" id='c:1577'>bucket</a>(n)) //free non-recursive
	return r
}</span><span id="es">
func <span class='q'>es</span>() K {<span id='c:es' class='n'>
</span>
	r := <a href="#mk" id='c:1578'>mk</a>(Lt, 0)
	for {
		n := <a href="#next" id='c:1579'>next</a>()
		if n == 0 {
			break
		}
		if n == 59 {
			continue
		}
		pp -= 8
		x := <a href="#e" id='c:1580'>e</a>(<a href="#t" id='c:1581'>t</a>()) &amp;^ 1
		if x == 0 {
			break
		}
		if <a href="#nn" id='c:1582'>nn</a>(r) != 0 {
			r = <a href="#cat1" id='c:1583'>cat1</a>(r, 256) // drop
		}
		r = <a href="#Cat" id='c:1584'>Cat</a>(r, x)
	}
	return r
}</span><span id="e">
func <span class='q'>e</span>(x K) K { // Lt<span id='c:e' class='n'>
</span>
	var r K
	xv := x &amp; 1
	x &amp;^= 1
	if x == 0 {
		return 0
	}
	xs := ps
	y := <a href="#t" id='c:1585'>t</a>()
	yv := y &amp; 1
	y &amp;^= 1
	if y == 0 {
		return x + xv
	}
	if yv != 0 &amp;&amp; xv == 0 {
		r = <a href="#e" id='c:1586'>e</a>(<a href="#t" id='c:1587'>t</a>())
		ev := r &amp; 1
		r &amp;^= 1
		a := <a href="#pasn" id='c:1588'>pasn</a>(x, y, r)
		if a != 0 {
			return a
		}
		if r == 0 || ev == 1 { // 1+ (projection)
			x = <a href="#ucat1" id='c:1589'>ucat1</a>(<a href="#cat1" id='c:1590'>cat1</a>(<a href="#ucat1" id='c:1591'>ucat1</a>(<a href="#l1" id='c:1592'>l1</a>(0), x, <a href="#Ki" id='c:1593'>Ki</a>(2)), 27), y, 92)
			if ev == 1 { // 1+-
				return <a href="#ucat1" id='c:1594'>ucat1</a>(r, x, 91) + 1
			}
			return x + 1
		}
		return <a href="#dyadic" id='c:1595'>dyadic</a>(<a href="#ucat" id='c:1596'>ucat</a>(r, x), y) // dyadic
	}
	r = <a href="#e" id='c:1597'>e</a>(<a href="#rx" id='c:1598'>rx</a>(y) + yv)
	ev := r &amp; 1
	r &amp;^= 1
	<a href="#dx" id='c:1599'>dx</a>(y)
	if xv == 0 {
		return <a href="#ucat1" id='c:1600'>ucat1</a>(r, x, 83|<a href="#K" id='c:1601'>K</a>(xs)&lt;&lt;32) // juxtaposition
	} else if (r == y &amp;&amp; xv+yv == 2) || ev == 1 {
		return <a href="#ucat1" id='c:1602'>ucat1</a>(r, x, 91) + 1 // composition
	}
	return <a href="#idiom" id='c:1603'>idiom</a>(<a href="#monadic" id='c:1604'>monadic</a>(<a href="#ucat" id='c:1605'>ucat</a>(r, x))) // monadic
}</span><span id="t">
func <span class='q'>t</span>() K { // Lt<span id='c:t' class='n'>
</span>
	r := <a href="#next" id='c:1606'>next</a>()
	if r == 0 {
		return 0
	}
	if <a href="#tp" id='c:1607'>tp</a>(r) == 0 &amp;&amp; <a href="#int32" id='c:1608'>int32</a>(r) &lt; 127 {
		if <a href="#is" id='c:1609'>is</a>(<a href="#int32" id='c:1610'>int32</a>(r), 32) != 0 {
			pp -= 8
			return 0
		}
	}
	verb := <a href="#K" id='c:1611'>K</a>(0)
	if r == <a href="#K" id='c:1612'>K</a>(&#39;(&#39;) {
		r = <a href="#rlist" id='c:1613'>rlist</a>(<a href="#plist" id='c:1614'>plist</a>(41)&amp;^1, 0)
	} else if r == <a href="#K" id='c:1615'>K</a>(&#39;{&#39;) {
		r = <a href="#plam" id='c:1616'>plam</a>(ps)
	} else if r == <a href="#K" id='c:1617'>K</a>(&#39;[&#39;) {
		r = <a href="#es" id='c:1618'>es</a>()
		if <a href="#next" id='c:1619'>next</a>() != <a href="#K" id='c:1620'>K</a>(&#39;]&#39;) {
			<a href="#trap" id='c:1621'>trap</a>() //parse
		}
		return r
	} else if <a href="#tp" id='c:1622'>tp</a>(r) == st {
		r = <a href="#l2" id='c:1623'>l2</a>(r, 20|(<a href="#K" id='c:1624'>K</a>(ps)&lt;&lt;32)) // .`x (lookup)
	} else {
		rt := <a href="#tp" id='c:1625'>tp</a>(r)
		if rt == 0 {
			r, verb = <a href="#quote" id='c:1626'>quote</a>(r)|<a href="#K" id='c:1627'>K</a>(ps)&lt;&lt;32, 1
		} else if rt == St {
			if <a href="#nn" id='c:1628'>nn</a>(r) == 1 {
				r = <a href="#Fst" id='c:1629'>Fst</a>(r)
			}
		}
		r = <a href="#l1" id='c:1630'>l1</a>(r)
	}
f:
	for {
		n := <a href="#next" id='c:1631'>next</a>()
		if n == 0 {
			break f
		}
		ks := <a href="#K" id='c:1632'>K</a>(ps) &lt;&lt; 32
		a := <a href="#int32" id='c:1633'>int32</a>(n)
		if <a href="#tp" id='c:1634'>tp</a>(n) == 0 &amp;&amp; a &gt; 20 &amp;&amp; a &lt; 27 { // +/
			r, verb = <a href="#cat1" id='c:1635'>cat1</a>(r, n), 1
		} else if n == 91 { // [
			verb = 0
			n = <a href="#plist" id='c:1636'>plist</a>(93)
			p := <a href="#K" id='c:1637'>K</a>(84) + 8*(n&amp;1) // <a href="#92" id='c:1638'>92</a>(project) or <a href="#call" id='c:1639'>call</a>(84)
			n &amp;^= 1
			s := <a href="#pspec" id='c:1640'>pspec</a>(r, n)
			if s != 0 {
				return s
			}
			if <a href="#nn" id='c:1641'>nn</a>(n) == 1 {
				r = <a href="#ucat1" id='c:1642'>ucat1</a>(<a href="#Fst" id='c:1643'>Fst</a>(n), r, 83|ks)
			} else {
				r = <a href="#cat1" id='c:1644'>cat1</a>(<a href="#Cat" id='c:1645'>Cat</a>(<a href="#rlist" id='c:1646'>rlist</a>(n, 2), r), p|ks)
			}
		} else {
			pp -= 8
			break f // within else-if
		}
	}
	return r + verb
}</span><span id="pasn">
func <span class='q'>pasn</span>(x, y, r K) K {<span id='c:pasn' class='n'>
</span>
	l := <a href="#K" id='c:1647'>K</a>(<a href="#I64" id='c:1648'>I64</a>(<a href="#int32" id='c:1649'>int32</a>(y)))
	v := <a href="#int32" id='c:1650'>int32</a>(l)
	sp := <a href="#h48" id='c:1651'>h48</a>(l)
	if <a href="#nn" id='c:1652'>nn</a>(y) == 1 &amp;&amp; <a href="#tp" id='c:1653'>tp</a>(l) == 0 &amp;&amp; v == 449 || (v &gt; 544 &amp;&amp; v &lt; 565) {
		<a href="#dx" id='c:1654'>dx</a>(y)
		xn := <a href="#nn" id='c:1655'>nn</a>(x)
		if xn &gt; 2 { // indexed amd/dmd
			if v &gt; 544 { // indexed-modified
				l -= 96
			}
			s := <a href="#ati" id='c:1656'>ati</a>(<a href="#rx" id='c:1657'>rx</a>(x), xn-3)
			lp := 0xff000000ffffffff &amp; <a href="#lastp" id='c:1658'>lastp</a>(x)
			// (+;.i.;`x;.;@) -&gt; x:@[x;.i.;+;rhs] which is (+;.i.;`x;.;211 or 212)
			// lp+128 is @[amd..] or .[dmd..]
			if lp == 92 {
				lp = 84 // x[i;]:.. no projection
			}
			x = <a href="#cat1" id='c:1659'>cat1</a>(<a href="#ucat1" id='c:1660'>ucat1</a>(<a href="#l1" id='c:1661'>l1</a>(l), <a href="#ldrop" id='c:1662'>ldrop</a>(-2, x), 20), (<a href="#K" id='c:1663'>K</a>(sp)&lt;&lt;32)|(lp+128))
			y = <a href="#l2" id='c:1664'>l2</a>(s, 448) // s:..
		} else if v == 449 || v == 545 {
			if xn == 1 { // `x: is (,`x) but type Lt replace with `&#34;x.&#34; to use with `x@
				x = <a href="#sc" id='c:1665'>sc</a>(<a href="#cat1" id='c:1666'>cat1</a>(<a href="#cs" id='c:1667'>cs</a>(<a href="#Fst" id='c:1668'>Fst</a>(<a href="#Fst" id='c:1669'>Fst</a>(x))), <a href="#Kc" id='c:1670'>Kc</a>(46))) // `x: -&gt; `&#34;x.&#34;
			} else {
				x = <a href="#Fst" id='c:1671'>Fst</a>(x) // (`x;.)
			}
			if loc != 0 &amp;&amp; v == 449 {
				loc = <a href="#Cat" id='c:1672'>Cat</a>(loc, <a href="#rx" id='c:1673'>rx</a>(x))
			}
			x = <a href="#l1" id='c:1674'>l1</a>(x)
			y = <a href="#l1" id='c:1675'>l1</a>(448) // asn
		} else { // modified
			y = <a href="#cat1" id='c:1676'>cat1</a>(<a href="#l2" id='c:1677'>l2</a>(<a href="#unquote" id='c:1678'>unquote</a>(l-32), <a href="#Fst" id='c:1679'>Fst</a>(<a href="#rx" id='c:1680'>rx</a>(x))), 448)
		}
		return <a href="#dyadic" id='c:1681'>dyadic</a>(<a href="#ucat" id='c:1682'>ucat</a>(r, x), y)
	}
	return 0
}</span><span id="plam">
func <span class='q'>plam</span>(s0 int32) K {<span id='c:plam' class='n'>
</span>
	r := <a href="#K" id='c:1683'>K</a>(0)
	slo := loc
	loc = 0
	ar := <a href="#int32" id='c:1684'>int32</a>(-1)
	n := <a href="#next" id='c:1685'>next</a>()
	if n == 91 { // argnames
		n := <a href="#plist" id='c:1686'>plist</a>(93) &amp;^ 1
		ln := <a href="#nn" id='c:1687'>nn</a>(n)
		loc = <a href="#Ech" id='c:1688'>Ech</a>(4, <a href="#l1" id='c:1689'>l1</a>(n)) // [a]-&gt;,(`a;.)  [a;b]-&gt;((`a;.);(`b;.))
		if ln &gt; 0 &amp;&amp; <a href="#tp" id='c:1690'>tp</a>(loc) != St {
			<a href="#trap" id='c:1691'>trap</a>() //parse
		}
		ar = <a href="#nn" id='c:1692'>nn</a>(loc)
		if ar == 0 {
			<a href="#dx" id='c:1693'>dx</a>(loc)
			loc = <a href="#mk" id='c:1694'>mk</a>(St, 0)
		}
	} else {
		pp -= 8
		loc = <a href="#mk" id='c:1695'>mk</a>(St, 0)
	}
	//c := <a href="#cat1" id='c:1696'>cat1</a>(<a href="#es" id='c:1697'>es</a>(), 30) //rst
	c := <a href="#es" id='c:1698'>es</a>()
	n = <a href="#next" id='c:1699'>next</a>()
	if n != 125 {
		<a href="#trap" id='c:1700'>trap</a>() //parse
	}
	cn := <a href="#nn" id='c:1701'>nn</a>(c)
	cp := <a href="#int32" id='c:1702'>int32</a>(c)
	if ar &lt; 0 {
		ar = 0
		for cn &gt; 0 {
			cn--
			r = <a href="#K" id='c:1703'>K</a>(<a href="#I64" id='c:1704'>I64</a>(cp))
			if <a href="#tp" id='c:1705'>tp</a>(r) == 0 &amp;&amp; <a href="#int32" id='c:1706'>int32</a>(r) == 20 {
				r = <a href="#K" id='c:1707'>K</a>(<a href="#I64" id='c:1708'>I64</a>(cp - 8))
				y := <a href="#int32" id='c:1709'>int32</a>(r) &gt;&gt; 3
				if <a href="#tp" id='c:1710'>tp</a>(r) == st &amp;&amp; y &gt; 0 &amp;&amp; y &lt; 4 {
					ar = <a href="#maxi" id='c:1711'>maxi</a>(ar, y)
				}
			}
			cp += 8
		}
		loc = <a href="#Cat" id='c:1712'>Cat</a>(<a href="#ntake" id='c:1713'>ntake</a>(ar, <a href="#rx" id='c:1714'>rx</a>(xyz)), loc)
	}
	i := <a href="#Add" id='c:1715'>Add</a>(<a href="#seq" id='c:1716'>seq</a>(1+ps-s0), <a href="#Ki" id='c:1717'>Ki</a>(s0-1))
	s := <a href="#atv" id='c:1718'>atv</a>(<a href="#rx" id='c:1719'>rx</a>(<a href="#src" id='c:1720'>src</a>()), i)
	r = <a href="#l3" id='c:1721'>l3</a>(c, s, <a href="#Unq" id='c:1722'>Unq</a>(loc))
	loc = slo
	cp = <a href="#int32" id='c:1723'>int32</a>(r)
	<a href="#SetI32" id='c:1724'>SetI32</a>(cp-12, ar)
	return <a href="#l1" id='c:1725'>l1</a>(<a href="#ti" id='c:1726'>ti</a>(lf, cp) | <a href="#K" id='c:1727'>K</a>(s0)&lt;&lt;32)
}</span><span id="pspec">
func <span class='q'>pspec</span>(r, n K) K {<span id='c:pspec' class='n'>
</span>
	ln := <a href="#nn" id='c:1728'>nn</a>(n)
	v := <a href="#K" id='c:1729'>K</a>(<a href="#I64" id='c:1730'>I64</a>(<a href="#int32" id='c:1731'>int32</a>(r)))
	if <a href="#nn" id='c:1732'>nn</a>(r) == 1 &amp;&amp; ln &gt; 2 { // $[..] cond
		if <a href="#tp" id='c:1733'>tp</a>(v) == 0 &amp;&amp; <a href="#int32" id='c:1734'>int32</a>(v) == 465 {
			<a href="#dx" id='c:1735'>dx</a>(r)
			return <a href="#cond" id='c:1736'>cond</a>(n, ln)
		}
	}
	if <a href="#nn" id='c:1737'>nn</a>(r) == 2 &amp;&amp; ln &gt; 1 &amp;&amp; <a href="#int32" id='c:1738'>int32</a>(v) == 64 { // while[..]
		<a href="#dx" id='c:1739'>dx</a>(r)
		return <a href="#whl" id='c:1740'>whl</a>(n, ln-1)
	}
	return 0
}</span><span id="whl">
func <span class='q'>whl</span>(x K, xn int32) K {<span id='c:whl' class='n'>
</span>
	r := <a href="#cat1" id='c:1741'>cat1</a>(<a href="#Fst" id='c:1742'>Fst</a>(<a href="#rx" id='c:1743'>rx</a>(x)), 0)
	p := <a href="#nn" id='c:1744'>nn</a>(r) - 1
	r = <a href="#ucat" id='c:1745'>ucat</a>(r, <a href="#l2" id='c:1746'>l2</a>(384, 256)) //jif drop
	xp := <a href="#int32" id='c:1747'>int32</a>(x)
	sum := <a href="#int32" id='c:1748'>int32</a>(2)
	for i := <a href="#int32" id='c:1749'>int32</a>(0); i &lt; xn; i++ {
		if i != 0 {
			r = <a href="#cat1" id='c:1750'>cat1</a>(r, 256)
		}
		xp += 8
		y := <a href="#x0" id='c:1751'>x0</a>(<a href="#K" id='c:1752'>K</a>(xp))
		sum += 1 + <a href="#nn" id='c:1753'>nn</a>(y)
		r = <a href="#ucat" id='c:1754'>ucat</a>(r, y)
	}
	r = <a href="#cat1" id='c:1755'>cat1</a>(<a href="#cat1" id='c:1756'>cat1</a>(r, <a href="#Ki" id='c:1757'>Ki</a>(-8*(2+<a href="#nn" id='c:1758'>nn</a>(r)))), 320) // jmp back
	<a href="#SetI64" id='c:1759'>SetI64</a>(<a href="#int32" id='c:1760'>int32</a>(r)+8*p, <a href="#int64" id='c:1761'>int64</a>(<a href="#Ki" id='c:1762'>Ki</a>(8*sum)))   // jif
	<a href="#dx" id='c:1763'>dx</a>(x)
	return <a href="#ucat" id='c:1764'>ucat</a>(<a href="#l1" id='c:1765'>l1</a>(0), r) // null for empty while
}</span><span id="cond">
func <span class='q'>cond</span>(x K, xn int32) K {<span id='c:cond' class='n'>
</span>
	nxt := <a href="#int32" id='c:1766'>int32</a>(0)
	sum := <a href="#int32" id='c:1767'>int32</a>(0)
	xp := <a href="#int32" id='c:1768'>int32</a>(x) + 8*xn
	state := <a href="#int32" id='c:1769'>int32</a>(1)
	for xp != <a href="#int32" id='c:1770'>int32</a>(x) {
		xp -= 8
		r := <a href="#K" id='c:1771'>K</a>(<a href="#I64" id='c:1772'>I64</a>(xp))
		if sum &gt; 0 {
			state = 1 - state
			if state != 0 {
				r = <a href="#cat1" id='c:1773'>cat1</a>(<a href="#cat1" id='c:1774'>cat1</a>(r, <a href="#Ki" id='c:1775'>Ki</a>(nxt)), 384) // jif
			} else {
				r = <a href="#cat1" id='c:1776'>cat1</a>(<a href="#cat1" id='c:1777'>cat1</a>(r, <a href="#Ki" id='c:1778'>Ki</a>(sum)), 320) // j
			}
			<a href="#SetI64" id='c:1779'>SetI64</a>(xp, <a href="#int64" id='c:1780'>int64</a>(r))
		}
		nxt = 8 * <a href="#nn" id='c:1781'>nn</a>(r)
		sum += nxt
	}
	return <a href="#Rdc" id='c:1782'>Rdc</a>(13, <a href="#l1" id='c:1783'>l1</a>(x))
}</span><span id="plist">
func <span class='q'>plist</span>(c K) K {<span id='c:plist' class='n'>
</span>
	p := <a href="#K" id='c:1784'>K</a>(0)
	r := <a href="#mk" id='c:1785'>mk</a>(Lt, 0)
	for {
		b := <a href="#next" id='c:1786'>next</a>()
		if b == 0 || b == c {
			break
		}
		if <a href="#nn" id='c:1787'>nn</a>(r) == 0 {
			pp -= 8
		}
		x := <a href="#e" id='c:1788'>e</a>(<a href="#t" id='c:1789'>t</a>()) &amp;^ 1
		if x == 0 {
			p = 1
		}
		r = <a href="#cat1" id='c:1790'>cat1</a>(r, x)
	}
	return r + p
}</span><span id="rlist">
func <span class='q'>rlist</span>(x, p K) K {<span id='c:rlist' class='n'>
</span>
	n := <a href="#nn" id='c:1791'>nn</a>(x)
	if n == 0 {
		return <a href="#l1" id='c:1792'>l1</a>(x)
	}
	if n == 1 {
		return <a href="#Fst" id='c:1793'>Fst</a>(x)
	}
	if p != 2 {
		p = <a href="#clist" id='c:1794'>clist</a>(x)
		if p != 0 {
			return <a href="#l1" id='c:1795'>l1</a>(p)
		}
	}
	return <a href="#cat1" id='c:1796'>cat1</a>(<a href="#cat1" id='c:1797'>cat1</a>(<a href="#Rdc" id='c:1798'>Rdc</a>(13, <a href="#l1" id='c:1799'>l1</a>(<a href="#Rev" id='c:1800'>Rev</a>(x))), <a href="#Ki" id='c:1801'>Ki</a>(n)), 27)
}</span><span id="clist">
func <span class='q'>clist</span>(x K) K { //constant-fold list<span id='c:clist' class='n'>
</span>
	p := <a href="#int32" id='c:1802'>int32</a>(x)
	e := <a href="#ep" id='c:1803'>ep</a>(x)
	for p &lt; e {
		xi := <a href="#K" id='c:1804'>K</a>(<a href="#I64" id='c:1805'>I64</a>(p))
		t := <a href="#tp" id='c:1806'>tp</a>(xi)
		if t != Lt {
			return 0
		}
		if <a href="#nn" id='c:1807'>nn</a>(xi) != 1 {
			return 0
		}
		if <a href="#tp" id='c:1808'>tp</a>(<a href="#K" id='c:1809'>K</a>(<a href="#I64" id='c:1810'>I64</a>(<a href="#int32" id='c:1811'>int32</a>(xi)))) == 0 {
			return 0
		}
		p += 8
	}
	return <a href="#uf" id='c:1812'>uf</a>(<a href="#Rdc" id='c:1813'>Rdc</a>(13, <a href="#l1" id='c:1814'>l1</a>(x)))
}</span>
<span id="next">
func <span class='q'>next</span>() K {<span id='c:next' class='n'>
</span>
	if pp == pe {
		return 0
	}
	r := <a href="#K" id='c:1815'>K</a>(<a href="#I64" id='c:1816'>I64</a>(pp))
	ps = <a href="#h48" id='c:1817'>h48</a>(r)
	pp += 8
	return r &amp; 0xff000000ffffffff
}</span><span id="lastp">
func <span class='q'>lastp</span>(x K) K   { return <a href="#K" id='c:1818'>K</a>(<a href="#I64" id='c:1819'>I64</a>(<a href="#ep" id='c:1820'>ep</a>(x) - 8)) }<span id='c:lastp' class='n'>
</span></span><span id="h48">
func <span class='q'>h48</span>(x K) int32 { return 0xffffff &amp; <a href="#int32" id='c:1821'>int32</a>(x&gt;&gt;32) }<span id='c:h48' class='n'>
</span></span><span id="dyadic">
func <span class='q'>dyadic</span>(x, y K) K {<span id='c:dyadic' class='n'>
</span>
	l := <a href="#lastp" id='c:1822'>lastp</a>(y)
	if <a href="#quoted" id='c:1823'>quoted</a>(l) != 0 {
		return <a href="#ucat1" id='c:1824'>ucat1</a>(x, <a href="#ldrop" id='c:1825'>ldrop</a>(-1, y), 64+<a href="#unquote" id='c:1826'>unquote</a>(l))
	}
	return <a href="#ucat1" id='c:1827'>ucat1</a>(x, y, 128)
}</span><span id="monadic">
func <span class='q'>monadic</span>(x K) K {<span id='c:monadic' class='n'>
</span>
	l := <a href="#lastp" id='c:1828'>lastp</a>(x)
	if <a href="#quoted" id='c:1829'>quoted</a>(l) != 0 {
		x = <a href="#ldrop" id='c:1830'>ldrop</a>(-1, x)
		if <a href="#int32" id='c:1831'>int32</a>(l) == 449 { // :x return lambda
			return <a href="#cat1" id='c:1832'>cat1</a>(<a href="#cat1" id='c:1833'>cat1</a>(x, <a href="#Ki" id='c:1834'>Ki</a>(1048576)), 320) //identity+long jump
		} else {
			return <a href="#cat1" id='c:1835'>cat1</a>(x, <a href="#unquote" id='c:1836'>unquote</a>(l))
		}
	}
	return <a href="#cat1" id='c:1837'>cat1</a>(x, 83) // dyadic-@
}</span><span id="ldrop">
func <span class='q'>ldrop</span>(n int32, x K) K { return <a href="#explode" id='c:1838'>explode</a>(<a href="#ndrop" id='c:1839'>ndrop</a>(n, x)) }<span id='c:ldrop' class='n'>
</span></span><span id="svrb">
func <span class='q'>svrb</span>(p int32) int32 {<span id='c:svrb' class='n'>
</span>
	x := <a href="#K" id='c:1840'>K</a>(<a href="#I64" id='c:1841'>I64</a>(p))
	return <a href="#I32B" id='c:1842'>I32B</a>(<a href="#int32" id='c:1843'>int32</a>(x) &lt; 64 &amp;&amp; <a href="#tp" id='c:1844'>tp</a>(x) == 0) * <a href="#int32" id='c:1845'>int32</a>(x)
}</span><span id="idiom">
func <span class='q'>idiom</span>(x K) K {<span id='c:idiom' class='n'>
</span>
	l := <a href="#int32" id='c:1846'>int32</a>(x) + 8*(<a href="#nn" id='c:1847'>nn</a>(x)-2)
	i := <a href="#svrb" id='c:1848'>svrb</a>(l) + <a href="#svrb" id='c:1849'>svrb</a>(l+8)&lt;&lt;6
	if i == 262 || i == 263 { // *&amp; 6 4 -&gt; 40
		i = 34 // 6-&gt;<a href="#40" id='c:1850'>40</a>(Fwh) 7-&gt;<a href="#41" id='c:1851'>41</a>(Las)
	} else if i == 1166 { // ?^ 14 18
		i = 23 // 14-&gt;<a href="#37" id='c:1852'>37</a>(Uqs)
	} else {
		return x
	}
	<a href="#SetI64" id='c:1853'>SetI64</a>(l, <a href="#I64" id='c:1854'>I64</a>(l)+<a href="#int64" id='c:1855'>int64</a>(i))
	return <a href="#ndrop" id='c:1856'>ndrop</a>(-1, x)
}</span><span id="rnd">
func <span class='q'>rnd</span>() int32 {<span id='c:rnd' class='n'>
</span>
	r := rand_
	r ^= (r &lt;&lt; 13)
	r ^= (r &gt;&gt; 17)
	r ^= (r &lt;&lt; 5)
	rand_ = r
	return r
}</span><span id="roll">
func <span class='q'>roll</span>(x K) K { // ?x (atom) ?<a href="#n" id='c:1857'>n</a>(uniform 0..1) ?-<a href="#n" id='c:1858'>n</a>(normal) ?<a href="#z" id='c:1859'>z</a>(binormal)<span id='c:roll' class='n'>
</span>
	xt := <a href="#tp" id='c:1860'>tp</a>(x)
	xp := <a href="#int32" id='c:1861'>int32</a>(x)
	if xt == it {
		if xp &gt; 0 {
			return <a href="#kx" id='c:1862'>kx</a>(72, x) // .rf uniform
		} else {
			r := <a href="#kx" id='c:1863'>kx</a>(80, <a href="#Ki" id='c:1864'>Ki</a>((1+-xp)/2))
			<a href="#SetI32" id='c:1865'>SetI32</a>(<a href="#int32" id='c:1866'>int32</a>(r)-12, -xp)
			return <a href="#ti" id='c:1867'>ti</a>(Ft, <a href="#int32" id='c:1868'>int32</a>(r)) // normal
		}
	}
	if xt == zt {
		<a href="#dx" id='c:1869'>dx</a>(x)
		return <a href="#kx" id='c:1870'>kx</a>(80, <a href="#Ki" id='c:1871'>Ki</a>(<a href="#int32" id='c:1872'>int32</a>(<a href="#F64floor" id='c:1873'>F64floor</a>(<a href="#F64" id='c:1874'>F64</a>(xp))))) //.rz binormal
	}
	<a href="#trap" id='c:1875'>trap</a>() //type
	return 0
}</span><span id="deal">
func <span class='q'>deal</span>(x, y K) K { // x?y (x atom) n?<a href="#n" id='c:1876'>n</a>(with replacement) -n?<a href="#n" id='c:1877'>n</a>(without) n?L (-#L)?L shuffle<span id='c:deal' class='n'>
</span>
	yt := <a href="#tp" id='c:1878'>tp</a>(y)
	if yt &gt; 16 {
		return <a href="#In" id='c:1879'>In</a>(x, y)
	}
	if <a href="#tp" id='c:1880'>tp</a>(x) != it {
		<a href="#trap" id='c:1881'>trap</a>() //type
	}
	xp := <a href="#int32" id='c:1882'>int32</a>(x)
	if yt == ct {
		return <a href="#Add" id='c:1883'>Add</a>(<a href="#Kc" id='c:1884'>Kc</a>(97), <a href="#Flr" id='c:1885'>Flr</a>(<a href="#deal" id='c:1886'>deal</a>(x, <a href="#Ki" id='c:1887'>Ki</a>(<a href="#int32" id='c:1888'>int32</a>(y)-96))))
	}
	if yt == st {
		return <a href="#Ech" id='c:1889'>Ech</a>(17, <a href="#l2" id='c:1890'>l2</a>(<a href="#Ks" id='c:1891'>Ks</a>(0), <a href="#deal" id='c:1892'>deal</a>(x, <a href="#Fst" id='c:1893'>Fst</a>(<a href="#cs" id='c:1894'>cs</a>(y))))) // `$&#39;x?*$y
	}
	if yt != it {
		<a href="#trap" id='c:1895'>trap</a>() //type
	}
	yp := <a href="#int32" id='c:1896'>int32</a>(y)
	if xp &gt; 0 {
		return <a href="#randI" id='c:1897'>randI</a>(yp, xp) // n?m
	}
	// todo n&lt;&lt;m
	return <a href="#ntake" id='c:1898'>ntake</a>(-xp, <a href="#shuffle" id='c:1899'>shuffle</a>(<a href="#seq" id='c:1900'>seq</a>(yp), -xp)) //-n?m (no duplicates)
}</span><span id="randi">
func <span class='q'>randi</span>(n int32) int32 {<span id='c:randi' class='n'>
</span>
	v := <a href="#uint32" id='c:1901'>uint32</a>(<a href="#rnd" id='c:1902'>rnd</a>())
	prod := <a href="#uint64" id='c:1903'>uint64</a>(v) * <a href="#uint64" id='c:1904'>uint64</a>(n)
	low := <a href="#uint32" id='c:1905'>uint32</a>(prod)
	if low &lt; <a href="#uint32" id='c:1906'>uint32</a>(n) {
		thresh := <a href="#uint32" id='c:1907'>uint32</a>(-n) % <a href="#uint32" id='c:1908'>uint32</a>(n)
		for low &lt; thresh {
			v = <a href="#uint32" id='c:1909'>uint32</a>(<a href="#rnd" id='c:1910'>rnd</a>())
			prod = <a href="#uint64" id='c:1911'>uint64</a>(v) * <a href="#uint64" id='c:1912'>uint64</a>(n)
			low = <a href="#uint32" id='c:1913'>uint32</a>(prod)
		}
	}
	return <a href="#int32" id='c:1914'>int32</a>(prod &gt;&gt; 32)
}</span><span id="randI">
func <span class='q'>randI</span>(i, n int32) K {<span id='c:randI' class='n'>
</span>
	r := <a href="#mk" id='c:1915'>mk</a>(It, n)
	rp := <a href="#int32" id='c:1916'>int32</a>(r)
	e := <a href="#ep" id='c:1917'>ep</a>(r)
	if i == 0 {
		for rp &lt; e {
			<a href="#SetI32" id='c:1918'>SetI32</a>(rp, <a href="#rnd" id='c:1919'>rnd</a>())
			rp += 4
		}
	} else {
		for rp &lt; e {
			<a href="#SetI32" id='c:1920'>SetI32</a>(rp, <a href="#randi" id='c:1921'>randi</a>(i))
			rp += 4
		}
	}
	return r
}</span><span id="shuffle">
func <span class='q'>shuffle</span>(r K, m int32) K { // I, inplace<span id='c:shuffle' class='n'>
</span>
	rp := <a href="#int32" id='c:1922'>int32</a>(r)
	n := <a href="#nn" id='c:1923'>nn</a>(r)
	m = <a href="#mini" id='c:1924'>mini</a>(n-1, m)
	for i := <a href="#int32" id='c:1925'>int32</a>(0); i &lt; m; i++ {
		j := rp + 4*<a href="#randi" id='c:1926'>randi</a>(n-i)
		t := <a href="#I32" id='c:1927'>I32</a>(rp)
		<a href="#SetI32" id='c:1928'>SetI32</a>(rp, <a href="#I32" id='c:1929'>I32</a>(j))
		<a href="#SetI32" id='c:1930'>SetI32</a>(j, t)
		rp += 4
	}
	return r
}</span><span id="rd0">
func <span class='q'>rd0</span>(yp int32, t T, n int32) K { return 0 }<span id='c:rd0' class='n'>
</span></span><span id="min">
func <span class='q'>min</span>(yp int32, t T, e int32) K { // &amp;/x<span id='c:min' class='n'>
</span>
	var xp int32
	switch t - 18 {
	case 0: // Ct
		xp = 127
		for yp &lt; e {
			xp = <a href="#mini" id='c:1931'>mini</a>(xp, <a href="#I8" id='c:1932'>I8</a>(yp))
			yp++
		}
		return <a href="#Kc" id='c:1933'>Kc</a>(xp)
	case 1: // It
		xp = 2147483647
		for yp &lt; e {
			xp = <a href="#mini" id='c:1934'>mini</a>(xp, <a href="#I32" id='c:1935'>I32</a>(yp))
			yp += 4
		}
		return <a href="#Ki" id='c:1936'>Ki</a>(xp)
	case 2: // St
		xp = (<a href="#nn" id='c:1937'>nn</a>(<a href="#K" id='c:1938'>K</a>(<a href="#I64" id='c:1939'>I64</a>(8))) &lt;&lt; 3) - 8
		for yp &lt; e {
			xp = <a href="#mini" id='c:1940'>mini</a>(xp, <a href="#I32" id='c:1941'>I32</a>(yp))
			yp += 4
		}
		return <a href="#Ks" id='c:1942'>Ks</a>(xp)
	case 3: // Ft
		f := <a href="#F64reinterpret_i64" id='c:1943'>F64reinterpret_i64</a>(<a href="#uint64" id='c:1944'>uint64</a>(0x7FF0000000000000))
		for yp &lt; e {
			f = <a href="#F64min" id='c:1945'>F64min</a>(f, <a href="#F64" id='c:1946'>F64</a>(yp))
			yp += 8
		}
		return <a href="#Kf" id='c:1947'>Kf</a>(f)
	default:
		return 0
	}
}</span><span id="max">
func <span class='q'>max</span>(yp int32, t T, e int32) K { // |/x<span id='c:max' class='n'>
</span>
	var xp int32
	switch t - 18 {
	case 0: // Ct
		xp = -128
		for yp &lt; e {
			xp = <a href="#maxi" id='c:1948'>maxi</a>(xp, <a href="#I8" id='c:1949'>I8</a>(yp))
			yp++
		}
		return <a href="#Kc" id='c:1950'>Kc</a>(xp)
	case 1: // It
		xp = nai
		for yp &lt; e {
			xp = <a href="#maxi" id='c:1951'>maxi</a>(xp, <a href="#I32" id='c:1952'>I32</a>(yp))
			yp += 4
		}
		return <a href="#Ki" id='c:1953'>Ki</a>(xp)
	case 2: // St
		xp = 0
		for yp &lt; e {
			xp = <a href="#maxi" id='c:1954'>maxi</a>(xp, <a href="#I32" id='c:1955'>I32</a>(yp))
			yp += 4
		}
		return <a href="#Ks" id='c:1956'>Ks</a>(xp)
	case 3: // Ft
		f := <a href="#F64reinterpret_i64" id='c:1957'>F64reinterpret_i64</a>(<a href="#uint64" id='c:1958'>uint64</a>(0xFFF0000000000000))
		for yp &lt; e {
			f = <a href="#F64max" id='c:1959'>F64max</a>(f, <a href="#F64" id='c:1960'>F64</a>(yp))
			yp += 8
		}
		return <a href="#Kf" id='c:1961'>Kf</a>(f)
	default:
		return 0
	}
}</span><span id="sum">
func <span class='q'>sum</span>(yp int32, t T, e int32) K { // +/x<span id='c:sum' class='n'>
</span>
	xp := <a href="#int32" id='c:1962'>int32</a>(0)
	switch t - 18 {
	case 0: // Ct
		for yp &lt; e {
			xp += <a href="#I8" id='c:1963'>I8</a>(yp)
			yp++
		}
		return <a href="#Kc" id='c:1964'>Kc</a>(xp)
	case 1: // It
		return <a href="#Ki" id='c:1965'>Ki</a>(xp + <a href="#sumi" id='c:1966'>sumi</a>(yp, e))
	case 2: // St
		return 0
	case 3: // Ft
		f := 0.0
		return <a href="#Kf" id='c:1967'>Kf</a>(f + <a href="#sumf" id='c:1968'>sumf</a>(yp, e, 8))
	case 4: // Zt
		re := 0.0
		im := 0.0
		return <a href="#Kz" id='c:1969'>Kz</a>(re+<a href="#sumf" id='c:1970'>sumf</a>(yp, e, 16), im+<a href="#sumf" id='c:1971'>sumf</a>(yp+8, e, 16))
	default:
		return 0
	}
}</span><span id="sumi">
func <span class='q'>sumi</span>(xp, e int32) int32 {<span id='c:sumi' class='n'>
</span>
	r := <a href="#int32" id='c:1972'>int32</a>(0)
	for xp &lt; e {
		r += <a href="#I32" id='c:1973'>I32</a>(xp)
		xp += 4
	}
	return r
}</span><span id="sumf">
func <span class='q'>sumf</span>(xp, e, s int32) float64 {<span id='c:sumf' class='n'>
</span>
	r := 0.0
	for xp &lt; e {
		r += <a href="#F64" id='c:1974'>F64</a>(xp)
		xp += s
	}
	return r
}</span><span id="prd">
func <span class='q'>prd</span>(yp int32, t T, e int32) K { // */x<span id='c:prd' class='n'>
</span>
	xp := <a href="#int32" id='c:1975'>int32</a>(1)
	switch t - 18 {
	case 0: // Ct
		for yp &lt; e {
			xp *= <a href="#I8" id='c:1976'>I8</a>(yp)
			yp++
		}
		return <a href="#Kc" id='c:1977'>Kc</a>(xp)
	case 1: // It
		for yp &lt; e {
			xp *= <a href="#I32" id='c:1978'>I32</a>(yp)
			yp += 4
		}
		return <a href="#Ki" id='c:1979'>Ki</a>(xp)
	case 2: // St
		return 0
	case 3: // Ft
		f := 1.0
		for yp &lt; e {
			f *= <a href="#F64" id='c:1980'>F64</a>(yp)
			yp += 8
		}
		return <a href="#Kf" id='c:1981'>Kf</a>(f)
	default:
		return 0
	}
}</span>
type f1i = func(int32) int32
type f1f = func(float64) float64
type f1z = func(float64, float64) K
type f2i = func(int32, int32) int32
type fi3 = func(int32, int32, int32)
<span id="Neg">
func <span class='q'>Neg</span>(x K) K              { return <a href="#nm" id='c:1982'>nm</a>(220, x) } //220<span id='c:Neg' class='n'>
</span></span><span id="negi">
func <span class='q'>negi</span>(x int32) int32     { return -x }<span id='c:negi' class='n'>
</span></span><span id="negf">
func <span class='q'>negf</span>(x float64) float64 { return -x }<span id='c:negf' class='n'>
</span></span><span id="negz">
func <span class='q'>negz</span>(x, y float64) K    { return <a href="#Kz" id='c:1983'>Kz</a>(-x, -y) }<span id='c:negz' class='n'>
</span></span>
<span id="Abs">
func <span class='q'>Abs</span>(x K) K {<span id='c:Abs' class='n'>
</span>
	xt := <a href="#tp" id='c:1984'>tp</a>(x)
	if xt &gt; Zt {
		return <a href="#Ech" id='c:1985'>Ech</a>(32, <a href="#l1" id='c:1986'>l1</a>(x))
	}
	if xt == zt {
		xp := <a href="#int32" id='c:1987'>int32</a>(x)
		<a href="#dx" id='c:1988'>dx</a>(x)
		return <a href="#Kf" id='c:1989'>Kf</a>(<a href="#hypot" id='c:1990'>hypot</a>(<a href="#F64" id='c:1991'>F64</a>(xp), <a href="#F64" id='c:1992'>F64</a>(xp+8)))
	} else if xt == Zt {
		return <a href="#absZ" id='c:1993'>absZ</a>(x)
	}
	return <a href="#nm" id='c:1994'>nm</a>(223, x) //227
}</span><span id="absi">
func <span class='q'>absi</span>(x int32) int32 {<span id='c:absi' class='n'>
</span>
	if x &lt; 0 {
		return -x
	}
	return x
}</span><span id="absf">
func <span class='q'>absf</span>(x float64) float64 { return <a href="#F64abs" id='c:1995'>F64abs</a>(x) }<span id='c:absf' class='n'>
</span></span><span id="absZ">
func <span class='q'>absZ</span>(x K) K {<span id='c:absZ' class='n'>
</span>
	n := <a href="#nn" id='c:1996'>nn</a>(x)
	r := <a href="#mk" id='c:1997'>mk</a>(Ft, n)
	rp := <a href="#int32" id='c:1998'>int32</a>(r)
	xp := <a href="#int32" id='c:1999'>int32</a>(x)
	for n &gt; 0 {
		n--
		<a href="#SetF64" id='c:2000'>SetF64</a>(rp, <a href="#hypot" id='c:2001'>hypot</a>(<a href="#F64" id='c:2002'>F64</a>(xp), <a href="#F64" id='c:2003'>F64</a>(xp+8)))
		xp += 16
		rp += 8
		continue
	}
	<a href="#dx" id='c:2004'>dx</a>(x)
	return r
}</span>
<span id="Sqr">
func <span class='q'>Sqr</span>(x K) K {<span id='c:Sqr' class='n'>
</span>
	if <a href="#tp" id='c:2005'>tp</a>(x)&amp;15 != ft {
		x = <a href="#Add" id='c:2006'>Add</a>(<a href="#Kf" id='c:2007'>Kf</a>(0), x)
	}
	return <a href="#nm" id='c:2008'>nm</a>(244, x) //300
}</span><span id="sqrf">
func <span class='q'>sqrf</span>(x float64) float64 { return <a href="#F64sqrt" id='c:2009'>F64sqrt</a>(x) }<span id='c:sqrf' class='n'>
</span></span>
<span id="Hyp">
func <span class='q'>Hyp</span>(x, y K) K { // e.g.  norm:0. abs/x<span id='c:Hyp' class='n'>
</span>
	xt := <a href="#tp" id='c:2010'>tp</a>(x)
	yt := <a href="#tp" id='c:2011'>tp</a>(y)
	if xt &gt; Zt || yt &gt; Zt {
		return <a href="#Ech" id='c:2012'>Ech</a>(32, <a href="#l2" id='c:2013'>l2</a>(x, y))
	}
	if xt == zt {
		x, xt = <a href="#Abs" id='c:2014'>Abs</a>(x), ft
	}
	if xt == ft {
		xp := <a href="#int32" id='c:2015'>int32</a>(x)
		yp := <a href="#int32" id='c:2016'>int32</a>(y)
		<a href="#dxy" id='c:2017'>dxy</a>(x, y)
		if yt == ft {
			return <a href="#Kf" id='c:2018'>Kf</a>(<a href="#hypot" id='c:2019'>hypot</a>(<a href="#F64" id='c:2020'>F64</a>(xp), <a href="#F64" id='c:2021'>F64</a>(yp)))
		} else if yt == zt {
			return <a href="#Kf" id='c:2022'>Kf</a>(<a href="#hypot" id='c:2023'>hypot</a>(<a href="#F64" id='c:2024'>F64</a>(xp), <a href="#hypot" id='c:2025'>hypot</a>(<a href="#F64" id='c:2026'>F64</a>(yp), <a href="#F64" id='c:2027'>F64</a>(yp+8))))
		}
	}
	<a href="#trap" id='c:2028'>trap</a>() //nyi
	return 0
}</span><span id="Img">
func <span class='q'>Img</span>(x K) K { // imag x<span id='c:Img' class='n'>
</span>
	xt := <a href="#tp" id='c:2029'>tp</a>(x)
	if xt &gt; Zt {
		return <a href="#Ech" id='c:2030'>Ech</a>(33, <a href="#l1" id='c:2031'>l1</a>(x))
	}
	if xt == Zt {
		xp := 8 + <a href="#int32" id='c:2032'>int32</a>(x)
		n := <a href="#nn" id='c:2033'>nn</a>(x)
		r := <a href="#mk" id='c:2034'>mk</a>(Ft, n)
		rp := <a href="#int32" id='c:2035'>int32</a>(r)
		e := rp + 8*n
		for rp &lt; e {
			<a href="#SetI64" id='c:2036'>SetI64</a>(rp, <a href="#I64" id='c:2037'>I64</a>(xp))
			xp += 16
			rp += 8
		}
		<a href="#dx" id='c:2038'>dx</a>(x)
		return r
	}
	<a href="#dx" id='c:2039'>dx</a>(x)
	if xt == zt {
		return <a href="#Kf" id='c:2040'>Kf</a>(<a href="#F64" id='c:2041'>F64</a>(<a href="#int32" id='c:2042'>int32</a>(x) + 8))
	}
	if xt &lt; zt {
		return <a href="#Kf" id='c:2043'>Kf</a>(0.0)
	} else {
		return <a href="#ntake" id='c:2044'>ntake</a>(<a href="#nn" id='c:2045'>nn</a>(x), <a href="#Kf" id='c:2046'>Kf</a>(0.0))
	}
}</span><span id="Cpx">
func <span class='q'>Cpx</span>(x, y K) K { return <a href="#Add" id='c:2047'>Add</a>(x, <a href="#Mul" id='c:2048'>Mul</a>(<a href="#Kz" id='c:2049'>Kz</a>(0.0, 1.0), y)) } // x imag y<span id='c:Cpx' class='n'>
</span></span><span id="Cnj">
func <span class='q'>Cnj</span>(x K) K { // conj x<span id='c:Cnj' class='n'>
</span>
	xt := <a href="#tp" id='c:2050'>tp</a>(x)
	if xt &gt; Zt {
		return <a href="#Ech" id='c:2051'>Ech</a>(34, <a href="#l1" id='c:2052'>l1</a>(x))
	}
	if xt&amp;15 &lt; zt {
		return x
	}
	xp := <a href="#int32" id='c:2053'>int32</a>(x)
	if <a href="#tp" id='c:2054'>tp</a>(x) == zt {
		<a href="#dx" id='c:2055'>dx</a>(x)
		return <a href="#Kz" id='c:2056'>Kz</a>(<a href="#F64" id='c:2057'>F64</a>(xp), -<a href="#F64" id='c:2058'>F64</a>(xp+8))
	}
	x = <a href="#use" id='c:2059'>use</a>(x)
	xp = 8 + <a href="#int32" id='c:2060'>int32</a>(x)
	e := xp + 16*<a href="#nn" id='c:2061'>nn</a>(x)
	for xp &lt; e {
		<a href="#SetF64" id='c:2062'>SetF64</a>(xp, -<a href="#F64" id='c:2063'>F64</a>(xp))
		xp += 16
	}
	return x
}</span>
<span id="Add">
func <span class='q'>Add</span>(x, y K) K          { return <a href="#nd" id='c:2064'>nd</a>(226, 2, x, y) } //234<span id='c:Add' class='n'>
</span></span><span id="addi">
func <span class='q'>addi</span>(x, y int32) int32 { return x + y }<span id='c:addi' class='n'>
</span></span><span id="addf">
func <span class='q'>addf</span>(xp, yp, rp int32) { <a href="#SetF64" id='c:2065'>SetF64</a>(rp, <a href="#F64" id='c:2066'>F64</a>(xp)+<a href="#F64" id='c:2067'>F64</a>(yp)) }<span id='c:addf' class='n'>
</span></span><span id="addz">
func <span class='q'>addz</span>(xp, yp, rp int32) { <a href="#SetF64" id='c:2068'>SetF64</a>(rp, <a href="#F64" id='c:2069'>F64</a>(xp)+<a href="#F64" id='c:2070'>F64</a>(yp)); <a href="#SetF64" id='c:2071'>SetF64</a>(rp+8, <a href="#F64" id='c:2072'>F64</a>(xp+8)+<a href="#F64" id='c:2073'>F64</a>(yp+8)) }<span id='c:addz' class='n'>
</span></span><span id="Sub">
func <span class='q'>Sub</span>(x, y K) K          { return <a href="#nd" id='c:2074'>nd</a>(229, 3, x, y) } //245<span id='c:Sub' class='n'>
</span></span><span id="subi">
func <span class='q'>subi</span>(x, y int32) int32 { return x - y }<span id='c:subi' class='n'>
</span></span><span id="subf">
func <span class='q'>subf</span>(xp, yp, rp int32) { <a href="#SetF64" id='c:2075'>SetF64</a>(rp, <a href="#F64" id='c:2076'>F64</a>(xp)-<a href="#F64" id='c:2077'>F64</a>(yp)) }<span id='c:subf' class='n'>
</span></span><span id="subz">
func <span class='q'>subz</span>(xp, yp, rp int32) { <a href="#SetF64" id='c:2078'>SetF64</a>(rp, <a href="#F64" id='c:2079'>F64</a>(xp)-<a href="#F64" id='c:2080'>F64</a>(yp)); <a href="#SetF64" id='c:2081'>SetF64</a>(rp+8, <a href="#F64" id='c:2082'>F64</a>(xp+8)-<a href="#F64" id='c:2083'>F64</a>(yp+8)) }<span id='c:subz' class='n'>
</span></span>
<span id="Mul">
func <span class='q'>Mul</span>(x, y K) K          { return <a href="#nd" id='c:2084'>nd</a>(232, 4, x, y) } //256<span id='c:Mul' class='n'>
</span></span><span id="muli">
func <span class='q'>muli</span>(x, y int32) int32 { return x * y }<span id='c:muli' class='n'>
</span></span><span id="mulf">
func <span class='q'>mulf</span>(xp, yp, rp int32) { <a href="#SetF64" id='c:2085'>SetF64</a>(rp, <a href="#F64" id='c:2086'>F64</a>(xp)*<a href="#F64" id='c:2087'>F64</a>(yp)) }<span id='c:mulf' class='n'>
</span></span><span id="mulz">
func <span class='q'>mulz</span>(xp, yp, rp int32) {<span id='c:mulz' class='n'>
</span>
	xr, xi := <a href="#F64" id='c:2088'>F64</a>(xp), <a href="#F64" id='c:2089'>F64</a>(xp+8)
	yr, yi := <a href="#F64" id='c:2090'>F64</a>(yp), <a href="#F64" id='c:2091'>F64</a>(yp+8)
	<a href="#SetF64" id='c:2092'>SetF64</a>(rp, xr*yr-xi*yi)
	<a href="#SetF64" id='c:2093'>SetF64</a>(rp+8, xr*yi+xi*yr)
}</span>
<span id="Mod">
func <span class='q'>Mod</span>(x, y K) K          { return <a href="#nd" id='c:2094'>nd</a>(244, 41, x, y) } //300<span id='c:Mod' class='n'>
</span></span><span id="modi">
func <span class='q'>modi</span>(x, y int32) int32 { return x % y }<span id='c:modi' class='n'>
</span></span><span id="idiv">
func <span class='q'>idiv</span>(x, y K, mod int32) K {<span id='c:idiv' class='n'>
</span>
	if mod != 0 {
		return <a href="#Mod" id='c:2095'>Mod</a>(x, y)
	}
	return <a href="#Div" id='c:2096'>Div</a>(x, y)
}</span><span id="Div">
func <span class='q'>Div</span>(x, y K) K          { return <a href="#nd" id='c:2097'>nd</a>(235, 5, x, y) } //267<span id='c:Div' class='n'>
</span></span><span id="divi">
func <span class='q'>divi</span>(x, y int32) int32 { return x / y }<span id='c:divi' class='n'>
</span></span><span id="divf">
func <span class='q'>divf</span>(xp, yp, rp int32) { <a href="#SetF64" id='c:2098'>SetF64</a>(rp, <a href="#F64" id='c:2099'>F64</a>(xp)/<a href="#F64" id='c:2100'>F64</a>(yp)) }<span id='c:divf' class='n'>
</span></span><span id="divz">
func <span class='q'>divz</span>(xp, yp, rp int32) {<span id='c:divz' class='n'>
</span>
	xr, xi := <a href="#F64" id='c:2101'>F64</a>(xp), <a href="#F64" id='c:2102'>F64</a>(xp+8)
	yr, yi := <a href="#F64" id='c:2103'>F64</a>(yp), <a href="#F64" id='c:2104'>F64</a>(yp+8)
	r, d, e, f := 0.0, 0.0, 0.0, 0.0
	if <a href="#F64abs" id='c:2105'>F64abs</a>(yr) &gt;= <a href="#F64abs" id='c:2106'>F64abs</a>(yi) {
		r = yi / yr
		d = yr + r*yi
		e = (xr + xi*r) / d
		f = (xi - xr*r) / d
	} else {
		r = yr / yi
		d = yi + r*yr
		e = (xr*r + xi) / d
		f = (xi*r - xr) / d
	}
	<a href="#SetF64" id='c:2107'>SetF64</a>(rp, e)
	<a href="#SetF64" id='c:2108'>SetF64</a>(rp+8, f)
}</span>
<span id="Min">
func <span class='q'>Min</span>(x, y K) K { return <a href="#nd" id='c:2109'>nd</a>(238, 6, x, y) } //278<span id='c:Min' class='n'>
</span></span><span id="mini">
func <span class='q'>mini</span>(x, y int32) int32 {<span id='c:mini' class='n'>
</span>
	if x &lt; y {
		return x
	}
	return y
}</span><span id="minf">
func <span class='q'>minf</span>(xp, yp, rp int32) { <a href="#SetF64" id='c:2110'>SetF64</a>(rp, <a href="#F64min" id='c:2111'>F64min</a>(<a href="#F64" id='c:2112'>F64</a>(xp), <a href="#F64" id='c:2113'>F64</a>(yp))) }<span id='c:minf' class='n'>
</span></span><span id="minz">
func <span class='q'>minz</span>(xp, yp, rp int32) {<span id='c:minz' class='n'>
</span>
	if <a href="#cmZ" id='c:2114'>cmZ</a>(xp, yp) &gt; 0 {
		xp = yp
	}
	<a href="#SetI64" id='c:2115'>SetI64</a>(rp, <a href="#I64" id='c:2116'>I64</a>(xp))
	<a href="#SetI64" id='c:2117'>SetI64</a>(rp+8, <a href="#I64" id='c:2118'>I64</a>(xp+8))
}</span>
<span id="Max">
func <span class='q'>Max</span>(x, y K) K { return <a href="#nd" id='c:2119'>nd</a>(241, 7, x, y) } //289<span id='c:Max' class='n'>
</span></span><span id="maxi">
func <span class='q'>maxi</span>(x, y int32) int32 {<span id='c:maxi' class='n'>
</span>
	if x &gt; y {
		return x
	} else {
		return y
	}
}</span><span id="maxf">
func <span class='q'>maxf</span>(xp, yp, rp int32) { <a href="#SetF64" id='c:2120'>SetF64</a>(rp, <a href="#F64max" id='c:2121'>F64max</a>(<a href="#F64" id='c:2122'>F64</a>(xp), <a href="#F64" id='c:2123'>F64</a>(yp))) }<span id='c:maxf' class='n'>
</span></span><span id="maxz">
func <span class='q'>maxz</span>(xp, yp, rp int32) {<span id='c:maxz' class='n'>
</span>
	if <a href="#cmZ" id='c:2124'>cmZ</a>(xp, yp) &lt; 0 {
		xp = yp
	}
	<a href="#SetI64" id='c:2125'>SetI64</a>(rp, <a href="#I64" id='c:2126'>I64</a>(xp))
	<a href="#SetI64" id='c:2127'>SetI64</a>(rp+8, <a href="#I64" id='c:2128'>I64</a>(xp+8))
}</span>

// compare: 0(match) -1(x&lt;y) 1(x&gt;y)<span id="cmi">
func <span class='q'>cmi</span>(x, y int32) int32 { return <a href="#I32B" id='c:2129'>I32B</a>(x &gt; y) - <a href="#I32B" id='c:2130'>I32B</a>(x &lt; y) }<span id='c:cmi' class='n'>
</span></span><span id="cmC">
func <span class='q'>cmC</span>(x, y int32) int32 { x, y = <a href="#I8" id='c:2131'>I8</a>(x), <a href="#I8" id='c:2132'>I8</a>(y); return <a href="#I32B" id='c:2133'>I32B</a>(x &gt; y) - <a href="#I32B" id='c:2134'>I32B</a>(x &lt; y) }<span id='c:cmC' class='n'>
</span></span><span id="cmI">
func <span class='q'>cmI</span>(x, y int32) int32 { x, y = <a href="#I32" id='c:2135'>I32</a>(x), <a href="#I32" id='c:2136'>I32</a>(y); return <a href="#I32B" id='c:2137'>I32B</a>(x &gt; y) - <a href="#I32B" id='c:2138'>I32B</a>(x &lt; y) }<span id='c:cmI' class='n'>
</span></span><span id="cmF">
func <span class='q'>cmF</span>(x, y int32) int32 {<span id='c:cmF' class='n'>
</span>
	a, b := <a href="#I64" id='c:2139'>I64</a>(x), <a href="#I64" id='c:2140'>I64</a>(y)
	if 2 == <a href="#I32B" id='c:2141'>I32B</a>(a &lt; 0)+<a href="#I32B" id='c:2142'>I32B</a>(b &lt; 0) {
		a, b = -a, -b
	}
	return <a href="#I32B" id='c:2143'>I32B</a>(a &gt; b) - <a href="#I32B" id='c:2144'>I32B</a>(a &lt; b)
}</span><span id="cmZ">
func <span class='q'>cmZ</span>(x, y int32) int32 {<span id='c:cmZ' class='n'>
</span>
	r := <a href="#cmF" id='c:2145'>cmF</a>(x, y)
	if r == 0 {
		return <a href="#cmF" id='c:2146'>cmF</a>(x+8, y+8)
	} else {
		return r
	}
}</span>
<span id="Eql">
func <span class='q'>Eql</span>(x, y K) K { return <a href="#nc" id='c:2147'>nc</a>(10, 0, x, y) } //308<span id='c:Eql' class='n'>
</span></span><span id="Les">
func <span class='q'>Les</span>(x, y K) K { // x&lt;y   `file&lt;c<span id='c:Les' class='n'>
</span>
	if <a href="#tp" id='c:2148'>tp</a>(x) == st &amp;&amp; <a href="#tp" id='c:2149'>tp</a>(y) == Ct {
		if <a href="#int32" id='c:2150'>int32</a>(x) == 0 {
			<a href="#write" id='c:2151'>write</a>(<a href="#rx" id='c:2152'>rx</a>(y))
			return y
		}
		return <a href="#writefile" id='c:2153'>writefile</a>(<a href="#cs" id='c:2154'>cs</a>(x), y)
	}
	return <a href="#nc" id='c:2155'>nc</a>(8, -1, x, y) //323
}</span><span id="Mor">
func <span class='q'>Mor</span>(x, y K) K { return <a href="#nc" id='c:2156'>nc</a>(9, 1, x, y) } //338<span id='c:Mor' class='n'>
</span></span>
<span id="Ang">
func <span class='q'>Ang</span>(x K) K { // angle x<span id='c:Ang' class='n'>
</span>
	var r K
	xt := <a href="#tp" id='c:2157'>tp</a>(x)
	if xt &gt; Zt {
		return <a href="#Ech" id='c:2158'>Ech</a>(35, <a href="#l1" id='c:2159'>l1</a>(x))
	}
	if xt &lt; zt {
		<a href="#dx" id='c:2160'>dx</a>(x)
		return <a href="#Kf" id='c:2161'>Kf</a>(0)
	}
	xp := <a href="#int32" id='c:2162'>int32</a>(x)
	if xt == zt {
		<a href="#dx" id='c:2163'>dx</a>(x)
		return <a href="#Kf" id='c:2164'>Kf</a>(<a href="#ang2" id='c:2165'>ang2</a>(<a href="#F64" id='c:2166'>F64</a>(xp+8), <a href="#F64" id='c:2167'>F64</a>(xp)))
	}
	n := <a href="#nn" id='c:2168'>nn</a>(x)
	if xt == Zt {
		r = <a href="#mk" id='c:2169'>mk</a>(Ft, n)
		rp := <a href="#int32" id='c:2170'>int32</a>(r)
		e := rp + 8*n
		for rp &lt; e {
			<a href="#SetF64" id='c:2171'>SetF64</a>(rp, <a href="#ang2" id='c:2172'>ang2</a>(<a href="#F64" id='c:2173'>F64</a>(xp+8), <a href="#F64" id='c:2174'>F64</a>(xp)))
			xp += 16
			rp += 8
		}
	} else {
		r = <a href="#ntake" id='c:2175'>ntake</a>(n, <a href="#Kf" id='c:2176'>Kf</a>(0))
	}
	<a href="#dx" id='c:2177'>dx</a>(x)
	return r
}</span><span id="Rot">
func <span class='q'>Rot</span>(x, y K) K { // r@deg<span id='c:Rot' class='n'>
</span>
	var r K
	if <a href="#tp" id='c:2178'>tp</a>(x) &gt; Zt {
		return <a href="#Ech" id='c:2179'>Ech</a>(35, <a href="#l2" id='c:2180'>l2</a>(x, y))
	}
	x = <a href="#uptype" id='c:2181'>uptype</a>(x, zt)
	if y == 0 {
		return x
	}
	if <a href="#tp" id='c:2182'>tp</a>(y)&amp;15 &gt; ft {
		<a href="#trap" id='c:2183'>trap</a>() //type
	}
	y = <a href="#uptype" id='c:2184'>uptype</a>(y, ft)
	yp := <a href="#int32" id='c:2185'>int32</a>(y)
	if <a href="#tp" id='c:2186'>tp</a>(y) == ft {
		r = <a href="#Kz" id='c:2187'>Kz</a>(0, 0)
		<a href="#cosin" id='c:2188'>cosin</a>(<a href="#F64" id='c:2189'>F64</a>(yp), <a href="#int32" id='c:2190'>int32</a>(r))
	} else {
		yn := <a href="#nn" id='c:2191'>nn</a>(y)
		r = <a href="#mk" id='c:2192'>mk</a>(Zt, yn)
		rp := <a href="#int32" id='c:2193'>int32</a>(r)
		for yn &gt; 0 {
			yn--
			<a href="#cosin" id='c:2194'>cosin</a>(<a href="#F64" id='c:2195'>F64</a>(yp), rp)
			yp += 8
			rp += 16
		}
	}
	<a href="#dx" id='c:2196'>dx</a>(y)
	return <a href="#Mul" id='c:2197'>Mul</a>(r, x)
}</span><span id="Sin">
func <span class='q'>Sin</span>(x K) K { return <a href="#nf" id='c:2198'>nf</a>(44, x, 0) } // sin x<span id='c:Sin' class='n'>
</span></span><span id="Cos">
func <span class='q'>Cos</span>(x K) K { return <a href="#nf" id='c:2199'>nf</a>(45, x, 0) } // cos x<span id='c:Cos' class='n'>
</span></span><span id="Exp">
func <span class='q'>Exp</span>(x K) K { return <a href="#nf" id='c:2200'>nf</a>(42, x, 0) } // exp x<span id='c:Exp' class='n'>
</span></span><span id="Log">
func <span class='q'>Log</span>(x K) K { return <a href="#nf" id='c:2201'>nf</a>(43, x, 0) } // log x<span id='c:Log' class='n'>
</span></span><span id="Pow">
func <span class='q'>Pow</span>(y, x K) K { // x^y<span id='c:Pow' class='n'>
</span>
	if <a href="#tp" id='c:2202'>tp</a>(x)&amp;15 == it {
		if <a href="#tp" id='c:2203'>tp</a>(y) == it {
			if <a href="#int32" id='c:2204'>int32</a>(y) &gt;= 0 {
				return <a href="#ipow" id='c:2205'>ipow</a>(x, <a href="#int32" id='c:2206'>int32</a>(y))
			}
		}
	}
	return <a href="#nf" id='c:2207'>nf</a>(106, x, y)
}</span><span id="Lgn">
func <span class='q'>Lgn</span>(x, y K) K { // n log y<span id='c:Lgn' class='n'>
</span>
	xf := <a href="#fk" id='c:2208'>fk</a>(x)
	if xf == 10.0 {
		xf = 0.4342944819032518
	} else if xf == 2.0 {
		xf = 1.4426950408889634
	} else {
		xf = 1.0 / <a href="#log" id='c:2209'>log</a>(xf)
	}
	return <a href="#Mul" id='c:2210'>Mul</a>(<a href="#Kf" id='c:2211'>Kf</a>(xf), <a href="#Log" id='c:2212'>Log</a>(y))
}</span><span id="fk">
func <span class='q'>fk</span>(x K) float64 {<span id='c:fk' class='n'>
</span>
	t := <a href="#tp" id='c:2213'>tp</a>(x)
	if t == it {
		return <a href="#float64" id='c:2214'>float64</a>(<a href="#int32" id='c:2215'>int32</a>(x))
	}
	if t != ft {
		<a href="#trap" id='c:2216'>trap</a>() //type
	}
	<a href="#dx" id='c:2217'>dx</a>(x)
	return <a href="#F64" id='c:2218'>F64</a>(<a href="#int32" id='c:2219'>int32</a>(x))
}</span><span id="nf">
func <span class='q'>nf</span>(f int32, x, y K) K {<span id='c:nf' class='n'>
</span>
	var r K
	xt := <a href="#tp" id='c:2220'>tp</a>(x)
	if xt &gt;= Lt {
		if y == 0 {
			return <a href="#Ech" id='c:2221'>Ech</a>(<a href="#K" id='c:2222'>K</a>(f), <a href="#l1" id='c:2223'>l1</a>(x))
		} else {
			return <a href="#Ech" id='c:2224'>Ech</a>(<a href="#K" id='c:2225'>K</a>(f-64), <a href="#l2" id='c:2226'>l2</a>(y, x))
		}
	}
	if xt&amp;15 &lt; ft {
		x = <a href="#uptype" id='c:2227'>uptype</a>(x, ft)
		xt = <a href="#tp" id='c:2228'>tp</a>(x)
	}
	xp := <a href="#int32" id='c:2229'>int32</a>(x)
	xn := <a href="#int32" id='c:2230'>int32</a>(1)
	if xt == ft {
		r = <a href="#Kf" id='c:2231'>Kf</a>(0)
	} else {
		xn = <a href="#nn" id='c:2232'>nn</a>(x)
		r = <a href="#mk" id='c:2233'>mk</a>(Ft, xn)
	}
	if xn &gt; 0 {
		f += 233 - 60*<a href="#I32B" id='c:2234'>I32B</a>(f == 106) //exp,log,sin,cos,pow only pow uses y
		dr := <a href="#int32" id='c:2235'>int32</a>(r) - xp
		e := xp + 8*xn
		for xp &lt; e {
			Func[f].(fi3)(xp, <a href="#int32" id='c:2236'>int32</a>(y), xp+dr)
			xp += 8
			continue
		}
	}
	<a href="#dxy" id='c:2237'>dxy</a>(x, y)
	return r
}</span><span id="nm">
func <span class='q'>nm</span>(f int32, x K) K { //monadic<span id='c:nm' class='n'>
</span>
	var r K
	xt := <a href="#tp" id='c:2238'>tp</a>(x)
	if xt &gt; Lt {
		r = <a href="#x0" id='c:2239'>x0</a>(x)
		return <a href="#key" id='c:2240'>key</a>(r, <a href="#nm" id='c:2241'>nm</a>(f, <a href="#r1" id='c:2242'>r1</a>(x)), xt)
	}
	xp := <a href="#int32" id='c:2243'>int32</a>(x)
	if xt == Lt {
		n := <a href="#nn" id='c:2244'>nn</a>(x)
		r = <a href="#mk" id='c:2245'>mk</a>(Lt, n)
		rp := <a href="#int32" id='c:2246'>int32</a>(r)
		for n &gt; 0 {
			n--
			<a href="#SetI64" id='c:2247'>SetI64</a>(rp, <a href="#int64" id='c:2248'>int64</a>(<a href="#nm" id='c:2249'>nm</a>(f, <a href="#x0" id='c:2250'>x0</a>(<a href="#K" id='c:2251'>K</a>(xp)))))
			xp += 8
			rp += 8
		}
		<a href="#dx" id='c:2252'>dx</a>(x)
		return <a href="#uf" id='c:2253'>uf</a>(r)
	}
	if xt &lt; 16 {
		switch xt - 2 {
		case 0:
			return <a href="#Kc" id='c:2254'>Kc</a>(Func[f].(f1i)(xp))
		case 1:
			return <a href="#Ki" id='c:2255'>Ki</a>(Func[f].(f1i)(xp))
		case 2:
			<a href="#trap" id='c:2256'>trap</a>() //type
			return 0
		case 3:
			r = <a href="#Kf" id='c:2257'>Kf</a>(Func[1+f].(f1f)(<a href="#F64" id='c:2258'>F64</a>(xp)))
			<a href="#dx" id='c:2259'>dx</a>(x)
			return r
		case 4:
			r = Func[2+f].(f1z)(<a href="#F64" id='c:2260'>F64</a>(xp), <a href="#F64" id='c:2261'>F64</a>(xp+8))
			<a href="#dx" id='c:2262'>dx</a>(x)
			return r
		default:
			<a href="#trap" id='c:2263'>trap</a>() //type
			return 0
		}
	}
	r = <a href="#use1" id='c:2264'>use1</a>(x)
	rp := <a href="#int32" id='c:2265'>int32</a>(r)
	e := <a href="#ep" id='c:2266'>ep</a>(r)
	if e == rp {
		<a href="#dx" id='c:2267'>dx</a>(x)
		return r
	}
	switch xt - 18 {
	case 0:
		for rp &lt; e {
			<a href="#SetI8" id='c:2268'>SetI8</a>(rp, Func[f].(f1i)(<a href="#I8" id='c:2269'>I8</a>(xp)))
			xp++
			rp++
			continue
		}
	case 1:
		for rp &lt; e {
			<a href="#SetI32" id='c:2270'>SetI32</a>(rp, Func[f].(f1i)(<a href="#I32" id='c:2271'>I32</a>(xp)))
			xp += 4
			rp += 4
			continue
		}
	case 2:
		<a href="#trap" id='c:2272'>trap</a>() //type
	default: //F/Z (only called for neg)
		for rp &lt; e {
			<a href="#SetF64" id='c:2273'>SetF64</a>(rp, Func[1+f].(f1f)(<a href="#F64" id='c:2274'>F64</a>(xp)))
			xp += 8
			rp += 8
			continue
		}
	}
	<a href="#dx" id='c:2275'>dx</a>(x)
	return r
}</span><span id="nd">
func <span class='q'>nd</span>(f, ff int32, x, y K) K { //dyadic<span id='c:nd' class='n'>
</span>
	var r K
	var n int32
	t := <a href="#dtypes" id='c:2276'>dtypes</a>(x, y)
	if t &gt; Lt {
		r = <a href="#dkeys" id='c:2277'>dkeys</a>(x, y)
		return <a href="#key" id='c:2278'>key</a>(r, Func[64+ff].(f2)(<a href="#dvals" id='c:2279'>dvals</a>(x), <a href="#dvals" id='c:2280'>dvals</a>(y)), t)
	}
	if t == Lt {
		return <a href="#Ech" id='c:2281'>Ech</a>(<a href="#K" id='c:2282'>K</a>(ff), <a href="#l2" id='c:2283'>l2</a>(x, y))
	}
	t = <a href="#maxtype" id='c:2284'>maxtype</a>(x, y)
	x = <a href="#uptype" id='c:2285'>uptype</a>(x, t)
	y = <a href="#uptype" id='c:2286'>uptype</a>(y, t)
	av := <a href="#conform" id='c:2287'>conform</a>(x, y)
	xp, yp := <a href="#int32" id='c:2288'>int32</a>(x), <a href="#int32" id='c:2289'>int32</a>(y)

	if av == 0 { //atom-atom
		switch t - 2 {
		case 0: // ct
			return <a href="#Kc" id='c:2290'>Kc</a>(Func[f].(f2i)(xp, yp))
		case 1: // it
			return <a href="#Ki" id='c:2291'>Ki</a>(Func[f].(f2i)(xp, yp))
		case 2: // st
			<a href="#trap" id='c:2292'>trap</a>() //type
			return 0
		default: // ft zt
			r = <a href="#mk" id='c:2293'>mk</a>(16+t, 1) //<a href="#Kf" id='c:2294'>Kf</a>(0.0)
			<a href="#dxy" id='c:2295'>dxy</a>(x, y)
			Func[f-4+<a href="#int32" id='c:2296'>int32</a>(t)].(fi3)(xp, yp, <a href="#int32" id='c:2297'>int32</a>(r))
			return <a href="#Fst" id='c:2298'>Fst</a>(r)
		}
	}

	ix := <a href="#sz" id='c:2299'>sz</a>(t + 16)
	iy := ix
	if av == 1 { //av
		x = <a href="#Enl" id='c:2300'>Enl</a>(x)
		xp = <a href="#int32" id='c:2301'>int32</a>(x)
		ix = 0
		n = <a href="#nn" id='c:2302'>nn</a>(y)
		r = <a href="#use1" id='c:2303'>use1</a>(y)
	} else if av == 2 { //va
		n = <a href="#nn" id='c:2304'>nn</a>(x)
		y = <a href="#Enl" id='c:2305'>Enl</a>(y)
		yp = <a href="#int32" id='c:2306'>int32</a>(y)
		iy = 0
		r = <a href="#use1" id='c:2307'>use1</a>(x)
	} else {
		n = <a href="#nn" id='c:2308'>nn</a>(x)
		if <a href="#I32" id='c:2309'>I32</a>(<a href="#int32" id='c:2310'>int32</a>(y)-4) == 1 {
			r = <a href="#rx" id='c:2311'>rx</a>(y)
		} else {
			r = <a href="#use1" id='c:2312'>use1</a>(x)
		}
	}
	if n == 0 {
		<a href="#dxy" id='c:2313'>dxy</a>(x, y)
		return r
	}

	rp := <a href="#int32" id='c:2314'>int32</a>(r)
	e := <a href="#ep" id='c:2315'>ep</a>(r)
	dz := <a href="#int32" id='c:2316'>int32</a>(8) &lt;&lt; <a href="#I32B" id='c:2317'>I32B</a>(t &gt; ft)
	switch t - 2 {
	case 0: // ct
		for rp &lt; e {
			<a href="#SetI8" id='c:2318'>SetI8</a>(rp, Func[f].(f2i)(<a href="#I8" id='c:2319'>I8</a>(xp), <a href="#I8" id='c:2320'>I8</a>(yp)))
			xp += ix
			yp += iy
			rp++
			continue
		}
	case 1: // it
		for rp &lt; e {
			<a href="#SetI32" id='c:2321'>SetI32</a>(rp, Func[f].(f2i)(<a href="#I32" id='c:2322'>I32</a>(xp), <a href="#I32" id='c:2323'>I32</a>(yp)))
			xp += ix
			yp += iy
			rp += 4
			continue
		}
	case 2: // st
		<a href="#trap" id='c:2324'>trap</a>() //type
	default: // ft zt
		for rp &lt; e {
			Func[f-4+<a href="#int32" id='c:2325'>int32</a>(t)].(fi3)(xp, yp, rp)
			xp += ix
			yp += iy
			rp += dz
			continue
		}
	}
	<a href="#dxy" id='c:2326'>dxy</a>(x, y)
	return r
}</span><span id="nc">
func <span class='q'>nc</span>(ff, q int32, x, y K) K { //compare<span id='c:nc' class='n'>
</span>
	var r K
	var n int32
	t := <a href="#dtypes" id='c:2327'>dtypes</a>(x, y)
	if t &gt; Lt {
		r = <a href="#dkeys" id='c:2328'>dkeys</a>(x, y)
		return <a href="#key" id='c:2329'>key</a>(r, <a href="#nc" id='c:2330'>nc</a>(ff, q, <a href="#dvals" id='c:2331'>dvals</a>(x), <a href="#dvals" id='c:2332'>dvals</a>(y)), t)
	}
	if t == Lt {
		return <a href="#Ech" id='c:2333'>Ech</a>(<a href="#K" id='c:2334'>K</a>(ff), <a href="#l2" id='c:2335'>l2</a>(x, y))
	}
	t = <a href="#maxtype" id='c:2336'>maxtype</a>(x, y)
	x = <a href="#uptype" id='c:2337'>uptype</a>(x, t)
	y = <a href="#uptype" id='c:2338'>uptype</a>(y, t)
	av := <a href="#conform" id='c:2339'>conform</a>(x, y)
	xp, yp := <a href="#int32" id='c:2340'>int32</a>(x), <a href="#int32" id='c:2341'>int32</a>(y)
	if av == 0 { // atom-atom
		<a href="#dxy" id='c:2342'>dxy</a>(x, y)
		// <a href="#11" id='c:2343'>11</a>(derived), <a href="#12" id='c:2344'>12</a>(proj), <a href="#13" id='c:2345'>13</a>(lambda), <a href="#14" id='c:2346'>14</a>(native)?
		return <a href="#Ki" id='c:2347'>Ki</a>(<a href="#I32B" id='c:2348'>I32B</a>(q == Func[245+t].(f2i)(xp, yp)))
	}
	ix := <a href="#sz" id='c:2349'>sz</a>(t + 16)
	iy := ix
	if av == 1 { //av
		x = <a href="#Enl" id='c:2350'>Enl</a>(x)
		xp = <a href="#int32" id='c:2351'>int32</a>(x)
		ix = 0
		n = <a href="#nn" id='c:2352'>nn</a>(y)
	} else if av == 2 { //va
		n = <a href="#nn" id='c:2353'>nn</a>(x)
		y = <a href="#Enl" id='c:2354'>Enl</a>(y)
		yp = <a href="#int32" id='c:2355'>int32</a>(y)
		iy = 0
	} else {
		n = <a href="#nn" id='c:2356'>nn</a>(x)
	}
	r = <a href="#mk" id='c:2357'>mk</a>(It, n)
	if n == 0 {
		<a href="#dxy" id='c:2358'>dxy</a>(x, y)
		return r
	}
	rp := <a href="#int32" id='c:2359'>int32</a>(r)
	e := <a href="#ep" id='c:2360'>ep</a>(r)
	for rp &lt; e {
		<a href="#SetI32" id='c:2361'>SetI32</a>(rp, <a href="#I32B" id='c:2362'>I32B</a>(q == Func[250+t].(f2i)(xp, yp)))
		xp += ix
		yp += iy
		rp += 4
		continue
	}
	<a href="#dxy" id='c:2363'>dxy</a>(x, y)
	return r
}</span><span id="conform">
func <span class='q'>conform</span>(x, y K) int32 { // 0:atom-atom 1:atom-vector, 2:vector-atom, 3:vector-vector<span id='c:conform' class='n'>
</span>
	r := 2*<a href="#I32B" id='c:2364'>I32B</a>(<a href="#tp" id='c:2365'>tp</a>(x) &gt; 16) + <a href="#I32B" id='c:2366'>I32B</a>(<a href="#tp" id='c:2367'>tp</a>(y) &gt; 16)
	if r == 3 {
		if <a href="#nn" id='c:2368'>nn</a>(x) != <a href="#nn" id='c:2369'>nn</a>(y) {
			<a href="#trap" id='c:2370'>trap</a>() //length
		}
	}
	return r
}</span><span id="dtypes">
func <span class='q'>dtypes</span>(x, y K) T {<span id='c:dtypes' class='n'>
</span>
	xt, yt := <a href="#tp" id='c:2371'>tp</a>(x), <a href="#tp" id='c:2372'>tp</a>(y)
	return <a href="#T" id='c:2373'>T</a>(<a href="#maxi" id='c:2374'>maxi</a>(<a href="#int32" id='c:2375'>int32</a>(xt), <a href="#int32" id='c:2376'>int32</a>(yt)))
}</span><span id="dkeys">
func <span class='q'>dkeys</span>(x, y K) K {<span id='c:dkeys' class='n'>
</span>
	if <a href="#tp" id='c:2377'>tp</a>(x) &gt; Lt {
		return <a href="#x0" id='c:2378'>x0</a>(x)
	}
	return <a href="#x0" id='c:2379'>x0</a>(y)
}</span><span id="dvals">
func <span class='q'>dvals</span>(x K) K {<span id='c:dvals' class='n'>
</span>
	if <a href="#tp" id='c:2380'>tp</a>(x) &gt; Lt {
		return <a href="#r1" id='c:2381'>r1</a>(x)
	}
	return x
}</span><span id="maxtype">
func <span class='q'>maxtype</span>(x, y K) T {<span id='c:maxtype' class='n'>
</span>
	xt, yt := <a href="#tp" id='c:2382'>tp</a>(x)&amp;15, <a href="#tp" id='c:2383'>tp</a>(y)&amp;15
	t := <a href="#T" id='c:2384'>T</a>(<a href="#maxi" id='c:2385'>maxi</a>(<a href="#int32" id='c:2386'>int32</a>(xt), <a href="#int32" id='c:2387'>int32</a>(yt)))
	if t == 0 {
		t = it
	}
	return t
}</span><span id="uptype">
func <span class='q'>uptype</span>(x K, dst T) K {<span id='c:uptype' class='n'>
</span>
	xt := <a href="#tp" id='c:2388'>tp</a>(x)
	xp := <a href="#int32" id='c:2389'>int32</a>(x)
	if xt&amp;15 == dst {
		return x
	}
	if xt &lt; 16 {
		if dst &lt; st {
			return <a href="#ti" id='c:2390'>ti</a>(dst, xp)
		} else if dst == ft {
			return <a href="#Kf" id='c:2391'>Kf</a>(<a href="#float64" id='c:2392'>float64</a>(xp))
		} else if dst == zt {
			f := <a href="#float64" id='c:2393'>float64</a>(xp)
			if xt == ft {
				f = <a href="#F64" id='c:2394'>F64</a>(xp)
				<a href="#dx" id='c:2395'>dx</a>(x)
			}
			return <a href="#Kz" id='c:2396'>Kz</a>(f, 0)
		} else {
			<a href="#trap" id='c:2397'>trap</a>() //type
			return 0
		}
	}
	if xt &lt; It &amp;&amp; dst == ft {
		x, xt = <a href="#uptype" id='c:2398'>uptype</a>(x, it), It
	}
	if xt &lt; Ft &amp;&amp; dst == zt {
		x, xt = <a href="#uptype" id='c:2399'>uptype</a>(x, ft), Ft
	}
	xn := <a href="#nn" id='c:2400'>nn</a>(x)
	xp = <a href="#int32" id='c:2401'>int32</a>(x)
	r := <a href="#mk" id='c:2402'>mk</a>(dst+16, xn)
	rp := <a href="#int32" id='c:2403'>int32</a>(r)
	e := <a href="#ep" id='c:2404'>ep</a>(r)
	if dst == it {
		for rp &lt; e {
			<a href="#SetI32" id='c:2405'>SetI32</a>(rp, <a href="#I8" id='c:2406'>I8</a>(xp))
			xp++
			rp += 4
		}
	} else if dst == ft {
		for rp &lt; e {
			<a href="#SetF64" id='c:2407'>SetF64</a>(rp, <a href="#float64" id='c:2408'>float64</a>(<a href="#I32" id='c:2409'>I32</a>(xp)))
			xp += 4
			rp += 8
		}
	} else if dst == zt {
		for rp &lt; e {
			<a href="#SetF64" id='c:2410'>SetF64</a>(rp, <a href="#F64" id='c:2411'>F64</a>(xp))
			<a href="#SetF64" id='c:2412'>SetF64</a>(rp+8, 0.0)
			xp += 8
			rp += 16
		}
	} else {
		<a href="#trap" id='c:2413'>trap</a>() //type
	}
	<a href="#dx" id='c:2414'>dx</a>(x)
	return r
}</span><span id="use1">
func <span class='q'>use1</span>(x K) K {<span id='c:use1' class='n'>
</span>
	if <a href="#I32" id='c:2415'>I32</a>(<a href="#int32" id='c:2416'>int32</a>(x)-4) == 1 {
		return <a href="#rx" id='c:2417'>rx</a>(x)
	}
	return <a href="#mk" id='c:2418'>mk</a>(<a href="#tp" id='c:2419'>tp</a>(x), <a href="#nn" id='c:2420'>nn</a>(x))
}</span><span id="use">
func <span class='q'>use</span>(x K) K {<span id='c:use' class='n'>
</span>
	xt := <a href="#tp" id='c:2421'>tp</a>(x)
	if xt &lt; 16 || xt &gt; Lt {
		<a href="#trap" id='c:2422'>trap</a>() //type
	}
	if <a href="#I32" id='c:2423'>I32</a>(<a href="#int32" id='c:2424'>int32</a>(x)-4) == 1 {
		return x
	}
	nx := <a href="#nn" id='c:2425'>nn</a>(x)
	r := <a href="#mk" id='c:2426'>mk</a>(xt, nx)
	<a href="#Memorycopy" id='c:2427'>Memorycopy</a>(<a href="#int32" id='c:2428'>int32</a>(r), <a href="#int32" id='c:2429'>int32</a>(x), <a href="#sz" id='c:2430'>sz</a>(xt)*nx)
	if xt == Lt {
		<a href="#rl" id='c:2431'>rl</a>(r)
	}
	<a href="#dx" id='c:2432'>dx</a>(x)
	return r
}</span><span id="Srt">
func <span class='q'>Srt</span>(x K) K { // ^x<span id='c:Srt' class='n'>
</span>
	var r K
	xt := <a href="#tp" id='c:2433'>tp</a>(x)
	if xt &lt; 16 {
		<a href="#trap" id='c:2434'>trap</a>() //type
	}
	if xt == Dt {
		r = <a href="#x0" id='c:2435'>x0</a>(x)
		x = <a href="#r1" id='c:2436'>r1</a>(x)
		i := <a href="#rx" id='c:2437'>rx</a>(<a href="#Asc" id='c:2438'>Asc</a>(<a href="#rx" id='c:2439'>rx</a>(x)))
		return <a href="#Key" id='c:2440'>Key</a>(<a href="#atv" id='c:2441'>atv</a>(r, i), <a href="#atv" id='c:2442'>atv</a>(x, i))
	}
	if <a href="#nn" id='c:2443'>nn</a>(x) &lt; 2 {
		return x
	}
	return <a href="#atv" id='c:2444'>atv</a>(x, <a href="#Asc" id='c:2445'>Asc</a>(<a href="#rx" id='c:2446'>rx</a>(x)))
}</span><span id="Asc">
func <span class='q'>Asc</span>(x K) K { // &lt;x  &lt;`file<span id='c:Asc' class='n'>
</span>
	if <a href="#tp" id='c:2447'>tp</a>(x) == st {
		return <a href="#readfile" id='c:2448'>readfile</a>(<a href="#cs" id='c:2449'>cs</a>(x))
	}
	return <a href="#grade" id='c:2450'>grade</a>(x, 1)
}</span><span id="Dsc">
func <span class='q'>Dsc</span>(x K) K { return <a href="#grade" id='c:2451'>grade</a>(x, -1) } //254 // &gt;x<span id='c:Dsc' class='n'>
</span></span><span id="grade">
func <span class='q'>grade</span>(x K, f int32) K { // &lt;x &gt;x<span id='c:grade' class='n'>
</span>
	var r K
	xt := <a href="#tp" id='c:2452'>tp</a>(x)
	if xt &lt; 16 {
		<a href="#trap" id='c:2453'>trap</a>() //type
	}
	if xt == Dt {
		r = <a href="#x0" id='c:2454'>x0</a>(x)
		return <a href="#Atx" id='c:2455'>Atx</a>(r, <a href="#grade" id='c:2456'>grade</a>(<a href="#r1" id='c:2457'>r1</a>(x), f))
	}
	n := <a href="#nn" id='c:2458'>nn</a>(x)
	if xt == Tt {
		return <a href="#cal" id='c:2459'>cal</a>(<a href="#Val" id='c:2460'>Val</a>(<a href="#Ks" id='c:2461'>Ks</a>(104)), <a href="#l2" id='c:2462'>l2</a>(x, <a href="#Ki" id='c:2463'>Ki</a>(<a href="#I32B" id='c:2464'>I32B</a>(f == -1)))) //gdt ngn:{(!#x){x@&lt;y x}/|.+x}
	}
	if n &lt; 2 {
		<a href="#dx" id='c:2465'>dx</a>(x)
		return <a href="#seq" id='c:2466'>seq</a>(n)
	}
	r = <a href="#seq" id='c:2467'>seq</a>(n)
	rp := <a href="#int32" id='c:2468'>int32</a>(r)
	xp := <a href="#int32" id='c:2469'>int32</a>(x)
	w := <a href="#mk" id='c:2470'>mk</a>(It, n)
	wp := <a href="#int32" id='c:2471'>int32</a>(w)
	<a href="#Memorycopy" id='c:2472'>Memorycopy</a>(wp, rp, 4*n)
	<a href="#msrt" id='c:2473'>msrt</a>(wp, rp, 0, n, xp, <a href="#int32" id='c:2474'>int32</a>(xt), f)
	<a href="#dxy" id='c:2475'>dxy</a>(w, x)
	return r
}</span>
<span id="msrt">
func <span class='q'>msrt</span>(x, r, a, b, p, t, f int32) {<span id='c:msrt' class='n'>
</span>
	if b-a &lt; 2 {
		return
	}
	c := (a + b) &gt;&gt; 1
	<a href="#msrt" id='c:2476'>msrt</a>(r, x, a, c, p, t, f)
	<a href="#msrt" id='c:2477'>msrt</a>(r, x, c, b, p, t, f)
	<a href="#mrge" id='c:2478'>mrge</a>(x, r, 4*a, 4*b, 4*c, p, t, f)
}</span><span id="mrge">
func <span class='q'>mrge</span>(x, r, a, b, c, p, t, f int32) {<span id='c:mrge' class='n'>
</span>
	var q int32
	i, j := a, c
	s := <a href="#sz" id='c:2479'>sz</a>(<a href="#T" id='c:2480'>T</a>(t))
	for k := a; k &lt; b; k += 4 {
		if i &lt; c &amp;&amp; j &lt; b {
			q = <a href="#I32B" id='c:2481'>I32B</a>(f == Func[234+t].(f2i)(p+s*<a href="#I32" id='c:2482'>I32</a>(x+i), p+s*<a href="#I32" id='c:2483'>I32</a>(x+j)))
		} else {
			q = 0
		}
		if i &gt;= c || q != 0 {
			<a href="#SetI32" id='c:2484'>SetI32</a>(r+k, <a href="#I32" id='c:2485'>I32</a>(x+j))
			j += 4
		} else {
			<a href="#SetI32" id='c:2486'>SetI32</a>(r+k, <a href="#I32" id='c:2487'>I32</a>(x+i))
			i += 4
		}
	}
}</span><span id="cmL">
func <span class='q'>cmL</span>(xp, yp int32) int32 { // compare lists lexically<span id='c:cmL' class='n'>
</span>
	var r int32
	x, y := <a href="#K" id='c:2488'>K</a>(<a href="#I64" id='c:2489'>I64</a>(xp)), <a href="#K" id='c:2490'>K</a>(<a href="#I64" id='c:2491'>I64</a>(yp))
	xt, yt := <a href="#tp" id='c:2492'>tp</a>(x), <a href="#tp" id='c:2493'>tp</a>(y)
	if xt != yt {
		return <a href="#I32B" id='c:2494'>I32B</a>(xt &gt; yt) - <a href="#I32B" id='c:2495'>I32B</a>(xt &lt; yt)
	}
	if xt &lt; 16 { // <a href="#11" id='c:2496'>11</a>(derived), <a href="#12" id='c:2497'>12</a>(proj), <a href="#13" id='c:2498'>13</a>(lambda), <a href="#14" id='c:2499'>14</a>(native)?
		xp, yp := <a href="#int32" id='c:2500'>int32</a>(x), <a href="#int32" id='c:2501'>int32</a>(y)
		return Func[245+xt].(f2i)(xp, yp)
	}
	if xt &gt; Lt {
		xp, yp := <a href="#int32" id='c:2502'>int32</a>(x), <a href="#int32" id='c:2503'>int32</a>(y)
		r = <a href="#cmL" id='c:2504'>cmL</a>(xp, yp)
		if r == 0 {
			r = <a href="#cmL" id='c:2505'>cmL</a>(xp+8, yp+8)
		}
		return r
	}
	xn, yn := <a href="#nn" id='c:2506'>nn</a>(x), <a href="#nn" id='c:2507'>nn</a>(y)
	xp = <a href="#int32" id='c:2508'>int32</a>(x)
	yp = <a href="#int32" id='c:2509'>int32</a>(y) - xp
	n := <a href="#mini" id='c:2510'>mini</a>(xn, yn)
	s := <a href="#sz" id='c:2511'>sz</a>(xt)
	e := xp + n*s
	for xp &lt; e {
		r = Func[234+xt].(f2i)(xp, xp+yp)
		if r != 0 {
			return r
		}
		xp += s
	}
	return <a href="#I32B" id='c:2512'>I32B</a>(xn &gt; yn) - <a href="#I32B" id='c:2513'>I32B</a>(xn &lt; yn)
}</span><span id="Kst">
func <span class='q'>Kst</span>(x K) K { return <a href="#Atx" id='c:2514'>Atx</a>(<a href="#Ks" id='c:2515'>Ks</a>(32), x) } // `k@<span id='c:Kst' class='n'>
</span></span><span id="Lst">
func <span class='q'>Lst</span>(x K) K { return <a href="#Atx" id='c:2516'>Atx</a>(<a href="#Ks" id='c:2517'>Ks</a>(40), x) } // `l@<span id='c:Lst' class='n'>
</span></span><span id="Str">
func <span class='q'>Str</span>(x K) K {<span id='c:Str' class='n'>
</span>
	var r K
	xt := <a href="#tp" id='c:2518'>tp</a>(x)
	if xt &gt; 16 {
		return <a href="#Ech" id='c:2519'>Ech</a>(17, <a href="#l1" id='c:2520'>l1</a>(x))
	}
	xp := <a href="#int32" id='c:2521'>int32</a>(x)
	if xt &gt; 8 {
		switch xt - cf {
		case 0: // cf
			<a href="#rx" id='c:2522'>rx</a>(x)
			r = <a href="#Rdc" id='c:2523'>Rdc</a>(13, <a href="#l1" id='c:2524'>l1</a>(<a href="#Rev" id='c:2525'>Rev</a>(<a href="#Str" id='c:2526'>Str</a>(<a href="#ti" id='c:2527'>ti</a>(Lt, xp)))))
		case 1: // df
			r = <a href="#ucat" id='c:2528'>ucat</a>(<a href="#Str" id='c:2529'>Str</a>(<a href="#x0" id='c:2530'>x0</a>(x)), <a href="#Str" id='c:2531'>Str</a>(21+<a href="#x1" id='c:2532'>x1</a>(x)))
		case 2: //pf
			f := <a href="#x0" id='c:2533'>x0</a>(x)
			l := <a href="#x1" id='c:2534'>x1</a>(x)
			i := <a href="#x2" id='c:2535'>x2</a>(x)
			ft := <a href="#tp" id='c:2536'>tp</a>(f)
			f = <a href="#Str" id='c:2537'>Str</a>(f)
			<a href="#dx" id='c:2538'>dx</a>(i)
			if <a href="#nn" id='c:2539'>nn</a>(i) == 1 &amp;&amp; <a href="#I32" id='c:2540'>I32</a>(<a href="#int32" id='c:2541'>int32</a>(i)) == 1 &amp;&amp; (ft == 0 || ft == df) {
				r = <a href="#ucat" id='c:2542'>ucat</a>(<a href="#Kst" id='c:2543'>Kst</a>(<a href="#Fst" id='c:2544'>Fst</a>(l)), f)
			} else {
				r = <a href="#ucat" id='c:2545'>ucat</a>(f, <a href="#emb" id='c:2546'>emb</a>(&#39;[&#39;, &#39;]&#39;, <a href="#ndrop" id='c:2547'>ndrop</a>(-1, <a href="#ndrop" id='c:2548'>ndrop</a>(1, <a href="#Kst" id='c:2549'>Kst</a>(l)))))
			}
		default: //lf, native
			r = <a href="#x1" id='c:2550'>x1</a>(x)
		}
		<a href="#dx" id='c:2551'>dx</a>(x)
		return r
	} else {
		switch xt {
		case 0:
			if xp &gt; 448 {
				return <a href="#Str" id='c:2552'>Str</a>(<a href="#K" id='c:2553'>K</a>(xp) - 448)
			}
			ip := xp
			switch xp &gt;&gt; 6 {
			case 0: //  0..63  monadic
				if xp == 0 {
					return <a href="#mk" id='c:2554'>mk</a>(Ct, 0)
				}
			case 1: // 64..127 dyadic
				ip -= 64
			case 2: // 128     dyadic indirect
				ip -= 128
			case 3: // 192     tetradic
				ip -= 192
				//default:
				//	return <a href="#ucat" id='c:2555'>ucat</a>(<a href="#Ku" id='c:2556'>Ku</a>(&#39;`&#39;), <a href="#si" id='c:2557'>si</a>(xp))
			}
			if ip &gt; 25 || ip == 0 {
				return <a href="#ucat" id='c:2558'>ucat</a>(<a href="#Ku" id='c:2559'>Ku</a>(&#39;`&#39;), <a href="#si" id='c:2560'>si</a>(xp))
			}
			r = <a href="#Ku" id='c:2561'>Ku</a>(<a href="#uint64" id='c:2562'>uint64</a>(<a href="#I8" id='c:2563'>I8</a>(226 + ip)))
		case 1: //not reached
			r = 0
		case ct:
			r = <a href="#Ku" id='c:2564'>Ku</a>(<a href="#uint64" id='c:2565'>uint64</a>(xp))
		case it:
			r = <a href="#si" id='c:2566'>si</a>(xp)
		case st:
			r = <a href="#cs" id='c:2567'>cs</a>(x)
		case ft:
			r = <a href="#sf" id='c:2568'>sf</a>(<a href="#F64" id='c:2569'>F64</a>(xp))
		default:
			r = <a href="#sfz" id='c:2570'>sfz</a>(<a href="#F64" id='c:2571'>F64</a>(xp), <a href="#F64" id='c:2572'>F64</a>(xp+8))
		}
	}
	<a href="#dx" id='c:2573'>dx</a>(x)
	return r
}</span><span id="emb">
func <span class='q'>emb</span>(a, b int32, x K) K { return <a href="#cat1" id='c:2574'>cat1</a>(<a href="#Cat" id='c:2575'>Cat</a>(<a href="#Kc" id='c:2576'>Kc</a>(a), x), <a href="#Kc" id='c:2577'>Kc</a>(b)) }<span id='c:emb' class='n'>
</span></span><span id="si">
func <span class='q'>si</span>(x int32) K {<span id='c:si' class='n'>
</span>
	if x == 0 {
		return <a href="#Ku" id='c:2578'>Ku</a>(<a href="#uint64" id='c:2579'>uint64</a>(&#39;0&#39;))
	} else if x == nai {
		return <a href="#Ku" id='c:2580'>Ku</a>(20016) // 0N
	} else if x &lt; 0 {
		return <a href="#ucat" id='c:2581'>ucat</a>(<a href="#Ku" id='c:2582'>Ku</a>(<a href="#uint64" id='c:2583'>uint64</a>(&#39;-&#39;)), <a href="#si" id='c:2584'>si</a>(-x))
	}
	r := <a href="#mk" id='c:2585'>mk</a>(Ct, 0)
	for x != 0 {
		r = <a href="#cat1" id='c:2586'>cat1</a>(r, <a href="#Kc" id='c:2587'>Kc</a>(&#39;0&#39;+x%10))
		x /= 10
	}
	return <a href="#Rev" id='c:2588'>Rev</a>(r)
}</span><span id="sf">
func <span class='q'>sf</span>(x float64) K {<span id='c:sf' class='n'>
</span>
	c := <a href="#int32" id='c:2589'>int32</a>(0)
	if x != x {
		return <a href="#Ku" id='c:2590'>Ku</a>(28208) // 0n
	}
	u := <a href="#uint64" id='c:2591'>uint64</a>(<a href="#I64reinterpret_f64" id='c:2592'>I64reinterpret_f64</a>(x))
	if u == <a href="#uint64" id='c:2593'>uint64</a>(0x7FF0000000000000) {
		return <a href="#Ku" id='c:2594'>Ku</a>(30512) // 0w
	} else if u == <a href="#uint64" id='c:2595'>uint64</a>(0xFFF0000000000000) {
		return <a href="#Ku" id='c:2596'>Ku</a>(7811117) // -0w
	}
	if x &lt; 0 {
		return <a href="#ucat" id='c:2597'>ucat</a>(<a href="#Ku" id='c:2598'>Ku</a>(<a href="#uint64" id='c:2599'>uint64</a>(&#39;-&#39;)), <a href="#sf" id='c:2600'>sf</a>(-x))
	}
	if x &gt; 0 &amp;&amp; (x &gt;= 1e6 || x &lt;= 1e-6) {
		return <a href="#se" id='c:2601'>se</a>(x)
	}
	r := <a href="#mk" id='c:2602'>mk</a>(Ct, 0)
	i := <a href="#int64" id='c:2603'>int64</a>(x)
	if i == 0 {
		r = <a href="#cat1" id='c:2604'>cat1</a>(r, <a href="#Kc" id='c:2605'>Kc</a>(&#39;0&#39;))
	}
	for i != 0 {
		r = <a href="#cat1" id='c:2606'>cat1</a>(r, <a href="#Kc" id='c:2607'>Kc</a>(<a href="#int32" id='c:2608'>int32</a>(&#39;0&#39;+i%10)))
		i /= 10
	}

	r = <a href="#Rev" id='c:2609'>Rev</a>(r)
	r = <a href="#cat1" id='c:2610'>cat1</a>(r, <a href="#Kc" id='c:2611'>Kc</a>(&#39;.&#39;))
	x -= <a href="#F64floor" id='c:2612'>F64floor</a>(x)
	for i := <a href="#int32" id='c:2613'>int32</a>(0); i &lt; 6; i++ {
		x *= 10
		r = <a href="#cat1" id='c:2614'>cat1</a>(r, <a href="#Kc" id='c:2615'>Kc</a>(&#39;0&#39;+(<a href="#int32" id='c:2616'>int32</a>(x)%10)))
		continue
	}
	n := <a href="#nn" id='c:2617'>nn</a>(r)
	rp := <a href="#int32" id='c:2618'>int32</a>(r)
	for n &gt; 0 {
		n--
		if <a href="#I8" id='c:2619'>I8</a>(rp) == &#39;0&#39; {
			c++
		} else {
			c = 0
		}
		rp++
	}
	return <a href="#ndrop" id='c:2620'>ndrop</a>(-c, r)
}</span><span id="se">
func <span class='q'>se</span>(x float64) K {<span id='c:se' class='n'>
</span>
	f := x
	e := <a href="#int64" id='c:2621'>int64</a>(0)
	if <a href="#frexp1" id='c:2622'>frexp1</a>(x) != 0 {
		f = <a href="#frexp2" id='c:2623'>frexp2</a>(x)
		e = <a href="#frexp3" id='c:2624'>frexp3</a>(x)
	}
	x = 0.3010299956639812 * <a href="#float64" id='c:2625'>float64</a>(e) // <a href="#log10" id='c:2626'>log10</a>(2)*
	ei := <a href="#int32" id='c:2627'>int32</a>(<a href="#F64floor" id='c:2628'>F64floor</a>(x))
	x = x - <a href="#float64" id='c:2629'>float64</a>(ei)
	return <a href="#ucat" id='c:2630'>ucat</a>(<a href="#cat1" id='c:2631'>cat1</a>(<a href="#sf" id='c:2632'>sf</a>(f*<a href="#pow" id='c:2633'>pow</a>(10.0, x)), <a href="#Kc" id='c:2634'>Kc</a>(&#39;e&#39;)), <a href="#si" id='c:2635'>si</a>(ei))
}</span><span id="sfz">
func <span class='q'>sfz</span>(re, im float64) K {<span id='c:sfz' class='n'>
</span>
	if (re != re) || (im != im) {
		return <a href="#Ku" id='c:2636'>Ku</a>(6385200) // 0na
	}
	z := <a href="#hypot" id='c:2637'>hypot</a>(re, im)
	a := <a href="#ang2" id='c:2638'>ang2</a>(im, re)
	r := <a href="#cat1" id='c:2639'>cat1</a>(<a href="#trdot" id='c:2640'>trdot</a>(<a href="#sf" id='c:2641'>sf</a>(z)), <a href="#Kc" id='c:2642'>Kc</a>(&#39;a&#39;))
	if a != 0.0 {
		r = <a href="#ucat" id='c:2643'>ucat</a>(r, <a href="#trdot" id='c:2644'>trdot</a>(<a href="#sf" id='c:2645'>sf</a>(a)))
	}
	return r
}</span><span id="trdot">
func <span class='q'>trdot</span>(x K) K {<span id='c:trdot' class='n'>
</span>
	n := <a href="#nn" id='c:2646'>nn</a>(x)
	if <a href="#I8" id='c:2647'>I8</a>(<a href="#int32" id='c:2648'>int32</a>(x)+n-1) == &#39;.&#39; {
		return <a href="#ndrop" id='c:2649'>ndrop</a>(-1, x)
	}
	return x
}</span>
<span id="Cst">
func <span class='q'>Cst</span>(x, y K) K { // x$y<span id='c:Cst' class='n'>
</span>
	yt := <a href="#tp" id='c:2650'>tp</a>(y)
	if yt &gt; Zt {
		return <a href="#Ecr" id='c:2651'>Ecr</a>(17, <a href="#l2" id='c:2652'>l2</a>(x, y))
	}
	if yt == ct {
		y, yt = <a href="#Enl" id='c:2653'>Enl</a>(y), Ct
	}
	if <a href="#tp" id='c:2654'>tp</a>(x) != st || yt != Ct {
		<a href="#trap" id='c:2655'>trap</a>() //type
	}
	if <a href="#int32" id='c:2656'>int32</a>(x) == 0 { // `$&#34;sym&#34;
		return <a href="#sc" id='c:2657'>sc</a>(y)
	}
	t := <a href="#ts" id='c:2658'>ts</a>(x)
	y = <a href="#val" id='c:2659'>val</a>(y)
	yt = <a href="#tp" id='c:2660'>tp</a>(y)
	if t == yt {
		return y
	}
	if y == 0 &amp;&amp; t &gt; 16 {
		return <a href="#mk" id='c:2661'>mk</a>(t, 0)
	}
	if t-yt &gt; 15 {
		y = <a href="#Enl" id='c:2662'>Enl</a>(y)
	}
	if t&amp;15 &gt; yt&amp;15 {
		y = <a href="#uptype" id='c:2663'>uptype</a>(y, t&amp;15)
	}
	return y
}</span><span id="ts">
func <span class='q'>ts</span>(x K) T {<span id='c:ts' class='n'>
</span>
	c := <a href="#inC" id='c:2664'>inC</a>(<a href="#int32" id='c:2665'>int32</a>(<a href="#Rdc" id='c:2666'>Rdc</a>(2, <a href="#l1" id='c:2667'>l1</a>(<a href="#cs" id='c:2668'>cs</a>(x)))), 254, 279)
	if c &gt; 0 {
		return <a href="#T" id='c:2669'>T</a>(c - 253)
	}
	return 0
}</span><span id="rtp">
func <span class='q'>rtp</span>(t T, x K) K { // `c@ `i@ `s@ `f@ `z@ (reinterpret data)<span id='c:rtp' class='n'>
</span>
	xt := <a href="#tp" id='c:2670'>tp</a>(x)
	if <a href="#uint32" id='c:2671'>uint32</a>(xt-18) &gt; 5 {
		<a href="#trap" id='c:2672'>trap</a>()
	}
	n := <a href="#nn" id='c:2673'>nn</a>(x) * <a href="#sz" id='c:2674'>sz</a>(xt)
	m := n / <a href="#sz" id='c:2675'>sz</a>(t)
	if n != m*<a href="#sz" id='c:2676'>sz</a>(t) {
		<a href="#trap" id='c:2677'>trap</a>() //length
	}
	x = <a href="#use" id='c:2678'>use</a>(x)
	<a href="#SetI32" id='c:2679'>SetI32</a>(<a href="#int32" id='c:2680'>int32</a>(x)-12, m)
	return <a href="#ti" id='c:2681'>ti</a>(t, <a href="#int32" id='c:2682'>int32</a>(x))
}</span><span id="repl">
func <span class='q'>repl</span>(x K) {<span id='c:repl' class='n'>
</span>
	c := <a href="#I8" id='c:2683'>I8</a>(<a href="#int32" id='c:2684'>int32</a>(x))
	x = <a href="#val" id='c:2685'>val</a>(x)
	if x != 0 {
		if c == 32 {
			<a href="#dx" id='c:2686'>dx</a>(<a href="#Out" id='c:2687'>Out</a>(x))
		} else {
			<a href="#write" id='c:2688'>write</a>(<a href="#cat1" id='c:2689'>cat1</a>(<a href="#join" id='c:2690'>join</a>(<a href="#Kc" id='c:2691'>Kc</a>(10), <a href="#Lst" id='c:2692'>Lst</a>(x)), <a href="#Kc" id='c:2693'>Kc</a>(10)))
		}
	}
}</span>
<span id="Out">
func <span class='q'>Out</span>(x K) K {<span id='c:Out' class='n'>
</span>
	<a href="#write" id='c:2694'>write</a>(<a href="#cat1" id='c:2695'>cat1</a>(<a href="#Kst" id='c:2696'>Kst</a>(<a href="#rx" id='c:2697'>rx</a>(x)), <a href="#Kc" id='c:2698'>Kc</a>(10)))
	return x
}</span><span id="Otu">
func <span class='q'>Otu</span>(x, y K) K {<span id='c:Otu' class='n'>
</span>
	<a href="#write" id='c:2699'>write</a>(<a href="#cat1" id='c:2700'>cat1</a>(<a href="#Kst" id='c:2701'>Kst</a>(x), <a href="#Kc" id='c:2702'>Kc</a>(&#39;:&#39;)))
	return <a href="#Out" id='c:2703'>Out</a>(y)
}</span><span id="write">
func <span class='q'>write</span>(x K) {<span id='c:write' class='n'>
</span>
	<a href="#Write" id='c:2704'>Write</a>(0, 0, <a href="#int32" id='c:2705'>int32</a>(x), <a href="#nn" id='c:2706'>nn</a>(x))
	<a href="#dx" id='c:2707'>dx</a>(x)
}</span><span id="readfile">
func <span class='q'>readfile</span>(x K) K { // x C<span id='c:readfile' class='n'>
</span>
	var r K
	if <a href="#nn" id='c:2708'>nn</a>(x) == 0 {
		<a href="#dx" id='c:2709'>dx</a>(x)
		r = <a href="#mk" id='c:2710'>mk</a>(Ct, 496)
		r = <a href="#ntake" id='c:2711'>ntake</a>(<a href="#ReadIn" id='c:2712'>ReadIn</a>(<a href="#int32" id='c:2713'>int32</a>(r), 496), r)
		return r
	}
	n := <a href="#Read" id='c:2714'>Read</a>(<a href="#int32" id='c:2715'>int32</a>(x), <a href="#nn" id='c:2716'>nn</a>(x), 0)
	if n &lt; 0 {
		<a href="#dx" id='c:2717'>dx</a>(x)
		return <a href="#mk" id='c:2718'>mk</a>(Ct, 0)
	}
	r = <a href="#mk" id='c:2719'>mk</a>(Ct, n)
	<a href="#Read" id='c:2720'>Read</a>(<a href="#int32" id='c:2721'>int32</a>(x), <a href="#nn" id='c:2722'>nn</a>(x), <a href="#int32" id='c:2723'>int32</a>(r))
	<a href="#dx" id='c:2724'>dx</a>(x)
	return r
}</span><span id="writefile">
func <span class='q'>writefile</span>(x, y K) K { // x, y C<span id='c:writefile' class='n'>
</span>
	r := <a href="#Write" id='c:2725'>Write</a>(<a href="#int32" id='c:2726'>int32</a>(x), <a href="#nn" id='c:2727'>nn</a>(x), <a href="#int32" id='c:2728'>int32</a>(y), <a href="#nn" id='c:2729'>nn</a>(y))
	if r != 0 {
		<a href="#trap" id='c:2730'>trap</a>() //io
	}
	<a href="#dx" id='c:2731'>dx</a>(x)
	return y
}</span><span id="test">
func <span class='q'>test</span>(x K) {<span id='c:test' class='n'>
</span>
	if <a href="#tp" id='c:2732'>tp</a>(x) != Ct {
		<a href="#trap" id='c:2733'>trap</a>() //type
	}
	l := <a href="#ndrop" id='c:2734'>ndrop</a>(-1, <a href="#split" id='c:2735'>split</a>(<a href="#Kc" id='c:2736'>Kc</a>(10), <a href="#rx" id='c:2737'>rx</a>(x)))
	n := <a href="#nn" id='c:2738'>nn</a>(l)
	<a href="#dx" id='c:2739'>dx</a>(l)
	for i := <a href="#int32" id='c:2740'>int32</a>(0); i &lt; n; i++ {
		<a href="#testi" id='c:2741'>testi</a>(<a href="#rx" id='c:2742'>rx</a>(x), i)
	}
	<a href="#dx" id='c:2743'>dx</a>(x)
}</span><span id="testi">
func <span class='q'>testi</span>(l K, i int32) {<span id='c:testi' class='n'>
</span>
	x := <a href="#split" id='c:2744'>split</a>(<a href="#Ku" id='c:2745'>Ku</a>(12064), <a href="#ati" id='c:2746'>ati</a>(<a href="#split" id='c:2747'>split</a>(<a href="#Kc" id='c:2748'>Kc</a>(10), l), i))
	if <a href="#nn" id='c:2749'>nn</a>(x) != 2 {
		<a href="#trap" id='c:2750'>trap</a>() //length
	}
	y := <a href="#x1" id='c:2751'>x1</a>(x)
	x = <a href="#r0" id='c:2752'>r0</a>(x)
	<a href="#dx" id='c:2753'>dx</a>(<a href="#Out" id='c:2754'>Out</a>(<a href="#ucat" id='c:2755'>ucat</a>(<a href="#ucat" id='c:2756'>ucat</a>(<a href="#rx" id='c:2757'>rx</a>(x), <a href="#Ku" id='c:2758'>Ku</a>(12064)), <a href="#rx" id='c:2759'>rx</a>(y))))
	x = <a href="#Kst" id='c:2760'>Kst</a>(<a href="#val" id='c:2761'>val</a>(x))
	if <a href="#match" id='c:2762'>match</a>(x, y) == 0 {
		x = <a href="#Out" id='c:2763'>Out</a>(x)
		<a href="#trap" id='c:2764'>trap</a>() //test fails
	}
	<a href="#dxy" id='c:2765'>dxy</a>(x, y)
}</span>
type ftok = func() K
<span id="tok">
func <span class='q'>tok</span>(x K) K {<span id='c:tok' class='n'>
</span>
	s := <a href="#cat1" id='c:2766'>cat1</a>(<a href="#src" id='c:2767'>src</a>(), <a href="#Kc" id='c:2768'>Kc</a>(10))
	pp = <a href="#nn" id='c:2769'>nn</a>(s)
	s = <a href="#Cat" id='c:2770'>Cat</a>(s, x)  // src contains all src
	pp += <a href="#int32" id='c:2771'>int32</a>(s) // pp is the parser position within src
	pe = pp + <a href="#nn" id='c:2772'>nn</a>(x)
	r := <a href="#mk" id='c:2773'>mk</a>(Lt, 0)
	for {
		<a href="#ws" id='c:2774'>ws</a>()
		if pp == pe {
			break
		}
		for i := <a href="#int32" id='c:2775'>int32</a>(193); i &lt; 200; i++ { // tchr, tnms, tvrb, tpct, tvar, tsym, trap
			y := Func[i].(ftok)()
			if y != 0 {
				y |= <a href="#K" id='c:2776'>K</a>(<a href="#int64" id='c:2777'>int64</a>(pp-<a href="#int32" id='c:2778'>int32</a>(s)) &lt;&lt; 32)
				r = <a href="#cat1" id='c:2779'>cat1</a>(r, y)
				break
			}
		}
	}
	<a href="#SetI32" id='c:2780'>SetI32</a>(16, <a href="#int32" id='c:2781'>int32</a>(s)) //<a href="#SetI64" id='c:2782'>SetI64</a>(512, <a href="#int64" id='c:2783'>int64</a>(s))
	return r
}</span><span id="src">
func <span class='q'>src</span>() K { return <a href="#ti" id='c:2784'>ti</a>(Ct, <a href="#I32" id='c:2785'>I32</a>(16)) }<span id='c:src' class='n'>
</span></span><span id="tchr">
func <span class='q'>tchr</span>() K {<span id='c:tchr' class='n'>
</span>
	if <a href="#I8" id='c:2786'>I8</a>(pp) == &#39;0&#39; &amp;&amp; pp &lt; pe { // 0x01ab (lower case only)
		if <a href="#I8" id='c:2787'>I8</a>(1+pp) == &#39;x&#39; {
			pp += 2
			return <a href="#thex" id='c:2788'>thex</a>()
		}
	}
	if <a href="#I8" id='c:2789'>I8</a>(pp) != 34 {
		return 0
	}
	pp++
	r := <a href="#mk" id='c:2790'>mk</a>(Ct, 0)
	q := <a href="#uint32" id='c:2791'>uint32</a>(0)
	for {
		if pp == pe {
			<a href="#trap" id='c:2792'>trap</a>() //parse
		}
		c := <a href="#I8" id='c:2793'>I8</a>(pp)
		pp++
		if c == 34 &amp;&amp; q == 0 {
			break
		}
		if c == &#39;\\&#39; &amp;&amp; q == 0 {
			q = 1
			continue
		}
		if q != 0 {
			c = <a href="#cq" id='c:2794'>cq</a>(c)
			q = 0
		}
		r = <a href="#cat1" id='c:2795'>cat1</a>(r, <a href="#Kc" id='c:2796'>Kc</a>(c))
	}
	if <a href="#nn" id='c:2797'>nn</a>(r) == 1 {
		return <a href="#Fst" id='c:2798'>Fst</a>(r)
	}
	return r
}</span><span id="cq">
func <span class='q'>cq</span>(c int32) int32 { // \t \n \r \&#34; \\   -&gt; 9 10 13 34 92<span id='c:cq' class='n'>
</span>
	if c == 116 {
		return 9
	}
	if c == 110 {
		return 10
	}
	if c == 114 {
		return 13
	}
	return c
}</span><span id="thex">
func <span class='q'>thex</span>() K {<span id='c:thex' class='n'>
</span>
	r := <a href="#mk" id='c:2799'>mk</a>(Ct, 0)
	for pp &lt; pe-1 {
		c := <a href="#I8" id='c:2800'>I8</a>(pp)
		if <a href="#is" id='c:2801'>is</a>(c, 128) == 0 {
			break
		}
		r = <a href="#cat1" id='c:2802'>cat1</a>(r, <a href="#Kc" id='c:2803'>Kc</a>((<a href="#hx" id='c:2804'>hx</a>(c)&lt;&lt;4)+<a href="#hx" id='c:2805'>hx</a>(<a href="#I8" id='c:2806'>I8</a>(1+pp))))
		pp += 2
	}
	if <a href="#nn" id='c:2807'>nn</a>(r) == 1 {
		return <a href="#Fst" id='c:2808'>Fst</a>(r)
	}
	return r
}</span><span id="hx">
func <span class='q'>hx</span>(c int32) int32 {<span id='c:hx' class='n'>
</span>
	if <a href="#is" id='c:2809'>is</a>(c, 4) != 0 {
		return c - &#39;0&#39;
	} else {
		return c - &#39;W&#39;
	}
}</span><span id="tnms">
func <span class='q'>tnms</span>() K {<span id='c:tnms' class='n'>
</span>
	r := <a href="#tnum" id='c:2810'>tnum</a>()
	for pp &lt; pe-1 &amp;&amp; <a href="#I8" id='c:2811'>I8</a>(pp) == &#39; &#39; {
		pp++
		x := <a href="#tnum" id='c:2812'>tnum</a>()
		if x == 0 {
			break
		}
		t := <a href="#tp" id='c:2813'>tp</a>(r)
		if t &lt; 16 {
			r = <a href="#Enl" id='c:2814'>Enl</a>(r)
		}
		t = <a href="#maxtype" id='c:2815'>maxtype</a>(r, x)
		r = <a href="#uptype" id='c:2816'>uptype</a>(r, t)
		r = <a href="#cat1" id='c:2817'>cat1</a>(r, <a href="#uptype" id='c:2818'>uptype</a>(x, t))
	}
	return r
}</span><span id="tnum">
func <span class='q'>tnum</span>() K {<span id='c:tnum' class='n'>
</span>
	c := <a href="#I8" id='c:2819'>I8</a>(pp)
	if c == &#39;-&#39; || c == &#39;.&#39; {
		if <a href="#is" id='c:2820'>is</a>(<a href="#I8" id='c:2821'>I8</a>(pp-1), 64) != 0 {
			return 0 // e.g. x-1 is (x - 1) not (x -1)
		}
	}
	if c == &#39;-&#39; &amp;&amp; pp &lt; 1+pe {
		pp++
		r := <a href="#tunm" id='c:2822'>tunm</a>()
		if r == 0 {
			pp--
			return 0
		}
		return <a href="#Neg" id='c:2823'>Neg</a>(r)
	}
	return <a href="#tunm" id='c:2824'>tunm</a>()
}</span><span id="tunm">
func <span class='q'>tunm</span>() K {<span id='c:tunm' class='n'>
</span>
	p := pp
	r := <a href="#pu" id='c:2825'>pu</a>()
	if r == 0 &amp;&amp; p == pp {
		if <a href="#I8" id='c:2826'>I8</a>(p) == &#39;.&#39; {
			if <a href="#is" id='c:2827'>is</a>(<a href="#I8" id='c:2828'>I8</a>(1+p), 4) != 0 {
				return <a href="#pflt" id='c:2829'>pflt</a>(r)
			}
		}
		return 0
	}
	if pp &lt; pe {
		c := <a href="#I8" id='c:2830'>I8</a>(pp)
		if c == &#39;.&#39; {
			return <a href="#pflt" id='c:2831'>pflt</a>(r)
		}
		if c == &#39;p&#39; {
			return <a href="#ppi" id='c:2832'>ppi</a>(<a href="#float64" id='c:2833'>float64</a>(r))
		}
		if c == &#39;a&#39; {
			return <a href="#pflz" id='c:2834'>pflz</a>(<a href="#float64" id='c:2835'>float64</a>(r))
		}
		if c == &#39;e&#39; || c == &#39;E&#39; {
			return <a href="#Kf" id='c:2836'>Kf</a>(<a href="#pexp" id='c:2837'>pexp</a>(<a href="#float64" id='c:2838'>float64</a>(r)))
		}
		if r == 0 {
			if c == &#39;N&#39; {
				pp++
				return <a href="#missing" id='c:2839'>missing</a>(it)
			}
			if c == &#39;n&#39; || c == &#39;w&#39; {
				q := <a href="#Kf" id='c:2840'>Kf</a>(0)
				<a href="#SetI64" id='c:2841'>SetI64</a>(<a href="#int32" id='c:2842'>int32</a>(q), <a href="#int64" id='c:2843'>int64</a>(0x7FF8000000000001)) // 0n
				if c == &#39;w&#39; {
					<a href="#SetF64" id='c:2844'>SetF64</a>(<a href="#int32" id='c:2845'>int32</a>(q), inf) // 0w
				}
				pp++
				if pp &lt; pe &amp;&amp; <a href="#I8" id='c:2846'>I8</a>(pp) == &#39;a&#39; {
					<a href="#dx" id='c:2847'>dx</a>(q)
					return <a href="#pflz" id='c:2848'>pflz</a>(<a href="#F64" id='c:2849'>F64</a>(<a href="#int32" id='c:2850'>int32</a>(q)))
				}
				return q
			}
		}
	}
	return <a href="#Ki" id='c:2851'>Ki</a>(<a href="#int32" id='c:2852'>int32</a>(r))
}</span><span id="pu">
func <span class='q'>pu</span>() int64 {<span id='c:pu' class='n'>
</span>
	r := <a href="#int64" id='c:2853'>int64</a>(0)
	for pp &lt; pe {
		c := <a href="#I8" id='c:2854'>I8</a>(pp)
		if <a href="#is" id='c:2855'>is</a>(c, 4) == 0 {
			break
		}
		r = 10*r + <a href="#int64" id='c:2856'>int64</a>(c-&#39;0&#39;)
		pp++
	}
	return r
}</span><span id="pexp">
func <span class='q'>pexp</span>(f float64) float64 {<span id='c:pexp' class='n'>
</span>
	pp++
	e := <a href="#int64" id='c:2857'>int64</a>(1)
	if pp &lt; pe {
		c := <a href="#I8" id='c:2858'>I8</a>(pp)
		if c == &#39;-&#39; || c == &#39;+&#39; {
			if c == &#39;-&#39; {
				e = <a href="#int64" id='c:2859'>int64</a>(-1)
			}
			pp++
		}
	}
	e *= <a href="#pu" id='c:2860'>pu</a>()
	return f * <a href="#pow" id='c:2861'>pow</a>(10.0, <a href="#float64" id='c:2862'>float64</a>(e))
}</span><span id="pflt">
func <span class='q'>pflt</span>(i int64) K {<span id='c:pflt' class='n'>
</span>
	var c int32
	d := 1.0
	f := <a href="#float64" id='c:2863'>float64</a>(i)
	pp++ // .
	for pp &lt; pe {
		c = <a href="#I8" id='c:2864'>I8</a>(pp)
		if <a href="#is" id='c:2865'>is</a>(c, 4) == 0 {
			break
		}
		d /= 10.0
		f += d * <a href="#float64" id='c:2866'>float64</a>(c-&#39;0&#39;)
		pp++
	}
	if pp &lt; pe {
		c = <a href="#I8" id='c:2867'>I8</a>(pp)
		if c == &#39;e&#39; || c == &#39;E&#39; {
			f = <a href="#pexp" id='c:2868'>pexp</a>(f)
		}
	}
	if pp &lt; pe {
		c = <a href="#I8" id='c:2869'>I8</a>(pp)
		if c == &#39;a&#39; {
			return <a href="#pflz" id='c:2870'>pflz</a>(f)
		}
		if c == &#39;p&#39; {
			return <a href="#ppi" id='c:2871'>ppi</a>(f)
		}
	}
	return <a href="#Kf" id='c:2872'>Kf</a>(f)
}</span><span id="pflz">
func <span class='q'>pflz</span>(f float64) K {<span id='c:pflz' class='n'>
</span>
	r := <a href="#K" id='c:2873'>K</a>(0)
	pp++
	if pp &lt; pe {
		r = <a href="#tunm" id='c:2874'>tunm</a>()
	}
	return <a href="#Rot" id='c:2875'>Rot</a>(<a href="#Kf" id='c:2876'>Kf</a>(f), r)
}</span><span id="ppi">
func <span class='q'>ppi</span>(f float64) K {<span id='c:ppi' class='n'>
</span>
	pp++
	return <a href="#Kf" id='c:2877'>Kf</a>(pi * f)
}</span>
<span id="tvrb">
func <span class='q'>tvrb</span>() K {<span id='c:tvrb' class='n'>
</span>
	c := <a href="#I8" id='c:2878'>I8</a>(pp)
	if <a href="#is" id='c:2879'>is</a>(c, 1) == 0 {
		return 0
	}
	pp++
	if c == 92 &amp;&amp; <a href="#I8" id='c:2880'>I8</a>(pp-2) == 32 { // \out
		return <a href="#K" id='c:2881'>K</a>(29)
	}
	o := <a href="#int32" id='c:2882'>int32</a>(1)
	if pp &lt; pe {
		if <a href="#I8" id='c:2883'>I8</a>(pp) == 58 { // :
			pp++
			if <a href="#is" id='c:2884'>is</a>(c, 8) != 0 {
				<a href="#trap" id='c:2885'>trap</a>() //parse
			}
			o = 97
			/*
				if <a href="#is" id='c:2886'>is</a>(c, 8) != 0 {
					o = 2 // &#39;:
				} else {
					o = 97 // +:
				}
			*/
		}
	}
	return <a href="#K" id='c:2887'>K</a>(o + <a href="#idx" id='c:2888'>idx</a>(c, 227, 253))
}</span><span id="tpct">
func <span class='q'>tpct</span>() K {<span id='c:tpct' class='n'>
</span>
	c := <a href="#I8" id='c:2889'>I8</a>(pp)
	if <a href="#is" id='c:2890'>is</a>(c, 48) != 0 { // ([{}]); \n
		pp++
		return <a href="#K" id='c:2891'>K</a>(c)
	}
	if c == 10 {
		pp++
		return <a href="#K" id='c:2892'>K</a>(&#39;;&#39;)
	}
	return 0
}</span><span id="tvar">
func <span class='q'>tvar</span>() K {<span id='c:tvar' class='n'>
</span>
	c := <a href="#I8" id='c:2893'>I8</a>(pp)
	if <a href="#is" id='c:2894'>is</a>(c, 2) == 0 {
		return 0
	}
	pp++
	r := <a href="#Ku" id='c:2895'>Ku</a>(<a href="#uint64" id='c:2896'>uint64</a>(c))
	for pp &lt; pe {
		c = <a href="#I8" id='c:2897'>I8</a>(pp)
		if <a href="#is" id='c:2898'>is</a>(c, 6) == 0 {
			break
		}
		r = <a href="#cat1" id='c:2899'>cat1</a>(r, <a href="#ti" id='c:2900'>ti</a>(ct, c))
		pp++
	}
	return <a href="#sc" id='c:2901'>sc</a>(r)
}</span><span id="tsym">
func <span class='q'>tsym</span>() K {<span id='c:tsym' class='n'>
</span>
	r := <a href="#K" id='c:2902'>K</a>(0)
	for <a href="#I8" id='c:2903'>I8</a>(pp) == 96 {
		pp++
		if r == 0 {
			r = <a href="#mk" id='c:2904'>mk</a>(St, 0)
		}
		s := <a href="#K" id='c:2905'>K</a>(0)
		if pp &lt; pe {
			s = <a href="#tchr" id='c:2906'>tchr</a>()
			if <a href="#tp" id='c:2907'>tp</a>(s) == ct {
				s = <a href="#sc" id='c:2908'>sc</a>(<a href="#Enl" id='c:2909'>Enl</a>(s))
			} else if s != 0 {
				s = <a href="#sc" id='c:2910'>sc</a>(s)
			} else {
				s = <a href="#tvar" id='c:2911'>tvar</a>()
			}
		}
		if s == 0 {
			s = <a href="#K" id='c:2912'>K</a>(st) &lt;&lt; 59
		}
		r = <a href="#cat1" id='c:2913'>cat1</a>(r, s)
		if pp == pe {
			break
		}
	}
	return r
}</span><span id="ws">
func <span class='q'>ws</span>() {<span id='c:ws' class='n'>
</span>
	var c int32
	for pp &lt; pe {
		c = <a href="#I8" id='c:2914'>I8</a>(pp)
		if c == 10 || c &gt; 32 {
			break
		}
		pp++
	}
	for pp &lt; pe {
		c = <a href="#I8" id='c:2915'>I8</a>(pp)
		if c == 47 &amp;&amp; <a href="#I8" id='c:2916'>I8</a>(pp-1) &lt; 33 {
			pp++
			for pp &lt; pe {
				c = <a href="#I8" id='c:2917'>I8</a>(pp)
				if c == 10 {
					break
				}
				pp++
			}
		} else {
			return
		}
	}
}</span><span id="is">
func <span class='q'>is</span>(x, m int32) int32 { return m &amp; <a href="#I8" id='c:2918'>I8</a>(100+x) }<span id='c:is' class='n'>
</span></span><span id="nyi">
func <span class='q'>nyi</span>(x K) K { <a href="#trap" id='c:2919'>trap</a>(); return 0 }<span id='c:nyi' class='n'>
</span></span><span id="Idy">
func <span class='q'>Idy</span>(x K) K { return x } // :x<span id='c:Idy' class='n'>
</span></span><span id="Dex">
func <span class='q'>Dex</span>(x, y K) K { // x:y<span id='c:Dex' class='n'>
</span>
	<a href="#dx" id='c:2920'>dx</a>(x)
	return y
}</span><span id="Flp">
func <span class='q'>Flp</span>(x K) K { // +x<span id='c:Flp' class='n'>
</span>
	xt := <a href="#tp" id='c:2921'>tp</a>(x)
	if xt == Lt {
		n := <a href="#nn" id='c:2922'>nn</a>(x)
		xp := <a href="#int32" id='c:2923'>int32</a>(x)
		m := <a href="#Ki" id='c:2924'>Ki</a>(<a href="#maxcount" id='c:2925'>maxcount</a>(xp, n))
		x = <a href="#Atx" id='c:2926'>Atx</a>(<a href="#Rdc" id='c:2927'>Rdc</a>(13, <a href="#l1" id='c:2928'>l1</a>(<a href="#Ecr" id='c:2929'>Ecr</a>(15, <a href="#l2" id='c:2930'>l2</a>(m, x)))), <a href="#Ecl" id='c:2931'>Ecl</a>(2, <a href="#l2" id='c:2932'>l2</a>(<a href="#Til" id='c:2933'>Til</a>(m), <a href="#Mul" id='c:2934'>Mul</a>(m, <a href="#Til" id='c:2935'>Til</a>(<a href="#Ki" id='c:2936'>Ki</a>(n))))))
	} else if xt &gt; Lt {
		r := <a href="#x0" id='c:2937'>x0</a>(x)
		x = <a href="#r1" id='c:2938'>r1</a>(x)
		if xt == Tt {
			x = <a href="#Key" id='c:2939'>Key</a>(r, x)
		} else {
			if <a href="#tp" id='c:2940'>tp</a>(r) != St || <a href="#tp" id='c:2941'>tp</a>(x) != Lt {
				<a href="#trap" id='c:2942'>trap</a>() //type
			}
			m := <a href="#maxcount" id='c:2943'>maxcount</a>(<a href="#int32" id='c:2944'>int32</a>(x), <a href="#nn" id='c:2945'>nn</a>(x))
			x = <a href="#Ech" id='c:2946'>Ech</a>(15, <a href="#l2" id='c:2947'>l2</a>(<a href="#Ki" id='c:2948'>Ki</a>(m), x)) // (|/#&#39;x)#&#39;x
			r = <a href="#l2" id='c:2949'>l2</a>(r, x)
			<a href="#SetI32" id='c:2950'>SetI32</a>(<a href="#int32" id='c:2951'>int32</a>(r)-12, m)
			x = <a href="#ti" id='c:2952'>ti</a>(Tt, <a href="#int32" id='c:2953'>int32</a>(r))
		}
	}
	return x
}</span><span id="maxcount">
func <span class='q'>maxcount</span>(xp int32, n int32) int32 { // |/#l<span id='c:maxcount' class='n'>
</span>
	r := <a href="#int32" id='c:2954'>int32</a>(0)
	for n &gt; 0 {
		n--
		x := <a href="#K" id='c:2955'>K</a>(<a href="#I64" id='c:2956'>I64</a>(xp))
		xp += 8
		if <a href="#tp" id='c:2957'>tp</a>(x) &lt; 16 {
			r = <a href="#maxi" id='c:2958'>maxi</a>(1, r)
		} else {
			r = <a href="#maxi" id='c:2959'>maxi</a>(<a href="#nn" id='c:2960'>nn</a>(x), r)
		}
	}
	return r
}</span><span id="Fst">
func <span class='q'>Fst</span>(x K) K { // *x<span id='c:Fst' class='n'>
</span>
	t := <a href="#tp" id='c:2961'>tp</a>(x)
	if t &lt; 16 {
		return x
	}
	if t == Dt {
		return <a href="#Fst" id='c:2962'>Fst</a>(<a href="#Val" id='c:2963'>Val</a>(x))
	}
	return <a href="#ati" id='c:2964'>ati</a>(x, 0)
}</span><span id="Las">
func <span class='q'>Las</span>(x K) K { // *|x<span id='c:Las' class='n'>
</span>
	t := <a href="#tp" id='c:2965'>tp</a>(x)
	if t &lt; 16 {
		return x
	}
	if t == Dt {
		x = <a href="#Val" id='c:2966'>Val</a>(x)
	}
	n := <a href="#nn" id='c:2967'>nn</a>(x)
	if n == 0 {
		return <a href="#Fst" id='c:2968'>Fst</a>(x)
	}
	return <a href="#ati" id='c:2969'>ati</a>(x, n-1)
}</span>
<span id="Cnt">
func <span class='q'>Cnt</span>(x K) K { // #x<span id='c:Cnt' class='n'>
</span>
	t := <a href="#tp" id='c:2970'>tp</a>(x)
	<a href="#dx" id='c:2971'>dx</a>(x)
	if t &lt; 16 {
		return <a href="#Ki" id='c:2972'>Ki</a>(1)
	}
	return <a href="#Ki" id='c:2973'>Ki</a>(<a href="#nn" id='c:2974'>nn</a>(x))
}</span><span id="Not">
func <span class='q'>Not</span>(x K) K { // ~x<span id='c:Not' class='n'>
</span>
	if <a href="#tp" id='c:2975'>tp</a>(x)&amp;15 == st {
		x = <a href="#Eql" id='c:2976'>Eql</a>(<a href="#Ks" id='c:2977'>Ks</a>(0), x)
	} else {
		x = <a href="#Eql" id='c:2978'>Eql</a>(<a href="#Ki" id='c:2979'>Ki</a>(0), x)
	}
	return x
}</span><span id="Til">
func <span class='q'>Til</span>(x K) K {<span id='c:Til' class='n'>
</span>
	xt := <a href="#tp" id='c:2980'>tp</a>(x)
	if xt &gt; Lt {
		t := <a href="#x0" id='c:2981'>x0</a>(x)
		<a href="#dx" id='c:2982'>dx</a>(x)
		return t
	}
	if xt == it {
		return <a href="#seq" id='c:2983'>seq</a>(<a href="#int32" id='c:2984'>int32</a>(x))
	}
	if xt == It {
		return <a href="#kx" id='c:2985'>kx</a>(120, x) // odo
	}
	<a href="#trap" id='c:2986'>trap</a>() //type
	return 0
}</span><span id="seq">
func <span class='q'>seq</span>(n int32) K {<span id='c:seq' class='n'>
</span>
	n = <a href="#maxi" id='c:2987'>maxi</a>(n, 0)
	r := <a href="#mk" id='c:2988'>mk</a>(It, n)
	for n &gt; 0 {
		n--
		<a href="#SetI32" id='c:2989'>SetI32</a>(<a href="#int32" id='c:2990'>int32</a>(r)+4*n, n)
	}
	return r
}</span><span id="Unq">
func <span class='q'>Unq</span>(x K) K { // ?x<span id='c:Unq' class='n'>
</span>
	var r K
	xt := <a href="#tp" id='c:2991'>tp</a>(x)
	if xt &lt; 16 {
		return <a href="#roll" id='c:2992'>roll</a>(x)
	}
	if xt &gt;= Lt {
		if xt == Dt {
			<a href="#trap" id='c:2993'>trap</a>() //type
		}
		if xt == Tt {
			r = <a href="#x0" id='c:2994'>x0</a>(x)
			x = <a href="#r1" id='c:2995'>r1</a>(x)
			return <a href="#key" id='c:2996'>key</a>(r, <a href="#Flp" id='c:2997'>Flp</a>(<a href="#Unq" id='c:2998'>Unq</a>(<a href="#Flp" id='c:2999'>Flp</a>(x))), xt)
		}
		return <a href="#kx" id='c:3000'>kx</a>(96, x) // .uqf
	}
	xn := <a href="#nn" id='c:3001'>nn</a>(x)
	r = <a href="#mk" id='c:3002'>mk</a>(xt, 0)
	for i := <a href="#int32" id='c:3003'>int32</a>(0); i &lt; xn; i++ {
		xi := <a href="#ati" id='c:3004'>ati</a>(<a href="#rx" id='c:3005'>rx</a>(x), i)
		if <a href="#int32" id='c:3006'>int32</a>(<a href="#In" id='c:3007'>In</a>(<a href="#rx" id='c:3008'>rx</a>(xi), <a href="#rx" id='c:3009'>rx</a>(r))) == 0 {
			r = <a href="#cat1" id='c:3010'>cat1</a>(r, xi)
		} else {
			<a href="#dx" id='c:3011'>dx</a>(xi)
		}
	}
	<a href="#dx" id='c:3012'>dx</a>(x)
	return r
}</span><span id="Uqs">
func <span class='q'>Uqs</span>(x K) K { // ?^x<span id='c:Uqs' class='n'>
</span>
	if <a href="#tp" id='c:3013'>tp</a>(x) &lt; 16 {
		<a href="#trap" id='c:3014'>trap</a>() //type
	}
	return <a href="#kx" id='c:3015'>kx</a>(88, x) // .uqs
}</span><span id="Grp">
func <span class='q'>Grp</span>(x K) K    { return <a href="#kx" id='c:3016'>kx</a>(128, x) }    // =x grp.<span id='c:Grp' class='n'>
</span></span><span id="Key">
func <span class='q'>Key</span>(x, y K) K { return <a href="#key" id='c:3017'>key</a>(x, y, Dt) } // x!y<span id='c:Key' class='n'>
</span></span><span id="key">
func <span class='q'>key</span>(x, y K, t T) K { // Dt or Tt<span id='c:key' class='n'>
</span>
	xt := <a href="#tp" id='c:3018'>tp</a>(x)
	yt := <a href="#tp" id='c:3019'>tp</a>(y)
	if xt &lt; 16 {
		if xt == it {
			return <a href="#Mod" id='c:3020'>Mod</a>(y, x)
		}
		if xt == st {
			if yt == Tt { // s!t (key table)
				x = <a href="#rx" id='c:3021'>rx</a>(x)
				y = <a href="#rx" id='c:3022'>rx</a>(y)
				return <a href="#Key" id='c:3023'>Key</a>(<a href="#Tak" id='c:3024'>Tak</a>(x, y), <a href="#Drp" id='c:3025'>Drp</a>(x, y))
			}
		}
		x = <a href="#Enl" id='c:3026'>Enl</a>(x) //allow `a!,1 2 3 short for (`a)!,1 2 3
	}
	xn := <a href="#nn" id='c:3027'>nn</a>(x)
	if t == Tt {
		if xn &gt; 0 {
			xn = <a href="#nn" id='c:3028'>nn</a>(<a href="#K" id='c:3029'>K</a>(<a href="#I64" id='c:3030'>I64</a>(<a href="#int32" id='c:3031'>int32</a>(y))))
		}
	} else if yt &lt; 16 {
		<a href="#trap" id='c:3032'>trap</a>() //type
	} else if xn != <a href="#nn" id='c:3033'>nn</a>(y) {
		<a href="#trap" id='c:3034'>trap</a>() //length
	}
	x = <a href="#l2" id='c:3035'>l2</a>(x, y)
	<a href="#SetI32" id='c:3036'>SetI32</a>(<a href="#int32" id='c:3037'>int32</a>(x)-12, xn)
	return <a href="#ti" id='c:3038'>ti</a>(t, <a href="#int32" id='c:3039'>int32</a>(x))
}</span><span id="Tak">
func <span class='q'>Tak</span>(x, y K) K { // x#y<span id='c:Tak' class='n'>
</span>
	xt := <a href="#tp" id='c:3040'>tp</a>(x)
	yt := <a href="#tp" id='c:3041'>tp</a>(y)
	if yt == Dt {
		x = <a href="#rx" id='c:3042'>rx</a>(x)
		if xt == it {
			r := <a href="#x0" id='c:3043'>x0</a>(y)
			y = <a href="#r1" id='c:3044'>r1</a>(y)
			r = <a href="#Tak" id='c:3045'>Tak</a>(x, r)
			y = <a href="#Tak" id='c:3046'>Tak</a>(x, y)
			return <a href="#Key" id='c:3047'>Key</a>(r, y)
		} else {
			return <a href="#Key" id='c:3048'>Key</a>(x, <a href="#Atx" id='c:3049'>Atx</a>(y, x))
		}
	} else if yt == Tt {
		if xt&amp;15 == st {
			if xt == st {
				x = <a href="#Enl" id='c:3050'>Enl</a>(x)
			}
			x = <a href="#rx" id='c:3051'>rx</a>(x)
			return <a href="#key" id='c:3052'>key</a>(x, <a href="#Atx" id='c:3053'>Atx</a>(y, x), yt)
		} else {
			return <a href="#Ecr" id='c:3054'>Ecr</a>(15, <a href="#l2" id='c:3055'>l2</a>(x, y))
		}
	}
	if xt == it {
		return <a href="#ntake" id='c:3056'>ntake</a>(<a href="#int32" id='c:3057'>int32</a>(x), y)
	}
	y = <a href="#rx" id='c:3058'>rx</a>(y)
	if xt &gt; 16 &amp;&amp; xt == yt {
		return <a href="#atv" id='c:3059'>atv</a>(y, <a href="#Wer" id='c:3060'>Wer</a>(<a href="#In" id='c:3061'>In</a>(y, x))) // set take
	}
	return <a href="#Atx" id='c:3062'>Atx</a>(y, <a href="#Wer" id='c:3063'>Wer</a>(<a href="#Cal" id='c:3064'>Cal</a>(x, <a href="#l1" id='c:3065'>l1</a>(y)))) // f#
}</span><span id="ntake">
func <span class='q'>ntake</span>(n int32, y K) K {<span id='c:ntake' class='n'>
</span>
	var r K
	t := <a href="#tp" id='c:3066'>tp</a>(y)
	if n == nai {
		if t &lt; 16 {
			n = 1
		} else {
			n = <a href="#nn" id='c:3067'>nn</a>(y)
		}
	}
	if n &lt; 0 {
		if <a href="#tp" id='c:3068'>tp</a>(y) &lt; 16 {
			return <a href="#ntake" id='c:3069'>ntake</a>(-n, y)
		}
		n += <a href="#nn" id='c:3070'>nn</a>(y)
		if n &lt; 0 {
			return <a href="#ucat" id='c:3071'>ucat</a>(<a href="#ntake" id='c:3072'>ntake</a>(-n, <a href="#missing" id='c:3073'>missing</a>(t-16)), y)
		}
		return <a href="#ndrop" id='c:3074'>ndrop</a>(n, y)
	}
	yp := <a href="#int32" id='c:3075'>int32</a>(y)
	if t &lt; 5 {
		t += 16
		r = <a href="#mk" id='c:3076'>mk</a>(t, n)
		s := <a href="#sz" id='c:3077'>sz</a>(t)
		rp := <a href="#int32" id='c:3078'>int32</a>(r)
		if s == 1 {
			<a href="#Memoryfill" id='c:3079'>Memoryfill</a>(rp, yp, n)
		} else {
			for n &gt; 0 {
				n--
				<a href="#SetI32" id='c:3080'>SetI32</a>(rp, yp)
				rp += 4
			}
		}
		return r
	} else if t == ft {
		r = <a href="#mk" id='c:3081'>mk</a>(Ft, n)
		rp := <a href="#int32" id='c:3082'>int32</a>(r)
		f := <a href="#F64" id='c:3083'>F64</a>(yp)
		for n &gt; 0 {
			n--
			<a href="#SetF64" id='c:3084'>SetF64</a>(rp, f)
			rp += 8
		}
		<a href="#dx" id='c:3085'>dx</a>(y)
		return r
	} else if t == zt {
		r = <a href="#mk" id='c:3086'>mk</a>(Zt, n)
		rp := <a href="#int32" id='c:3087'>int32</a>(r)
		re, im := <a href="#F64" id='c:3088'>F64</a>(yp), <a href="#F64" id='c:3089'>F64</a>(yp+8)
		for n &gt; 0 {
			n--
			<a href="#SetF64" id='c:3090'>SetF64</a>(rp, re)
			<a href="#SetF64" id='c:3091'>SetF64</a>(rp+8, im)
			rp += 16
		}
		<a href="#dx" id='c:3092'>dx</a>(y)
		return r
	} else if t &lt; 16 {
		r = <a href="#mk" id='c:3093'>mk</a>(Lt, n)
		rp := <a href="#int32" id='c:3094'>int32</a>(r)
		for n &gt; 0 {
			n--
			<a href="#SetI64" id='c:3095'>SetI64</a>(rp, <a href="#int64" id='c:3096'>int64</a>(<a href="#rx" id='c:3097'>rx</a>(y)))
			rp += 8
		}
		<a href="#dx" id='c:3098'>dx</a>(y)
		return r
	}
	yn := <a href="#nn" id='c:3099'>nn</a>(y)
	s := <a href="#sz" id='c:3100'>sz</a>(t)
	if <a href="#I32" id='c:3101'>I32</a>(yp-4) == 1 &amp;&amp; <a href="#bucket" id='c:3102'>bucket</a>(s*yn) == <a href="#bucket" id='c:3103'>bucket</a>(s*n) &amp;&amp; n &lt;= yn &amp;&amp; t &lt; Lt {
		<a href="#SetI32" id='c:3104'>SetI32</a>(yp-12, n)
		return y
	}
	r = <a href="#seq" id='c:3105'>seq</a>(n)
	if n &gt; yn &amp;&amp; yn &gt; 0 {
		r = <a href="#idiv" id='c:3106'>idiv</a>(r, <a href="#Ki" id='c:3107'>Ki</a>(yn), 1)
	}
	return <a href="#atv" id='c:3108'>atv</a>(y, r)
}</span><span id="Drp">
func <span class='q'>Drp</span>(x, y K) K { // x_y<span id='c:Drp' class='n'>
</span>
	xt := <a href="#tp" id='c:3109'>tp</a>(x)
	yt := <a href="#tp" id='c:3110'>tp</a>(y)
	if yt &gt; Lt {
		if yt == Dt || (yt == Tt &amp;&amp; xt&amp;15 == st) {
			r := <a href="#x0" id='c:3111'>x0</a>(y)
			y = <a href="#r1" id='c:3112'>r1</a>(y)
			if xt &lt; 16 {
				x = <a href="#Enl" id='c:3113'>Enl</a>(x)
			}
			x = <a href="#rx" id='c:3114'>rx</a>(<a href="#Wer" id='c:3115'>Wer</a>(<a href="#Not" id='c:3116'>Not</a>(<a href="#In" id='c:3117'>In</a>(<a href="#rx" id='c:3118'>rx</a>(r), x))))
			return <a href="#key" id='c:3119'>key</a>(<a href="#Atx" id='c:3120'>Atx</a>(r, x), <a href="#Atx" id='c:3121'>Atx</a>(y, x), yt)
		} else {
			return <a href="#Ecr" id='c:3122'>Ecr</a>(16, <a href="#l2" id='c:3123'>l2</a>(x, y))
		}
	}
	if xt == it {
		return <a href="#ndrop" id='c:3124'>ndrop</a>(<a href="#int32" id='c:3125'>int32</a>(x), y)
	}
	if xt &gt; 16 &amp;&amp; xt == yt {
		return <a href="#atv" id='c:3126'>atv</a>(y, <a href="#Wer" id='c:3127'>Wer</a>(<a href="#Not" id='c:3128'>Not</a>(<a href="#In" id='c:3129'>In</a>(<a href="#rx" id='c:3130'>rx</a>(y), x)))) // set drop
	}
	if yt == it {
		return <a href="#atv" id='c:3131'>atv</a>(x, <a href="#Wer" id='c:3132'>Wer</a>(<a href="#Not" id='c:3133'>Not</a>(<a href="#Eql" id='c:3134'>Eql</a>(y, <a href="#seq" id='c:3135'>seq</a>(<a href="#nn" id='c:3136'>nn</a>(x))))))
	}
	return <a href="#Atx" id='c:3137'>Atx</a>(y, <a href="#Wer" id='c:3138'>Wer</a>(<a href="#Not" id='c:3139'>Not</a>(<a href="#Cal" id='c:3140'>Cal</a>(x, <a href="#l1" id='c:3141'>l1</a>(<a href="#rx" id='c:3142'>rx</a>(y)))))) // f#
}</span><span id="ndrop">
func <span class='q'>ndrop</span>(n int32, y K) K {<span id='c:ndrop' class='n'>
</span>
	var r K
	yt := <a href="#tp" id='c:3143'>tp</a>(y)
	if yt &lt; 16 || yt &gt; Lt {
		<a href="#trap" id='c:3144'>trap</a>() //type
	}
	yn := <a href="#nn" id='c:3145'>nn</a>(y)
	if n &lt; 0 {
		return <a href="#ntake" id='c:3146'>ntake</a>(<a href="#maxi" id='c:3147'>maxi</a>(0, yn+n), y)
	}
	rn := yn - n
	if rn &lt; 0 {
		<a href="#dx" id='c:3148'>dx</a>(y)
		return <a href="#mk" id='c:3149'>mk</a>(yt, 0)
	}
	s := <a href="#sz" id='c:3150'>sz</a>(yt)
	yp := <a href="#int32" id='c:3151'>int32</a>(y)
	if <a href="#I32" id='c:3152'>I32</a>(yp-4) == 1 &amp;&amp; <a href="#bucket" id='c:3153'>bucket</a>(s*yn) == <a href="#bucket" id='c:3154'>bucket</a>(s*rn) &amp;&amp; yt &lt; Lt {
		r = <a href="#rx" id='c:3155'>rx</a>(y)
		<a href="#SetI32" id='c:3156'>SetI32</a>(yp-12, rn)
	} else {
		r = <a href="#mk" id='c:3157'>mk</a>(yt, rn)
	}
	rp := <a href="#int32" id='c:3158'>int32</a>(r)
	<a href="#Memorycopy" id='c:3159'>Memorycopy</a>(rp, yp+s*n, s*rn)
	if yt == Lt {
		<a href="#rl" id='c:3160'>rl</a>(r)
		r = <a href="#uf" id='c:3161'>uf</a>(r)
	}
	<a href="#dx" id='c:3162'>dx</a>(y)
	return r
}</span>
<span id="Cut">
func <span class='q'>Cut</span>(x, y K) K { // x^y<span id='c:Cut' class='n'>
</span>
	yt := <a href="#tp" id='c:3163'>tp</a>(y)
	if yt == it || yt == ft {
		return <a href="#Pow" id='c:3164'>Pow</a>(y, x)
	}
	xt := <a href="#tp" id='c:3165'>tp</a>(x)
	if xt == It {
		return <a href="#cuts" id='c:3166'>cuts</a>(x, y)
	}
	if xt == Ct &amp;&amp; yt == Ct { // &#34;set&#34;^&#34;abc&#34;
		x = <a href="#rx" id='c:3167'>rx</a>(<a href="#Wer" id='c:3168'>Wer</a>(<a href="#In" id='c:3169'>In</a>(<a href="#rx" id='c:3170'>rx</a>(y), x)))
		return <a href="#rcut" id='c:3171'>rcut</a>(y, <a href="#Cat" id='c:3172'>Cat</a>(<a href="#Ki" id='c:3173'>Ki</a>(0), <a href="#Add" id='c:3174'>Add</a>(<a href="#Ki" id='c:3175'>Ki</a>(1), x)), <a href="#Cat" id='c:3176'>Cat</a>(x, <a href="#Ki" id='c:3177'>Ki</a>(<a href="#nn" id='c:3178'>nn</a>(y))))
	}
	if xt != it || yt &lt; 16 {
		<a href="#trap" id='c:3179'>trap</a>() //type
	}
	xp := <a href="#int32" id='c:3180'>int32</a>(x)
	if xp &lt;= 0 {
		xp = <a href="#nn" id='c:3181'>nn</a>(y) / -xp
	}
	r := <a href="#mk" id='c:3182'>mk</a>(Lt, xp)
	rp := <a href="#int32" id='c:3183'>int32</a>(r)
	e := <a href="#ep" id='c:3184'>ep</a>(r)
	n := <a href="#nn" id='c:3185'>nn</a>(y) / xp
	x = <a href="#seq" id='c:3186'>seq</a>(n)
	for rp &lt; e {
		<a href="#SetI64" id='c:3187'>SetI64</a>(rp, <a href="#int64" id='c:3188'>int64</a>(<a href="#atv" id='c:3189'>atv</a>(<a href="#rx" id='c:3190'>rx</a>(y), <a href="#rx" id='c:3191'>rx</a>(x))))
		x = <a href="#Add" id='c:3192'>Add</a>(<a href="#Ki" id='c:3193'>Ki</a>(n), x)
		rp += 8
		continue
	}
	<a href="#dxy" id='c:3194'>dxy</a>(x, y)
	return r
}</span><span id="cuts">
func <span class='q'>cuts</span>(x, y K) K { return <a href="#rcut" id='c:3195'>rcut</a>(y, x, <a href="#cat1" id='c:3196'>cat1</a>(<a href="#ndrop" id='c:3197'>ndrop</a>(1, <a href="#rx" id='c:3198'>rx</a>(x)), <a href="#Ki" id='c:3199'>Ki</a>(<a href="#nn" id='c:3200'>nn</a>(y)))) }<span id='c:cuts' class='n'>
</span></span><span id="rcut">
func <span class='q'>rcut</span>(x, a, b K) K { // a, b start-stop ranges<span id='c:rcut' class='n'>
</span>
	n := <a href="#nn" id='c:3201'>nn</a>(a)
	ap, bp := <a href="#int32" id='c:3202'>int32</a>(a), <a href="#int32" id='c:3203'>int32</a>(b)
	r := <a href="#mk" id='c:3204'>mk</a>(Lt, n)
	rp := <a href="#int32" id='c:3205'>int32</a>(r)
	for n &gt; 0 {
		n--
		o := <a href="#I32" id='c:3206'>I32</a>(ap)
		m := <a href="#I32" id='c:3207'>I32</a>(bp) - o
		if m &lt; 0 {
			<a href="#trap" id='c:3208'>trap</a>() //value
		}
		<a href="#SetI64" id='c:3209'>SetI64</a>(rp, <a href="#int64" id='c:3210'>int64</a>(<a href="#atv" id='c:3211'>atv</a>(<a href="#rx" id='c:3212'>rx</a>(x), <a href="#Add" id='c:3213'>Add</a>(<a href="#Ki" id='c:3214'>Ki</a>(o), <a href="#seq" id='c:3215'>seq</a>(m)))))
		rp += 8
		ap += 4
		bp += 4
	}
	<a href="#dxy" id='c:3216'>dxy</a>(a, b)
	<a href="#dx" id='c:3217'>dx</a>(x)
	return r
}</span><span id="split">
func <span class='q'>split</span>(x, y K) K {<span id='c:split' class='n'>
</span>
	xt, yt := <a href="#tp" id='c:3218'>tp</a>(x), <a href="#tp" id='c:3219'>tp</a>(y)
	xn := <a href="#int32" id='c:3220'>int32</a>(1)
	if yt == xt+16 {
		x = <a href="#Wer" id='c:3221'>Wer</a>(<a href="#Eql" id='c:3222'>Eql</a>(x, <a href="#rx" id='c:3223'>rx</a>(y)))
	} else {
		if xt == yt &amp;&amp; xt == Ct {
			xn = <a href="#nn" id='c:3224'>nn</a>(x)
			x = <a href="#Find" id='c:3225'>Find</a>(x, <a href="#rx" id='c:3226'>rx</a>(y))
		} else {
			<a href="#trap" id='c:3227'>trap</a>() //type
		}
	}
	x = <a href="#rx" id='c:3228'>rx</a>(x)
	return <a href="#rcut" id='c:3229'>rcut</a>(y, <a href="#Cat" id='c:3230'>Cat</a>(<a href="#Ki" id='c:3231'>Ki</a>(0), <a href="#Add" id='c:3232'>Add</a>(<a href="#Ki" id='c:3233'>Ki</a>(xn), x)), <a href="#cat1" id='c:3234'>cat1</a>(x, <a href="#Ki" id='c:3235'>Ki</a>(<a href="#nn" id='c:3236'>nn</a>(y))))
}</span><span id="join">
func <span class='q'>join</span>(x, y K) K {<span id='c:join' class='n'>
</span>
	xt := <a href="#tp" id='c:3237'>tp</a>(x)
	if xt &lt; 16 {
		x = <a href="#Enl" id='c:3238'>Enl</a>(x)
		xt = <a href="#tp" id='c:3239'>tp</a>(x)
	}
	yt := <a href="#tp" id='c:3240'>tp</a>(y)
	if yt != Lt {
		<a href="#trap" id='c:3241'>trap</a>() //type
	}
	yp := <a href="#int32" id='c:3242'>int32</a>(y)
	yn := <a href="#nn" id='c:3243'>nn</a>(y)
	r := <a href="#mk" id='c:3244'>mk</a>(xt, 0)
	for i := <a href="#int32" id='c:3245'>int32</a>(0); i &lt; yn; i++ {
		v := <a href="#x0" id='c:3246'>x0</a>(<a href="#K" id='c:3247'>K</a>(yp))
		if <a href="#tp" id='c:3248'>tp</a>(v) != xt {
			<a href="#trap" id='c:3249'>trap</a>() //type
		}
		if i &gt; 0 {
			r = <a href="#ucat" id='c:3250'>ucat</a>(r, <a href="#rx" id='c:3251'>rx</a>(x))
		}
		r = <a href="#ucat" id='c:3252'>ucat</a>(r, v)
		yp += 8
	}
	<a href="#dxy" id='c:3253'>dxy</a>(x, y)
	return r
}</span><span id="Bin">
func <span class='q'>Bin</span>(x, y K) K { // x&#39;y<span id='c:Bin' class='n'>
</span>
	var r K
	xt := <a href="#tp" id='c:3254'>tp</a>(x)
	yt := <a href="#tp" id='c:3255'>tp</a>(y)
	if xt == yt || yt == Lt {
		return <a href="#Ecr" id='c:3256'>Ecr</a>(40, <a href="#l2" id='c:3257'>l2</a>(x, y))
	} else if xt == yt+16 {
		r = <a href="#Ki" id='c:3258'>Ki</a>(<a href="#ibin" id='c:3259'>ibin</a>(x, y, xt))
	} else {
		<a href="#trap" id='c:3260'>trap</a>() //type
	}
	<a href="#dxy" id='c:3261'>dxy</a>(x, y)
	return r
}</span><span id="ibin">
func <span class='q'>ibin</span>(x, y K, t T) int32 {<span id='c:ibin' class='n'>
</span>
	var h int32
	k := <a href="#int32" id='c:3262'>int32</a>(0)
	n := <a href="#nn" id='c:3263'>nn</a>(x)
	xp := <a href="#int32" id='c:3264'>int32</a>(x)
	yp := <a href="#int32" id='c:3265'>int32</a>(y)
	j := n - 1
	s := <a href="#sz" id='c:3266'>sz</a>(t)
	switch s &gt;&gt; 2 {
	case 0:
		for {
			if k &gt; j {
				return k - 1
			}
			h = (k + j) &gt;&gt; 1
			if <a href="#I8" id='c:3267'>I8</a>(xp+h) &gt; yp {
				j = h - 1
			} else {
				k = h + 1
			}
		}
	case 1:
		for {
			if k &gt; j {
				return k - 1
			}
			h = (k + j) &gt;&gt; 1
			if <a href="#I32" id='c:3268'>I32</a>(xp+4*h) &gt; yp {
				j = h - 1
			} else {
				k = h + 1
			}
		}
	default:
		f := <a href="#F64" id='c:3269'>F64</a>(yp)
		for {
			if k &gt; j {
				return k - 1
			}
			h = (k + j) &gt;&gt; 1
			if <a href="#F64" id='c:3270'>F64</a>(xp+8*h) &gt; f {
				j = h - 1
			} else {
				k = h + 1
			}
		}
	}
	return 0 // not reached
}</span><span id="Flr">
func <span class='q'>Flr</span>(x K) K { // _x<span id='c:Flr' class='n'>
</span>
	var r K
	rp := <a href="#int32" id='c:3271'>int32</a>(0)
	xt := <a href="#tp" id='c:3272'>tp</a>(x)
	xp := <a href="#int32" id='c:3273'>int32</a>(x)

	if xt &lt; 16 {
		switch xt - 2 {
		case 0: // c
			return <a href="#Kc" id='c:3274'>Kc</a>(<a href="#lc" id='c:3275'>lc</a>(xp))
		case 1: // i
			return <a href="#Kc" id='c:3276'>Kc</a>(xp)
		case 2: // s
			return <a href="#Ki" id='c:3277'>Ki</a>(<a href="#int32" id='c:3278'>int32</a>(xp))
		case 3: // f
			<a href="#dx" id='c:3279'>dx</a>(x)
			return <a href="#Ki" id='c:3280'>Ki</a>(<a href="#int32" id='c:3281'>int32</a>(<a href="#F64floor" id='c:3282'>F64floor</a>(<a href="#F64" id='c:3283'>F64</a>(xp))))
		case 4: // z
			<a href="#dx" id='c:3284'>dx</a>(x)
			return <a href="#Kf" id='c:3285'>Kf</a>(<a href="#F64" id='c:3286'>F64</a>(xp))
		default:
			return x
		}
	}
	xn := <a href="#nn" id='c:3287'>nn</a>(x)
	switch xt - 18 {
	case 0: //C
		return <a href="#lower" id='c:3288'>lower</a>(x)
	case 1: //I
		r = <a href="#mk" id='c:3289'>mk</a>(Ct, xn)
		rp = <a href="#int32" id='c:3290'>int32</a>(r)
		e := rp + xn
		for rp &lt; e {
			<a href="#SetI8" id='c:3291'>SetI8</a>(rp, <a href="#I32" id='c:3292'>I32</a>(xp))
			xp += 4
			rp++
		}
	case 2: //S
		x = <a href="#use" id='c:3293'>use</a>(x)
		return <a href="#ti" id='c:3294'>ti</a>(It, <a href="#int32" id='c:3295'>int32</a>(x))
	case 3: //F
		r = <a href="#mk" id='c:3296'>mk</a>(It, xn)
		rp = <a href="#int32" id='c:3297'>int32</a>(r)
		for xn &gt; 0 {
			xn--
			<a href="#SetI32" id='c:3298'>SetI32</a>(rp, <a href="#int32" id='c:3299'>int32</a>(<a href="#F64floor" id='c:3300'>F64floor</a>(<a href="#F64" id='c:3301'>F64</a>(xp))))
			xp += 8
			rp += 4
		}
	case 4: // Z
		r = <a href="#mk" id='c:3302'>mk</a>(Ft, xn)
		rp = <a href="#int32" id='c:3303'>int32</a>(r)
		for xn &gt; 0 {
			xn--
			<a href="#SetI64" id='c:3304'>SetI64</a>(rp, <a href="#I64" id='c:3305'>I64</a>(xp))
			xp += 16
			rp += 8
		}
	default: // L/D/T
		return <a href="#Ech" id='c:3306'>Ech</a>(16, <a href="#l1" id='c:3307'>l1</a>(x))
	}
	<a href="#dx" id='c:3308'>dx</a>(x)
	return r
}</span><span id="lower">
func <span class='q'>lower</span>(x K) K {<span id='c:lower' class='n'>
</span>
	x = <a href="#use" id='c:3309'>use</a>(x)
	p := <a href="#int32" id='c:3310'>int32</a>(x)
	e := p + <a href="#nn" id='c:3311'>nn</a>(x)
	for p &lt; e {
		<a href="#SetI8" id='c:3312'>SetI8</a>(p, <a href="#lc" id='c:3313'>lc</a>(<a href="#I8" id='c:3314'>I8</a>(p)))
		p++
	}
	return x
}</span><span id="lc">
func <span class='q'>lc</span>(x int32) int32 { return x + 32*<a href="#I32B" id='c:3315'>I32B</a>(<a href="#uint32" id='c:3316'>uint32</a>(x-65) &lt; 26) }<span id='c:lc' class='n'>
</span></span>
<span id="Rev">
func <span class='q'>Rev</span>(x K) K { // |x<span id='c:Rev' class='n'>
</span>
	var r K
	t := <a href="#tp" id='c:3317'>tp</a>(x)
	if t &lt; 16 {
		return x
	}
	if t == Dt {
		r = <a href="#x0" id='c:3318'>x0</a>(x)
		return <a href="#Key" id='c:3319'>Key</a>(<a href="#Rev" id='c:3320'>Rev</a>(r), <a href="#Rev" id='c:3321'>Rev</a>(<a href="#r1" id='c:3322'>r1</a>(x)))
	}
	xn := <a href="#nn" id='c:3323'>nn</a>(x)
	if xn &lt; 2 {
		return x
	}
	r = <a href="#mk" id='c:3324'>mk</a>(It, xn)
	rp := <a href="#int32" id='c:3325'>int32</a>(r)
	for xn &gt; 0 {
		xn--
		<a href="#SetI32" id='c:3326'>SetI32</a>(rp, xn)
		rp += 4
	}
	return <a href="#atv" id='c:3327'>atv</a>(x, r)
}</span>
<span id="Wer">
func <span class='q'>Wer</span>(x K) K { // &amp;x<span id='c:Wer' class='n'>
</span>
	r := <a href="#K" id='c:3328'>K</a>(0)
	t := <a href="#tp" id='c:3329'>tp</a>(x)
	if t &lt; 16 {
		x = <a href="#Enl" id='c:3330'>Enl</a>(x)
		t = <a href="#tp" id='c:3331'>tp</a>(x)
	}
	if t == Dt {
		r = <a href="#x0" id='c:3332'>x0</a>(x)
		return <a href="#Atx" id='c:3333'>Atx</a>(r, <a href="#Wer" id='c:3334'>Wer</a>(<a href="#r1" id='c:3335'>r1</a>(x)))
	}
	xn := <a href="#nn" id='c:3336'>nn</a>(x)
	xp := <a href="#int32" id='c:3337'>int32</a>(x)
	if t == It {
		n := <a href="#sumi" id='c:3338'>sumi</a>(xp, <a href="#ep" id='c:3339'>ep</a>(x))
		r = <a href="#mk" id='c:3340'>mk</a>(It, n)
		rp := <a href="#int32" id='c:3341'>int32</a>(r)
		for i := <a href="#int32" id='c:3342'>int32</a>(0); i &lt; xn; i++ {
			j := <a href="#I32" id='c:3343'>I32</a>(xp)
			for j &gt; 0 {
				j--
				<a href="#SetI32" id='c:3344'>SetI32</a>(rp, i)
				rp += 4
			}
			xp += 4
		}
	} else if xn == 0 {
		r = <a href="#mk" id='c:3345'>mk</a>(It, 0)
	} else {
		<a href="#trap" id='c:3346'>trap</a>() //type
	}
	<a href="#dx" id='c:3347'>dx</a>(x)
	return r
}</span><span id="Fwh">
func <span class='q'>Fwh</span>(x K) K { // *&amp;x<span id='c:Fwh' class='n'>
</span>
	t := <a href="#tp" id='c:3348'>tp</a>(x)
	if t == It {
		<a href="#dx" id='c:3349'>dx</a>(x)
		p := <a href="#int32" id='c:3350'>int32</a>(x)
		e := <a href="#ep" id='c:3351'>ep</a>(x)
		for p &lt; e {
			if <a href="#I32" id='c:3352'>I32</a>(p) != 0 {
				return <a href="#Ki" id='c:3353'>Ki</a>((p - <a href="#int32" id='c:3354'>int32</a>(x)) &gt;&gt; 2)
			}
			p += 4
		}
		return <a href="#Ki" id='c:3355'>Ki</a>(nai)
	}
	return <a href="#Fst" id='c:3356'>Fst</a>(<a href="#Wer" id='c:3357'>Wer</a>(x))
}</span><span id="Typ">
func <span class='q'>Typ</span>(x K) K { // @x<span id='c:Typ' class='n'>
</span>
	<a href="#dx" id='c:3358'>dx</a>(x)
	return <a href="#sc" id='c:3359'>sc</a>(<a href="#Ku" id='c:3360'>Ku</a>(<a href="#uint64" id='c:3361'>uint64</a>(<a href="#I8" id='c:3362'>I8</a>(253 + <a href="#int32" id='c:3363'>int32</a>(<a href="#tp" id='c:3364'>tp</a>(x))))))
}</span><span id="Tok">
func <span class='q'>Tok</span>(x K) K { // `t@&#34;src&#34;<span id='c:Tok' class='n'>
</span>
	if <a href="#tp" id='c:3365'>tp</a>(x) == Ct {
		return <a href="#tok" id='c:3366'>tok</a>(x)
	} else {
		return x
	}
}</span><span id="Val">
func <span class='q'>Val</span>(x K) K {<span id='c:Val' class='n'>
</span>
	xt := <a href="#tp" id='c:3367'>tp</a>(x)
	if xt == st {
		return <a href="#lup" id='c:3368'>lup</a>(x)
	}
	if xt == Ct {
		return <a href="#val" id='c:3369'>val</a>(x)
	}
	if xt == lf || xt == xf { // lambda: (code;string;locals;arity)
		//xp := <a href="#int32" id='c:3370'>int32</a>(x)  // native: (ptr;string;arity)
		r := <a href="#l2" id='c:3371'>l2</a>(<a href="#x0" id='c:3372'>x0</a>(x), <a href="#x1" id='c:3373'>x1</a>(x))
		if xt == lf {
			r = <a href="#cat1" id='c:3374'>cat1</a>(r, <a href="#x2" id='c:3375'>x2</a>(x))
		}
		<a href="#dx" id='c:3376'>dx</a>(x)
		return <a href="#cat1" id='c:3377'>cat1</a>(r, <a href="#Ki" id='c:3378'>Ki</a>(<a href="#nn" id='c:3379'>nn</a>(x)))
	}
	if xt == Lt {
		return <a href="#exec" id='c:3380'>exec</a>(x) // .L e.g. 1+2 is (1;2;`66)
	}
	if xt &gt; Lt {
		return <a href="#r1" id='c:3381'>r1</a>(x)
	} else {
		<a href="#trap" id='c:3382'>trap</a>() //type
		return 0
	}
}</span><span id="val">
func <span class='q'>val</span>(x K) K {<span id='c:val' class='n'>
</span>
	x = <a href="#parse" id='c:3383'>parse</a>(<a href="#tok" id='c:3384'>tok</a>(x))
	xn := <a href="#nn" id='c:3385'>nn</a>(x)
	xp := <a href="#int32" id='c:3386'>int32</a>(x) + 8*(xn-1)
	a := <a href="#int32" id='c:3387'>int32</a>(0)
	if xn &gt; 2 &amp;&amp; <a href="#I64" id='c:3388'>I64</a>(xp) == 64 {
		a = 1
	}
	x = <a href="#exec" id='c:3389'>exec</a>(x)
	if a != 0 {
		<a href="#dx" id='c:3390'>dx</a>(x)
		return 0
	}
	return x
}</span><span id="Enc">
func <span class='q'>Enc</span>(x, y K) K { // x\\y<span id='c:Enc' class='n'>
</span>
	xt := <a href="#tp" id='c:3391'>tp</a>(x)
	n := <a href="#int32" id='c:3392'>int32</a>(0)
	if xt == It {
		n = <a href="#nn" id='c:3393'>nn</a>(x)
	}
	r := <a href="#mk" id='c:3394'>mk</a>(It, 0)
l:
	for {
		n--
		xi := <a href="#ati" id='c:3395'>ati</a>(<a href="#rx" id='c:3396'>rx</a>(x), n)
		r = <a href="#Cat" id='c:3397'>Cat</a>(r, <a href="#Enl" id='c:3398'>Enl</a>(<a href="#idiv" id='c:3399'>idiv</a>(<a href="#rx" id='c:3400'>rx</a>(y), xi, 1)))
		y = <a href="#idiv" id='c:3401'>idiv</a>(y, xi, 0)
		if n == 0 || (n &lt; 0 &amp;&amp; <a href="#int32" id='c:3402'>int32</a>(y) == 0) {
			break
		}
		if <a href="#tp" id='c:3403'>tp</a>(y) &gt; 16 &amp;&amp; n &lt; 0 {
			if <a href="#sumi" id='c:3404'>sumi</a>(<a href="#int32" id='c:3405'>int32</a>(y), <a href="#ep" id='c:3406'>ep</a>(y)) == 0 {
				break l
			}
		}
	}
	<a href="#dxy" id='c:3407'>dxy</a>(x, y)
	return <a href="#Rev" id='c:3408'>Rev</a>(r)
}</span><span id="Dec">
func <span class='q'>Dec</span>(x, y K) K { // x//y   {z+x*y}/[0;x;y]<span id='c:Dec' class='n'>
</span>
	if <a href="#tp" id='c:3409'>tp</a>(y) &lt; 16 {
		<a href="#trap" id='c:3410'>trap</a>() //type
	}
	r := <a href="#Fst" id='c:3411'>Fst</a>(<a href="#rx" id='c:3412'>rx</a>(y))
	n := <a href="#nn" id='c:3413'>nn</a>(y)
	for i := <a href="#int32" id='c:3414'>int32</a>(1); i &lt; n; i++ {
		r = <a href="#Add" id='c:3415'>Add</a>(<a href="#ati" id='c:3416'>ati</a>(<a href="#rx" id='c:3417'>rx</a>(y), i), <a href="#Mul" id='c:3418'>Mul</a>(<a href="#ati" id='c:3419'>ati</a>(<a href="#rx" id='c:3420'>rx</a>(x), i), r))
	}
	<a href="#dxy" id='c:3421'>dxy</a>(x, y)
	return r
}</span><span id="zk">
func <span class='q'>zk</span>() {<span id='c:zk' class='n'>
</span>
	<a href="#Data" id='c:3422'>Data</a>(280, &#34;`k`l`a`b`while`\&#34;rf.\&#34;`\&#34;rz.\&#34;`\&#34;uqs.\&#34;`\&#34;uqf.\&#34;`\&#34;gdt.\&#34;`\&#34;lin.\&#34;`\&#34;odo.\&#34;`\&#34;grp.\&#34;\n`x:,/+\&#34;0123456789abcdef\&#34;@16 16\\256!256+\n`t:`39\n`p:`46\n`uqs:{x@&amp;1,1_~x~&#39;x@-1+!#x:^x}\n`uqf:{x@&amp;(!#x)=x?x}\n`gdt:{[t;g]($[g;{x@&gt;y x};{x@&lt;y x}])/(,!#t),|.t}\n`odo:{{y@(#y)!!x}/[*/x;&amp;&#39;x#&#39;|*\\-1_1,|x]}\n`grp:{(x@*&#39;g)!g:(&amp;~a~&#39;a@-1+!#a:x i)^i:&lt;x}\nabs:`32;sin:`44;cos:`45;find:`31;imag:`33;conj:`34;angle:`35;exp:`42;log:`43\n`pad:{x@\\!|/#&#39;x}\n`lxy:{\nkt:{[x;y;k;T]x:$[`T~@x;T[x;k];`<a href="#pad" id='c:3423'>pad</a>(\&#34;\&#34;;\&#34;-\&#34;),$x];(x,&#39;\&#34;|\&#34;),&#39;T[y;k]}\nd:{[x;k;kt;T]r:!x;x:.x;$[`T~@x;kt[r;x;k;T];,&#39;[,&#39;[`<a href="#pad" id='c:3424'>pad</a>(k&#39;r);\&#34;|\&#34;];k&#39;x]]}\nT:{[x;k]$[`L?@&#39;.x;,k x;(,*x),(,(#*x)#\&#34;-\&#34;),1_x:\&#34; \&#34;/&#39;+`pad@&#39;$(!x),&#39;.x]}\nt:@y;k:`kxy@*x;h:*|x\ndd:(\&#34;\&#34;;,\&#34;..\&#34;)h&lt;#y:$[(@y)?`L`D`T;y;y~*y;y;[t:`L;,y]]\ny:$[y~*y;y;(h&amp;#y)#y]\n$[`D~t;d[y;k;kt;T];`T~t;T[y;k];y~*y;,k y;k&#39;y],dd}\n`l:`lxy 70 20\n`str:{q:{c,(\&#34;\\\\\&#34;/(0,i)^@[x;i;(qs!\&#34;tnr\\\&#34;\\\\\&#34;)x i:&amp;x?\\qs:\&#34;\\t\\n\\r\\\&#34;\\\\\&#34;]),c:_34}\n$[|/x?\\\&#34;\\t\\n\\r\&#34;__!31;\&#34;0x\&#34;,`x@x;q x]}\n`kxy:{\na:{t:@x;x:$x;$[`c~t;`str x;`s~t;\&#34;`\&#34;,x;x]}\nd:{[x;k]r:\&#34;!\&#34;,k@.x;n:#!x;x:k@!x;$[(n&lt;2)|(@.x)?`D`T;\&#34;(\&#34;,x,\&#34;)\&#34;;x],r}\nv:{[x;k;m]t:@x;x:(m&amp;n:#x)#x\nx:$[`L~t;k&#39;x;`C~t;x;$x]\nx:$[`C~t;`str x;`S~t;c,(c:\&#34;`\&#34;)/x;`L~t;$[1~n;*x;\&#34;(\&#34;,(\&#34;;\&#34;/x),\&#34;)\&#34;];\&#34; \&#34;/x]\n$[m&lt;#x:((\&#34;\&#34;;\&#34;,\&#34;)(1~n)),x;((m-2)#x),\&#34;..\&#34;;x]}\nt:@y;k:`kxy x\n$[`T~t;\&#34;+\&#34;,d[+y;k];`D~t;d[y;k];0~#y;(`C`I`S`F`Z`L!(\&#34;\\\&#34;\\\&#34;\&#34;;\&#34;!0\&#34;;\&#34;0#`\&#34;;\&#34;0#0.\&#34;;\&#34;0@0a\&#34;;\&#34;()\&#34;))t;y~*y;a y;v[y;k;x]]}\n`k:`kxy 1000000\n`d:{x-(*x),-1_x}\n`rf: {.5+(x?0)%4294967295.}\n`rf1:{.5+(1.+x?0)%4294967295.}        \n`rz: {(%-2*log `rf1 x)@360.*`rf x}\n&#34;)
	zn := <a href="#int32" id='c:3425'>int32</a>(1425) // should end before 2k
	x := <a href="#mk" id='c:3426'>mk</a>(Ct, zn)
	<a href="#Memorycopy" id='c:3427'>Memorycopy</a>(<a href="#int32" id='c:3428'>int32</a>(x), 280, zn)
	<a href="#dx" id='c:3429'>dx</a>(<a href="#Val" id='c:3430'>Val</a>(x))
}</span>
<hr/><span id="z.k"><h2>z.k</h2>
z.k is placed in the initial memory section at 600 by <a href='#zk'>zk</a> called from <a href='#kinit'>kinit</a>
it contains the runtime part of the interpreter that is written in k. it also prepopulates the <a href="#symtab">symbol table</a>.

todo: s-dot@ k@ l@ space sin/cos..
/        64     72    80    88     96     104    112    120    128                 
`k`l`a`b`while`&#34;rf.&#34;`&#34;rz.&#34;`&#34;uqs.&#34;`&#34;uqf.&#34;`&#34;gdt.&#34;`&#34;lin.&#34;`&#34;odo.&#34;`&#34;grp.&#34; /

`x:,/+&#34;0123456789abcdef&#34;@16 16\256!256+  /`x@ hex
`t:`39         /`t@ token
`p:`46         /`p@ parse

`uqs:{x@&amp;1,1_~x~&#39;x@-1+!#x:^x}                  /?^x
`uqf:{x@&amp;(!#x)=x?x}                            /?xL
`gdt:{[t;g]($[g;{x@&gt;y x};{x@&lt;y x}])/(,!#t),|.t}  /&lt;t &gt;t  grade table

`odo:{{y@(#y)!!x}/[*/x;&amp;&#39;x#&#39;|*\-1_1,|x]}       /!I (odometer)
`grp:{(x@*&#39;g)!g:(&amp;~a~&#39;a@-1+!#a:x i)^i:&lt;x}      /=x

abs:`32;sin:`44;cos:`45;find:`31;imag:`33;conj:`34;angle:`35;exp:`42;log:`43

/ pretty print  `l@x  `k@x
`pad:{x@\!|/#&#39;x}

`lxy:{ /k
 kt:{[x;y;k;T]x:$[`T~@x;T[x;k];`pad(&#34;&#34;;&#34;-&#34;),$x];(x,&#39;&#34;|&#34;),&#39;T[y;k]}
 d:{[x;k;kt;T]r:!x;x:.x;$[`T~@x;kt[r;x;k;T];,&#39;[,&#39;[`pad(k&#39;r);&#34;|&#34;];k&#39;x]]}
 T:{[x;k]$[`L?@&#39;.x;,k x;(,*x),(,(#*x)#&#34;-&#34;),1_x:&#34; &#34;/&#39;+`pad@&#39;$(!x),&#39;.x]}
 t:@y;k:`kxy@*x;h:*|x
 dd:(&#34;&#34;;,&#34;..&#34;)h&lt;#y:$[(@y)?`L`D`T;y;y~*y;y;[t:`L;,y]]
 y:$[y~*y;y;(h&amp;#y)#y]
 $[`D~t;d[y;k;kt;T];`T~t;T[y;k];y~*y;,k y;k&#39;y],dd}

`l:`lxy 70 20

`str:{q:{c,(&#34;\\&#34;/(0,i)^@[x;i;(qs!&#34;tnr\&#34;\\&#34;)x i:&amp;x?\qs:&#34;\t\n\r\&#34;\\&#34;]),c:_34}
 $[|/x?\&#34;\t\n\r&#34;__!31;&#34;0x&#34;,`x@x;q x]}

`kxy:{ /k m t n
 a:{t:@x;x:$x;$[`c~t;`str x;`s~t;&#34;`&#34;,x;x]}
 d:{[x;k]r:&#34;!&#34;,k@.x;n:#!x;x:k@!x;$[(n&lt;2)|(@.x)?`D`T;&#34;(&#34;,x,&#34;)&#34;;x],r}
 v:{[x;k;m]t:@x;x:(m&amp;n:#x)#x
  x:$[`L~t;k&#39;x;`C~t;x;$x]
  x:$[`C~t;`str x;`S~t;c,(c:&#34;`&#34;)/x;`L~t;$[1~n;*x;&#34;(&#34;,(&#34;;&#34;/x),&#34;)&#34;];&#34; &#34;/x]
  $[m&lt;#x:((&#34;&#34;;&#34;,&#34;)(1~n)),x;((m-2)#x),&#34;..&#34;;x]}
 t:@y;k:`kxy x
 $[`T~t;&#34;+&#34;,d[+y;k];`D~t;d[y;k];0~#y;(`C`I`S`F`Z`L!(&#34;\&#34;\&#34;&#34;;&#34;!0&#34;;&#34;0#`&#34;;&#34;0#0.&#34;;&#34;0@0a&#34;;&#34;()&#34;))t;y~*y;a y;v[y;k;x]]} /344
 
`k:`kxy 1000000
`d:{x-(*x),-1_x}  /deltas

/random
`rf: {.5+(x?0)%4294967295.}           /?n (uniform)  e.g. ?100
`rf1:{.5+(1.+x?0)%4294967295.}        
`rz: {(%-2*log `rf1 x)@360.*`rf x}    /?-n (normal)  ?z (binormal)   ?-100   ?100a
</span><hr/><span id="intro"><h2>intro</h2>
ktye/k is an implementation of the k programming language.
this page documents the implementation of the interpreter.
it is not an introduction to k or array programming in general.

the focus of the implementation is a simple system at small size, portability and the possibility
to embed and extend it into applications.

 size     is measured in bytes of the wasm binary, below 40k. the actual size in bytes is the
          number in the banner of the repl.
 port     the source code looks like go but it isn't. it's a structural assembly language that
          also happens to satisfy the go compiler.
          a <a href="https://github.com/ktye/wg">separate compiler</a> parses the source and writes a k table <a href="#ir">intermediate representation</a>.
	  <a href="#compilers">compilers</a> written in k transform the IR to other languages: <a href="#cc">c</a> <a href="#go">go</a> <a href="#wasm">wasm</a> <a href="#wasi">wasi</a>.
	  the fact that the source can also be directly compiled with a go compiler simplifies
	  bootstrapping testing and development by no small amount.
 embed    ..
 extend   ..

try/compile/run
try in the repl above, or see the any of the ports <a href="#cc">c</a> <a href="#go">go</a> <a href="#wasm">wasm</a> <a href="#wasi">wasi</a> <a href="#f77">fortran</a>.
</span><hr/><span id="invoke"><h2>invoke</h2>
$k              /interactive
$k a.k b.k      /run both files in order, drop to interactive mode
$k a.k -e       /run a.k then exit
$k a.k -e 'f x' /run a.k, eval f x then exit
$k k.t          /runs tests, e.g. <https://raw.githubusercontent.com/ktye/i/master/k.t>k.t</a>
-e stands for both: exit and eval.
</span><hr/><span id="types"><h2>k type system</h2>
k values are represented by a 64 bit integer called K in the go implementation.
depending on the type, the value has a different meaning.
the type is stored in the upper 5 bits (and accessed by t := x&gt;&gt;59).
t&lt;16 are atoms and t&gt;16 are vectors/compound types
vector types t&lt;23 are flat
the base type of atoms or vectors is t&15

 atoms      t  t  vectors         t functions         t compound
 c char     2  18 C chars         0 v primitives      23 L list
 i int32    3  19 I ints         10 m compositions    24 D dict
 s symbol   4  20 S symbols      11 d derived         25 T table
 f float64  5  21 F floats       12 p projections
 z complex  6  22 Z complexs     13 l lambda
                                 14 x native/extern

values of type c i s carry their value withing the k value in the lower 32 bits.
all other values live in heap memory. the lower 32 bits are the index to the start of the data section.
flat vectors of type I S F Z store their vector data consecutive as 4 4 8 16 byte widths per element.
compound types m d p l x L D T store 64 bit k values in the data section.
the length of vector values is accessed by <a href="#nn">nn</a> and stored as int32 12 bytes before the data.
values the live in heap memory also have their <a href="#allocator">refcount</a> stored at 4 bytes before the data.

L is a general list that <a href="#uf">collapses/unifies</a> to flat vector if all values are atoms of the same type.
D and T are always a 2 element list (keys and values of the same length) and their length field stores the length of the keys.
D and T only differ by type, but a table is more restricted: it's keys must be symbols and values a general list (L)
each containing a vector of the same size.

the function types m d p l x store:
 m(function-list)                   forming the composition <a href="#calltrain">call train</a>
 d(base-function;adverb)            the adverb value is the function table index at 85 + <a href="#Ech">1</a> <a href="#Rdc">2</a> <a href="#Scn">3</a> 
 p(base-function;arglist;emptylist) <a href="#callprj">call projection</a>
 l(code;string;locals)              <a href="#lambda">call lambda</a>. code is the <a href="#kvm">instruction list</a> and locals a list of symbols including the arguments. the length field stores the arity.
 x(index/ptr;string)                <a href="#native">call native</a>, see <a href="#extend">extend</a>

primitive verbs store a value between 0 and 64 that corresponds to the index into the indirect function table defined in <a href="#init">init</a>.
primitives are ambivalent, their value corresponds to the monadic case and is <i>fixed</i> at call time, 
e.g. when called with two arguments the function tables is indexed at value x+64.

some k values also store the source location offset in the lower bits of the upper 32 bit value.
the offset is retrieved by 0xffffff & int32(x&gt;&gt;32) at execution time and stored in the global <i>srcp</i>.
it is the offset to the executed source code which is stored in a k value written to <a href="#src">16</a> in the <a href=#heap>heap</a>.
all k source is catenated to this value by the parser.
</span><hr/><span id="literals"><h2>literals</h2>
literals are parsed by the <a href="#tok">tokenizer</a>.
the functions <a href="#tchr">tchr</a> <a href="#tnms">tnms</a> <a href="#tvrb">tvrb</a> <a href="#tpct">tpct</a> <a href="#tvar">tvar</a> <a href="#tsym">tsym</a> parse characters, numbers, primitive verbs, punctuation, variables and symbols.
<span id="classes">
class  bytes
  1    :+-*%!&amp;|&lt;&gt;=~,^#_$?@.&#39;/\
  2    abcdefghijklmnopqrstuvxwyzABCDEFGHIJKLMNOPQRSTUVWXYZ
  4    0123456789
  8    &#39;/\
 16    ([{
 32    \n;)]}
 64    abcdefghijklmnopqrstuvxwyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789)]}
128    0123456789abcdef
</span>

<a href="#is">is</a>(b,c) tests if the char value b belongs to class c. classes can can also be combined:
e.g. <a href="#tvar">tvar</a> tests if the first character is in class 2 (alphabetic) and the following characters are alphanumeric 2+4.

type  literal
 c    "a" or 0x23
 i    -123
 f    .5  leading/trailing 0 may be omitted
 s    `ab or `"anything" shortform only for valid varnames
 z    1.5a30  abs and angle in degree, both maybe floats, 3a is 3a0

vector types are combined                  lists
 C     "ab"                                (1;(2;3 4);5)   (1;2;3) single element lists collapse to 1 2 3
 I     1 2      single space only          dicts have no literal form, use the functional form   `a`b!2 3
 F     3 4.2 5  any float promotes to F                                              or !/+-2^(`a;2;`b;3)
 S     `a`b`c                              tables are flipped dicts:                      +`a`b!(2 3;4 5)
 Z     1a 2a30                             also key tables S!T and T!T
</span><hr/><span id="adverbs"><h2>adverbs</h2>
</span><hr/><span id="control"><h2>control flow</h2>
</span><hr/><span id="heap"><h2>heap memory</h2>
the <a href="#mach">abstract machine</a> has access to a linear range of heap memory. memory can only <a href="#Memorygrow">grow</a> but never shrinks.
in the initial state it's size is one block of 64kb. addresses are byte indexes into the memory section.
low addresses have special meaning, setup by <a href="#init">init</a> or created by <a href="#kinit">kinit</a>.
memory above 4k is managed by the <a href="#allocator">allocator</a> and used to store k values.

byte-addr
   0....7  keys see <a href=#symtab>symbol table</a>
   8...15  vals
  16...19  <a href="#src">src</a>(int32) catenated for <a href="#trap">error indication</a>
  20..127  free list see <a href="#allocator>memory allocator</a>
 128..131  currently allocated memory (log2)
 132..226  <a href="#class">character classes</a> for the parser (starts at 100) ⎫
 228..252  :+-*%!&|<>=~,^#_$?@.':/:\:                                     ⎬ text section
 253..279  vbcisfzldtcdpl000BCISFZLDT  type symbols                       ⎮
 280.....  <a href="#z.k">z.k</a> (embedded source)                                          ⎭
 2k....4k  <a href="#kvm">kvm</a> stack
 4k....4g  vector-space
</span><hr/><span id="allocator"><h2>memory allocator</h2>
memory is allocated by the k implementation by dividing the linear memory section to chunks on request.
if more memory is needed, the total memory section grows before dividing it.
it is a buddy allocator, that divides by chunck sizes of powers of two.
memory is requested by <a href=#mk>mk(t,n)</a> which <i>makes</i> a k value for the given type and number of elements.
e.g. r := mk(19,1000) creates an integer vector with 1000 elements.
the required size is 4000 to store 1000 int32 values + a 16 byte header, so 4016.
the next power-of-2 block size where it fits into is 4096 or 2^12, called a block of bucket type 12.
the smallest block is type 5 or 32 bytes with space for 16 chars, 4 ints or 2 floats (or other k values) or 1 complex number.

the allocator keeps a free list (linked-list) for each bucket type t in the heap memory at 4*t.
so I32(4*12) returns memory index to the start of the next free block for a type-12 memory chunck.
it also writes the next free block to the free list at the top location SetI32(4*12, ..).

when no free chuck is available for the given type, the next larger chunck is tried and splitted into two.
when nothing is found, total memory is doubled.

memory is freed when it's refcount drops to 0 by calls to <a href="#dx">dx</a> which calls <a href="#mfree">mfree</a>.
in this case it is prepended to the free list at it's bucket size location, and stores index of the current free block in it's memory.
memory is never released to the system.
divided blocks are also never merged to larger blocks. to prevent an accumulation of small chuncks, no primitive splits memory.
memory is only reused if the refcount is 1 and the new value has the same bucket type (e.g. when dropping the last value from a vector).

 <a href="#mk">mk(t,n)</a> make k value, also shortcuts <a href="#Kc">Kc</a> <a href="#Ki">Ki</a> <a href="#Kf">Kf</a> a href=#Kz">Kz</a> for atoms,
 <a href="#l2">l2(x,y)</a> make a list of two k values
 <a href="#rx">rx(x)</a> increase refcount, <a href="#dx">dx(x)</a> decrease refcount (from derive: d/dx)
 <a href="#rl">rl(x)</a> increase refcount of each value of a list, but not x itself
also low level <a href="#alloc">alloc</a> <a href="#mfree">mfree</a> <a href="#bucket">bucket</a>.
</span><hr/><span id="symtab"><h2>symbol table</h2>
symbols are stored as interned strings. their value is 32 bit integer.
the integer is an offset to the symbol table, a k list of chars stored at memory location 0.
e.g. we can use `i@ to convert a list of symbols to their integer value: `i ``x`y`z returns 0 8 16 24.

the symbol table needs to be searched only once for each symbol: when it is created by the tokenizer.
<a href="#tsym">tsym</a> uses <a href="#sc">sc</a> symbol from char which returns a symbol value with the correct offset.
if the symbol is new, the character vector for the new symbol is appended to the symbol table. that means the value at memory 0 point to a new location.

symbol values depend on the creation order. <a href="#z.k">z.k</a> is executed first and parses a set of symbols that should have known values, such as
`x`y`z the <i>while</i> keyword and some k implementations of primitives that use <a href="#kx">kx</a> and <a href="#kxy">kxy</a>.

the symbol offset values also serve a second purpose: they serve as the offset in the <b>lookup table for variables</b>.
variables are stored in a k list of type L that is stored at location 8.
both lists (keys at 0 and values at 8) are always in sync and append-only.
variable lookup never searches, it already knows it's offset. but it uses two indirections as the number of symbols or variables is not restricted.

as a consequence there is no <i>value error</i> for undefined variables:
when parsing the symbol for a variable that does not exist, both the symbol table and the value list is extended. the new value is 0 (the verb not the integer).

the value list is the only location where variables are stored. both local and global variables.
opposed to most other implementations of k, variables have dynamic scope and there is no k-tree or namespaces.

<span id="#scope">dynamic scope means, lambda function arguments and their local variables shadow variables with the same name.
when a lambda function is called, the values corresponding to the same symbol as the locals are saved and restored when the function returns.
this also means that a lambda function can modify a local variable of it's caller when it is treated as a global variable.
</span></span><hr/><span id="kvm"><h2>kvm - virtual machine - instruction set</h2>
</span><hr/><span id="ir"><h2>intermediate representation</h2>
the IR stores the parse tree of the source of the k interpreter as a k table.
this is about the source notation and the compilers that transpile it to other languages not about the execution of k code, see <a href="#kvm">kvm</a> for the latter.

node type                    i-value             s-value
 prg     root node           -                   prog/libname    first node only
 mem     memory segment      #64k blocks         `a|`b           a|b: memory1|memory2
 con     constant            -                   name            child: lit
 var     global variable     -                   name            child: lit
 lit     literal (con|var)   val(32bit)|C-index  type
 tab     func table entry    index               func name
 fun     function            exported            func name       children: args res locs ast dfr
 arg     func argument       -                   type            child: sym
 sym     symbol              1(global)|0N(func)  name
 res     return value        -                   type            unnamed
 loc     local var decl      -                   type            child: sym
 ast     func ast root       -                   -               one per func
 stm     statement list      -                   -
 ret     return              -                   `|type          children: return values, s-type only for single res
 cal     function call       -                   func name       children: args
 cli     indirect call       #args               res-type        children: func-expr args arg-types
 drp     drop return vals    -                   -               child: cal
 get     get local           -                   varname
 Get     get global          -                   varname
 lod     load                -                   type(bijf)      child:    addr
 sto     store               -                   type(bijf)      children: addr, value
 asn     assignment          1(global)           varname         children: expr
 cst     cast                -                   dst type        2 children: typ(src), arg
 typ     type                -                   type
 cnd     if condition        -                   `|result-type   2|3 children: if then [else]
 swc     switch              1(has default)      `|result-type   children: expr cases [default]
 jmp     break/continue      1(break)|0(cont)    label
 for     loop                1(simple)           label           children: (cond|nop) (post|nop) body
 dfr     defer stmt node     -                   -               child: cal
 nop     ignore              -                   -
unary operator nodes
 neg|not                     1                   type            1 child
binary operator nodes
 eql|les|mor|gte|lte|and|orr 2                   type            2 children
 add|sub|mul|div|mod|shr|shl	
 xor|neq|ant(andnot)|bnd|bor(&& ||)			     
 
types: `i`u`j`k`f!(i32;u32;i64;u64;f64)
</span><hr/><span id="mach"><h2>abstract machine model</h2>
 the <a href="#ir">IR</a> targets an abstract machine model that the target languages need to implement.
 it is roughly based on the characteristics of wasm:
 - basic data types are i32 i64 f64
 - infinite set of registers (local variables) 
 - one linear memory section (heap) addressable by a 32bit index (0..)
 - memory can grow by sections of 64k but never shrinks
 - code and data are separated, no jit
 - in addition to i32 i64 f64, heap can read/write a <a href="#I8">single byte as i32</a>
 - heap access must be aligned to the size of the data type
 - no stack, use locals or heap, no pointers to local variables, call by value
 - no multi return values
 - only wasm floating point ops are available, e.g. f64.sqrt everyting else is implemented in software, e.g. <a href="#cosin_">sin cos</a> <a href="#exp">exp</a>
 - undefined order of evaluating of function arguments
 - sequential operations, no threads
 - a function table and indirect calls by index is available (e.g. array of function pointers)
 - global variables
 - structured type safe control flow: <a href="#if">if</a> <a href="#if-else">if-else</a> <a href="#loop">loop</a> <a href="#jump-table">jump-table</a>

no-multi-return and undefined-order-of-evaluation was added to make the c target simpler.
an earlier compiler generated ssa temporaries for c to enforce the evaluation order which bloats the generated source and makes it hard to read.

intrinsic functions 
some builtins are represented as function calls instead of IR nodes and are implemented individually by the target language runtime:

 <span id="int32"     >int32(any)                   : convert to i32, e.g. int32(K) takes the lower 32 bit of a k value</span>
 <span id="int64"     >int64(any)                   : convert to i64, e.g. int64(K) is usually a non-op but required by Go's type system</span>
 <span id="float64"   >float64(any)                 : convert to f64</span>
 <span id="F64reinterpret_i64">F64reinterpret_i64(x): reinterpret/cast u64 value as f64</span>
 <span id="I64reinterpret_f64">I64reinterpret_f64(x): reinterpret/cast f64 value as i64</span>
 <span id="I8"        >I32(addr)                    : get byte as i32 from heap</span>
 <span id="I32"       >I32(addr)                    : get i32 from heap</span>
 <span id="I64"       >I64(addr)                    : get i64 from heap</span>
 <span id="F64"       >F64(addr)                    : get f64 from heap</span>
 <span id="SetI8"     >I32(addr)                    : set byte at addr to i32 low byte value</span>
 <span id="SetI32"    >SetI32(addr,value)           : set heap at addr to i32 value</span>
 <span id="SetI64"    >SetI64(addr,value)           : set heap at addr to i64 value</span>
 <span id="SetF64"    >SetF64(addr,value)           : set heap at addr to f64 value</span>
 <span id="I32clz"    >I32clz(x)                    : count leading zeros</span>
 <span id="Memory"    >Memory(blocks)               : declare the number of blocks of initial memory</span>
 <span id="Data"      >Data(offset,bytes)           : prepopulate initial memory at offset</span>
 <span id="Export"    >Export(functions..)          : declare exported functions, e.g. for wasm</span>
 <span id="Functions" >Functions(offset,functions..): add functions to function table at offset</span>
 <span id="Memorycopy">Memorycopy(d,s,n)            : e.g. memcpy in c, in wasm it needs bulk memory instructions</span>
 <span id="Memorysize">Memorysize()                 : returns the current number of blocks of the memory section</span>
 <span id="Memorygrow">Memorygrow(blocks)           : grows the memorysection by the given number of 64k blocks</span>
 <span id="Data"      >Data(off,string)             : initializes memory at offset</span>
 <span id="panic"     >panic(x)                     : traps on k errors, e.g. unreachable in wasm. it is up to the embedder to recover</span>

in the bootstrap interpreter k.go they are defined and imported from <a href="https://raw.githubusercontent.com/ktye/wg/master/module/module.go">wg/module/module.go</a>
</span><hr/><span id="syscalls"><h2>system interface</h2>
the abstrace machine requires a set of simplified syscalls.
all arguments except for Native() are 32 bit integers:

 <span id="Args"      ><a href="#getargv">Args()</a>         :return number of command line arguments</span>
 <span id="Arg"       ><a href="#getargv">Arg(i,r)</a>       :call twice: first with r=0 returns the size of the argument, call again with allocated memory index in r</span>
 <span id="Read"      ><a href="#readfile">Read(f,n,d)</a>    :call twice: first with d=0 returns the size of the argument, call again with allocated memory index in r
                 n is the length of the filename and f it's memory index</span>
 <span id="Write"     ><a href="#writefile">Write(f,n,b,m)</a> :write content at b and length m to file with name at f with length n</span>
 <span id="ReadIn"    ><a href="#readfile">ReadIn(d,n)</a>    :read from stdin at most n bytes and write to d. return number of bytes written</span>
 <span id="Native"    ><a href="#cal">Native(x,y)</a>    :<a href="#extend">native</a> function call x,y are 64bit. the native function is registered at x (e.g. an index or a pointer) and
                 called with argument list y (a k value).</span>
 <span id="Exit"      ><a href="#repl">Exit(c)</a>        :exit with code c</span>
the reference implementation is imported from <a href="https://raw.githubusercontent.com/ktye/wg/master/module/system.go">wg/module/system.go</a>
the wasm version imports the system interface as an import module implemented in js which can be different for each application,
e.g. a Write call may write to an in-memory file system, trigger a download or use the file system api.
</span><hr/><span id="extend"><h2>extend</h2>
the k interpreter can be extended when <a href="#embed">embedded</a> to a host application assigning native functions to a k variable.
a native function is represented as a k value with type 14 that contains a list of two values: an identifier for
the host system and the string form.
the identifier may be an index to a table of registered native functions,
e.g. as a k-verb (type 0) to prevent refcounting, or a pointer disguised as a character vector.
native function have <b>fixed arity</b>. the arity is stored in the <a href="#types">length field</a>.
when called, the argument list has the length of the arity, otherwise a projection/error is triggered
before the native function call.

there is also a mild protection for k variables used in <a href="#z.k">z.k</a> which can be used in any k source:
monadic functions assigned to a symbol including the backtick, e.g. `f:{+/x} use the symbol with a dot attached internally.
these functions are called as overloads to @ e.g. with `f 2 3 4.
z.k defines `x(hex) `t(token) `p(parse) `c(as-chars) `i(as-ints) `s(as symbols) `f(as-floats) `z(as-complexs)
`(int) converts the numeric value of a basic verb or instruction to verb type(0). e.g. `@'1 2 3 is (:;+;-)
</span><hr/><span id="embed"><h2>embed</h2>
</span><hr/><span id="f77"><h2>fortran</h2>
compile with: gfortran <a href="https://github.com/ktye/i/releases/download/latest/k.f">k.f</a>
</span><hr/><span id="c"><h2>c</h2>
</span><hr/><span id="wasm"><h2>WebAssembly</h2>
</span><hr/><span id="wasi"><h2>WebAssembly (standalone/wasi)</h2>
</span></pre>
<pre id="mono">M 0 1 2 3 4 5 6 7 8 9 0</pre>
</body>
