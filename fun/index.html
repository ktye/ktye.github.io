<!DOCTYPE html>
<head><meta charset="utf-8">
<link rel="icon" type="image/png" sizes="16x16" href="../kelas16.png">
<title>k/fun</title>
<style>
body{font-family:georgia,serif;margin:0;width:100vw;overflow:hidden}
table{margin:1em}
table,th{border:1px solid}td{border-right:1px solid}th{background:#eee}
table,th,td{border-collapse:collapse}
td{text-align:center}
h2{margin:0}
pre{background:#eee;margin:1em}
.l{color:blue}
.l:hover{cursor:pointer}
#t{background:black;color:white;height:10em;line-height:1;padding:3px;margin:0;outline:none;overflow:hidden}
</style>
</head><body onload="kinit()">

<iframe src="c.html" style="width:100vw;height:30vh;resize:vertical"></iframe>

<div style="display:flex;flex-direction:row;width:100vw">

<div style="width:calc(70vw - 10px);height:70vh;overflow:auto">
<h2 id="typ">types</h2>
<table>
<tr><th>type </th><th> num  </th><th> what         </th><th> log2 </th><th> bits/element </th></tr>
<tr><td>     </td><td> 0    </td><td> list         </td><td> 3    </td><td> 64           </td></tr>
<tr><td>b    </td><td> 1    </td><td> bool         </td><td> 0    </td><td> 8            </td></tr>
<tr><td>c    </td><td> 2    </td><td> char         </td><td> 0    </td><td> 8            </td></tr>
<tr><td>i    </td><td> 3    </td><td> int          </td><td> 2    </td><td> 32           </td></tr>
<tr><td>e    </td><td> 4    </td><td> float        </td><td> 2    </td><td> 32           </td></tr>
<tr><td>g    </td><td> 5    </td><td> geo(complex) </td><td> 3    </td><td> 64           </td></tr>
</table>
<pre>L[]={3,0,0,2,2,3}      log2 sizes are stored in L</pre>

<h2 id="lay">memory layout</h2>
the k value is a 64-bit pointer type called <code>U</code>.
small atoms are stored in the k value itself:
<pre>
#define t(t,x) ((U)(t)<<61|(x))     the type is stored in the high bits
</pre>
the functions <code>tb,tc,ti,te</code> (types 1 to 4) create bool, char, int and float atoms.</p>

for larger types the pointer in the k value points to the array part and the type is stored in the header 5 bytes before.
<pre>
-32      -8    -4     0            array layout in memory
[padding][rrit][nnnn][array data]  rr: 16bit refcout
                      â†‘pointer      i: bucket type,  t:k-type,  nnnn:32bit element count
</pre>

the type is accessed by the macros
<pre>
#define tx (x>>61)   /for tagged atoms
#define Tx sx[-5]    /for values stored in memory
</pre>
<code>tx</code> returns 0 if the values are stored in memory and is also used to check if it's a small or large value.

<h2 id="mem">bucket allocator</h2>
<pre>
          4   1k    14   1m    24  1g
          5   2k    15   2m    25  2g
          6   4k    16   4m    26  4g
          7   8k    17   8m    27  8g
          8  16k    18  16m    28 16g
          9  32k    19  32m    29 32g
0  64    10  64k    20  64m
1 128    11 128k    21 128m    
2 256    12 256k    22 256m    bucket type
3 512    13 512k    23 512m    and space(bytes)
</pre>
memory is managed in blocks. there is only one allocation(mmap) at the start of the program of 32gb of virtual memory.
the memory is stored in the free list <code>M[29]</code>. all other buckets <code>M[0..]</code> are initially empty(zero value).</p>

when a block of memory is requested, the required bucket type is calculated and the first free block of that type is returned.
if there is none, the next larger block is requested and split into two.
this is done by the function <code>M_</code> recursively. the function takes the bucket type as argument <code>x</code> and returns a pointer.
<pre>
Ui(M_,Ux=M[i];x?(W+=1&lt;&lt;i,M[i]=xx,x):30>i?_M(i,M_(i+1))+(2*n0&lt;&lt;i):OO())
</pre>
<code>W</code> stores the total allocated memory.
a free block of memory contains a pointer to the next free block at the start.
splitting is done by freeing the next larger block as a smaller one (half size).
<code>_M</code> releases memory, it has two arguments bucket type and pointer: <code>f</code> and <code>x</code> and returns the input pointer:
<pre>
g(_M,W-=1&lt;&lt;f;xx=M[f];M[f]=x)
</pre>
in fact when a larger block is split, the lower part is used and the upper part is not touched only referenced in the free list, such that the operating system can lazily allocate memory.

<h2 id="ref">reference counting</h2>
large k values are refcounted. the refcount 0 when the value is used once and freed when a value with refcount 0 is no longer used.
<code>r_</code> checks if the k value lives in memory and increases the refcount. it aborts if the refcount overflows 16bits.
<pre>
f(r_,px||tx?x:M1&++rx?x:OO())
f(_r,P(px||tx,x)P(M1&rx,--rx;x)if(!Tx)n(_r(xU))_M(mx,x-n0);x)</pre>
<code>_r</code> decreases the refcount.
if it was used only once, it frees memory.
if the value is compound (e.g. a general list) it recursively unrefs it's elements before freeing the block.</br>
the macros <code>Tx rx mx</code> access type, refcount and bucket type from the array header.

<h2 id="prs">parse</h2>
<h2 id="exe">execute</h2>
<h2 id="vrb">verbs</h2>
<h2 id="sys">syscalls</h2>
<h2 id="smd">vector instructions</h2>
<script>


let g=x=>document.getElementById(x)
let t=g("t"),j=g("j") //t:console(content-editable pre element)
let O=s=>{t.textContent=(t.textContent+s).split("\n").slice(-20).join("\n");E()}
let E=_=>{let s=window.getSelection();s.removeAllRanges();let r=document.createRange();r.selectNodeContents(t);r.collapse(false);s.addRange(r);t.focus()}
let lo=x=>Number(BigInt.asUintN(32,x))
let su=x=>t_.decode(x),t_=new TextDecoder("utf-8")
let us=x=>_t.encode(x),_t=new TextEncoder("utf-8")


let abs=Math.abs,hypot=Math.hypot,sin=Math.sin,cos=Math.cos,exp=Math.exp,log=Math.log,log2=Math.log2,atan2=Math.atan2,sqrt=Math.sqrt
let cexpf=(x,y)=>{let e=exp(x);return[e*cos(y),e*sin(y)]}
let clogf=(x,y)=>{let r=hypot(x,y),p=atan2(y,x);r=log(r);return[r*cos(p),r*sin(p)]}
let csqrtf=(x,y)=>{
 if(x>=0){let t=sqrt(( x+hypot(x,y))*0.5);return[t,y/(2.0*t)]}
 else    {let t=sqrt((-x+hypot(x,y))*0.5);return[abs(y)/(2.0*t),(y<0)?-t:t]}}
let cdiv=(a,b,c,d)=>{if(abs(c)>abs(d)){let r=d/c,q=c+r*d;return[(a+b*r)/q,(b-a*r)/q]}else{let r=c/d,q=d+r*c;return[(a*r+b)/q,(b*r-a)/q]}}


let /*there be*/ K,C,U,F
let ab=()=>{C=new Uint8Array(K.memory.buffer),I=new Int32Array(K.memory.buffer),U=new Uint32Array(K.memory.buffer),F=new Float32Array(K.memory.buffer),D=new Float64Array(K.memory.buffer)}
let BK=new Array(32).fill(0)
let bk=x=>Math.max(6,32-Math.clz32(8+x))
let mk=x=>{let s=1<<x;if(s<K.memory.buffer.byteLength-M){U[M>>2]=x;x=M;M+=s;return x};K.memory.grow(1+(s>>16));ab();return mk(x)}
let ma=x=>{let b=bk(x),p=BK[b];if(p){BK[b]=U[p>>2];U[p>>2]=b;return 8+p};return mk(b)}
let fr=x=>{x-=8;let b=U[x>>2];U[x>>2]=BK[b];BK[b]=x}

let s0=x=>{let u=new Uint8Array(K.memory.buffer,x,24);let n=u.indexOf(0);return su(u.slice(0,(n<0)?22:n))}
let zz=(r,x,f)=>[F[r],F[1+r]]=f(F[x],F[1+x])
let M,B /*,ma=x=>{M+=x;return M-x}*/
let S=(x,n)=>su(new Uint8Array(K.memory.buffer,x,n))
let kenv={env:{
 write:(X,y,Z)=>{O(S(y,lo(Z)));return lo(Z);},
 free:  x=>{fr(x)},
 malloc:x=>{return ma(x)},
 ut:()=>{return BigInt(Math.floor(2.4e6*performance.now()))},
 atof:x=>{x=s0(x);return parseFloat(x)},
 atoi:x=>{x=s0(x);return parseInt(x)},
 atan2:atan2,
 expf:exp,
 exp2f:x=>Math.pow(2,x),
 logf:log,
 log2f:log2,
 cabsf:x=>hypot(F[x],F[1+x]),
 csqrtf:(r,x)=>{zz(r,x,csqrtf)},
 clogf: (r,x)=>{zz(r,x,clogf)},
 cexpf: (r,x)=>{zz(r,x,cexpf)},
 sprintf:(x,y,z)=>{let S=s0(y),s=""+((C[1+y]==100)?I[z>>2]:D[z>>3]);z=us(s);y=s.length;z[y]=0;C.set(z,x);return y},
 stat:(x,y)=>{return akstat(x,y)},
 open:(x,Y)=>{return 12288},
 read:(X,y,Z)=>{let u=us(sak());C.set(us(sak()),y);return lo(Z)},
 close:(X)=>{return 0},
 __mulsc3:(r,a,b,c,d)=>[F[r],F[1+r]]=[a*c-b*d,a*d+b*d],
 __divsc3:(r,a,b,c,d)=>[F[r],F[1+r]]=cdiv(a,b,c,d),
}}

let key=(e,t)=>{if("Enter"==e.key){
 let s="\n"+t.textContent;s=s.slice(1+s.lastIndexOf("\n")).trim();t.textContent+="\n"
// try{
  ws(us(s));t.textContent+=" "
// }catch(e){
//  O("segmentation fault\n");B=kinit()
// }
  E()
}}
 
let ws=u=>{u.forEach((x,i)=>C[B+i]=x);C[B+u.length]=0;K.keval(B,u.length)}  //fill buffer then call w_(e(s))


let kinit=()=>{
 fetch("a.k").then(r=>r.text()).then(r=>g("f").textContent=r)
 fetch("a.wasm").then(r=>r.arrayBuffer()).then(r=>WebAssembly.instantiate(r,kenv)).then(r=>{
  K=r.instance.exports,M=K.__heap_base
  K.kinit();ab();B=ma(64);O(" ")})}

let ak=()=>{C[B]=97;C[1+B]=46;C[2+B]=107;C[3+B]=0;K.kload(B)}
let akstat=(x,y)=>{y>>=2;U[6+y]=1<<15;U[12+y]=g("f").textContent.length;return 0}
let sak=()=>g("f").textContent

</script>



</div>
<div style="width:30vw">
 <div style="display:flex;flex-direction:column">
  <pre id="t" contenteditable="true" spellcheck="false" onkeyup="key(event,this)">todo..</pre>
 </div>
 <p/>
 <pre style="background:white">
 <a href="#typ">types</a>  <a href="#lay">memory layout</a> <a href="#mem">allocator</a> <a href="#ref">refcount</a>
 <a href="#prs">parse</a>         <a href="#exe">execute</a>
 <a href="#vrb">verbs</a> 
 <a href="#sys">syscalls</a>
 <a href="#smd">vector instructions</a>
 </pre>
</div>

</div></body></html>
