#!/usr/bin/env -S deno --allow-read --allow-write

//embed
let ab=(x,B)=>{
let C="aaaaaaaaaanaaaaaaaaaaaaaaaaaaaaaadhddddebcdddjgmggggggggggebdedddffffffffffffffffffffffffffblcddiffffkfffffffffffffffffffffbdcdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
let T="abcdefghijfdkbabcdefghijfdkbabcdefghidfddbabcdrfghijfddbabcdefghijfddbabcdemmhidmddbabcdennhidoddbppppppprpppqppabcdemghidmddbabcdefnhijfddblllllllllllllblllllllllllllbabcdemmhidmddbabcdennhidoddbabcdennhinnddbppppppprpppqppppppppppppppppabcdefghidfddb"

let ic=x=>x.split("").map(x=>x.charCodeAt(0))
C=ic(C).map(x=>x-97);T=ic(T).map(x=>x-97)
let cut=(x,i)=>i.map((_,k)=>x.slice(i[k],i[1+k]))
let token=(x,s,i,l)=>(s=0,i=ic(x).map(x=>s=T[14*s+C[x]]).map((x,i)=>x>10?-1:i).filter(x=>x>=0),
 x=cut(x,i),s=i.map((_,j)=>((x[j]==" ")||((j==0||x[j-1]==" "||x[j-1]=="\n")&&(x[j][0]=="/"&&x[j][1]!="'"))?0:1)),
 l=0,s.forEach((y,i)=>{if(y)l=(";"==x[i]||"\n"==x[i]?((s[i]=l?0:1),1):0)}),
 [where(x,s).map(x=>x=="\n"?";":x).toReversed(),where(i,s).toReversed()])
let where=(x,k)=>x.filter((_,i)=>k[i])
let left="([{",right="}])"
let op=":+*%&|<>=~!,^#_$?@/\\",nm=".-0123456789",az="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",vc="BGHSIEJFZ"
let parse=x=>{let[tok,pos]=x,locs,args,res,funs={},glob={},tabl={},data=[],lp=0
 let runt={
  "malloc":{r:"i",a:"i",c:["malloc i:i import env malloc"]},
  "fill.i":{r:"I",a:"ii",c:"fill.i j:ii\ni r\ni p\ni 2\nget 0\nsli\ncal malloc\nset r\nget 1\nif\nget r\nget 0\ni 2\nsli\nadi\nset p\nwhile\nget p\ni 4\nsui\ntee p\nget r\ngei\ndo\nget 1\nget p\nsti\nend\nend\nget r\njoi\nget 0\njoi\nj 32\nslj\norj\n"},
  "fill.j":{r:"J",a:"ij",c:"fill.j j:ij\ni r\ni p\ni 3\nget 0\nsli\ncal malloc\nset r\nget 1\nj 0\neqj\nezi\nif\nget r\nget 0\ni 3\nsli\nadi\nset p\nwhile\nget p\ni 8\nsui\ntee p\nget r\ngei\ndo\nget 1\nget p\nstj\nend\nend\nget r\njoi\nget 0\njoi\nj 32\nslj\norj\n"},
  "fill.e":{r:"E",a:"ie",c:"fill.e j:ie\ni r\ni p\ni 2\nget 0\nsli\ncal malloc\nset r\nget 1\ne 0\neqe\nezi\nif\nget r\nget 0\ni 2\nsli\nadi\nset p\nwhile\nget p\ni 4\nsui\ntee p\nget r\ngei\ndo\nget 1\nget p\nste\nend\nend\nget r\njoi\nget 0\njoi\nj 32\nslj\norj\n"},
  "fill.f":{r:"F",a:"if",c:"fill.f j:if\ni r\ni p\ni 3\nget 0\nsli\ncal malloc\nset r\nget 1\nf 0\neqf\nezi\nif\nget r\nget 0\ni 3\nsli\nadi\nset p\nwhile\nget p\ni 8\nsui\ntee p\nget r\ngei\ndo\nget 1\nget p\nstf\nend\nend\nget r\njoi\nget 0\njoi\nj 32\nslj\norj\n"},
  "fill.z":{r:"Z",a:"iz",c:"fill.z j:iz\ni r\ni p\ni 4\nget 0\nsli\ncal malloc\nset r\nget 1\nz 0\neqz\nezi\nif\nget r\nget 0\ni 4\nsli\nadi\nset p\nwhile\nget p\ni 16\nsui\ntee p\nget r\ngei\ndo\nget 1\nget p\nstz\nend\nend\nget r\njoi\nget 0\njoi\nj 32\nslj\norj\n"},
 }
 let mark=(...x)=>x.forEach(x=>(!(x in runt))?perr("no builtin: "+x):(x in funs)?0:funs[x]=runt[x])
 let ipos=0,typs="ijefzBGHSIJEFZ",it=t=>typs.indexOf(t)
 let l=x=>x[x.length-1],lop=x=>l(x).slice(0,3),vt=x=>vc.includes(x.t)
 let perr=(x,p)=>{p=p?p:ipos;if(ed){ed.selectionStart=ed.selectionEnd=p;ed.focus()};throw new Error("@"+p+": "+x)}
 let type=(x,t)=>x=="-"||op.includes(x[0])?0:(nm.includes(x[0])?(typs.includes(l(x))?l(x):x.includes("a")?"z":x.includes(".")?"f":"i"):"i")
 let tyck=(x,y,p)=>{if(x!=y)perr("type",p)}
 let avec=x=>(vt(x)?(lp=x.n,x.push("ioj","get "+temp("i","i"),...shift(x.t),"adi","ld"+x.t.toLowerCase()),x.t=x.t.toLowerCase(),x):x)
 let upty=(x,y)=>(x=avec(x),y=avec(y),x=xloc(x,y),x.t==y.t?[x,y]:it(x.t)<it(y.t)?(x.push(y.t+"o"+x.t),x.t=y.t):(y.push(x.t+"o"+y.t),y.t=x.t),[x,y])
 let loty=t=>t.charCodeAt(0)<97?"j":t
 let next=(r,t)=>(r=tok.pop(),r==undefined?0:(t=type(r),r=[r],r.t=t,r.p=(ipos=pos.pop()),r))
 let peek=_=>l(tok)
 let immm=(x,i)=>(x=x.slice(4),(i=x.indexOf(" @"),i)?x.slice(0,i):x)
 let loop=x=>lp?(drop(x),x=[...lp,"set n","i -1","set i","while","get i","i 1","adi","tee i","get n","lti","do",...x,"end"],x.t=0,lp=0,x):x
 let list=p=>{let e,r=[];r.t="l";while(1){if(right.includes(peek())){next();return r};r.push(e=loop(expr(term())));if(";"==peek())next();if(!e)perr("unclosed",p)}}
 let seql=(l,r)=>{if(!l.t=="l")return l;if(!l.length)return["nop"];r=[];l.forEach((x,i)=>{drop(x);r.push(...x)});r.t="";return r}
 let find=(x,y,a)=>{a=0;while((a=x.indexOf(y[0],1+a),a>=0));if(y.every((c,i)=>x[i+a]==c))return a;return x.length}
 let char=(x,s,i)=>{s=unqt(x[0].slice(1,-1));x.t="B";x.t="B";x.n=["i "+s.length];if(!s.length){x[0]="j 0";return x};i=find(data,s);if(i==data.length)data.push(...s);x[0]="j "+((BigInt(s.length)<<32n)|BigInt(i)).toString();return x}
 let argn=(s,i)=>(i=args.indexOf(s),i<0?s:i)
 let cndl=c=>{c=expr(term());if(c.t=="l"){if(c.length>1)perr("condition length");c=c[0]};if("{"!=peek())perr("expect-{");next();return[c,seql(list())]}
 let cond=(l,r)=>{if(l.length<3||1!=l.length%2)perr("cond length");r=[];r.t=l[l.length-1].t;l.forEach((x,i)=>(r.push(...x),(i==l.length-1)?r.push(...Array(l.length/2|0).fill("end")):r.push(i%2?(tyck(r.t,x.t,x.p),"else"):(tyck("i",x.t,x.p),"if "+r.t))));return r}
 let swtc=(l,r)=>{if(l.length<3)perr("switch length");r=[];r.t=l[l.length-1].t;l.forEach((x,i)=>(r.push(...x),tyck(x.t,r.t,x.p),r.push(i==0?"switch "+(l.length-1):i==l.length-1?"end":"endcase "+(i-1))));return r}
 let ical=(r,l,s)=>{r.pop();if(l.length<2)perr("icall length");s=r.t+":";if(!typs.includes(r.t))perr("icall return type");l.slice(1).forEach(x=>(s+=x.t,r.push(...x)));if(l[0].t!="i")perr("icall index type");r.push(...l[0],s);return r}
 let take=(x,y,p,s,v)=>(p=" @"+p,tyck(x.t,"i",x.p),vt(y)?(y.push("j 32","slj","j 32","srl"),x.push("joi"+p,"j 32","slj","orj"),y.push(...x),y):(x.push(...y,(mark("malloc","fill."+y.t),"cal fill."+y.t)),x.t=y.t.toUpperCase(),x))
 let drup=(x,y,p,s,v)=>(p=" @"+p,tyck(x.t,"i",x.p),vt(y)?1:perr("type",y.p),y.push(...x,"joi"+p,"tee "+(v=temp("j","n_x")), "j "+("BCHSIEJFZZ".indexOf(y.t)/2|0),"slj","adj","get "+v,"j 32","slj","suj"+p),y)
 let term=(r,n)=>{r=peek();if(r)if(";"==r[0]||"{"==r[0]||right.includes(r[0]))return 0
  r=next();if(!r)return r
  if("("==r[0]){n=ipos;r=expr(term());if(")"!=peek())perr("unclosed)",n);next();return r}
  if(left.includes(r[0]))return list()
  if('"'==r[0][0])return char(r)
  if(r.t&&nm.includes(n=r[0][0])){r[0]=r.t+" "+(typs.includes(l(r[0]))?r[0].slice(0,-1):r[0])+" @"+r.p;return r}
  if(r[0]=="if"){[r,n]=cndl();r.push("if",...n);"{"!=peek()?r.push("end"):(next(),r.push("else",...seql(list()),"end"));r.t="";return r}
  if(r[0]=="while"){[r,n]=cndl();r.unshift("while");r.push("do",...n,"end");r.t="";return r}
  if(az.includes(n)){n=r[0];[r[0],r.t]=(peek()=="?"?(next(),["cast",n]):n in locs?["get",locs[n]]:n in glob?["glo",glob[n]]:n in funs?["cal",funs[n].r]:peek().endsWith(":")?["get","?"]:perr("lookup"));r[0]+=" "+argn(n);r[0]+=" @"+r.p;if(!r[0].startsWith("cal")){r.n=["get "+argn(n),"j 32","srl","ioj"];r.n.t="i"}}
  while("["==peek()){next();n=list();if(r[0].startsWith("cast ")&&n.length>1)return ical(r,n);if(1==r.length&&"$?".includes(r[0])){return("$"==r[0]?cond(n):swtc(n))};r=peek().endsWith(":")?amnd(r,(1!=n.length?perr("rank assign",n.p):n[0]),next(),expr(term())):cali(r,n)}
  return r}
 let mona=(x,y,i,m)=>x[0]=="#"?(vt(y)?(y.push("j 32","srl","ioj"),y.t="i",y):perr("rank")):x[0]==":"?(cast(y,res),y.push("ret"),y):(y=avec(y),(m="!iezi!jezj~inoi~jnoj-ingi-jngj-enge-fngf|eabe|fabf_efle_fflf%esqe%fsqf"),(i=m.indexOf(x[0]+y.t))<0?perr("monadic"):(y.push(m.slice(2+i,5+i)+" @"+x.p),y))
 let nega=(x,p)=>("ij".includes(x.t)?(x.unshift(x.t+" 0"),x.push("su"+x.t+" @"+p)):x.push("ng"+x.t+" @"+p),x)
 let dyad=(x,y,z,d,i,p)=>(d="+ad-ad*mu%dv%'dv\\sl/sr/'sr=eq~ne<ge>le<=gt>=lt<'gt>'lt",p=y.p,y=y[0],y=="#"?take(x,z,p):y=="_"?drup(x,z,p):([x,z]=upty(x,z),z=("-"==y?nega(z,z.p):z),[x,z]="%"==y[0]?[z,x]:[x,z],z.push(...x),i=d.indexOf(y),i>=0?z.push(d.slice(i+y.length,2+i+y.length)+(y[1]=="'"?("j"==z.t?"l":"u"):z.t)+" @"+p):(perr("dyadic"+y)),z.t="~<=>".includes(y[0])?"i":z.t,z))
 let cast=(x,t)=>t==x.t?x:(x.push(loty(t)+"o"+loty(x.t)),x.t=t,x)
 let temp=(t,q,s)=>(s=(q?q:"$"+t),s in locs?s:(locs[s]=t,s))
 let xloc=(x,y)=>x.t=="?"?(locs[immm(x[0])]=y.t,x.t=y.t,x):x
 let shift=(t,s)=>(s="bghsiejfz".indexOf(t.toLowerCase()),s=s?["i "+(s>>1),"sli"]:[])
 let mamd=(x,i,f,z)=>(x.push("ioj",...i,...shift(x.t),"tee "+temp("i","_i")),x.t=x.t.toLowerCase(),x.push("ld"+x.t),f[0]=f[0].slice(0,-1),x=dyad(x,f,z),x.push("set "+temp(x.t),"get _i","get "+temp(x.t),"st"+x.t,"get $"+x.t),x)
 let amnd=(x,i,f,z)=>(f[0]!=":"?mamd(x,i,f,z):(x.push("ioj",...i,...shift(x.t),"adi",...z,"tee "+temp(z.t),"st"+x.t.toLowerCase(),"get "+temp(z.t)),x.t=z.t,x))
 let indx=(x,y,t,s)=>((y.t!="i"||(t=x.t,!vt(x)))?perr("index type"+t):t=t.toLowerCase(),x.push("ioj",...y,...shift(t),"adi","ld"+t ),x.t=t,x)
 let cali=(x,y,a)=>(y="l"!=y.t?[y]:y,x[0].startsWith("cal ")?(a=funs[immm(x[0])],a.a.length!=y.length?perr("arity"):(y=y.map((x,i)=>cast(x,a.a[i]))),y=y.flat(),y.push(x),y.t=a.r,y):(y.length!=1)?perr("index rank"):indx(x,y[0]))

/*
x :y  asin
x+:y  asin
X :Y  asin
x :Y  asin(x,avec(Y))
x+:Y  asin(x,avec(Y))

X :y  amnd(x,i,f,y)          lp=x.n
X+:y  amnd(x,i,f,y)
X+:Y  amnd(x,i,f,avec(Y))
*/

 let asxy=(x,a,y,v)=>(2==(v=vt(x)+vt(y))&&":"==a[0])||(!v)?asin(x,a,y):(y=vt(y)?avec(y):y,vt(x)?(lp=x.n,amnd(x,(v=["get i"],v.t="i",v),a,y)):asin(x,a,y))
 let asin=(x,a,y)=>(y=a[0]==":"?y:(a[0]=a[0][0],dyad(x,a,y)),x[0]=(x[0].startsWith("get")?"tee":"gst")+x[0].slice(3),x=xloc(x,y), 
  y.push(...x),x[0].startsWith("gst")?y.push("glo"+x[0].slice(3)):0,y)
 let drop=x=>{if(x.t&&typs.includes(x.t)&&"ret"!=lop(x)){"tee"==lop(x)?(x[x.length-1]="set"+x[x.length-1].slice(3)):"get"==lop(x)?x.pop():x.push("drp")}}
 let expr=x=>{if(!x)return x
  let y=term(),r,v=x=>!x.t
  if(!y)return x
  if(v(y)&&!(v(x))){
   r=expr(term())
   if(!r)perr("1+")
   return"@"==y[0]?cali(x,r):y[0].endsWith(":")?asxy(x,y,r):dyad(x,y,r)
  }
  r=expr(y)
  return(v(x))?mona(x,r):x[0].startsWith("cast ")?cast(r,x.t):cali(x,r)
 }
 let floc=(n,r)=>((!("i n r".includes(n)))?1:r.some(s=>s.split("\n").map(s=>s.split(" ")).some(x=>(x[0]=="get"||x[0]=="set"||x[0]=="tee")&&n==x[1])))
 let code=r=>(r=list(),(res&&!(l(r).t))?(r.push(["get r"]),l(r).t=res):0,r.forEach((x,i)=>{i==r.length-1?cast(x,res):drop(x);r[i]=x.join("\n")}),r.unshift(...Object.keys(locs).filter(x=>!args.includes(x)).filter(x=>floc(x,r)).map(x=>(vc.includes(locs[x])?"j":locs[x])+" "+x).sort()),r.join("\n"))
 let unqt=s=>{let r=[];for(let i=0;i<s.length;i++)r.push((s[i]=="\\"?(s[++i]=="n"?"\n":s[i]=="t"?"\t":s[i]):s[i]).charCodeAt(0));return r}
 let unhx=s=>s.match(/../g).map(x=>parseInt(x,16))
 let adda=(o,x)=>{if(o>data.length)data.push(...Array(o-data.length).fill(0));x.forEach((x,i)=>data[o+i]=x)}
 let ptop=_=>{while(";"==peek())next();let n=next(),a=next(),r;if(!n)return;if(a==0||a[0]!=":")perr("toplevel assignment")
  if(nm.includes(n[0][0])){a=Number(n[0]);n=next();if(n[0][0]=="["){while((n=next(),n&&n!="]"))az.includes(n[0][0])?tabl[a++]=[n[0],ipos]:perr("table syntax")}else adda(a,n[0][0]=='"'?unqt(n[0].slice(1,-1)):unhx(n[0]))}
  else{r=next();if(r&&nm.includes(r[0][0])){if(0!=Number(r[0]))perr("nonzero global");glob[n]=r.t;return}
   let f={n:n[0],p:n.p,r:r[0]};r=next();if(r[0]!=":")perr("signature");f.a=next()[0];r=next();if(r[0]!="{"){f.l={};funs[f.n]=f;return};if(peek()=="["){next();f.l={};f.a.split("").forEach((t,i,a,x)=>{x=next();if((!x)||(!az.includes(x[0][0])))perr("arg name:"+x[0][0]);f.l[x[0]]=t;x=next();if(x[0]!=(i<a.length-1?";":"]"))perr("arg length")})}
   if(!("l"in f)){f.l={};"xyzabcdefghijklmnopqrstuvw".slice(0,f.a.length).split("").forEach((x,i)=>f.l[x]=f.a[i])}
   f.l.i="i";f.l.n="i";if(f.r)f.l.r=f.r;
   f.tok=[],f.pos=[];r=0;while(tok.length){n=tok.pop(),a=pos.pop();r+=n=="{"?1:n=="}"?-1:0;f.tok.unshift(n);f.pos.unshift(a);if(r<0)break};if(f.n in funs)perr("func "+f.n+" already defined",f.p);funs[f.n]=f;if(r>=0)perr("function unclosed: "+f.n,f.p)
 }}
 while(tok.length)ptop();for(let n in funs){let f=funs[n],imp=f.tok?0:1;locs=f.l;args=Object.keys(locs).slice(0,f.a.length);tok=f.tok,pos=f.pos;res=f.r;f.c=f.c?f.c:"\n"+f.n+" "+loty(f.r)+":"+(f.a.split("").map(loty).join(""))+(imp?" import env ":" export ")+f.n+" @"+f.p+(imp?"":"\n"+code())}
 let G=Object.keys(glob).map(x=>glob[x]+" "+x).join("\n");if(G.length)G+="\n"
 let I=Object.keys(funs).filter(x=>!funs[x].tok).map(x=>funs[x].c).join("\n")
 let F=Object.keys(funs).filter(x=> funs[x].tok).map(x=>funs[x].c).join("\n")
 let t="";for(o in tabl){t+="\ntab "+o+" "+tabl[o][0];if(!(tabl[o][0]in funs))perr("unknown func in table: "+tabl[o][0],tabl[o][1])}
 let n=(((7+data.length)>>3)<<3)
 let d="";{let o=0,x=data;while((((7+x.length)>>3)<<3)>x.length)x.push(0);if(x.length)x.push(...unqt("data end"));while(x.length){d+="0000000000000000"==(y=(x.length>8?x.slice(0,8):x).map(x=>x.toString(16).padStart(2,"0")).join(""))?"":"\ndat "+o+" "+y;o+=8;x=x.slice(8)}}
 if(B){B.f=funs,B.g=glob}
 return(G+I+F+t+d).trimStart()}
return parse(token(x))}
/* wa:wasm compiler
   wa compiles a(assembly) to a wasm binary (uint8array)

   the wasm binary can be downloaded with Compile->Save wasm

   see help/a for a description of the assembly language.  */

//wa.js opcode table is generated by ../ai/wa.mk, source is wa_js
let wa=(_=>{
let o,O=x=>o.push(...(Array.isArray(x)?x:[x])),E=(l,x)=>{if(ea)ea.selectedIndex=l;throw new Error("wa: line "+l+": "+x)},
lebu=(x,r,b)=>{r=[];do{b=x&127;r.push((x>>>=7)?b|=128:b)}while(x);return r},                                                         //unsigned i32
lebs=(x,r,b)=>{x|=0;r=[];while(1){b=x&127;x>>=7;if(x==0&&!(b&64)||(x==-1&&(b&64))){r.push(b);break};r.push(b|128)};return r},        //signed i32
lebn=(x,r,b)=>{r=[];while(1){b=Number(x&127n);x>>=7n;if(x==0n&&!(b&64)||(x==-1n&&(b&64))){r.push(b);break};r.push(b|128)};return r},  //signed BitInt
sect=(x,y)=>(y.length&&y[0]!=0)?(O(x),O(lebu(y.length)),O(y)):0,
vect=x=>[...lebu(x.length),...x.flat()],
typs={"":0,g:1,i:127,j:126,e:125,f:124,z:123},
expo=(n,j)=>n.map((x,i)=>[...lebu(x.length),...x.split("").map(x=>x.charCodeAt(0)),(i==0?2:j[i]<0?3:0),...lebu(j[i]<0?-1-j[i]:j[i])]),
locs=x=>{let t=new Map();Object.values(x.lo).forEach(x=>t.set(x,(t.has(x)?1+t.get(x):1)));let r=vect([...t.keys()].map(x=>[...lebu(t.get(x)),Number(x)]));return r},
asci=x=>[...lebu(x.length),...x.split("").map(x=>x.charCodeAt(0))],
iota=x=>Array(x).fill(0).map((_,i)=>i),
hexa=x=>x.match(/.{1,2}/g).map(x=>parseInt(x,16)),
repa=(n,x)=>Array(n).fill(x).flat(),

/*o-p-s*/
ops={ezi:0x45,eqi:0x46,nei:0x47,lti:0x48,ltu:0x49,gti:0x4a,gtu:0x4b,lei:0x4c,leu:0x4d,gei:0x4e,geu:0x4f,ezj:0x50,eqj:0x51,nej:0x52,ltj:0x53,ltl:0x54,
gtj:0x55,gtl:0x56,lej:0x57,lel:0x58,gej:0x59,gel:0x5a,eqe:0x5b,nee:0x5c,lte:0x5d,gte:0x5e,lee:0x5f,gee:0x60,eqf:0x61,nef:0x62,ltf:0x63,gtf:0x64,
lef:0x65,gef:0x66,clz:0x67,ctz:0x68,pci:0x69,adi:0x6a,sui:0x6b,mui:0x6c,dvi:0x6d,dvu:0x6e,moi:0x6f,mou:0x70,ani:0x71,ori:0x72,xoi:0x73,sli:0x74,
sri:0x75,sru:0x76,rli:0x77,rri:0x78,noi:[0x41,0x7f,0x73],clj:0x79,ctj:0x7a,pcj:0x7b,adj:0x7c,suj:0x7d,muj:0x7e,dvj:0x7f,dvl:0x80,moj:0x81,mol:0x82,anj:0x83,
orj:0x84,xoj:0x85,slj:0x86,srj:0x87,srl:0x88,rlj:0x89,rrj:0x8a,noj:[0x42,0x7f,0x85],abe:0x8b,nge:0x8c,cee:0x8d,fle:0x8e,tre:0x8f,nae:0x90,sqe:0x91,ade:0x92,
sue:0x93,mue:0x94,dve:0x95,mie:0x96,mae:0x97,cse:0x98,abf:0x99,ngf:0x9a,cef:0x9b,flf:0x9c,trf:0x9d,naf:0x9e,sqf:0x9f,adf:0xa0,suf:0xa1,muf:0xa2,
dvf:0xa3,mif:0xa4,maf:0xa5,csf:0xa6,ioj:0xa7,ioe:0xa8,uoe:0xa9,iof:0xaa,iou:0xab,joi:0xac,jou:0xad,joe:0xae,loe:0xaf,jof:0xb0,lof:0xb1,eoi:0xb2,
eou:0xb3,eoj:0xb4,eol:0xb5,eof:0xb6,foi:0xb7,fou:0xb8,foj:0xb9,fol:0xba,foe:0xbb,ire:0xbc,jrf:0xbd,eri:0xbe,frj:0xbf,ixg:0xc0,ixh:0xc1,jxg:0xc2,
jxh:0xc3,jxi:0xc4,ngi:[65,127,108],ngj:[66,127,127],drp:0x1a,sel:0x1b,ret:0x0f,adz:[0xfd,0xf0,1],suz:[0xfd,0xf1,1],scz:[0xfd,0xf2,1],eqz:[0xfd,0x41,0xfd,0xc3,1],nez:[0xfd,0x42,0xfd,0x53],ngz:[0xfd,0xed,1],zoi:[0xb7,0xfd,0x14,0x41,0,0xb7,0xfd,0x22,1],zoj:[0xb9,0xfd,0x14,0x41,0,0xb7,0xfd,0x22,1],zoe:[0xbb,0xfd,0x14,0x41,0,0xb7,0xfd,0x22,1],
zof:[0xfd,0x14,0x41,0,0xb7,0xfd,0x22,1],foz:[0xfd,0x21,0],imz:[0xfd,0x21,1],zrr:[0xfd,0x14],stz:[0xfd,0x0b,4,0],ldz:[0xfd,0,4,0],ldi:[0x28,2,0],ldj:[0x29,3,0],lde:[0x2a,2,0],ldf:[0x2b,3,0],ldg:[0x2c,0,0],ldb:[0x2d,0,0],ldh:[0x2e,1,0],lds:[0x2f,1,0],sti:[0x36,2,0],stj:[0x37,3,0],
ste:[0x38,2,0],stf:[0x39,3,0],stg:[0x3a,0,0],sth:[0x3b,1,0],siz:[0x3f,0],grw:[0x40,0],cpy:[0xfc,10,0,0],fil:[0xfc,11,0],}
/*o-p-s*/

return(x=>{
 //parse asm 
 let a,n=0,narg=0,s,e="",imp=0,c=[],lo={},i,p=_=>((n?funs.push({sig:s,lo:lo,code:c,name:n,export:e,import:imp}):0),[n,s,e,imp,c,lo]=[0,"","",0,[],{}]),
 sigs=[],addsig=x=>(sigs.includes(x)?x:sigs.push(x),x), //e.g. ["i:ii",":ij",..]
 fns={},funs=[],       //{sig:"i:ii",code:[1,2,..],name:"a","export":"A"}
 lsrt=_=>lo=Object.fromEntries(Object.entries(lo).sort(([,a],[,b])=>b-a)), //group locs by type (decreasing) ijefz
 glob={},addglo=(t,c,s)=>{glob[s]={t:t,c:[...[c],...Array(67==t?4:68==t?8:1).fill(0),11],i:Object.keys(glob).length,s:s}}, //name:{t:127,c:[42,7,11],i:0}
 tabl=[],addtab=(i,s)=>(i!=tabl.length?E(line,"index error"):(s in fns)?tabl[i]=fns[s]:E(line,"unknown function: "+s)),
 data=[],adddat=(i,s)=>(data.filter(x=>i==x.o+x.d.length).length?data[data.length-1].d.push(...hexa(s)):data.push({o:i,d:hexa(s)})), //{o:1,d:[1,2,3,4]}
 swtc=[],sw,sc,nest=[],whdo=_=>nest.length-nest.lastIndexOf("whdo")-1,
 l=x.split("\n");
 l.forEach((x,line)=>{x=x.trim().split(" ");if(1<x.length&&x[1].includes(":")){fns[x[0]]=Object.keys(fns).length;addsig(x[1])}})
 l.forEach((x,line)=>{
  let im=x=>(2>x.length)?E(line,x[0]+" expect immediate"):x[1],cmpl=(x,a,p)=>(p=(a=x[1]?x[1]:0)/180*Math.PI,x=x[0],a==0?[x,0]:a==90?[0,x]:a==180?[-x,0]:a==270?[0,-x]:[x*Math.cos(p),x*Math.sin(p)]),
  numvar=(x,b)=>"-0123456789".includes(x[0])?(x.includes("a")?cmpl(x.split("a").map(parseFloat)):b?BigInt(x):parseFloat(x)):x,
  int=a=>Number.isInteger(a)?a:E(line,"expect integer"),int1=a=>int(Number(im(a))),
  lup=(x,g,r)=>lebu(int("0123456789".includes(x[0])?Number(x[0]):g?(x in glob?glob[x].i:E(line,"global undefined")):(x in lo)?narg+Object.keys(lo).indexOf(x):E(line,"local undefined")))
  x=x.trim();if(x.length){a=(x.includes(" ")?x.split(" "):[x]);
   ((1<a.length)&&(a[1].includes(":")))?(p(),n=a[0],s=a[1],narg=s.length-s.indexOf(":")-1,e=(a[2]==="export"?a[3]:""),imp=(a[2]==="import"?a.slice(3):0))
   :(a[0]in ops)?(Array.isArray(ops[a[0]])?c.push(...ops[a[0]]):c.push(ops[a[0]]))
   :(3==a[0].length&&(i="get set tee glo gst ".indexOf(a[0]+" "))>=0)?c.push(32+i/4,...lup(im(a),2<i/4))
   :"i"==a[0]?(("string"==typeof(i=numvar(im(a),0))?(s?(lsrt(lo[a[1]]=127)):addglo(127,[65],a[1]))    :c.push(65,...lebs(int(i)))))
   :"j"==a[0]?(("string"==typeof(i=numvar(im(a),1))?(s?(lsrt(lo[a[1]]=126)):addglo(126,[66],a[1]))    :c.push(66,...lebn(i))))
   :"e"==a[0]?(("string"==typeof(i=numvar(im(a),0))?(s?(lsrt(lo[a[1]]=125)):addglo(125,[67],a[1]))    :c.push(67,...new Uint8Array(new Float32Array([i]).buffer))))
   :"f"==a[0]?(("string"==typeof(i=numvar(im(a),0))?(s?(lsrt(lo[a[1]]=124)):addglo(124,[68],a[1]))    :c.push(68,...new Uint8Array(new Float64Array([i]).buffer))))
   :"z"==a[0]?(("string"==typeof(i=numvar(im(a),0))?(s?(lsrt(lo[a[1]]=123)):addglo(123,[253,12],a[1])):c.push(253,12,...new Uint8Array(new Float64Array(i).buffer))))
   :"if"==a[0]?(nest.push("if"),c.push(4,[64,127,126,125,124,123][1+"ijefz".indexOf(a[1])]))
   :"else"==a[0]?c.push(5)
   :"end"==a[0]?(i=nest.pop(),i=="do"?c.push(13,0,11):i=="whdo"?c.push(12,0,11,11):i=="swtc"?c.push(12,0,11):c.push(11))
   :a[0].includes(":")?(addsig(a[0]),c.push(17,...lebu(sigs.indexOf(a[0])),0))
   :"cal"==a[0]?c.push(16,...lebu(a[1] in fns?fns[a[1]]:E(line,"undefined function: "+a[1])))
   :"while"==a[0]?(nest.push("while"),c.push(2,64,3,64))
   :"do" ==a[0]?((nest[nest.length-1]==="while")?(nest[nest.length-1]="whdo",c.push(69,13,1)):(nest.push("do"),c.push(3,[64,127,126,125,124,123]["ijefz".indexOf(a[1])+1])))
   :"break"==a[0]?c.push(12,1+whdo())
   :"continue"==a[0]?c.push(12,whdo())
   :"switch"==a[0]?(i=int1(a)-1,sw=sigs.indexOf(addsig(ss=("ijefz".indexOf(a[2])>=0?a[2]:"")+":i")),sc=sigs.indexOf(addsig(":i")),nest.push("swtc"),swtc.push(i),c.push(2,...lebu(sw),...repa(1+i,[2,...lebu(sc)]),14,i,...iota(i),i,11))
   :"endcase"==a[0]?(i=swtc[swtc.length-1]--,c.push(12,i,11))
   :"tab"==a[0]?(p(),addtab(int1(a),a[2]))
   :"dat"==a[0]?(p(),adddat(int1(a),a[2]))
   :E(line,"unknown op "+a[0])
  }
 });p()

 //emit
 o=[0,97,115,109,1,0,0,0] 
 sect( 1,vect(sigs.map((x,r,a)=>([r,a]=x.split(":"),[96,a.length,...a.split("").map(x=>typs[x]),r.length,...r.split("").map(x=>typs[x])]))))
 sect( 2,vect(funs.filter(x=>x.import).map(x=>[...asci(x.import[0]),...asci(x.import[1]),0,...lebu(sigs.indexOf(x.sig))] ))) //imports..
 sect( 3,vect(funs.filter(x=>!x.import).map(x=>lebu(sigs.indexOf(x.sig)))))
 if(tabl.length)sect(4,[1,112,0,...lebu(tabl.length)])
 sect( 5,[1,0,1]) //memory: 1segment, unshared, 1block
 sect( 6,vect(Object.values(glob).map(x=>[x.t,1,...x.c]))) //global..
 sect( 7,vect(expo(["memory",...funs.filter(x=>x.export.length>0).map(x=>x.export),...Object.keys(glob).map(x=>x)], //names
                   [0,...funs.map((x,i)=>(x.export.length?i:-1)).filter(x=>x>=0),...Object.keys(glob).map(x=>-1-glob[x].i)]))) //index
 sect( 8,[]) //start
 if(tabl.length)sect(9,[1,0,65,0,11,...lebu(tabl.length),...tabl.map(lebu).flat()]) //elements(indirect function table)
 sect(10,vect(funs.filter(x=>!x.import).map(x=>((x=[...locs(x),...x.code,11]),[...lebu(x.length),...x])))) //code
 sect(11,vect(data.map(x=>[0,65,...lebu(x.o),11,...lebu(x.d.length),...x.d]))) //data
 return new Uint8Array(o)})})()
/* ai:assembly interpreter
   ai interprets a(assembly) instead of compiling it.
   it is used by the debugger and allows breakpoints, stepping and watches.

   in a first pass the asm listing is translated to an internal array
   which has jump offsets computed for structured program flow.
   the number of lines still matches the original asm to stay in sync with the ui.  */

let ai=(_=>{

let parse=(x,M,aim)=>{ //source,import-object,ai.a(compiled module)
 let A=new WebAssembly.Instance(aim,M).exports
 let G={} //globals {name:v}
 let F={} //functions
 let T=[] //indirect call table
 let U=new Uint8Array(A.memory.buffer),dd=(o,s)=>{for(let i=0;i<s.length;i+=2)U[o++]=parseInt(s.substr(i,2),16)} //data/heap
 let isvar=x=>!"-0123456789".includes(x[0])
 let args =x=>{let r={};x.split("").forEach((t,i)=>r[i]="j"==t?0n:0);return r}
 let nest=[],addr=[],la=""
 let cmpl=(x,a,p)=>(p=(a=x[1]?x[1]:0)/180*Math.PI,x=x[0],a==0?[x,0]:a==90?[0,x]:a==180?[-x,0]:a==270?[0,-x]:[x*Math.cos(p),x*Math.sin(p)])
 let n=0,s="",c=[],l=0,im="",lo={}
 let brk=(a,b)=>{while(++a<b)if(c[a][0]=="break")c[a]=["jmp",b-a]}                   //fix break offset
 let cnt=(a,b,i)=>{i=a;while(++a<b)if(c[a][0]=="continue")c[a]=["jmp",i-a];return i} //fix continue
 let swc=(i,b)=>{c[i].slice(2).forEach((x,j)=>{c[x][1]=b-c[x][1],c[i][2+j]-=i});c.push(["nop"])} //fix switch
 let p=_=>{if(!n)return;s=s.split(":");F[n]={r:s[0],a:s[1],c:c,lo:{...args(s[1]),...lo},l:l};[n,s,c,l,im,lo]=[0,"",[],0,"",{}]}
 x.trimEnd().split("\n").forEach((x,line)=>{let i,j,a=x.trim().split(" "),a0=a[0].trim(),a1=(a[1]?a[1].trim():"");
  (1<a.length&&a[1].includes(":"))?(p(),n=a0,s=a[1],l=line,c.push((a[2]=="import")?[M[a[3]][a[4]]]:["nop"]))
  :    "tab"==a0?(p(),T.push(a[2]))
  :    "dat"==a0?(p(),dd(Number(a1),a[2]))
  :     "if"==a0?(nest.push("if"),addr.push(c.length),c.push(["if",0]))
  :   "else"==a0?(nest.pop(),i=addr.pop(),c[i][1]=c.length-i,nest.push("else"),addr.push(c.length),c.push(["jmp",0]))
  :  "while"==a0?(nest.push("while"),addr.push(c.length),c.push(["nop"]))
  :     "do"==a0?((nest[nest.length-1]=="while")?(nest.push("whdo"),addr.push(c.length),c.push(["if",0]))//  (while)do
                                               :(nest.push("do"),addr.push(c.length),c.push(["nop",c.length,a1])))                     //    do(end)
  : "switch"==a0?(nest.push("switch"),addr.push(c.length),c.push(["switch",Number(a1)]))
  :"endcase"==a0?(i=addr[addr.length-1],c[i].push(c.length),c.push(["jmp",c.length]))
  :    "end"==a0?(la=nest.pop(),i=addr.pop(),(la==  "if"?(c[i][1]=c.length-i,c.push(["nop"]))                                          //    (if)end
                                             :la=="whdo"?(brk(i,c.length),c[i][1]=c.length-i,nest.pop(),c.push(["jmp",cnt(addr.pop(),c.length)-c.length]))
                                             :la=="else"?(c[i][1]=c.length-i,c.push(["nop"]))                                          //  (else)end
                                             :la==  "do"?c.push(["donot",c[i][1]-c.length,c[i][2]])                                            //    (do)end
                                             :swc(i,c.length))) //(switch)end 
  :(1==a0.length&&"ijefz".includes(a0))?(n?("i"==a0?(isvar(a1)?(c.push(["nop"]),lo[a[1]]=0    ):c.push(["const",Number(a1)]))
                                           :"j"==a0?(isvar(a1)?(c.push(["nop"]),lo[a[1]]=0n   ):c.push(["const",BigInt(a1)]))
                                           :"e"==a0?(isvar(a1)?(c.push(["nop"]),lo[a[1]]=0    ):c.push(["const",Number(a1)]))
                                           :"f"==a0?(isvar(a1)?(c.push(["nop"]),lo[a[1]]=0    ):c.push(["const",Number(a1)]))
					   :        (isvar(a1)?(c.push(["nop"]),lo[a[1]]=[0,0]):c.push(["const",cmpl(a1.split("a").map(Number))])))
                                          :(G[a[1]]=(a0=="j"?0n:0)))
  :a0.includes(":")?c.push(["ical",a0])
  :c.push(a)
  if(a.length>1&&a[a.length-1].startsWith("@"))c[c.length-1]["@"]=Number(a[a.length-1].slice(1))
 });p();return{A:A,G:G,F:F,T:T,M:M,S:[],C:[],H:[0,1],B:[],f:"",l:0}}  //S(value stack) C(call stack) f(current function name) l(line of function) H(heapmarks) B(breakpoints)
/*o-p-s*/
let ops={
ezi:1,eqi:2,nei:2,lti:2,ltu:2,gti:2,gtu:2,lei:2,leu:2,gei:2,geu:2,ezj:1,eqj:2,nej:2,ltj:2,ltl:2,
gtj:2,gtl:2,lej:2,lel:2,gej:2,gel:2,eqe:2,nee:2,lte:2,gte:2,lee:2,gee:2,eqf:2,nef:2,ltf:2,gtf:2,
lef:2,gef:2,clz:1,ctz:1,pci:1,adi:2,sui:2,mui:2,dvi:2,dvu:2,moi:2,mou:2,ani:2,ori:2,xoi:2,sli:2,
sri:2,sru:2,rli:2,rri:2,noi:1,clj:1,ctj:1,pcj:1,adj:2,suj:2,muj:2,dvj:2,dvl:2,moj:2,mol:2,anj:2,
orj:2,xoj:2,slj:2,srj:2,srl:2,rlj:2,rrj:2,noj:1,abe:1,nge:1,cee:1,fle:1,tre:1,nae:1,sqe:1,ade:2,
sue:2,mue:2,dve:2,mie:2,mae:2,cse:2,abf:1,ngf:1,cef:1,flf:1,trf:1,naf:1,sqf:1,adf:2,suf:2,muf:2,
dvf:2,mif:2,maf:2,csf:2,ioj:1,ioe:1,uoe:1,iof:1,iou:1,joi:1,jou:1,joe:1,loe:1,jof:1,lof:1,eoi:1,
eou:1,eoj:1,eol:1,eof:1,foi:1,fou:1,foj:1,fol:1,foe:1,ire:1,jrf:1,eri:1,frj:1,ixg:1,ixh:1,jxg:1,
jxh:1,jxi:1,ngi:1,ngj:1,adz:2,suz:2,scz:2,eqz:2,nez:2,ngz:1,zoi:1,zoj:1,zoe:1,zof:1,foz:1,imz:1,
zrr:1,stz:2,ldz:1,ldi:1,ldj:1,lde:1,ldf:1,ldg:1,ldb:1,ldh:1,lds:1,sti:2,stj:2,ste:2,stf:2,stg:2,
sth:2,siz:0,grw:1,cpy:3,fil:3,}
/*o-p-s*/

let op=(m,s,a)=>{if(!s in ops)throw new Error("unknown op:",s);a=ops[s];a=m.A[s](...m.S.splice(-a,a));if(a!==undefined)m.S.push(a)}
let zop=(m,o,f,n)=>(f={adz:(x,y)=>[x[0]+y[0],x[1]+y[1]],suz:(x,y)=>[x[0]-y[0],x[1]-y[1]],scz:(x,y)=>[x[0]*y[0],x[1]*y[1]],eqz:(x,y)=>(x[0]==y[0]&&x[1]==y[1]),nez:(x,y)=>(x[0]!=y[0]||x[1]!=y[1]),ngz:x=>[-x[0],-y[0]],zoi:x=>[x,0],zoj:x=>[x,0],zoe:x=>[x,0],zof:x=>[x,0],foz:x=>x[0],imz:x=>x[1],zrr:x=>[x,x],stz:(x,y)=>(m.A.stf(x,y[0]),m.A.stf(x+8,y[1])),ldz:x=>[m.A.ldf(x),m.A.ldf(x+8)]}[o],f?(n=ops[o],o=f(...m.S.splice(-n,n)),((o!=undefined)?m.S.push(o):1),1):0)
let exit=m=>{throw new Error("exit")}
let ret=m=>{m.C.length>1?[m.f,m.l]=m.C.pop():(m.exit=1,exit())}
let ncal=(F,m)=>{let r=F.c[0][0](...Object.values(F.lo));if(F.r.length)m.S.push(r)} //native
let scal=(f,m,ad)=>{m.C.push([m.f,m.l,"@"+ad]);m.f=f;m.l=0;let F=m.F[f];for(let i=0;i<F.a.length;i++)F.lo[F.a.length-1-i]=m.S.pop();if(1==F.c.length)ncal(F,m)}
let dcal=(f,m)=>{let n=m.C.length;scal(f,m);while(m.C.length>n)step(m,1)}
let heap=(m,o,s)=>{if((s=o.startsWith("st"))||o.startsWith("ld"))m.H=[m.S[m.S.length-1-s],{g:1,b:1,h:2,s:2,i:4,j:8,e:4,f:8,z:8}[o[2]]]} //store heap access

let step=(m,over)=>{if(m.exit)return;let F=m.F[m.f],cal=over?dcal:scal;if(F.c.length<=++m.l)return ret(m)
 if(!m.C.length)m.C.push([m.f,0])
 let a=F.c[m.l],a0=a[0],a1=a[1],ad=a["@"],x
 if(a0=="")return
 let icl=(x,s,ad,f)=>{f=m.T[x];x=m.F[f];if(s!=x.r+":"+x.a){throw new Error("line "+(F.l+m.l)+": signature mismatch for indirect function "+x)};cal(f,m,ad)}
   "const"==a0?m.S.push(a1)                    //iefz(Number) j(BigNum)
 :   "get"==a0?m.S.push(F.lo[a1])
 :   "set"==a0?F.lo[a1]=m.S.pop()
 :   "tee"==a0?F.lo[a1]=m.S[m.S.length-1]
 :   "glo"==a0?m.S.push(m.G[a1])
 :   "gst"==a0?m.G[a1]=m.S.pop()
 :   "cal"==a0?cal(a1,m,ad)
 :    "if"==a0?(m.l+=m.S.pop()?0:a1)
 : "donot"==a0?(m.l+=m.S.pop()?(a[2]?m.S.pop():0,a1):0)   //end after do
 :"switch"==a0?(x=m.S.pop(),m.l+=(x==0?0:(x>0&&x<a1)?a[1+x]:a[a1]))
 :   "jmp"==a0?m.l+=a1                          //else break continue endcase end
 :   "nop"==a0?0                                //do while
 :  "ical"==a0?icl(m.S.pop(),a1,ad)
 :  "ret"==a0?ret(m)
 :(heap(m,a0),zop(m,a0)?0:op(m,a0))}

let runto=m=>{if(m.exit)return;if(m.B.includes(line(m)))step(m,1);do{if(m.B.includes(line(m)))return;step(m,0)}while(1)}
let run=(f,a,m)=>{m.f=f,m.l=0,a.forEach((v,i)=>m.F[f].lo[i]=v);try{ while(1)step(m,0) }catch(e){ if(e.message=="exit"){if(m.S.length)return m.S[0]}else{throw(e)} }}
let line=x=>x.l+x.F[x.f].l
return{parse:parse,step:step,run:run,runto:runto,line:line}})()
let aia="\
ezi i:i export ezi\n \
 get 0\n \
 ezi\n \
eqi i:ii export eqi\n \
 get 0\n \
 get 1\n \
 eqi\n \
nei i:ii export nei\n \
 get 0\n \
 get 1\n \
 nei\n \
lti i:ii export lti\n \
 get 0\n \
 get 1\n \
 lti\n \
ltu i:ii export ltu\n \
 get 0\n \
 get 1\n \
 ltu\n \
gti i:ii export gti\n \
 get 0\n \
 get 1\n \
 gti\n \
gtu i:ii export gtu\n \
 get 0\n \
 get 1\n \
 gtu\n \
lei i:ii export lei\n \
 get 0\n \
 get 1\n \
 lei\n \
leu i:ii export leu\n \
 get 0\n \
 get 1\n \
 leu\n \
gei i:ii export gei\n \
 get 0\n \
 get 1\n \
 gei\n \
geu i:ii export geu\n \
 get 0\n \
 get 1\n \
 geu\n \
ezj i:j export ezj\n \
 get 0\n \
 ezj\n \
eqj i:jj export eqj\n \
 get 0\n \
 get 1\n \
 eqj\n \
nej i:jj export nej\n \
 get 0\n \
 get 1\n \
 nej\n \
ltj i:jj export ltj\n \
 get 0\n \
 get 1\n \
 ltj\n \
ltl i:jj export ltl\n \
 get 0\n \
 get 1\n \
 ltl\n \
gtj i:jj export gtj\n \
 get 0\n \
 get 1\n \
 gtj\n \
gtl i:jj export gtl\n \
 get 0\n \
 get 1\n \
 gtl\n \
lej i:jj export lej\n \
 get 0\n \
 get 1\n \
 lej\n \
lel i:jj export lel\n \
 get 0\n \
 get 1\n \
 lel\n \
gej i:jj export gej\n \
 get 0\n \
 get 1\n \
 gej\n \
gel i:jj export gel\n \
 get 0\n \
 get 1\n \
 gel\n \
eqe i:ee export eqe\n \
 get 0\n \
 get 1\n \
 eqe\n \
nee i:ee export nee\n \
 get 0\n \
 get 1\n \
 nee\n \
lte i:ee export lte\n \
 get 0\n \
 get 1\n \
 lte\n \
gte i:ee export gte\n \
 get 0\n \
 get 1\n \
 gte\n \
lee i:ee export lee\n \
 get 0\n \
 get 1\n \
 lee\n \
gee i:ee export gee\n \
 get 0\n \
 get 1\n \
 gee\n \
eqf i:ff export eqf\n \
 get 0\n \
 get 1\n \
 eqf\n \
nef i:ff export nef\n \
 get 0\n \
 get 1\n \
 nef\n \
ltf i:ff export ltf\n \
 get 0\n \
 get 1\n \
 ltf\n \
gtf i:ff export gtf\n \
 get 0\n \
 get 1\n \
 gtf\n \
lef i:ff export lef\n \
 get 0\n \
 get 1\n \
 lef\n \
gef i:ff export gef\n \
 get 0\n \
 get 1\n \
 gef\n \
clz i:i export clz\n \
 get 0\n \
 clz\n \
ctz i:i export ctz\n \
 get 0\n \
 ctz\n \
pci i:i export pci\n \
 get 0\n \
 pci\n \
adi i:ii export adi\n \
 get 0\n \
 get 1\n \
 adi\n \
sui i:ii export sui\n \
 get 0\n \
 get 1\n \
 sui\n \
mui i:ii export mui\n \
 get 0\n \
 get 1\n \
 mui\n \
dvi i:ii export dvi\n \
 get 0\n \
 get 1\n \
 dvi\n \
dvu i:ii export dvu\n \
 get 0\n \
 get 1\n \
 dvu\n \
moi i:ii export moi\n \
 get 0\n \
 get 1\n \
 moi\n \
mou i:ii export mou\n \
 get 0\n \
 get 1\n \
 mou\n \
ani i:ii export ani\n \
 get 0\n \
 get 1\n \
 ani\n \
ori i:ii export ori\n \
 get 0\n \
 get 1\n \
 ori\n \
xoi i:ii export xoi\n \
 get 0\n \
 get 1\n \
 xoi\n \
sli i:ii export sli\n \
 get 0\n \
 get 1\n \
 sli\n \
sri i:ii export sri\n \
 get 0\n \
 get 1\n \
 sri\n \
sru i:ii export sru\n \
 get 0\n \
 get 1\n \
 sru\n \
rli i:ii export rli\n \
 get 0\n \
 get 1\n \
 rli\n \
rri i:ii export rri\n \
 get 0\n \
 get 1\n \
 rri\n \
noi i:i export noi\n \
 get 0\n \
 noi\n \
clj j:j export clj\n \
 get 0\n \
 clj\n \
ctj j:j export ctj\n \
 get 0\n \
 ctj\n \
pcj j:j export pcj\n \
 get 0\n \
 pcj\n \
adj j:jj export adj\n \
 get 0\n \
 get 1\n \
 adj\n \
suj j:jj export suj\n \
 get 0\n \
 get 1\n \
 suj\n \
muj j:jj export muj\n \
 get 0\n \
 get 1\n \
 muj\n \
dvj j:jj export dvj\n \
 get 0\n \
 get 1\n \
 dvj\n \
dvl j:jj export dvl\n \
 get 0\n \
 get 1\n \
 dvl\n \
moj j:jj export moj\n \
 get 0\n \
 get 1\n \
 moj\n \
mol j:jj export mol\n \
 get 0\n \
 get 1\n \
 mol\n \
anj j:jj export anj\n \
 get 0\n \
 get 1\n \
 anj\n \
orj j:jj export orj\n \
 get 0\n \
 get 1\n \
 orj\n \
xoj j:jj export xoj\n \
 get 0\n \
 get 1\n \
 xoj\n \
slj j:jj export slj\n \
 get 0\n \
 get 1\n \
 slj\n \
srj j:jj export srj\n \
 get 0\n \
 get 1\n \
 srj\n \
srl j:jj export srl\n \
 get 0\n \
 get 1\n \
 srl\n \
rlj j:jj export rlj\n \
 get 0\n \
 get 1\n \
 rlj\n \
rrj j:jj export rrj\n \
 get 0\n \
 get 1\n \
 rrj\n \
noj j:j export noj\n \
 get 0\n \
 noj\n \
abe e:e export abe\n \
 get 0\n \
 abe\n \
nge e:e export nge\n \
 get 0\n \
 nge\n \
cee e:e export cee\n \
 get 0\n \
 cee\n \
fle e:e export fle\n \
 get 0\n \
 fle\n \
tre e:e export tre\n \
 get 0\n \
 tre\n \
nae e:e export nae\n \
 get 0\n \
 nae\n \
sqe e:e export sqe\n \
 get 0\n \
 sqe\n \
ade e:ee export ade\n \
 get 0\n \
 get 1\n \
 ade\n \
sue e:ee export sue\n \
 get 0\n \
 get 1\n \
 sue\n \
mue e:ee export mue\n \
 get 0\n \
 get 1\n \
 mue\n \
dve e:ee export dve\n \
 get 0\n \
 get 1\n \
 dve\n \
mie e:ee export mie\n \
 get 0\n \
 get 1\n \
 mie\n \
mae e:ee export mae\n \
 get 0\n \
 get 1\n \
 mae\n \
cse e:ee export cse\n \
 get 0\n \
 get 1\n \
 cse\n \
abf f:f export abf\n \
 get 0\n \
 abf\n \
ngf f:f export ngf\n \
 get 0\n \
 ngf\n \
cef f:f export cef\n \
 get 0\n \
 cef\n \
flf f:f export flf\n \
 get 0\n \
 flf\n \
trf f:f export trf\n \
 get 0\n \
 trf\n \
naf f:f export naf\n \
 get 0\n \
 naf\n \
sqf f:f export sqf\n \
 get 0\n \
 sqf\n \
adf f:ff export adf\n \
 get 0\n \
 get 1\n \
 adf\n \
suf f:ff export suf\n \
 get 0\n \
 get 1\n \
 suf\n \
muf f:ff export muf\n \
 get 0\n \
 get 1\n \
 muf\n \
dvf f:ff export dvf\n \
 get 0\n \
 get 1\n \
 dvf\n \
mif f:ff export mif\n \
 get 0\n \
 get 1\n \
 mif\n \
maf f:ff export maf\n \
 get 0\n \
 get 1\n \
 maf\n \
csf f:ff export csf\n \
 get 0\n \
 get 1\n \
 csf\n \
ioj i:j export ioj\n \
 get 0\n \
 ioj\n \
ioe i:e export ioe\n \
 get 0\n \
 ioe\n \
uoe i:e export uoe\n \
 get 0\n \
 uoe\n \
iof i:f export iof\n \
 get 0\n \
 iof\n \
iou i:f export iou\n \
 get 0\n \
 iou\n \
joi j:i export joi\n \
 get 0\n \
 joi\n \
jou j:i export jou\n \
 get 0\n \
 jou\n \
joe j:e export joe\n \
 get 0\n \
 joe\n \
loe j:e export loe\n \
 get 0\n \
 loe\n \
jof j:f export jof\n \
 get 0\n \
 jof\n \
lof j:f export lof\n \
 get 0\n \
 lof\n \
eoi e:i export eoi\n \
 get 0\n \
 eoi\n \
eou e:i export eou\n \
 get 0\n \
 eou\n \
eoj e:j export eoj\n \
 get 0\n \
 eoj\n \
eol e:j export eol\n \
 get 0\n \
 eol\n \
eof e:f export eof\n \
 get 0\n \
 eof\n \
foi f:i export foi\n \
 get 0\n \
 foi\n \
fou f:i export fou\n \
 get 0\n \
 fou\n \
foj f:j export foj\n \
 get 0\n \
 foj\n \
fol f:j export fol\n \
 get 0\n \
 fol\n \
foe f:e export foe\n \
 get 0\n \
 foe\n \
ire i:e export ire\n \
 get 0\n \
 ire\n \
jrf j:f export jrf\n \
 get 0\n \
 jrf\n \
eri e:i export eri\n \
 get 0\n \
 eri\n \
frj f:j export frj\n \
 get 0\n \
 frj\n \
ixg i:i export ixg\n \
 get 0\n \
 ixg\n \
ixh i:i export ixh\n \
 get 0\n \
 ixh\n \
jxg j:j export jxg\n \
 get 0\n \
 jxg\n \
jxh j:j export jxh\n \
 get 0\n \
 jxh\n \
jxi j:j export jxi\n \
 get 0\n \
 jxi\n \
ngi i:i export ngi\n \
 get 0\n \
 ngi\n \
ngj j:j export ngj\n \
 get 0\n \
 ngj\n \
adz z:zz export adz\n \
 get 0\n \
 get 1\n \
 adz\n \
suz z:zz export suz\n \
 get 0\n \
 get 1\n \
 suz\n \
scz z:zz export scz\n \
 get 0\n \
 get 1\n \
 scz\n \
eqz i:zz export eqz\n \
 get 0\n \
 get 1\n \
 eqz\n \
nez i:zz export nez\n \
 get 0\n \
 get 1\n \
 nez\n \
ngz z:z export ngz\n \
 get 0\n \
 ngz\n \
zoi z:i export zoi\n \
 get 0\n \
 zoi\n \
zoj z:j export zoj\n \
 get 0\n \
 zoj\n \
zoe z:e export zoe\n \
 get 0\n \
 zoe\n \
zof z:f export zof\n \
 get 0\n \
 zof\n \
foz f:z export foz\n \
 get 0\n \
 foz\n \
imz f:z export imz\n \
 get 0\n \
 imz\n \
zrr z:f export zrr\n \
 get 0\n \
 zrr\n \
stz :iz export stz\n \
 get 0\n \
 get 1\n \
 stz\n \
ldz z:i export ldz\n \
 get 0\n \
 ldz\n \
ldi i:i export ldi\n \
 get 0\n \
 ldi\n \
ldj j:i export ldj\n \
 get 0\n \
 ldj\n \
lde e:i export lde\n \
 get 0\n \
 lde\n \
ldf f:i export ldf\n \
 get 0\n \
 ldf\n \
ldg i:i export ldg\n \
 get 0\n \
 ldg\n \
ldb i:i export ldb\n \
 get 0\n \
 ldb\n \
ldh i:i export ldh\n \
 get 0\n \
 ldh\n \
lds i:i export lds\n \
 get 0\n \
 lds\n \
sti :ii export sti\n \
 get 0\n \
 get 1\n \
 sti\n \
stj :ij export stj\n \
 get 0\n \
 get 1\n \
 stj\n \
ste :ie export ste\n \
 get 0\n \
 get 1\n \
 ste\n \
stf :if export stf\n \
 get 0\n \
 get 1\n \
 stf\n \
stg :ii export stg\n \
 get 0\n \
 get 1\n \
 stg\n \
sth :ii export sth\n \
 get 0\n \
 get 1\n \
 sth\n \
siz i: export siz\n \
 siz\n \
grw i:i export grw\n \
 get 0\n \
 grw\n \
cpy :iii export cpy\n \
 get 0\n \
 get 1\n \
 get 2\n \
 cpy\n \
fil :iii export fil\n \
 get 0\n \
 get 1\n \
 get 2\n \
 fil\n \
"
/*asm simplifier

 set .   tee .
 get .

 tee .   set .
 drp

 i .     j .
 joi

 i .     fold
 i .
 sli/adi/mli/*

 todo: - dont assign 0 at first set: (i 0;set x)->()  (i 0;tee x)->(i 0)
*/

/*
let opt=(a,A)=>{ //input flat array (nonformatted), A:ai module exports
 if(a<1)return a
 let C="eqi nei lti ltu gti gtu lei leu gei geu adi sui mui dvi dvu moi mou ani ori xoi sli sri sru rli rri" //all(i:ii)
 let r=[a[0]],j=0,k=1,o
 for(let i=1;i<a.length;i++){ let ai=a[i]

  o=r[j].slice(0,3)
  c=ai.slice(0,3)
  if("set"==o&&"get"==c&&(r[j].slice(3)==(s=ai.slice(3)))){
   r[j]="tee"+s; continue }
  
  if("tee"==o&&"drp"==c){ r[j]="set "+r[j].slice(4); continue }

  o=r[j].slice(0,2)
  if("i "==o&&"joi"==c){ r[j]="j "+r[j].slice(2); continue }

  if("i "==o&&"i "==r[j-1].slice(0,2)&&-1<(s=C.indexOf(ai))){
   s=A[C.slice(s,s+3)]( Number(r[j-1].slice(2)), Number(r[j].slice(2)) )
   r[j-1]="i "+s;r.pop();j--;continue;}

  r[++j]=ai}
 return r}
*/

let opt=a=>{ //format
 let s=""
 for(let i=0;i<a.length;i++){let b=a[i]
  if(b.includes(":")){s="";continue}
   if(b.startsWith("else")||b.startsWith("do")||b.startsWith("end"))s=s.slice(1)
   a[i]=s+b
   if(b.startsWith("else")||b.startsWith("if")||b.startsWith("while")||b.startsWith("do"))s+=" "
 }
 return a
}
let winter=(R,x)=>{
let C="aaaaaaaaaanaaaaaaaaaaaaaaaaaaaaaadhddddebcdddjgmggggggggggebdedddffffffffffffffffffffffffffblcddiffffkfffffffffffffffffffffbdcdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
let T="abcdefghijfdkbabcdefghijfdkbabcdefghidfddbabcdrfghijfddbabcdefghijfddbabcdemmhidmddbabcdennhidoddbppppppprpppqppabcdemghidmddbabcdefnhijfddblllllllllllllblllllllllllllbabcdemmhidmddbabcdennhidoddbabcdennhinnddbppppppprpppqppppppppppppppppabcdefghidfddb"
//winter(R,f) R.f(functions), R.g:(globals) filled by ab.js, R.v={} vars(globals&new vars)
if(R.A.constructor!=WebAssembly.Instance)R.A=new WebAssembly.Instance(R.A)
if(!("v"in R))R.v={}
let perr=e=>{throw new Error(e)}
if(!Object.keys(R).length)perr("not runtime information")

let ic=x=>x.split("").map(x=>x.charCodeAt(0))
C=ic(C).map(x=>x-97);T=ic(T).map(x=>x-97)
let cut=(x,i)=>i.map((_,k)=>x.slice(i[k],i[1+k]))
let token=(x,s,i,l)=>(s=0,i=ic(x).map(x=>s=T[14*s+C[x]]).map((x,i)=>x>10?-1:i).filter(x=>x>=0),
 x=cut(x,i),s=i.map((_,j)=>((x[j]==" ")||((j==0||x[j-1]==" "||x[j-1]=="\n")&&(x[j][0]=="/"&&x[j][1]!="'"))?0:1)),
 l=0,s.forEach((y,i)=>{if(y)l=(";"==x[i]||"\n"==x[i]?((s[i]=l?0:1),1):0)}),
 [where(x,s).map(x=>x=="\n"?";":x).toReversed(),where(i,s).toReversed()])
let where=(x,k)=>x.filter((_,i)=>k[i])
let min=Math.min
let af=x=>Array.from(x)

let left="([{",right="}])"
let op=":+*%&|<>=~!,^#_$?@/\\",nm=".-0123456789",az="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",vc="BGHSIEJFZ"

let tok,pos
let ipos=0,typs="ijefzBGHSIJEFZ",it=t=>typs.indexOf(t)
let l=x=>x[x.length-1],lop=x=>l(x).slice(0,3),vt=x=>vc.includes(x.t)
let type=(x,t)=>x=="-"||op.includes(x[0])?0:(nm.includes(x[0])?(typs.includes(l(x))?l(x):x.includes("a")?"z":x.includes(".")?"f":"i"):"?")
let upty=(x,y)=>(/*x=avec(x),y=avec(y),*/x.t==y.t?[x,y]:it(x.t)<it(y.t)?[conv(x,y.t),y]:[x,conv(y,x.t)])
let next=(r,t)=>(r=tok.pop(),r==undefined?0:(t=type(r),r=["if".includes(t)?parseFloat(r):"j"==t?BigInt(r.slice(0,-1)):r],r.t=t,r.p=(ipos=pos.pop()),r))
let cast=(x,t)=>(x.t!=t)?perr("nyi:cast"):x
let peek=_=>l(tok)
let list=p=>{let e,r=[];r.t="l";while(1){if(right.includes(peek())){next();return r};r.push(e=expr(term()));if(";"==peek())next();if(!e)perr("unclosed",p)}}
let asin=(n,a,y)=>(y=cast(y,R.g[n]),y=(a!=":")?perr("nyi:modified-assign"):y,I.exports[n].value=y[0],y)
let term=(r,n)=>{r=peek();if(";"==r[0]||"{"==r[0]||right.includes(r[0]))return 0
 r=next();if(!r)return r
 if("("==r[0]){n=ipos;r=expr(term());if(")"!=peek())perr("unclosed)",n);next();return r}
 if(left.includes(r[0]))return list() //todo
 if('"'==r[0][0])return char(r)       //todo
 n=r[0][0];if(az.includes(n)){n=r[0]
       if(n in R.g){R.v[n]=I.exports[n];R.v[n].t=R.g[n];if(peek().endsWith(":")){return asin(n,next(),expr(term()))};r[0]=R.v[n].value;r.t=R.v[n].t}
  else if(n in R.v){                                   ;if(peek().endsWith(":")){return asin(n,next(),expr(term()))};r[0]=R.v[n].value;r.t=R.v[n].t}
  else if(n in R.f){if(peek().endsWith(":"))perr("reassign function "+n);r[0]=I.exports[n];r.t=R.f[n].r+":"+R.f[n].a}
  else if(":"==peek()){next();r=expr(term());R.v[n]={value:r[0],t:r.t};return r}
  else {console.log("n in v?",n in R.v);perr("lookup: "+n)}
 }
 while("["==peek()){next();n=list();if(r[0]=="$")perr("no-cond");r=peek().endsWith(":")?amnd(r,(1!=n.length?perr("rank assign",n.p):n[0]),next(),expr(term())):cali(r,n)}
 return r
}
let acal=(f,...x)=>R.A.exports[f](...x)
let cali=(x,y,a)=>(x.t.includes(":")?(x.t=x.t.slice(0,x.t.indexOf(":")),x[0]=x[0](...y.map(x=>x[0])),x):perr("cali/nyi index"))
let nega=(x,p)=>(("ijefz".includes(x.t)?x[0]=acal("ng"+x.t,x[0]):perr("neg on type "+x.t,p)),x)
let dyad=(x,y,z,d,i,p)=>(d="+ad-ad*mu%dv%'dv\\sl/sr/'sr=eq~ne<ge>le<=gt>=lt<'gt>'lt",
 p=y.p,y=y[0],y=="#"?take(x,z,p):y=="_"?drup(x,z,p):([x,z]=upty(x,z),z=("-"==y?nega(z,z.p):z),[x,z]="%"==y[0]?[z,x]:[x,z],
  i=d.indexOf(y),i>=0?z[0]=acal(d.slice(i+y.length,2+i+y.length)+(y[1]=="'"?("j"==z.t?"l":"u"):z.t),z,x):(perr("dyadic"+y)),z.t="~<=>".includes(y[0])?"i":z.t,z))
let mona=(x,y,i,m)=>{console.log("monadic-nyi",x,y);return
 x[0]=="#"?(vt(y)?(nyi()):perr("rank")):x[0]==":"?perr(":x (cannot return)"):(/*y=avec(y),*/(m="!iezi!jezj~inoi~jnoj-ingi-jngj-enge-fngf|eabe|fabf_efle_fflf%esqe%fsqf"),(i=m.indexOf(x[0]+y.t))<0?perr("monadic"):(y[0]=acal(m.slice(2+i,5+i),y[0])),y)
}

let expr=x=>{if(!x)return x
  let y=term(),r,v=x=>!x.t
  if(!y)return x
  if(v(y)&&!(v(x))){
   r=expr(term())
   if(!r)perr("1+")
   return"@"==y[0]?cali(x,r):y[0].endsWith(":")?asxy(x,y,r):dyad(x,y,r)
  }
  r=expr(y)
  return(v(x))?mona(x,r)/*:x[0].startsWith("cast ")?cast(r,x.t)*/:cali(x,[r])
}
//let vect=x=>{ x.t.toLowerCase()+"#"  200#i)..
//BGHSIEJFZ
let dots=x=>x.length>70?x.slice(0,70)+"..":x
let vstr=(n,a,f)=>dots(af(new f(I.exports.memory.buffer,a,min(36,n))).join(" "))
let jspl=x=>[Number(x[0]>>32n),Number(x[0]&0xffffffffn)]
let vect=(x,n,a,t)=>([n,a]=jspl(x),t=x.t,n+"#"+t+")"+vstr(n,a,t=="G"?Int8Array:t=="B"?Uint8Array:t=="H"?Int16Array:t=="S"?Uint16Array:t=="I"?Int32Array:t=="U"?Uint32Array:t=="J"?BigInt64Array:t=="L"?BigUint64Array:t=="E"?Float32Array:t=="F"?Float64Array:t=="Z"?perr("zvec-nyi"):perr("vectype:"+t)))
let exec=x=>{[tok,pos]=token(x.trim()+"}");if(l(tok)=="\\")return help();x=l(list());return vc.includes(x.t)?vect(x):x.t+")"+x}
let help=_=>"globals  : "+Object.keys(R.g).map(x=>x+":"+R.g[x]).join(" ")+"\n"+
            "new vars : "+Object.keys(R.v).filter(x=>!(x in R.g)).map(x=>x+":"+R.v[x].t).join(" ")+"\n"+
            "functions:\n"+Object.keys(R.f).map(x=>" "+x+" "+R.f[x].r+":"+R.f[x].a).join("\n")

return exec(x)}
//embed

let indicate=x=>{let i=b.lastIndexOf("\n",x),j=b.indexOf("\n",x);i=i<0?0:i;j=j<0?b.length:j;console.log(b.slice(i,j));console.log(" ".repeat(x-i)+"^")}
let ed={selectionStart:0,selectionEnd:0,focus:_=>indicate(ed.selectionStart)}
let aout=0,xout=0,wout=0,aint=0
let argv=process.argv.slice(2)
if(argv.length&&argv[0].startsWith("-")){let a0=argv[0]
 a0=="-a"?aout=1:a0=="-i"?aint=1:a0=="-w"?wout=1:"-x"==a0?xout=1:argv.push(1,2,3)
 argv=argv.slice(1)
}
if(1>argv.length||(!(argv[0].endsWith(".b")))){
 console.log(process.argv[0], process.argv[1])
 console.log("use:")
 console.log("$b    file.b       /repl")
 console.log("$b    file.b func args.. /run")
 console.log("$b -i file.b       /interpret")
 console.log("$b -a file.b       /print  asm")
 console.log("$b -x file.b       /hexdump wasm")
 console.log("$b -w file.b       /writes file.wasm")
 process.exit(1)
}
let xxd=(x,s,i,o,O)=>(i=0,o="",O=x=>o+=x,s="  ",x.forEach((x,i)=>{
 if(0==i%16)(O((i?s+"\n":"")+i.toString(16).padStart(8,'0')+":"),s="  ")
 if(0==i%2)O(" ");O(x.toString(16).padStart(2,'0'));s+=(x>31&&x<127)?String.fromCharCode(x):"."}),(i=x.length%16),O(i?" ".repeat(2.5*(16-x.length%16)):""+s),o)

//let xxd=x=>x.map(x=>x.toString(16).padStart(2,"0")).join(" ").match(/.{1,12}/g).join("\n").replaceAll(" \n","\n")
let R={}
let b=new TextDecoder("utf-8").decode(Deno.readFileSync(argv[0]))
let a=ab(b,R);a=opt(a.split("\n")).join("\n")
if(aout){console.log(a);process.exit(0)}
let w=wa(a)
if(xout){console.log(xxd(w));process.exit(0)}
if(wout){a=argv[0].slice(0,-2)+".wasm";Deno.writeFileSync(a,w);process.exit(0)}

let findtop=_=>8*(1+new BigInt64Array(I.exports.memory.buffer).findLastIndex(x=>x))
let malloc=x=>{x=((7+x)>>>3)<<3;I.top=I.top?I.top:findtop();let n=I.exports.memory.buffer.byteLength,t=I.top+x,r=I.top;if(t>n){I.exports.memory.grow((65535+(n-t))>>>16)};I.top=t;return r}
let libm=Object.assign(...("acos acosh asin asinh atan atan2 atanh cbrt ceil clz32 cos cosh exp expm1 floor hypot sin cos log log10 log1p pow random round sign sin tan tanh trunc".split(" ").map(x=>({[x]:Math[x]}))))

let M={env:{...{/*..*/malloc:malloc},...libm}}


let m=new WebAssembly.Module(w),I=new WebAssembly.Instance(m,M)
let repl=_=>{let buf=new Uint8Array(256),p=new Uint8Array([32]);R.A=new WebAssembly.Module(wa(aia));while(1){Deno.stdout.writeSync(p);let n=Deno.stdin.readSync(buf);if(!n)return;let x=new TextDecoder().decode(buf.subarray(0,n));try{console.log(winter(R,x.trim()))}catch(e){console.log(e)};}}

if(1==argv.length){repl();process.exit(0)}
let f;if(argv.length&&argv[1] in I.exports){f=argv[1];argv=argv.slice(2)}else{f="main";argv=argv.slice(1)}

let findsig=f=>{let x=b.split("\n").filter(x=>x.startsWith(f+":"));if(1!=x.length){throw new Error("cannot find signature for: "+f)};return x[0].slice(f.length+1).replace(/{.*/,"").split(":")}
let s=findsig(f),r=s[0],args=s[1]
if(args.length!=argv.length){throw new Error("args should be: "+args+", got "+argv.length+": "+argv)}
//todo ..convert chars
let unsup=x=>{throw new Error("unsupported argument type: "+x)}
argv=argv.map((x,i)=>"ief".includes(args[i])?Number(x):"j"==args[i]?BigInt(x):"C"==args[i]?bstring(x):unsup(args[i]))

if(aint){
 let A=new WebAssembly.Module(wa(aia))
 let I=ai.parse(a,M,A)
 console.log(ai.run(f,argv,I))
}else{
 console.log(I.exports[f](...argv))
}

