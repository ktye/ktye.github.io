#!/usr/bin/env -S deno --allow-read --allow-write

//embed
//written my mk. do not edit.
let ab=x=>{
let C="aaaaaaaaaanaaaaaaaaaaaaaaaaaaaaaadhddddebcdddjgmggggggggggebdedddffffffffffffffffffffffffffblcddiffffkfffffffffffffffffffffbdcdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
let T="abcdefghijfdkbabcdefghijfdkbabcdefghidfddbabcdrfghijfddbabcdefghijfddbabcdemmhidmddbabcdennhidoddbppppppprpppqppabcdemghidmddbabcdefnhijfddblllllllllllllblllllllllllllbabcdemmhidmddbabcdennhidoddbabcdennhinnddbppppppprpppqppppppppppppppppabcdefghidfddb"

let ic=x=>x.split("").map(x=>x.charCodeAt(0))
C=ic(C).map(x=>x-97);T=ic(T).map(x=>x-97)
let cut=(x,i)=>i.map((_,k)=>x.slice(i[k],i[1+k]))
let token=(x,s,i,l)=>(s=0,i=ic(x).map(x=>s=T[14*s+C[x]]).map((x,i)=>x>10?-1:i).filter(x=>x>=0),
 x=cut(x,i),s=i.map((_,j)=>((x[j]==" ")||((j==0||x[j-1]==" "||x[j-1]=="\n")&&(x[j][0]=="/"&&x[j][1]!="'"))?0:1)),
 l=0,s.forEach((y,i)=>{if(y)l=(";"==x[i]||"\n"==x[i]?((s[i]=l?0:1),1):0)}),
 [where(x,s).map(x=>x=="\n"?";":x).toReversed(),where(i,s).toReversed()])
let where=(x,k)=>x.filter((_,i)=>k[i])
let left="([{",right="}])"
let op=":+-*%&|<>=~!,^#_$?@/\\",nm=".-0123456789",az="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",vc="BGHSIEJFZ"
let parse=x=>{let[tok,pos]=x,locs,args,res,funs={},glob={},tabl={},data=[],lp=0
 let runt={
  "malloc":{r:"i",a:"i",c:["malloc i:i import env malloc"]},
  "fill.i":{r:"I",a:"ii",c:"fill.i j:ii\ni r\ni p\ni 2\nget 0\nsli\ncal malloc\nset r\nget 1\nif\nget r\nget 0\ni 2\nsli\nadi\nset p\nwhile\nget p\ni 4\nsui\ntee p\nget r\ngei\ndo\nget 1\nget p\nsti\nend\nend\nget r\njoi\nget 0\njoi\nj 32\nslj\norj\n"},
  "fill.j":{r:"J",a:"ij",c:"fill.j j:ij\ni r\ni p\ni 3\nget 0\nsli\ncal malloc\nset r\nget 1\nj 0\neqj\nezi\nif\nget r\nget 0\ni 3\nsli\nadi\nset p\nwhile\nget p\ni 8\nsui\ntee p\nget r\ngei\ndo\nget 1\nget p\nstj\nend\nend\nget r\njoi\nget 0\njoi\nj 32\nslj\norj\n"},
  "fill.e":{r:"E",a:"ie",c:"fill.e j:ie\ni r\ni p\ni 2\nget 0\nsli\ncal malloc\nset r\nget 1\ne 0\neqe\nezi\nif\nget r\nget 0\ni 2\nsli\nadi\nset p\nwhile\nget p\ni 4\nsui\ntee p\nget r\ngei\ndo\nget 1\nget p\nste\nend\nend\nget r\njoi\nget 0\njoi\nj 32\nslj\norj\n"},
  "fill.f":{r:"F",a:"if",c:"fill.f j:if\ni r\ni p\ni 3\nget 0\nsli\ncal malloc\nset r\nget 1\nf 0\neqf\nezi\nif\nget r\nget 0\ni 3\nsli\nadi\nset p\nwhile\nget p\ni 8\nsui\ntee p\nget r\ngei\ndo\nget 1\nget p\nstf\nend\nend\nget r\njoi\nget 0\njoi\nj 32\nslj\norj\n"},
  "fill.z":{r:"Z",a:"iz",c:"fill.z j:iz\ni r\ni p\ni 4\nget 0\nsli\ncal malloc\nset r\nget 1\nz 0\neqz\nezi\nif\nget r\nget 0\ni 4\nsli\nadi\nset p\nwhile\nget p\ni 16\nsui\ntee p\nget r\ngei\ndo\nget 1\nget p\nstz\nend\nend\nget r\njoi\nget 0\njoi\nj 32\nslj\norj\n"},
 }
 let mark=(...x)=>x.forEach(x=>(!(x in runt))?perr("no builtin: "+x):(x in funs)?0:funs[x]=runt[x])
 let ipos=0,typs="ijefzBGHSIJEFZ",it=t=>typs.indexOf(t)
 let l=x=>x[x.length-1],lop=x=>l(x).slice(0,3),vt=x=>vc.includes(x.t)
 let perr=(x,p)=>{p=p?p:ipos;if(ed){ed.selectionStart=ed.selectionEnd=p;ed.focus()};throw new Error("@"+p+": "+x)}
 let type=(x,t)=>x=="-"||op.includes(x[0])?0:(nm.includes(x[0])?(typs.includes(l(x))?l(x):x.includes(".")?"f":"i"):"i")
 let tyck=(x,y,p)=>{if(x!=y)perr("type",p)}
 let avec=x=>(vt(x)?(lp=x.n,x.push("ioj","get "+temp("i","i"),...shift(x.t),"adi","ld"+x.t.toLowerCase()),x.t=x.t.toLowerCase(),x):x)
 let upty=(x,y)=>(x=avec(x),y=avec(y),x=xloc(x,y),x.t==y.t?[x,y]:it(x.t)<it(y.t)?(x.push(y.t+"o"+x.t),x.t=y.t):(y.push(x.t+"o"+y.t),y.t=x.t),[x,y])
 let loty=t=>t.charCodeAt(0)<97?"j":t
 let next=(r,t)=>(r=tok.pop(),r==undefined?0:(t=type(r),r=[r],r.t=t,r.p=(ipos=pos.pop()),r))
 let peek=_=>l(tok)
 let immm=(x,i)=>(x=x.slice(4),(i=x.indexOf(" @"),i)?x.slice(0,i):x)
 let loop=x=>lp?(drop(x),x=[...lp,"set n","i -1","set i","while","get i","i 1","adi","tee i","get n","lti","do",...x,"end"],x.t=0,lp=0,x):x
 let list=p=>{let e,r=[];r.t="l";while(1){if(right.includes(peek())){next();return r};r.push(e=loop(expr(term())));if(";"==peek())next();if(!e)perr("unclosed",p)}}
 let seql=(l,r)=>{if(!l.t=="l")return l;if(!l.length)return["nop"];r=[];l.forEach((x,i)=>{drop(x);r.push(...x)});r.t="";return r}
 let find=(x,y,a)=>{a=0;while((a=x.indexOf(y[0],1+a),a>=0));if(y.every((c,i)=>x[i+a]==c))return a;return x.length}
 let char=(x,s,i)=>{s=unqt(x[0].slice(1,-1));x.t="B";x.t="B";x.n=["i "+s.length];if(!s.length){x[0]="j 0";return x};i=find(data,s);if(i==data.length)data.push(...s);x[0]="j "+((BigInt(s.length)<<32n)|BigInt(i)).toString();return x}
 let argn=(s,i)=>(i=args.indexOf(s),i<0?s:i)
 let cndl=c=>{c=expr(term());if(c.t=="l"){if(c.length>1)perr("condition length");c=c[0]};if("{"!=peek())perr("expect-{");next();return[c,seql(list())]}
 let cond=(l,r)=>{if(l.length<3||1!=l.length%2)perr("cond length");r=[];r.t=l[l.length-1].t;l.forEach((x,i)=>(r.push(...x),(i==l.length-1)?r.push(...Array(l.length/2|0).fill("end")):r.push(i%2?(tyck(r.t,x.t,x.p),"else"):(tyck("i",x.t,x.p),"if "+r.t))));return r}
 let swtc=(l,r)=>{if(l.length<3)perr("switch length");r=[];r.t=l[l.length-1].t;l.forEach((x,i)=>(r.push(...x),tyck(x.t,r.t,x.p),r.push(i==0?"switch "+(l.length-1):i==l.length-1?"end":"endcase "+(i-1))));return r}
 let ical=(r,l,s)=>{r.pop();if(l.length<2)perr("icall length");s=r.t+":";if(!typs.includes(r.t))perr("icall return type");l.slice(1).forEach(x=>(s+=x.t,r.push(...x)));if(l[0].t!="i")perr("icall index type");r.push(...l[0],s);return r}
 let take=(x,y,p,s,v)=>(p=" @"+p,tyck(x.t,"i",x.p),vt(y)?(y.push("j 32","slj","j 32","srl"),x.push("joi"+p,"j 32","slj","orj"),y.push(...x),y):(x.push(...y,(mark("malloc","fill."+y.t),"cal fill."+y.t)),x.t=y.t.toUpperCase(),x))
 let drup=(x,y,p,s,v)=>(p=" @"+p,tyck(x.t,"i",x.p),vt(y)?1:perr("type",y.p),y.push(...x,"joi"+p,"tee "+(v=temp("j","n_x")), "j "+("BCHSIEJFZZ".indexOf(y.t)/2|0),"slj","adj","get "+v,"j 32","slj","suj"+p),y)
 let term=(r,n)=>{r=peek();if(r)if(";"==r[0]||"{"==r[0]||right.includes(r[0]))return 0
  r=next();if(!r)return r
  if("("==r[0]){n=ipos;r=expr(term());if(")"!=peek())perr("unclosed)",n);next();return r}
  if(left.includes(r[0]))return list()
  if('"'==r[0][0])return char(r)
  if(r.t&&nm.includes(n=r[0][0])){r[0]=r.t+" "+(typs.includes(l(r[0]))?r[0].slice(0,-1):r[0])+" @"+r.p;return r}
  if(r[0]=="if"){[r,n]=cndl();r.push("if",...n);"{"!=peek()?r.push("end"):(next(),r.push("else",...seql(list()),"end"));r.t="";return r}
  if(r[0]=="while"){[r,n]=cndl();r.unshift("while");r.push("do",...n,"end");r.t="";return r}
  if(az.includes(n)){n=r[0];[r[0],r.t]=(peek()=="?"?(next(),["cast",n]):n in locs?["get",locs[n]]:n in glob?["glo",glob[n]]:n in funs?["cal",funs[n].r]:peek().endsWith(":")?["get","?"]:perr("lookup"));r[0]+=" "+argn(n);r[0]+=" @"+r.p;if(!r[0].startsWith("cal")){r.n=["get "+argn(n),"j 32","srl","ioj"];r.n.t="i"}}
  while("["==peek()){next();n=list();if(r[0].startsWith("cast ")&&n.length>1)return ical(r,n);if(1==r.length&&"$?".includes(r[0])){return("$"==r[0]?cond(n):swtc(n))};r=peek().endsWith(":")?amnd(r,(1!=n.length?perr("rank assign",n.p):n[0]),next(),expr(term())):cali(r,n)}
  return r}
 let mona=(x,y,i,m)=>x[0]=="#"?(vt(y)?(y.push("j 32","srl","ioj"),y.t="i",y):perr("rank")):x[0]==":"?(cast(y,res),y.push("ret"),y):(y=avec(y),(m="!iezi!jezj~inoi~jnoj-ingi-jngj-enge-fngf|eabe|fabf_efle_fflf%esqe%fsqf"),(i=m.indexOf(x[0]+y.t))<0?perr("monadic"):(y.push(m.slice(2+i,5+i)+" @"+x.p),y))
 let nega=(x,p)=>("ij".includes(x.t)?(x.unshift(x.t+" 0"),x.push("su"+x.t+" @"+p)):x.push("ng"+x.t+" @"+p),x)
 let dyad=(x,y,z,d,i,p)=>(d="+ad-ad*mu%di%'di\\sl/sr/'sr=eq~ne<ge>le<=gt>=lt<'gt>'lt",p=y.p,y=y[0],y=="#"?take(x,z,p):y=="_"?drup(x,z,p):([x,z]=upty(x,z),z=("-"==y?nega(z,z.p):z),[x,z]="%"==y[0]?[z,x]:[x,z],z.push(...x),i=d.indexOf(y),i>=0?z.push(d.slice(i+y.length,2+i+y.length)+(y[1]=="'"?("j"==z.t?"l":"u"):z.t)+" @"+p):(perr("dyadic"+y)),z.t="~<=>".includes(y[0])?"i":z.t,z))
 let cast=(x,t)=>t==x.t?x:(x.push(loty(t)+"o"+loty(x.t)),x.t=t,x)
 let temp=(t,q,s)=>(s=(q?q:"$"+t),s in locs?s:(locs[s]=t,s))
 let xloc=(x,y)=>x.t=="?"?(locs[immm(x[0])]=y.t,x.t=y.t,x):x
 let shift=(t,s)=>(s="bghsiejfz".indexOf(t.toLowerCase()),s=s?["i "+(s>>1),"sli"]:[])
 let mamd=(x,i,f,z)=>(x.push("ioj",...i,...shift(x.t),"tee "+temp("i","_i")),x.t=x.t.toLowerCase(),x.push("ld"+x.t),f[0]=f[0].slice(0,-1),x=dyad(x,f,z),x.push("set "+temp(x.t),"get _i","get "+temp(x.t),"st"+x.t,"get $"+x.t),x)
 let amnd=(x,i,f,z)=>(f[0]!=":"?mamd(x,i,f,z):(x.push("ioj",...i,...shift(x.t),"adi",...z,"tee "+temp(z.t),"st"+x.t.toLowerCase(),"get "+temp(z.t)),x.t=z.t,x))
 let indx=(x,y,t,s)=>((y.t!="i"||(t=x.t,!vt(x)))?perr("index type"+t):t=t.toLowerCase(),x.push("ioj",...y,...shift(t),"adi","ld"+t ),x.t=t,x)
 let cali=(x,y,a)=>(y="l"!=y.t?[y]:y,x[0].startsWith("cal ")?(a=funs[immm(x[0])],a.a.length!=y.length?perr("arity"):(y=y.map((x,i)=>cast(x,a.a[i]))),y=y.flat(),y.push(x),y.t=a.r,y):(y.length!=1)?perr("index rank"):indx(x,y[0]))

/*
x :y  asin
x+:y  asin
X :Y  asin
x :Y  asin(x,avec(Y))
x+:Y  asin(x,avec(Y))

X :y  amnd(x,i,f,y)          lp=x.n
X+:y  amnd(x,i,f,y)
X+:Y  amnd(x,i,f,avec(Y))
*/

 let asxy=(x,a,y,v)=>(2==(v=vt(x)+vt(y))&&":"==a[0])||(!v)?asin(x,a,y):(y=vt(y)?avec(y):y,vt(x)?(lp=x.n,amnd(x,(v=["get i"],v.t="i",v),a,y)):asin(x,a,y))
 let asin=(x,a,y)=>(y=a[0]==":"?y:(a[0]=a[0][0],dyad(x,a,y)),x[0]=(x[0].startsWith("get")?"tee":"gst")+x[0].slice(3),x=xloc(x,y), 
  y.push(...x),x[0].startsWith("gst")?y.push("glo"+x[0].slice(3)):0,y)
 let drop=x=>{if(x.t&&typs.includes(x.t)&&"ret"!=lop(x)){"tee"==lop(x)?(x[x.length-1]="set"+x[x.length-1].slice(3)):"get"==lop(x)?x.pop():x.push("drp")}}
 let expr=x=>{if(!x)return x
  let y=term(),r,v=x=>!x.t
  if(!y)return x
  if(v(y)&&!(v(x))){
   r=expr(term())
   if(!r)perr("1+")
   return"@"==y[0]?cali(x,r):y[0].endsWith(":")?asxy(x,y,r):dyad(x,y,r)
  }
  r=expr(y)
  return(v(x))?mona(x,r):x[0].startsWith("cast ")?cast(r,x.t):cali(x,r)
 }
 let floc=(n,r)=>((!("i n r".includes(n)))?1:r.some(s=>s.split("\n").map(s=>s.split(" ")).some(x=>(x[0]=="get"||x[0]=="set"||x[0]=="tee")&&n==x[1])))
 let code=r=>(r=list(),(res&&!(l(r).t))?(r.push(["get r"]),l(r).t=res):0,r.forEach((x,i)=>{i==r.length-1?cast(x,res):drop(x);r[i]=x.join("\n")}),r.unshift(...Object.keys(locs).filter(x=>!args.includes(x)).filter(x=>floc(x,r)).map(x=>(vc.includes(locs[x])?"j":locs[x])+" "+x).sort()),r.join("\n"))
 let unqt=s=>{let r=[];for(let i=0;i<s.length;i++)r.push((s[i]=="\\"?(s[++i]=="n"?"\n":s[i]=="t"?"\t":s[i]):s[i]).charCodeAt(0));return r}
 let unhx=s=>s.match(/../g).map(x=>parseInt(x,16))
 let adda=(o,x)=>{if(o>data.length)data.push(...Array(o-data.length).fill(0));x.forEach((x,i)=>data[o+i]=x)}
 let ptop=_=>{while(";"==peek())next();let n=next(),a=next(),r;if(!n)return;if(a==0||a[0]!=":")perr("toplevel assignment")
  if(nm.includes(n[0][0])){a=Number(n[0]);n=next();if(n[0][0]=="["){while((n=next(),n&&n!="]"))az.includes(n[0][0])?tabl[a++]=[n[0],ipos]:perr("table syntax")}else adda(a,n[0][0]=='"'?unqt(n[0].slice(1,-1)):unhx(n[0]))}
  else{r=next();if(r&&nm.includes(r[0][0])){if(0!=Number(r[0]))perr("nonzero global");glob[n]=r.t;return}
   let f={n:n[0],p:n.p,r:r[0]};r=next();if(r[0]!=":")perr("signature");f.a=next()[0];r=next();if(r[0]!="{"){f.l={};funs[f.n]=f;return};if(peek()=="["){next();f.l={};f.a.split("").forEach((t,i,a,x)=>{x=next();if((!x)||(!az.includes(x[0][0])))perr("arg name:"+x[0][0]);f.l[x[0]]=t;x=next();if(x[0]!=(i<a.length-1?";":"]"))perr("arg length")})}
   if(!("l"in f)){f.l={};"xyzabcdefghijklmnopqrstuvw".slice(0,f.a.length).split("").forEach((x,i)=>f.l[x]=f.a[i])}
   f.l.i="i";f.l.n="i";if(f.r)f.l.r=f.r;
   f.tok=[],f.pos=[];r=0;while(tok.length){n=tok.pop(),a=pos.pop();r+=n=="{"?1:n=="}"?-1:0;f.tok.unshift(n);f.pos.unshift(a);if(r<0)break};if(f.n in funs)perr("func "+f.n+" already defined",f.p);funs[f.n]=f;if(r>=0)perr("function unclosed: "+f.n,f.p)
 }}
 while(tok.length)ptop();for(let n in funs){let f=funs[n],imp=f.tok?0:1;locs=f.l;args=Object.keys(locs).slice(0,f.a.length);tok=f.tok,pos=f.pos;res=f.r;f.c=f.c?f.c:"\n"+f.n+" "+loty(f.r)+":"+(f.a.split("").map(loty).join(""))+(imp?" import env ":" export ")+f.n+" @"+f.p+(imp?"":"\n"+code())}
 let I=Object.keys(funs).filter(x=>!funs[x].tok).map(x=>funs[x].c).join("\n")
 let F=Object.keys(funs).filter(x=> funs[x].tok).map(x=>funs[x].c).join("\n")
 let t="";for(o in tabl){t+="\ntab "+o+" "+tabl[o][0];if(!(tabl[o][0]in funs))perr("unknown func in table: "+tabl[o][0],tabl[o][1])}
 let n=(((7+data.length)>>3)<<3)
 let d="";{let o=0,x=data;while((((7+x.length)>>3)<<3)>x.length)x.push(0);if(x.length)x.push(...unqt("data end"));while(x.length){d+="0000000000000000"==(y=(x.length>8?x.slice(0,8):x).map(x=>x.toString(16).padStart(2,"0")).join(""))?"":"\ndat "+o+" "+y;o+=8;x=x.slice(8)}}
 return I+F+t+d}
return parse(token(x))}
/* wa:wasm compiler
   wa compiles a(assembly) to a wasm binary (uint8array)

   the wasm binary can be downloaded with Compile->Save wasm

   see help/a for a description of the assembly language.  */

//wa.js opcode table is generated by ../ai/wa.mk, source is wa_js
let wa=(_=>{
let o,O=x=>o.push(...(Array.isArray(x)?x:[x])),E=(l,x)=>{if(ea)ea.selectedIndex=l;throw new Error("wa: line "+l+": "+x)},
lebu=(x,r,b)=>{r=[];do{b=x&127;r.push((x>>>=7)?b|=128:b)}while(x);return r},                                                         //unsigned i32
lebs=(x,r,b)=>{x|=0;r=[];while(1){b=x&127;x>>=7;if(x==0&&!(b&64)||(x==-1&&(b&64))){r.push(b);break};r.push(b|128)};return r},        //signed i32
lebn=(x,r,b)=>{r=[];while(1){b=Number(x&127n);x>>=7n;if(x==0n&&!(b&64)||(x==-1n&&(b&64))){r.push(b);break};r.push(b|128)};return r},  //signed BitInt
sect=(x,y)=>(y.length&&y[0]!=0)?(O(x),O(lebu(y.length)),O(y)):0,
vect=x=>[...lebu(x.length),...x.flat()],
typs={"":0,g:1,i:127,j:126,e:125,f:124,z:123},
expo=(n,j)=>n.map((x,i)=>[...lebu(x.length),...x.split("").map(x=>x.charCodeAt(0)),2*!i,...lebu(j[i])]),
locs=x=>{let t=new Map();Object.values(x.lo).forEach(x=>t.set(x,(t.has(x)?1+t.get(x):1)));let r=vect([...t.keys()].map(x=>[...lebu(t.get(x)),Number(x)]));return r},
asci=x=>[...lebu(x.length),...x.split("").map(x=>x.charCodeAt(0))],
iota=x=>Array(x).fill(0).map((_,i)=>i),
hexa=x=>x.match(/.{1,2}/g).map(x=>parseInt(x,16)),
repa=(n,x)=>Array(n).fill(x).flat(),

/*o-p-s*/
ops={ezi:0x45,eqi:0x46,nei:0x47,lti:0x48,ltu:0x49,gti:0x4a,gtu:0x4b,lei:0x4c,leu:0x4d,gei:0x4e,geu:0x4f,ezj:0x50,eqj:0x51,nej:0x52,ltj:0x53,ltl:0x54,
gtj:0x55,gtl:0x56,lej:0x57,lel:0x58,gej:0x59,gel:0x5a,eqe:0x5b,nee:0x5c,lte:0x5d,gte:0x5e,lee:0x5f,gee:0x60,eqf:0x61,nef:0x62,ltf:0x63,gtf:0x64,
lef:0x65,gef:0x66,clz:0x67,ctz:0x68,pci:0x69,adi:0x6a,sui:0x6b,mui:0x6c,dvi:0x6d,dvu:0x6e,moi:0x6f,mou:0x70,ani:0x71,ori:0x72,xoi:0x73,sli:0x74,
sri:0x75,sru:0x76,rli:0x77,rri:0x78,noi:[0x41,0x7f,0x73],clj:0x79,ctj:0x7a,pcj:0x7b,adj:0x7c,suj:0x7d,muj:0x7e,dvj:0x7f,dvl:0x80,moj:0x81,mol:0x82,anj:0x83,
orj:0x84,xoj:0x85,slj:0x86,srj:0x87,srl:0x88,rlj:0x89,rrj:0x8a,noj:[0x42,0x7f,0x85],abe:0x8b,nge:0x8c,cee:0x8d,fle:0x8e,tre:0x8f,nae:0x90,sqe:0x91,ade:0x92,
sue:0x93,mue:0x94,dve:0x95,mie:0x96,mae:0x97,cse:0x98,abf:0x99,ngf:0x9a,cef:0x9b,flf:0x9c,trf:0x9d,naf:0x9e,sqf:0x9f,adf:0xa0,suf:0xa1,muf:0xa2,
dvf:0xa3,mif:0xa4,maf:0xa5,csf:0xa6,ioj:0xa7,ioe:0xa8,uoe:0xa9,iof:0xaa,iou:0xab,joi:0xac,jou:0xad,joe:0xae,loe:0xaf,jof:0xb0,lof:0xb1,eoi:0xb2,
eou:0xb3,eoj:0xb4,eol:0xb5,eof:0xb6,foi:0xb7,fou:0xb8,foj:0xb9,fol:0xba,foe:0xbb,ire:0xbc,jrf:0xbd,eri:0xbe,frj:0xbf,ixg:0xc0,ixh:0xc1,jxg:0xc2,
jxh:0xc3,jxi:0xc4,ngi:[65,127,108],ngj:[66,127,127],drp:0x1a,sel:0x1b,ret:0x0f,adz:[0xfd,0xf0,1],suz:[0xfd,0xf1,1],scz:[0xfd,0xf2,1],eqz:[0xfd,0x41,0xfd,0xc3,1],nez:[0xfd,0x42,0xfd,0x53],ngz:[0xfd,0xed,1],zoi:[0xb7,0xfd,0x14,0x41,0,0xb7,0xfd,0x22,1],zoj:[0xb9,0xfd,0x14,0x41,0,0xb7,0xfd,0x22,1],zoe:[0xbb,0xfd,0x14,0x41,0,0xb7,0xfd,0x22,1],
zof:[0xfd,0x14,0x41,0,0xb7,0xfd,0x22,1],foz:[0xfd,0x21,0],imz:[0xfd,0x21,1],zrr:[0xfd,0x14],stz:[0xfd,0x0b,4,0],ldz:[0xfd,0,4,0],ldi:[0x28,2,0],ldj:[0x29,3,0],lde:[0x2a,2,0],ldf:[0x2b,3,0],ldg:[0x2c,0,0],ldb:[0x2d,0,0],ldh:[0x2e,1,0],lds:[0x2f,1,0],sti:[0x36,2,0],stj:[0x37,3,0],
ste:[0x38,2,0],stf:[0x39,3,0],stg:[0x3a,0,0],sth:[0x3b,1,0],siz:[0x3f,0],grw:[0x40,0],cpy:[0xfc,10,0,0],fil:[0xfc,11,0],}
/*o-p-s*/

return(x=>{
 //parse asm 
 let a,n=0,narg=0,s,e="",imp=0,c=[],lo={},i,p=_=>((n?funs.push({sig:s,lo:lo,code:c,name:n,export:e,import:imp}):0),[n,s,e,imp,c,lo]=[0,"","",0,[],{}]),
 sigs=[],addsig=x=>(sigs.includes(x)?x:sigs.push(x),x), //e.g. ["i:ii",":ij",..]
 fns={},funs=[],       //{sig:"i:ii",code:[1,2,..],name:"a","export":"A"}
 lsrt=_=>lo=Object.fromEntries(Object.entries(lo).sort(([,a],[,b])=>b-a)), //group locs by type (decreasing) ijefz
 glob={},addglo=(t,c,s)=>{glob[s]={t:t,c:[...[c],...Array(67==t?4:68==t?8:1).fill(0),11],i:Object.keys(glob).length}}, //name:{t:127,c:[42,7,11],i:0}
 tabl=[],addtab=(i,s)=>(i!=tabl.length?E(line,"index error"):(s in fns)?tabl[i]=fns[s]:E(line,"unknown function: "+s)),
 data=[],adddat=(i,s)=>(data.filter(x=>i==x.o+x.d.length).length?data[data.length-1].d.push(...hexa(s)):data.push({o:i,d:hexa(s)})), //{o:1,d:[1,2,3,4]}
 swtc=[],sw,sc,nest=[],whdo=_=>nest.length-nest.lastIndexOf("whdo")-1,
 l=x.split("\n");
 l.forEach((x,line)=>{x=x.trim().split(" ");if(1<x.length&&x[1].includes(":")){fns[x[0]]=Object.keys(fns).length;addsig(x[1])}})
 l.forEach((x,line)=>{
  let im=x=>(2>x.length)?E(line,x[0]+" expect immediate"):x[1],cmpl=(x,a,p)=>(p=(a=x[1]?x[1]:0)/180*Math.PI,x=x[0],a==0?[x,0]:a==90?[0,x]:a==180?[-x,0]:a==270?[0,-x]:[x*Math.cos(p),x*Math.sin(p)]),
  numvar=(x,b)=>"-0123456789".includes(x[0])?(x.includes("a")?cmpl(x.split("a").map(parseFloat)):b?BigInt(x):parseFloat(x)):x,
  int=a=>Number.isInteger(a)?a:E(line,"expect integer"),int1=a=>int(Number(im(a))),
  lup=(x,g,r)=>lebu(int("0123456789".includes(x[0])?Number(x[0]):g?(x in glob?glob[x].i:E(line,"global undefined")):(x in lo)?narg+Object.keys(lo).indexOf(x):E(line,"local undefined")))
  x=x.trim();if(x.length){a=(x.includes(" ")?x.split(" "):[x]);
   ((1<a.length)&&(a[1].includes(":")))?(p(),n=a[0],s=a[1],narg=s.length-s.indexOf(":")-1,e=(a[2]==="export"?a[3]:""),imp=(a[2]==="import"?a.slice(3):0))
   :(a[0]in ops)?(Array.isArray(ops[a[0]])?c.push(...ops[a[0]]):c.push(ops[a[0]]))
   :(3==a[0].length&&(i="get set tee glo gst ".indexOf(a[0]+" "))>=0)?c.push(32+i/4,...lup(im(a),2<i/4))
   :"i"==a[0]?(("string"==typeof(i=numvar(im(a),0))?(s?(lsrt(lo[a[1]]=127)):addglo(127,[65],a[1]))    :c.push(65,...lebs(int(i)))))
   :"j"==a[0]?(("string"==typeof(i=numvar(im(a),1))?(s?(lsrt(lo[a[1]]=126)):addglo(126,[66],a[1]))    :c.push(66,...lebn(i))))
   :"e"==a[0]?(("string"==typeof(i=numvar(im(a),0))?(s?(lsrt(lo[a[1]]=125)):addglo(125,[67],a[1]))    :c.push(67,...new Uint8Array(new Float32Array([i]).buffer))))
   :"f"==a[0]?(("string"==typeof(i=numvar(im(a),0))?(s?(lsrt(lo[a[1]]=124)):addglo(124,[68],a[1]))    :c.push(68,...new Uint8Array(new Float64Array([i]).buffer))))
   :"z"==a[0]?(("string"==typeof(i=numvar(im(a),0))?(s?(lsrt(lo[a[1]]=123)):addglo(123,[253,12],a[1])):c.push(253,12,...new Uint8Array(new Float64Array(i).buffer))))
   :"if"==a[0]?(nest.push("if"),c.push(4,[64,127,126,125,124,123][1+"ijefz".indexOf(a[1])]))
   :"else"==a[0]?c.push(5)
   :"end"==a[0]?(i=nest.pop(),i=="do"?c.push(13,0,11):i=="whdo"?c.push(12,0,11,11):i=="swtc"?c.push(12,0,11):c.push(11))
   :a[0].includes(":")?(addsig(a[0]),c.push(17,...lebu(sigs.indexOf(a[0])),0))
   :"cal"==a[0]?c.push(16,...lebu(a[1] in fns?fns[a[1]]:E(line,"undefined function: "+a[1])))
   :"while"==a[0]?(nest.push("while"),c.push(2,64,3,64))
   :"do" ==a[0]?((nest[nest.length-1]==="while")?(nest[nest.length-1]="whdo",c.push(69,13,1)):(nest.push("do"),c.push(3,[64,127,126,125,124,123]["ijefz".indexOf(a[1])+1])))
   :"break"==a[0]?c.push(12,1+whdo())
   :"continue"==a[0]?c.push(12,whdo())
   :"switch"==a[0]?(i=int1(a)-1,sw=sigs.indexOf(addsig(ss=("ijefz".indexOf(a[2])>=0?a[2]:"")+":i")),sc=sigs.indexOf(addsig(":i")),nest.push("swtc"),swtc.push(i),c.push(2,...lebu(sw),...repa(1+i,[2,...lebu(sc)]),14,i,...iota(i),i,11))
   :"endcase"==a[0]?(i=swtc[swtc.length-1]--,c.push(12,i,11))
   :"tab"==a[0]?(p(),addtab(int1(a),a[2]))
   :"dat"==a[0]?(p(),adddat(int1(a),a[2]))
   :E(line,"unknown op "+a[0])
  }
 });p()

 //emit
 o=[0,97,115,109,1,0,0,0] 
 sect( 1,vect(sigs.map((x,r,a)=>([r,a]=x.split(":"),[96,a.length,...a.split("").map(x=>typs[x]),r.length,...r.split("").map(x=>typs[x])]))))
 sect( 2,vect(funs.filter(x=>x.import).map(x=>[...asci(x.import[0]),...asci(x.import[1]),0,...lebu(sigs.indexOf(x.sig))] ))) //imports..
 sect( 3,vect(funs.filter(x=>!x.import).map(x=>lebu(sigs.indexOf(x.sig)))))
 if(tabl.length)sect(4,[1,112,0,...lebu(tabl.length)])
 sect( 5,[1,0,1]) //memory: 1segment, unshared, 1block
 sect( 6,vect(Object.values(glob).map(x=>[x.t,1,...x.c]))) //global..
 sect( 7,vect(expo(["memory",...funs.filter(x=>x.export.length>0).map(x=>x.export)], //names
                   [0,...funs.map((x,i)=>(x.export.length?i:-1)).filter(x=>x>=0)]))) //index
 sect( 8,[]) //start
 if(tabl.length)sect(9,[1,0,65,0,11,...lebu(tabl.length),...tabl.map(lebu).flat()]) //elements(indirect function table)
 sect(10,vect(funs.filter(x=>!x.import).map(x=>((x=[...locs(x),...x.code,11]),[...lebu(x.length),...x])))) //code
 sect(11,vect(data.map(x=>[0,65,...lebu(x.o),11,...lebu(x.d.length),...x.d]))) //data
 return new Uint8Array(o)})})()
//embed

let indicate=x=>{let i=b.lastIndexOf("\n",x),j=b.indexOf("\n",x);i=i<0?0:i;j=j<0?b.length:j;console.log(b.slice(i,j));console.log(" ".repeat(x-i)+"^")}
let ed={selectionStart:0,selectionEnd:0,focus:_=>indicate(ed.selectionStart)},aout=0,xout=0,wout=0
let argv=process.argv.slice(2)
if(argv.length&&argv[0].startsWith("-")){let a0=argv[0]
 a0=="-a"?aout=1:a0=="-w"?wout=1:"-x"==a0?xout=1:argv.push(1,2,3)
 argv=argv.slice(1)
}
if(1>argv.length||(!(argv[0].endsWith(".b")))){
 console.log(process.argv[0], process.argv[1])
 console.log("use:")
 console.log("$b    file.b [func args..] /run")
 console.log("$b -t file.b       /call test()")
 console.log("$b -a file.b       /print  asm")
 console.log("$b -x file.b       /hexdump wasm")
 console.log("$b -w file.b       /writes file.wasm")
 process.exit(1)
}
let xxd=(x,s,i,o,O)=>(i=0,o="",O=x=>o+=x,s="  ",x.forEach((x,i)=>{
 if(0==i%16)(O((i?s+"\n":"")+i.toString(16).padStart(8,'0')+":"),s="  ")
 if(0==i%2)O(" ");O(x.toString(16).padStart(2,'0'));s+=(x>31&&x<127)?String.fromCharCode(x):"."}),(i=x.length%16),O(i?" ".repeat(2.5*(16-x.length%16)):""+s),o)

//let xxd=x=>x.map(x=>x.toString(16).padStart(2,"0")).join(" ").match(/.{1,12}/g).join("\n").replaceAll(" \n","\n")
let b=new TextDecoder("utf-8").decode(Deno.readFileSync(argv[0]))
let a=ab(b)
if(aout){console.log(a);process.exit(0)}
let w=wa(a)
if(xout){console.log(xxd(w));process.exit(0)}
if(wout){a=argv[0].slice(0,-2)+".wasm";Deno.writeFileSync(a,w);process.exit(0)}

let findtop=_=>8*(1+new BigInt64Array(I.exports.memory.buffer).findLastIndex(x=>x))
let malloc=x=>{x=((7+x)>>>3)<<3;I.top=I.top?I.top:findtop();let n=I.exports.memory.buffer.byteLength,t=I.top+x,r=I.top;if(t>n){I.exports.memory.grow((65535+(n-t))>>>16)};I.top=t;return r}
let libm=Object.assign(...("acos acosh asin asinh atan atan2 atanh cbrt ceil clz32 cos cosh exp expm1 floor hypot sin cos log log10 log1p pow random round sign sin tan tanh trunc".split(" ").map(x=>({[x]:Math[x]}))))

let M={env:{...{/*..*/malloc:malloc},...libm}}
let m=new WebAssembly.Module(w),I=new WebAssembly.Instance(m,M)

let f;if(argv.length&&argv[1] in I.exports){f=argv[1];argv=argv.slice(2)}else{f="main";argv=argv.slice(1)}

let findsig=f=>{let x=b.split("\n").filter(x=>x.startsWith(f+":"));if(1!=x.length){throw new Error("cannot find signature for: "+f)};return x[0].slice(f.length+1).replace(/{.*/,"").split(":")}
let s=findsig(f),r=s[0];a=s[1]
if(a.length!=argv.length){throw new Error("args should be: "+a+", got "+argv.length+": "+argv)}
//todo ..convert chars
let unsup=x=>{throw new Error("unsupported argument type: "+x)}
argv=argv.map((x,i)=>"ief".includes(a[i])?Number(x):"j"==a[i]?BigInt(x):"C"==a[i]?bstring(x):unsup(a[i]))
console.log(I.exports[f](...argv.map(Number)))

